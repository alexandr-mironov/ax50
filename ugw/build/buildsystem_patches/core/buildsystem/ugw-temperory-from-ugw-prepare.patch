Temp_Commit_Donot_Push

diff --git a/manifest_chdauto_03-12-2018.xml b/manifest_chdauto_03-12-2018.xml
new file mode 100644
index 0000000000..958bcb6025
--- /dev/null
+++ b/manifest_chdauto_03-12-2018.xml
@@ -0,0 +1,143 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<manifest>
+  <remote fetch="ssh://git@gts-chd.intel.com:29418/sw_ugw" name="sw_ugw"/>
+  
+  <default remote="sw_ugw" revision="7.4.2" sync-j="4"/>
+  
+  <project groups="ugw" name="asc_drv" path="ugw_sw/ugw/./drivers/asc_drv" revision="8a258d5bc068d95953f70900cb91264a6ec47fda" upstream="7.4.2"/>
+  <project groups="ugw" name="atm_drv" path="ugw_sw/ugw/./drivers/atm_drv" revision="528ebfa664ced542a14a80912f500d39e5b3f934" upstream="7.4.2"/>
+  <project groups="ugw" name="bsp_basic_drv" path="ugw_sw/ugw/./drivers/bsp_basic_drv" revision="467c25d8d3c005d80c2edd9d31305bc1e36ba6b9" upstream="7.4.2"/>
+  <project groups="ugw" name="cgu_drv" path="ugw_sw/ugw/./drivers/cgu_drv" revision="5288f3aac999fcaf0fcfcd5db0ec525187a8276e" upstream="7.4.2"/>
+  <project groups="ugw" name="coc_cpufreq_drv" path="ugw_sw/ugw/./drivers/coc_cpufreq_drv" revision="a8b75214497c14a92c2bd0c9f5578d128fa2c650" upstream="7.4.2"/>
+  <project groups="ugw" name="coc_pmcu_drv" path="ugw_sw/ugw/./drivers/coc_pmcu_drv" revision="c5de46aeee002b21133f3954f0ae9cf716c4735c" upstream="7.4.2"/>
+  <project groups="ugw" name="config_cpe" path="ugw_sw/ugw/./config_cpe" revision="f7160b48022451ef52269150d84b4474414948fa" upstream="7.5.0"/>
+  <project groups="ugw" name="dcdc_drv" path="ugw_sw/ugw/./drivers/dcdc_drv" revision="18156aa5b27d1ba50515d843c211c90cc6a6a598" upstream="7.4.2"/>
+  <project groups="ugw" name="deu_drv" path="ugw_sw/ugw/./drivers/deu_drv" revision="5af82078a9396df2626758b53cca8427c7cb9689" upstream="7.4.2"/>
+  <project groups="ugw" name="devm" path="ugw_sw/ugw/./devm_ss/devm" revision="e288aec3dd10ee0866641eed545c9b93d7f9136e" upstream="7.4.2"/>
+  <project groups="ugw" name="devm_ss" path="ugw_sw/ugw/./devm_ss" revision="79877f771630c8b6b6480b764feabffe2451ee2c" upstream="7.4.2"/>
+  <project groups="ugw" name="dma_drv" path="ugw_sw/ugw/./drivers/dma_drv" revision="c5ea0a4ff11cd45b0a32eed79fad6da21a62bb6e" upstream="7.4.2"/>
+  <project groups="ugw" name="drivers_config" path="ugw_sw/ugw/./drivers/drivers_config" revision="489dab18a70f8ef9822f71e733da5387e85f1599" upstream="7.4.2"/>
+  <project groups="ugw" name="drivers_config_vbg" path="ugw_sw/ugw/./drivers/drivers_config_vbg" revision="47c16b36c697f08a22636f6efbbc002ef83aa857" upstream="7.4.2"/>
+  <project groups="ugw" name="drivers_patches" path="ugw_sw/ugw/./drivers/drivers_patches" revision="019123de3761ab6e7ecf091e056adfcb6a45ed5d" upstream="7.4.2"/>
+  <project groups="ugw" name="drivers_patches_grx500" path="ugw_sw/ugw/./drivers/drivers_patches_grx500" revision="1176e6cf581b8a12057d68696e8aafc22c882416" upstream="7.4.2"/>
+  <project groups="ugw" name="eth_drv" path="ugw_sw/ugw/./drivers/eth_drv" revision="8b921f37a295251182e5700a711a960dfd038b29" upstream="7.4.2"/>
+  <project groups="ugw" name="fapi_wlan_common" path="ugw_sw/ugw/./ugw_components/fapi_wlan_common" revision="34ff6836d40d2b8e8b4e8f8f21e96f68b7090685" upstream="7.4.2"/>
+  <project groups="ugw" name="fapi_wlan_common_6x" path="ugw_sw/ugw/./ugw_components/fapi_wlan_common_6x" revision="1a8c393e4be9c39e574f8c8de9d31f1694ba9d87" upstream="7.5.0"/>
+  <project groups="ugw" name="fapi_wlan_vendor_mtk" path="ugw_sw/ugw/./ugw_components/fapi_wlan_vendor_mtk" revision="1525ded3330088b29131766164e85a067175f3b9" upstream="7.4.2"/>
+  <project groups="ugw" name="fapi_wlan_vendor_qca" path="ugw_sw/ugw/./ugw_components/fapi_wlan_vendor_qca" revision="6e17abf5f4c5a25ce798ff6a27d5a36ad5b7a52d" upstream="7.4.2"/>
+  <project groups="ugw" name="fapi_wlan_vendor_wave" path="ugw_sw/ugw/./ugw_components/fapi_wlan_vendor_wave" revision="a30b2cebb9b603fe11ee93d51b0f01ca6936e72b" upstream="7.4.2"/>
+  <project groups="ugw" name="fapi_wlan_vendor_wave_6x" path="ugw_sw/ugw/./ugw_components/fapi_wlan_vendor_wave_6x" revision="ead7317ff347fb49c17cda104319ad58f5b14b90" upstream="7.5.0"/>
+  <project groups="ugw" name="feed_3rdparty" path="ugw_sw/ugw/./feed_3rdparty" revision="3398e948e7defa583c4909d5591afa9f0a1886e1" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_3rdparty_nda" path="ugw_sw/ugw/./feed_3rdparty_nda" revision="ad5cd908179eca206da3b738913ae54e67005717" upstream="7.4.2"/>
+  <project groups="ugw,beerocks" name="feed_beerocks" path="ugw_sw/ugw/./feed_beerocks" revision="db6592e582c30f4b68d3826781ac3bc739d55e9d" upstream="7.5.0"/>
+  <project groups="ugw" name="feed_coc" path="ugw_sw/ugw/./feed_coc" revision="c34405844b9f0901edd19afdb2d5a0537aaf6ac4" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_common" path="ugw_sw/ugw/./feed_common" revision="757736da4a8e851b81486d0a9622a2c19ba60f56" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_datapath" path="ugw_sw/ugw/./feed_datapath" revision="c99a354d372f9d0684ad9ed286feb55fcc973bdb" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_debug_tools" path="ugw_sw/ugw/./feed_debug_tools" revision="5e10825a8d67891676623e0d1759a5a16e69cce9" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_dect" path="ugw_sw/ugw/./feed_dect" revision="8fc83c303df304e295a89477122690dd44f7f88f" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_devm" path="ugw_sw/ugw/./devm_ss/feed_devm" revision="cdce4bec262de28adb250011616175c8e0bf0229" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_driver_tools" path="ugw_sw/ugw/./feed_driver_tools" revision="717cdd7eecff8d30300133536b3d2335ca548bf6" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_dsl_cpe" path="ugw_sw/ugw/./feed_dsl_cpe" revision="b65d7b19050a10e421508764c01f921fc5d40180" upstream="4.19.3.x_UGW-7.x"/>
+  <project groups="ugw" name="feed_dsl_ppe" path="ugw_sw/ugw/./feed_dsl_ppe" revision="22f97eac2bcddca5b2971a13ee73f6b0a2087300" upstream="7.x"/>
+  <project groups="ugw" name="feed_gphy_firmware" path="ugw_sw/ugw/./feed_gphy_firmware" revision="2f9aa051c998102092d130c3b67a4fc606e4bb2e" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_gpon_onu" path="ugw_sw/ugw/./feed_gpon_onu" revision="6ebdaff34210ed692a097388cfc443eec1eff9c7" upstream="gpon_fs7.6"/>
+  <project groups="ugw" name="feed_hotspot_services" path="ugw_sw/ugw/./ugw_components/feed_hotspot_services" revision="3e4a25a9d2e20c0b5ed7c2d5ff954fa2a13fc151" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_intel_ugw" path="ugw_sw/ugw/./feed_intel" revision="475f54f5bf2df842f103844f1d6cae9db131eb04" upstream="7.5.0"/>
+  <project groups="ugw" name="feed_iotivity" path="ugw_sw/ugw/./feed_iotivity" revision="680bb22edcd8c231bc5874f513ab9bc3f8d77ec8" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_lxc" path="ugw_sw/ugw/./ugw_components/feed_lxc" revision="e1e312098c018dda12afb76ee071f92a5a97d6cf" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_mcast_service" path="ugw_sw/ugw/./ugw_components/feed_mcast_service" revision="71c25bd7d8c553c2b71ac48e0345ef58893424de" upstream="7.4.2"/>
+  <project groups="ugw,multiap" name="feed_multiap" path="ugw_sw/ugw/./feed_multiap" revision="70e7edbf754a2ead374cea76a7826bad0481984a" upstream="7.5.0"/>
+  <project groups="ugw" name="feed_network_service" path="ugw_sw/ugw/./ugw_components/feed_network_service" revision="6282c3766d9277973e5871caa19dd907b4c16a8d" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_opensource_apps" path="ugw_sw/ugw/./feed_opensource_apps" revision="0a7cab164a202ed4330804f45400d17f9ef3964d" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_puma_components" path="ugw_sw/ugw/./feed_puma_components" revision="3e58371cd4f20717192ecbaa3c3a775eee7dc563" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_qos_service" path="ugw_sw/ugw/./ugw_components/feed_qos_service" revision="71afed6d40d6ba4a33f2798995e65167fa5e4a05" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_router" path="ugw_sw/ugw/./router_ss/feed_router" revision="6a7b3780d8d30fb91566ec264a29a3547b98c5c8" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_sample" path="ugw_sw/ugw/./ugw_components/feed_sample" revision="abcf964635ab447d4b7941db5889fd493803fcee" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_session_management" path="ugw_sw/ugw/./ugw_components/feed_session_management" revision="8fa716b23f45365948dc940b9f00fff36a88f92f" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_shdap" path="ugw_sw/ugw/./feed_shdap" revision="f8701244b971bddf472699fef7aacfcc584f854a" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_shgw" path="ugw_sw/ugw/./feed_shgw" revision="0be30b145110686b840e38ccbba4928506c4925a" upstream="7.4.2"/>
+  <project groups="ugw,beerocks" name="feed_sl_beerocks" path="ugw_sw/ugw/./ugw_components/feed_sl_beerocks" revision="ce19e1db19fe132af3c6519eb2331746ac7ae156" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_sl_client_mode" path="ugw_sw/ugw/./ugw_components/feed_sl_client_mode" revision="f5565e8f85a997c43b6ec8fd6c227b84bdd82dbd" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_sl_components" path="ugw_sw/ugw/./ugw_components/feed_sl_components" revision="7d27265e782eaaa67a4019d063045fa49532c9ba" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_sl_home_nwk_mgr" path="ugw_sw/ugw/./ugw_components/feed_sl_home_nwk_mgr" revision="1f330d4e97758dd3f793afc0bd8e6f76defb4b08" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_sl_wisp" path="ugw_sw/ugw/./ugw_components/feed_sl_wisp" revision="434b8b03dd61ccf073d44a3372d471d68918c0ea" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_sl_wlan" path="ugw_sw/ugw/./ugw_components/feed_sl_wlan" revision="e35ec937b1a6005049560a393ae4b51a8a83d240" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_sl_wlan_6x" path="ugw_sw/ugw/./ugw_components/feed_sl_wlan_6x" revision="5266983cbfdd3c1bace7b8b2c1385ed06f4eda78" upstream="7.5.0"/>
+  <project groups="ugw" name="feed_switch_api" path="ugw_sw/ugw/./feed_switch_api" revision="f31441d91068bd4df3ee3d115f6a234f0e0fd223" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_target_xway" path="ugw_sw/ugw/./feed_target_xway" revision="f93618461b261dc789233ce7b1420a23c2b8ed4a" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_uboot" path="ugw_sw/ugw/./feed_uboot" revision="46b008b2693a78f527c0474fba09adcb01d6b0f6" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_ugw_utils" path="ugw_sw/ugw/./ugw_components/feed_ugw_utils" revision="8b144d787498a5a7b8da1e5dd2482844056a2b9d" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_upnpdm" path="ugw_sw/ugw/./feed_upnpdm" revision="c21c3f5ea425d61863cd7a389340e1a594c00030" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_voice" path="ugw_sw/ugw/./feed_voice" revision="7de90b19532a9ee1c3f2c63dda32894fd6988f77" upstream="telephony"/>
+  <project groups="ugw" name="feed_voice_cpe" path="ugw_sw/ugw/./feed_voice_cpe" revision="1dc6e503d469cf48a4235d2f6e6d7adab66ae027" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_voip" path="ugw_sw/ugw/./feed_voip" revision="4f8b30344e050a7a2aabdc0e5242083ce3c02a11" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_wlan" path="ugw_sw/ugw/./feed_wlan_5_x" revision="3527ee8a64d52848e144b47ad82b17d17a00b36f" upstream="7.4.2"/>
+  <project groups="ugw" name="feed_wlan_6x" path="ugw_sw/ugw/./feed_wlan_6x" revision="8c4eec7b65e9a81bf3c82b3887b2062827cf2c5d" upstream="7.5.0"/>
+  <project groups="ugw" name="feed_wwan_service" path="ugw_sw/ugw/./ugw_components/feed_wwan_service" revision="8120ceda0b183ecfa776001bc77a700e216244bf" upstream="7.4.2"/>
+  <project groups="ugw" name="gpio_drv" path="ugw_sw/ugw/./drivers/gpio_drv" revision="dc1be3f29f50ca739a4b1c96c8957b08bda2aff4" upstream="7.4.2"/>
+  <project groups="ugw" name="gptu_drv" path="ugw_sw/ugw/./drivers/gptu_drv" revision="bfa382536727b4e94e3530de8bd176b25c5abdb1" upstream="7.4.2"/>
+  <project groups="ugw" name="hotspot_services" path="ugw_sw/ugw/./ugw_components/hotspot_services" revision="2628239b796d0b1523f7b9a2535aad4da7c4b6fd" upstream="7.4.2"/>
+  <project groups="ugw" name="kernel_patches" path="ugw_sw/ugw/./kernel_patches" revision="d9839d43e22d1c624c52f8254fa1c132ae000aa0" upstream="7.5.0"/>
+  <project groups="ugw" name="led_drv" path="ugw_sw/ugw/./drivers/led_drv" revision="8a140e91585b18cb2578bd8eb3888fbc604e9c44" upstream="7.4.2"/>
+  <project groups="ugw" name="license" path="ugw_sw/ugw/./license" revision="34243bf53d55501f2d494a1a09eec92e6cc569b3" upstream="7.4.2"/>
+  <project groups="ugw" name="mcast_service" path="ugw_sw/ugw/./ugw_components/mcast_service" revision="2ffab8c38945c39484d5ba47344be412c3ad9dae" upstream="7.4.2"/>
+  <project groups="ugw" name="mmc_drv" path="ugw_sw/ugw/./drivers/mmc_drv" revision="53427740e5ffcfdfb636d34f8853ed91cd6e1fb8" upstream="7.4.2"/>
+  <project groups="ugw" name="mtd_nand_drv" path="ugw_sw/ugw/./drivers/mtd_nand_drv" revision="39defe832cf462e9aff9d4f52ff47d5bec76bb6e" upstream="7.4.2"/>
+  <project groups="ugw" name="mtd_nor_drv" path="ugw_sw/ugw/./drivers/mtd_nor_drv" revision="0c0a65b68030f11a5da708b65cf22bfbd14fd8d6" upstream="7.4.2"/>
+  <project groups="ugw" name="network_service" path="ugw_sw/ugw/./ugw_components/network_service" revision="6d074f56b9f51002f8a4c021c9b28dae8c1ae238" upstream="7.4.2"/>
+  <project groups="ugw" name="openwrt" path="ugw_sw/ugw/./openwrt" revision="6d217dc94e8db5ced903d71fd0df14d657ee306f" upstream="ltq_15.05_devel"/>
+  <project groups="ugw" name="openwrt_core" path="ugw_sw/ugw/./openwrt/core" revision="8c119be7f29002c811e9346e79984ceb2c1ba326"/>
+  <project groups="ugw" name="openwrt_luci" path="ugw_sw/ugw/./openwrt/luci" revision="636c72c3f2cac72de7643f618cd8fa431ace4a8b" upstream="for-15.05"/>
+  <project groups="ugw" name="openwrt_management" path="ugw_sw/ugw/./openwrt/management" revision="77bfb08105fc02cb60760c559db7cf37f524fef2" upstream="7.4.2"/>
+  <project groups="ugw" name="openwrt_packages" path="ugw_sw/ugw/./openwrt/packages" revision="2b28aa95b56b7412370d5c0ef844b91c50f50803" upstream="14.07"/>
+  <project groups="ugw" name="openwrt_patches_core" path="ugw_sw/ugw/./openwrt/patches/core" revision="56c9e85cf34fa8a33a269c03138b1e550ac26356" upstream="ltq_15.05_devel"/>
+  <project groups="ugw" name="openwrt_patches_luci" path="ugw_sw/ugw/./openwrt/patches/luci" revision="ff0e66e1b9ced8b3484b93cb1f1ae78a08416084" upstream="for-15.05_devel"/>
+  <project groups="ugw" name="openwrt_patches_packages" path="ugw_sw/ugw/./openwrt/patches/packages" revision="d4ccd571fad16eb8aa13352e721c7272e46cc457" upstream="ltq_14.07"/>
+  <project groups="ugw" name="openwrt_support" path="ugw_sw/ugw/./support" revision="0e41dfccf2fb955bb95b2e9c0888c2e96c7fad31" upstream="beerocks_1.1"/>
+  <project groups="ugw" name="openwrt_telephony" path="ugw_sw/ugw/./openwrt/telephony" revision="44f7f2f7d605ecf4dcf5969b9ddc68a872a4792c" upstream="7.4.2"/>
+  <project groups="ugw" name="pci_drv" path="ugw_sw/ugw/./drivers/pci_drv" revision="918177a065a08f38c8a26a01216bd28d82959d91" upstream="7.4.2"/>
+  <project groups="ugw" name="pmon_drv" path="ugw_sw/ugw/./drivers/pmon_drv" revision="a6ea42dcd71452491b818a5d1d56118894a68687" upstream="7.4.2"/>
+  <project groups="ugw" name="pmu_drv" path="ugw_sw/ugw/./drivers/pmu_drv" revision="204c20cab1802ea57937232383917ccff62d9bf6" upstream="7.4.2"/>
+  <project groups="ugw" name="ppa_drv" path="ugw_sw/ugw/./drivers/ppa_drv" revision="57f84f0000dcd2d16bab7131d83cb6fc1586037d" upstream="7.4.2"/>
+  <project groups="ugw" name="ppe_customization_drv" path="ugw_sw/ugw/./drivers/ppe_customization_drv" revision="2f30840e143d733882066063ae051f8a2d37a93c" upstream="7.4.2"/>
+  <project groups="ugw" name="ptm_drv" path="ugw_sw/ugw/./drivers/ptm_drv" revision="ae2483cb75ae89aab19b969213f9369713b3df11" upstream="7.4.2"/>
+  <project groups="ugw" name="puma_kernel_patches" path="ugw_sw/ugw/./puma_kernel_patches" revision="bb44f4a96952e5b411a2f00bb49e5fd0f19f64c3" upstream="7.4.2"/>
+  <project groups="ugw" name="qos_service" path="ugw_sw/ugw/./ugw_components/qos_service" revision="8e6007575c213752b372b234ab54975aab45b8e8" upstream="7.4.2"/>
+  <project groups="ugw" name="rcu_drv" path="ugw_sw/ugw/./drivers/rcu_drv" revision="84c8674cf64f30edb53fd30df0535d549f656535" upstream="7.4.2"/>
+  <project groups="ugw" name="rootfs" path="ugw_sw/ugw/./rootfs" revision="86488ec1315af30496afa0aeb7fe32a9cd24be52" upstream="7.4.2"/>
+  <project groups="ugw" name="router" path="ugw_sw/ugw/./router_ss/router" revision="c332dacfb07039fc8d251c618b59052c4a64e52c" upstream="7.4.2"/>
+  <project groups="ugw" name="router_ss" path="ugw_sw/ugw/./router_ss" revision="1cb67391baa970bc6aeb6f11c73f2d301dc82269" upstream="7.4.2"/>
+  <project groups="ugw" name="sdk_utils" path="ugw_sw/ugw/./sdk_utils" revision="6ffefd593ec0acc23d1bb1dcec0ac4ad6fb39e97" upstream="7.4.2"/>
+  <project groups="ugw" name="shdap_src" path="ugw_sw/ugw/./shdap_src" revision="6c21390bcdb45fd3454cc8e387e0d4cc94c537b2" upstream="7.4.2"/>
+  <project groups="ugw" name="si_drv" path="ugw_sw/ugw/./drivers/si_drv" revision="5f2636881f8ec6e4e015b694d2c879fd39946695" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_acl" path="ugw_sw/ugw/./ugw_components/sl_components/sl_acl" revision="736bd23e239d67909f34d05868866de0b524c0da" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_client_mode" path="ugw_sw/ugw/./ugw_components/sl_components/sl_client_mode" revision="9f09b52572b0c39edf508fffa90ca72481e04d33" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_device_info" path="ugw_sw/ugw/./ugw_components/sl_components/sl_device_info" revision="f366abfd3f57ca618a03b9885276a4d6ce77af7c" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_device_prioritization" path="ugw_sw/ugw/./ugw_components/sl_components/sl_device_prioritization" revision="55c4aeae3baf2c4a216a6560a1e68b99ac15f989" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_diagnostics" path="ugw_sw/ugw/./ugw_components/sl_components/sl_diagnostics" revision="0f3a8c09899c02301aa98f37101b26dade507915" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_firewall_nat" path="ugw_sw/ugw/./ugw_components/sl_components/sl_firewall_nat" revision="4864182e5527436db1bee7cdfd94637c7e9b57ac" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_gpon" path="ugw_sw/ugw/./ugw_components/sl_components/sl_gpon" revision="227b35ea762e0ab4a6234e7d2680dcdd6e54de17" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_guest_access" path="ugw_sw/ugw/./ugw_components/sl_components/sl_guest_access" revision="5459539583f00162254c0e0d5a461a4364ce056f" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_ipv6_src" path="ugw_sw/ugw/./ugw_components/sl_components/sl_ipv6" revision="16d50bd9ae78873e94cdb084086f72a2ff4617af" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_managementserver" path="ugw_sw/ugw/./ugw_components/sl_components/sl_managementserver" revision="8e8cf6ae8551a5f3093fb6fdc361857f704e475e" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_syslogng" path="ugw_sw/ugw/./ugw_components/sl_components/sl_syslogng" revision="7ae0ec0ac049d6fd99531c751a0ce5e0c95cd452" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_upgrade" path="ugw_sw/ugw/./ugw_components/sl_components/sl_upgrade" revision="c3bdf0b4035884170e5caec572ddf89f42edf119" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_usb_hosts" path="ugw_sw/ugw/./ugw_components/sl_components/sl_usb_hosts" revision="01d74480814468ef9d7c3396aa0ea01cc455393f" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_user_management" path="ugw_sw/ugw/./ugw_components/sl_components/sl_user_management" revision="53161c0f466f2bffdce1ad83aabc60620fb9a2e3" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_vendor_cfg" path="ugw_sw/ugw/./ugw_components/sl_components/sl_vendor_cfg" revision="99389130107e4dd079c4bfa4850987bdb725c460" upstream="7.4.2"/>
+  <project groups="ugw" name="sl_wlan" path="ugw_sw/ugw/./ugw_components/sl_wlan" revision="983e66afb854c5de93ee6c70dc81bc437384742b" upstream="7.4.2"/>
+  <project groups="ugw" name="spi_drv" path="ugw_sw/ugw/./drivers/spi_drv" revision="82b8936fc8bec841fc55ad59f1771e0b33978e41" upstream="7.4.2"/>
+  <project groups="ugw" name="switch_api_drv" path="ugw_sw/ugw/./drivers/switch_api_drv" revision="005347803d3fe665edb510b49792744d5b2f1051" upstream="7.4.2"/>
+  <project groups="ugw" name="system_service" path="ugw_sw/ugw/./ugw_components/system_service" revision="3977d2b42654eacf46305ba5f1774574180371d2" upstream="7.4.2"/>
+  <project groups="ugw" name="target" path="ugw_sw/ugw/./target" revision="87457e7248bc59cd1e79fe33af30164c0af3e592" upstream="7.5.0"/>
+  <project groups="ugw" name="ts_drv" path="ugw_sw/ugw/./drivers/ts_drv" revision="4ee90b74879f692c463a4659f846d007d34865ad" upstream="7.4.2"/>
+  <project groups="ugw" name="ugw_devm" path="ugw_sw/ugw/./devm_ss/ugw_devm" revision="64d92b66393c18c80eb95de3a4fd9595c5f7888c" upstream="7.4.2"/>
+  <project groups="ugw" name="ugw_sdk" path="ugw_sw/ugw/./ugw_sdk" revision="4318d494ed02fb98eb2452112d51f614badc5650" upstream="7.5.0"/>
+  <project groups="ugw" name="ugw_sw" revision="9272d37f3c98b2ee49c4849522f3f92925381519" upstream="7.5.0"/>
+  <project groups="ugw" name="usb_drv" path="ugw_sw/ugw/./drivers/usb_drv" revision="f6fe45f5b4b154a87f5a6bee8b93f9bee006e155" upstream="7.4.2"/>
+  <project groups="ugw" name="usb_oc_drv" path="ugw_sw/ugw/./drivers/usb_oc_drv" revision="edc6989dd159a3d15eab975760ba943c13929ff7" upstream="7.4.2"/>
+  <project groups="ugw" name="usif_drv" path="ugw_sw/ugw/./drivers/usif_drv" revision="8c1625ffc634a9b738649cb385c958fb80e1760d" upstream="7.4.2"/>
+  <project groups="ugw" name="wdt_drv" path="ugw_sw/ugw/./drivers/wdt_drv" revision="5e3c79538d9ef5b7365e6fa7e4ea88211556c56c" upstream="7.4.2"/>
+  <project groups="ugw" name="webui" path="ugw_sw/ugw/./webui" revision="c45c90543be0f51711585272773941b465845ed5" upstream="7.5.0"/>
+  <project groups="ugw" name="wwan_service" path="ugw_sw/ugw/./ugw_components/wwan_service" revision="78d26d44af49a7b61124bc742d89909649bf5f66" upstream="7.4.2"/>
+</manifest>
diff --git a/other_config_path b/other_config_path
new file mode 100644
index 0000000000..3273397c15
--- /dev/null
+++ b/other_config_path
@@ -0,0 +1 @@
+./ugw/config
diff --git a/target/linux/intel-x86 b/target/linux/intel-x86
new file mode 120000
index 0000000000..4cdecbb7b3
--- /dev/null
+++ b/target/linux/intel-x86
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/openwrt/core/ugw/target/linux/intel-x86
\ No newline at end of file
diff --git a/target/linux/intel-xway b/target/linux/intel-xway
new file mode 120000
index 0000000000..7879ccdd44
--- /dev/null
+++ b/target/linux/intel-xway
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/openwrt/core/ugw/target/linux/intel-xway
\ No newline at end of file
diff --git a/target/linux/lantiq b/target/linux/lantiq
new file mode 120000
index 0000000000..50483133fd
--- /dev/null
+++ b/target/linux/lantiq
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/openwrt/core/ugw/target/linux/lantiq
\ No newline at end of file
diff --git a/target/linux/lantiq/Makefile b/target/linux/lantiq/Makefile
deleted file mode 100644
index 4f3b7ee94a..0000000000
--- a/target/linux/lantiq/Makefile
+++ /dev/null
@@ -1,25 +0,0 @@
-#
-# Copyright (C) 2007-2011 OpenWrt.org
-#
-# This is free software, licensed under the GNU General Public License v2.
-# See /LICENSE for more information.
-#
-include $(TOPDIR)/rules.mk
-
-BOARD:=lantiq
-BOARDNAME:=Lantiq
-FEATURES:=squashfs
-#SUBTARGETS=xway xrx200
-MAINTAINER:=John Crispin <blogic@openwrt.org>
-
-KERNEL_PATCHVER:=3.18
-
-CPU_TYPE:=mips32r2
-
-define Target/Description
-	Build firmware images for Lantiq SoC
-endef
-
-include $(INCLUDE_DIR)/target.mk
-
-$(eval $(call BuildTarget))
diff --git a/target/linux/lantiq/base-files.mk b/target/linux/lantiq/base-files.mk
deleted file mode 100644
index d6682bd388..0000000000
--- a/target/linux/lantiq/base-files.mk
+++ /dev/null
@@ -1,5 +0,0 @@
-define Package/base-files/install-target
-	rm -f $(1)/etc/config/network
-endef
-
-
diff --git a/target/linux/lantiq/base-files/etc/diag.sh b/target/linux/lantiq/base-files/etc/diag.sh
deleted file mode 100644
index e9aa2a4a63..0000000000
--- a/target/linux/lantiq/base-files/etc/diag.sh
+++ /dev/null
@@ -1,46 +0,0 @@
-#!/bin/sh
-# Copyright (C) 2012-2013 OpenWrt.org
-
-. /lib/functions/leds.sh
-
-status_led="power"
-
-set_state() {
-	[ -d /sys/class/leds/power2/ ] && {
-
-		case "$1" in
-		preinit)
-			led_set_attr "power2" "trigger" "heartbeat"
-			status_led_on
-			;;
-		failsafe)
-			led_off "power2"
-			status_led_set_timer 100 100
-			;;
-		done)
-			led_off "power2"
-			;;
-		esac
-		return
-	}
-
-	case "$1" in
-	preinit)
-		status_led_set_heartbeat
-		;;
-	failsafe)
-		[ -d /sys/class/leds/power1 ] && {
-			status_led_off
-			led_timer "power1" 100 100
-		} || status_led_set_timer 100 100
-		;;
-	done)
-		status_led_on
-		led_off "power1"
-		;;
-	esac
-}
-
-if [ -e /etc/diag.arch.sh ]; then
-	. /etc/diag.arch.sh
-fi
diff --git a/target/linux/lantiq/base-files/etc/hotplug.d/firmware/10-rt2x00-eeprom b/target/linux/lantiq/base-files/etc/hotplug.d/firmware/10-rt2x00-eeprom
deleted file mode 100644
index 5f1cb00452..0000000000
--- a/target/linux/lantiq/base-files/etc/hotplug.d/firmware/10-rt2x00-eeprom
+++ /dev/null
@@ -1,60 +0,0 @@
-#!/bin/sh
-# based on gabors ralink wisoc implementation
-
-rt2x00_eeprom_die() {
-	echo "rt2x00 eeprom: " "$*"
-	exit 1
-}
-
-rt2x00_eeprom_extract() {
-	local part=$1
-	local offset=$2
-	local count=$3
-	local swab=$4
-	local mtd
-
-	. /lib/functions.sh
-
-	mtd=$(find_mtd_part $part)
-	[ -n "$mtd" ] || \
-		rt2x00_eeprom_die "no mtd device found for partition $part"
-
-	if [ $swab -gt 0 ]; then
-		dd if=$mtd of=/lib/firmware/$FIRMWARE bs=2 skip=$offset count=$count conv=swab || \
-			rt2x00_eeprom_die "failed to extract from $mtd"
-	else
-		dd if=$mtd of=/lib/firmware/$FIRMWARE bs=1 skip=$offset count=$count || \
-			rt2x00_eeprom_die "failed to extract from $mtd"
-	fi
-}
-
-[ -e /lib/firmware/$FIRMWARE ] && exit 0
-. /lib/functions/lantiq.sh
-
-case "$FIRMWARE" in
-"RT2860.eeprom" )
-	local board=$(lantiq_board_name)
-	case $board in
-	ARV7510PW22|ARV7519PW|ARV752DPW|ARV752DPW22|VGV7519)
-		rt2x00_eeprom_extract "board_config" 520 256 1
-		;;
-	ARV7525PW)
-		rt2x00_eeprom_extract "board_config" 1040 512 0
-		;;
-	*)
-		rt2x00_eeprom_die "board $board is not supported yet"
-		;;
-	esac
-	;;
-"RT3062.eeprom" )
-	local board=$(lantiq_board_name)
-	case $board in
-	VGV7510KW22)
-		rt2x00_eeprom_extract "board_config" 520 256 1
-		;;
-	*)
-		rt2x00_eeprom_die "board $board is not supported yet"
-		;;
-	esac
-	;;
-esac
diff --git a/target/linux/lantiq/base-files/etc/init.d/dsl_fs b/target/linux/lantiq/base-files/etc/init.d/dsl_fs
deleted file mode 100755
index ccba4ae843..0000000000
--- a/target/linux/lantiq/base-files/etc/init.d/dsl_fs
+++ /dev/null
@@ -1,35 +0,0 @@
-#!/bin/sh /etc/rc.common
-# Copyright (C) 2014 OpenWrt.org
-
-. $IPKG_INSTROOT/lib/functions.sh
-
-START=30
-
-boot() {
-	MTD=$(find_mtd_index dsl_fw)
-
-	grep /lib/firmware/lantiq /proc/mounts && umount /lib/firmware/lantiq
-
-	mkdir -p /lib/firmware/lantiq
-	[ "$MTD" -gt 0 ] || return 0
-
-	mount -t tmpfs none /lib/firmware/lantiq
-	case "$(dd if=/dev/mtd$MTD bs=2 count=1 2>/dev/null | hexdump -n 2 -e '1/1 "%02x"')" in
-		1985)
-			mkdir -p /tmp/fw_mnt
-			mount -t jffs2 /dev/mtdblock$MTD /tmp/fw_mnt
-			cp -a /tmp/fw_mnt/*.bin /lib/firmware/lantiq/
-			umount /tmp/fw_mnt
-			rmdir /tmp/fw_mnt
-		;;
-		1f8b)
-			tar xz -C /lib/firmware/lantiq < /dev/mtd$MTD
-		;;
-		*)
-			echo "No DSL firmware detected in /dev/mtd$MTD (dsl_fw)"
-			return 0
-		;;
-	esac
-
-	[ -e /lib/firmware/vdsl.bin ] || ln -s /lib/firmware/lantiq/vr9_dsl_fw_annex_b.bin /lib/firmware/vdsl.bin
-}
diff --git a/target/linux/lantiq/base-files/etc/init.d/esi b/target/linux/lantiq/base-files/etc/init.d/esi
deleted file mode 100755
index ca79070c9e..0000000000
--- a/target/linux/lantiq/base-files/etc/init.d/esi
+++ /dev/null
@@ -1,7 +0,0 @@
-#!/bin/sh /etc/rc.common
-# Copyright (C) 2013 OpenWrt.org
-
-START=19
-start() {
-	esi $(printf '%012X' $((1+0x$(tr -d : </sys/class/net/eth0/address)))) 2>/dev/console || :
-}
diff --git a/target/linux/lantiq/base-files/etc/inittab b/target/linux/lantiq/base-files/etc/inittab
deleted file mode 100644
index 46a1312c67..0000000000
--- a/target/linux/lantiq/base-files/etc/inittab
+++ /dev/null
@@ -1,3 +0,0 @@
-::sysinit:/etc/init.d/rcS S boot
-::shutdown:/etc/init.d/rcS K stop
-ttyLTQ0::askfirst:/bin/ash --login
diff --git a/target/linux/lantiq/base-files/etc/uci-defaults/01_leds b/target/linux/lantiq/base-files/etc/uci-defaults/01_leds
deleted file mode 100644
index 8041ac941f..0000000000
--- a/target/linux/lantiq/base-files/etc/uci-defaults/01_leds
+++ /dev/null
@@ -1,65 +0,0 @@
-#!/bin/sh
-#
-# Copyright (C) 2011 OpenWrt.org
-# based on ar71xx
-#
-
-. /lib/functions/uci-defaults.sh
-. /lib/functions/lantiq.sh
-
-[ -e "/sys/class/leds/wifi" ] && ucidef_set_led_wlan "wifi" "wifi" "wifi" "phy0tpt"
-[ -e "/sys/class/leds/usb" ] && ucidef_set_led_usbdev "usb" "usb" "usb" "1-1"
-[ -e "/sys/class/leds/usb2" ] && ucidef_set_led_usbdev "usb2" "usb2" "usb2" "2-1"
-[ -e "/sys/class/leds/internet" ] && ucidef_set_led_netdev "internet" "internet" "internet" "pppoe-wan"
-
-board=$(lantiq_board_name)
-
-case "$board" in
-VG3503J)
-	ucidef_set_led_netdev "vdsl" "vdsl" "bt:green:dsl" "ptm0"
-	;;
-BTHOMEHUBV2B)
-	ucidef_set_led_default "power" "power" "soc:blue:power" "1"
-#	ucidef_set_led_wlan "wifi" "wifi" "soc:blue:wireless" "phy0radio"
-	ucidef_set_led_wlan "wifi" "wifi" "soc:blue:wireless" "phy0tpt"
-	ucidef_set_led_netdev "internet" "internet" "soc:blue:broadband" "pppoa-wan"
-	ucidef_set_led_usbdev "usb" "usb" "soc:blue:phone" "1-1"
-	;;
-BTHOMEHUBV3A)
-	ucidef_set_led_default "power" "power" "soc:blue:power" "1"
-	ucidef_set_led_wlan "wifi" "wifi" "soc:blue:wireless" "phy0tpt"
-	ucidef_set_led_netdev "internet" "internet" "soc:blue:broadband" "pppoa-wan"
-	;;
-VGV7510KW22)
-	ucidef_set_led_default "power" "power" "power" "1"
-	ucidef_set_led_default "power2" "power2" "power2" "0"
-	ucidef_set_led_wlan "wifi" "wifi" "wifi" "phy0radio"
-	ucidef_set_led_netdev "dsl" "dsl" "dsl" "nas0"
-	ucidef_set_led_netdev "internet_green" "internet_green" "internet_green" "pppoe-wan"
-	;;
-VGV7519)
-	ucidef_set_led_default "power" "power" "power" "0"
-	ucidef_set_led_default "power2" "power2" "power2" "1"
-	ucidef_set_led_wlan "wireless_yellow" "wireless_yellow" "wireless_yellow" "phy0radio"
-	ucidef_set_led_netdev "internet_yellow" "internet_yellow" "internet_yellow" "nas0"
-	ucidef_set_led_netdev "broadband_yellow" "broadband_yellow" "broadband_yellow" "pppoe-wan"
-	;;
-P2812HNUF*)
-	ucidef_set_led_default "power" "power" "power" "0"
-	ucidef_set_led_default "power2" "power2" "power2" "1"
-	ucidef_set_led_wlan "wireless_green" "wireless_green" "wireless_green" "phy0radio"
-	ucidef_set_led_netdev "dsl" "dsl" "dsl" "nas0"
-	ucidef_set_led_netdev "internet_green" "internet_green" "internet_green" "pppoe-wan"
-	;;
-*)
-	;;
-esac
-
-for a in `ls /sys/class/leds/`; do
-	grep -q "\[none\]" /sys/class/leds/$a/trigger
-	[ $? -eq 0 ] && ucidef_set_led_default $a $a $a `cat /sys/class/leds/$a/brightness`
-done
-
-ucidef_commit_leds
-
-exit 0
diff --git a/target/linux/lantiq/base-files/etc/uci-defaults/02_network b/target/linux/lantiq/base-files/etc/uci-defaults/02_network
deleted file mode 100644
index 20f95a63ac..0000000000
--- a/target/linux/lantiq/base-files/etc/uci-defaults/02_network
+++ /dev/null
@@ -1,200 +0,0 @@
-#!/bin/sh
-#
-# Copyright (C) 2011-2012 OpenWrt.org
-#
-
-[ -e /etc/config/network ] && exit 0
-
-set_atm_wan() {
-	local vpi=$1
-	local vci=$2
-	local encaps=$3
-	local payload=$4
-	uci batch <<EOF
-set network.atm='atm-bridge'
-set network.atm.vpi='$vpi'
-set network.atm.vci='$vci'
-set network.atm.encaps='$encaps'
-set network.atm.payload='$payload'
-set network.wan='interface'
-set network.wan.ifname='nas0'
-set network.wan.proto='pppoe'
-set network.wan.username='foo'
-set network.wan.password='bar'
-set network.wan.ipv6='1'
-set network.wan6='interface'
-set network.wan6.ifname='@wan'
-set network.wan6.proto='dhcpv6'
-EOF
-}
-
-set_adsl_modem() {
-	local annex=$1
-	local firmware=$2
-	uci batch <<EOF
-set network.dsl='adsl'
-set network.dsl.annex='$annex'
-set network.dsl.firmware='$firmware'
-EOF
-}
-
-set_vdsl_modem() {
-	local annex=$1
-	local firmware=$2
-	local tone=$3
-	local xfer_mode=$4
-	uci batch <<EOF
-set network.dsl='vdsl'
-set network.dsl.annex='$annex'
-set network.dsl.firmware='$firmware'
-set network.dsl.tone='$tone'
-set network.dsl.xfer_mode='$xfer_mode'
-EOF
-}
-
-. /lib/functions/uci-defaults.sh
-. /lib/functions/lantiq.sh
-
-touch /etc/config/network
-
-ucidef_set_interface_loopback
-grep -q "nfsroot" /proc/cmdline || ucidef_set_interface_lan 'eth0'
-
-vpi=1
-vci=32
-annex="a"
-encaps="llc"
-payload="bridged"
-lan_mac=""
-wan_mac=""
-
-board=$(lantiq_board_name)
-
-case "$board" in
-# adm6996
-ARV4510PW)
-	lan_mac=$(mtd_get_mac_ascii uboot_env ethaddr)
-	wan_mac=$(macaddr_add "$lan_mac" 1)
-	ucidef_set_interface_lan "eth0.1"
-	ucidef_add_switch "switch0" "1" "1"
-	ucidef_add_switch_vlan "switch0" "1" "3 2 1 0 5t"
-	;;
-
-ARV4520PW)
-	ucidef_set_interface_lan "eth0.1"
-	ucidef_add_switch "switch0" "1" "1"
-	ucidef_add_switch_vlan "switch0" "1" "3 2 1 0 5t"
-	;;
-
-ACMP252|GIGASX76X)
-	ucidef_set_interface_lan "eth0.1"
-	ucidef_add_switch "switch0" "1" "1"
-	ucidef_add_switch_vlan "switch0" "1" "4 3 2 1 5t"
-	;;
-
-# ar8316
-ARV4519PW|ARV7510PW22|ARV7518PW|ARV752DPW22)
-	ucidef_set_interface_lan "eth0.1"
-	ucidef_add_switch "switch0" "1" "1"
-	ucidef_add_switch_vlan "switch0" "1" "0t 2 3 4 5"
-	;;
-
-# rtl8306g
-ARV7519PW)
-	lan_mac=$(mtd_get_mac_binary board_config 22)
-	wan_mac=$(macaddr_add "$lan_mac" 1)
-	ucidef_set_interface_lan "eth0.1"
-	ucidef_add_switch "switch0" "1" "1"
-	ucidef_add_switch_vlan "switch0" "1" "0 1 2 3 4t"
-	;;
-
-WBMR)
-	ucidef_set_interface_lan "eth0.1"
-	ucidef_add_switch "switch0" "1" "1"
-	ucidef_add_switch_vlan "switch0" "1" "0t 2 3 4 5"
-	;;
-
-VG3503J)
-	ucidef_set_interface_lan 'eth0'
-	uci set network.lan.type='none'
-	;;
-
-DGN3500*)
-	ucidef_set_interface_lan "eth0.1"
-	ucidef_add_switch "switch0" "1" "1"
-	ucidef_add_switch_vlan "switch0" "1" "3 2 1 0 5t"
-	;;
-
-GR7000)
-	ucidef_set_interface_wan "eth0"
-	uci set network.lan.ifname=''
-	;;
-
-H201L)
-	ucidef_set_interface_lan "eth0.1"
-	ucidef_add_switch "switch0" "1" "1"
-	ucidef_add_switch_vlan "switch0" "1" "0 1 2 3 4t"
-	;;
-
-#rtl8306g
-P2601HNFX)
-	ucidef_set_interface_lan "eth0.1"
-	ucidef_add_switch "switch0" "1" "1"
-	ucidef_add_switch_vlan "switch0" "1" "0 1 2 3 5t"
-	;;
-
-P2812HNUF*)
-	lan_mac=$(mtd_get_mac_ascii uboot-env ethaddr)
-	wan_mac=$(macaddr_add "$lan_mac" 1)
-	ucidef_set_interface_lan 'eth0.1'
-	ucidef_add_switch "switch0" "1" "1"
-	ucidef_add_switch_vlan "switch0" "1" "0 1 2 4 5 6t"
-	;;
-
-TDW8970)
-	lan_mac=$(mtd_get_mac_binary boardconfig 61696)
-	wan_mac=$(macaddr_add "$lan_mac" 1)
-	ucidef_set_interface_lan 'eth0.1'
-	ucidef_add_switch "switch0" "1" "1"
-	ucidef_add_switch_vlan "switch0" "1" "0 2 4 5 6t"
-	;;
-
-ARV7519RW22)
-	lan_mac=$(mtd_get_mac_binary boardconfig 22)
-	wan_mac=$(macaddr_add "$lan_mac" 1)
-	;;
-
-BTHOMEHUBV2B|BTHOMEHUBV3A)
-	lan_mac=$(mtd_get_mac_ascii uboot_env ethaddr)
-	wan_mac=$(macaddr_add "$lan_mac" 1)
-	;;
-
-VGV7519)
-	lan_mac=$(mtd_get_mac_binary board_config 22)
-	wan_mac=$(macaddr_add "$lan_mac" 1)
-	;;
-
-VGV7510KW22)
-	lan_mac=$(mtd_get_mac_binary board_config 22)
-	wan_mac=$(macaddr_add "$lan_mac" 1)
-	ucidef_set_interface_lan 'eth0.1'
-	ucidef_add_switch "switch0" "1" "1"
-	ucidef_add_switch_vlan "switch0" "1" "2 3 4 5 6t"
-	;;
-
-esac
-
-[ -z "$(ls /lib/modules/`uname -r`/ltq_atm*)" ] || set_atm_wan "$vpi" "$vci" "$encaps" "$payload"
-
-if [ -n "$(grep "system type.*: VR9" /proc/cpuinfo)" ]; then
-	set_vdsl_modem "$annex" "/lib/firmware/vdsl.bin" "av" "ptm"
-else
-	set_adsl_modem "$annex" "/lib/firmware/adsl.bin"
-fi
-
-[ -n "$lan_mac" ] && ucidef_set_interface_macaddr lan $lan_mac
-[ -n "$wan_mac" ] && ucidef_set_interface_macaddr wan $wan_mac
-
-uci commit network
-
-exit 0
diff --git a/target/linux/lantiq/base-files/etc/uci-defaults/03_wireless-wps b/target/linux/lantiq/base-files/etc/uci-defaults/03_wireless-wps
deleted file mode 100644
index e75fb8493f..0000000000
--- a/target/linux/lantiq/base-files/etc/uci-defaults/03_wireless-wps
+++ /dev/null
@@ -1,16 +0,0 @@
-. /lib/functions.sh
-. /lib/functions/lantiq.sh
-
-set_wps() {
-	uci set wireless.$1.wps_pushbutton=0
-	uci set wireless.$1.wps_device_name="OpenWrt - $(lantiq_board_model)"
-}
-
-board=$(lantiq_board_name)
-case $board in
-WBMR)
-	config_load wireless
-	config_foreach set_wps wifi-iface
-	uci commit wireless
-	;;
-esac
diff --git a/target/linux/lantiq/base-files/lib/functions/lantiq.sh b/target/linux/lantiq/base-files/lib/functions/lantiq.sh
deleted file mode 100644
index 88da794ca9..0000000000
--- a/target/linux/lantiq/base-files/lib/functions/lantiq.sh
+++ /dev/null
@@ -1,29 +0,0 @@
-#!/bin/sh
-
-lantiq_board_detect() {
-	name=`grep "^machine" /proc/cpuinfo | sed "s/machine.*: \(.*\)/\1/g" | sed "s/\(.*\) - .*/\1/g"`
-	model=`grep "^machine" /proc/cpuinfo | sed "s/machine.*: \(.*\)/\1/g" | sed "s/.* - \(.*\)/\1/g"`
-	[ -z "$name" ] && name="unknown"
-	[ -z "$model" ] && model="unknown"
-	[ -e "/tmp/sysinfo/" ] || mkdir -p "/tmp/sysinfo/"
-	echo $name > /tmp/sysinfo/board_name
-	echo $model > /tmp/sysinfo/model
-}
-
-lantiq_board_model() {
-	local model
-
-	[ -f /tmp/sysinfo/model ] && model=$(cat /tmp/sysinfo/model)
-	[ -z "$model" ] && model="unknown"
-
-	echo "$model"
-}
-
-lantiq_board_name() {
-	local name
-
-	[ -f /tmp/sysinfo/board_name ] && name=$(cat /tmp/sysinfo/board_name)
-	[ -z "$name" ] && name="unknown"
-
-	echo "$name"
-}
diff --git a/target/linux/lantiq/base-files/lib/functions/lantiq_dsl.sh b/target/linux/lantiq/base-files/lib/functions/lantiq_dsl.sh
deleted file mode 100644
index 56b8652588..0000000000
--- a/target/linux/lantiq/base-files/lib/functions/lantiq_dsl.sh
+++ /dev/null
@@ -1,248 +0,0 @@
-#!/bin/sh /etc/rc.common
-# Copyright (C) 2012-2014 OpenWrt.org
-
-if [ "$( which vdsl_cpe_control )" ]; then
-	XDSL_CTRL=vdsl_cpe_control
-else
-	XDSL_CTRL=dsl_cpe_control
-fi
-
-#
-# Basic functions to send CLI commands to the vdsl_cpe_control daemon
-#
-dsl_cmd() {
-	killall -0 ${XDSL_CTRL} && (
-		echo "$@" > /tmp/pipe/dsl_cpe0_cmd
-		cat /tmp/pipe/dsl_cpe0_ack
-	)
-}
-dsl_val() {
-	echo $(expr "$1" : '.*'$2'=\([-\.[:alnum:]]*\).*')
-}
-
-#
-# Simple divide by 10 routine to cope with one decimal place
-#
-dbt() {
-	local a=$(expr $1 / 10)
-	local b=$(expr $1 % 10)
-	echo "${a}.${b}"
-}
-#
-# Take a number and convert to k or meg
-#
-scale() {
-	local val=$1
-	local a
-	local b
-
-	if [ "$val" -gt 1000000 ]; then
-		a=$(expr $val / 1000)
-		b=$(expr $a % 1000)
-		a=$(expr $a / 1000)
-		printf "%d.%03d Mb" ${a} ${b}
-	elif [ "$val" -gt 1000 ]; then
-		a=$(expr $val / 1000)
-		printf "%d Kb" ${a}
-	else
-		echo "${val} b"
-	fi
-}
-
-#
-# Read the data rates for both directions
-#
-data_rates() {
-	local csg
-	local dru
-	local drd
-	local sdru
-	local sdrd
-
-	csg=$(dsl_cmd g997csg 0 1)
-	drd=$(dsl_val "$csg" ActualDataRate)
-
-	csg=$(dsl_cmd g997csg 0 0)
-	dru=$(dsl_val "$csg" ActualDataRate)
-
-	[ -z "$drd" ] && drd=0
-	[ -z "$dru" ] && dru=0
-
-	sdrd=$(scale $drd)
-	sdru=$(scale $dru)
-
-	if [ "$action" = "lucistat" ]; then
-		echo "dsl.data_rate_down=$drd"
-		echo "dsl.data_rate_up=$dru"
-		echo "dsl.data_rate_down_s=\"$sdrd\""
-		echo "dsl.data_rate_up_s=\"$sdru\""
-	else
-		echo "Data Rate:		${sdrd}/s / ${sdru}/s"
-	fi
-}
-
-#
-# Chipset
-#
-chipset() {
-	local vig
-	local cs
-	local csv
-
-	vig=$(dsl_cmd vig)
-	cs=$(dsl_val "$vig" DSL_ChipSetType)
-	csv=$(dsl_val "$vig" DSL_ChipSetHWVersion)
-
-	if [ "$action" = "lucistat" ]; then
-		echo "dsl.chipset=\"${cs} ${csv}\""
-	else
-		echo "Chipset:		${cs} ${csv}"
-	fi
-}
-
-#
-# Work out how long the line has been up
-#
-line_uptime() {
-	local ccsg
-	local et
-	local etr
-	local d
-	local h
-	local m
-	local s
-	local rc=""
-
-	ccsg=$(dsl_cmd pmccsg 0 0 0)
-	et=$(dsl_val "$ccsg" nElapsedTime)
-
-	[ -z "$et" ] && et=0
-
-	if [ "$action" = "lucistat" ]; then
-		echo "dsl.line_uptime=${et}"
-		return
-	fi
-
-	d=$(expr $et / 86400)
-	etr=$(expr $et % 86400)
-	h=$(expr $etr / 3600)
-	etr=$(expr $etr % 3600)
-	m=$(expr $etr / 60)
-	s=$(expr $etr % 60)
-
-
-	[ "${d}${h}${m}${s}" -ne 0 ] && rc="${s}s"
-	[ "${d}${h}${m}" -ne 0 ] && rc="${m}m ${rc}"
-	[ "${d}${h}" -ne 0 ] && rc="${h}h ${rc}"
-	[ "${d}" -ne 0 ] && rc="${d}d ${rc}"
-
-	[ -z "$rc" ] && rc="down"
-	echo "Line Uptime:		${rc}"
-}
-
-#
-# Get noise and attenuation figures
-#
-line_data() {
-	local lsg
-	local latnu
-	local latnd
-	local snru
-	local snrd
-
-	lsg=$(dsl_cmd g997lsg 1 1)
-	latnd=$(dsl_val "$lsg" LATN)
-	snrd=$(dsl_val "$lsg" SNR)
-
-	lsg=$(dsl_cmd g997lsg 0 1)
-	latnu=$(dsl_val "$lsg" LATN)
-	snru=$(dsl_val "$lsg" SNR)
-
-	[ -z "$latnd" ] && latnd=0
-	[ -z "$latnu" ] && latnu=0
-	[ -z "$snrd" ] && snrd=0
-	[ -z "$snru" ] && snru=0
-
-	latnd=$(dbt $latnd)
-	latnu=$(dbt $latnu)
-	snrd=$(dbt $snrd)
-	snru=$(dbt $snru)
-	
-	if [ "$action" = "lucistat" ]; then
-		echo "dsl.line_attenuation_down=$latnd"
-		echo "dsl.line_attenuation_up=$latnu"
-		echo "dsl.noise_margin_down=$snrd"
-		echo "dsl.noise_margin_up=$snru"
-	else
-		echo "Line Attenuation:	${latnd}dB / ${latnu}dB"
-		echo "Noise Margin:		${snrd}dB / ${snru}dB"
-	fi
-}
-
-#
-# Is the line up? Or what state is it in?
-#
-line_state() {
-	local lsg=$(dsl_cmd lsg)
-	local ls=$(dsl_val "$lsg" nLineState);
-	local s;
-
-	case "$ls" in
-		"0x0")		s="not initialized" ;;
-		"0x1")		s="exception" ;;
-		"0x10")		s="not updated" ;;
-		"0xff")		s="idle request" ;;
-		"0x100")	s="idle" ;;
-		"0x1ff")	s="silent request" ;;
-		"0x200")	s="silent" ;;
-		"0x300")	s="handshake" ;;
-		"0x380")	s="full_init" ;;
-		"0x400")	s="discovery" ;;
-		"0x500")	s="training" ;;
-		"0x600")	s="analysis" ;;
-		"0x700")	s="exchange" ;;
-		"0x800")	s="showtime_no_sync" ;;
-		"0x801")	s="showtime_tc_sync" ;;
-		"0x900")	s="fastretrain" ;;
-		"0xa00")	s="lowpower_l2" ;;
-		"0xb00")	s="loopdiagnostic active" ;;
-		"0xb10")	s="loopdiagnostic data exchange" ;;
-		"0xb20")	s="loopdiagnostic data request" ;;
-		"0xc00")	s="loopdiagnostic complete" ;;
-		"0x1000000")	s="test" ;;
-		"0xd00")	s="resync" ;;
-		"0x3c0")	s="short init entry" ;;
-		"")		s="not running daemon"; ls="0xfff" ;;
-		*)		s="unknown" ;;
-	esac
-
-	if [ "$action" = "lucistat" ]; then
-		echo "dsl.line_state_num=$ls"
-		echo "dsl.line_state_detail=\"$s\""
-		if [ "$ls" = "0x801" ]; then
-			echo "dsl.line_state=\"UP\""
-		else
-			echo "dsl.line_state=\"DOWN\""
-		fi
-	else
-		if [ "$ls" = "0x801" ]; then
-			echo "Line State:		UP [$ls: $s]"
-		else
-			echo "Line State:		DOWN [$ls: $s]"
-		fi
-	fi
-}
-
-status() {
-	chipset
-	line_state
-	data_rates
-	line_data
-	line_uptime
-}
-
-lucistat() {
-	echo "local dsl={}"
-	status
-	echo "return dsl"
-}
diff --git a/target/linux/lantiq/base-files/lib/preinit/03_preinit_board.sh b/target/linux/lantiq/base-files/lib/preinit/03_preinit_board.sh
deleted file mode 100755
index 6d4bd67af5..0000000000
--- a/target/linux/lantiq/base-files/lib/preinit/03_preinit_board.sh
+++ /dev/null
@@ -1,9 +0,0 @@
-#!/bin/sh
-
-do_lantiq() {
-	. /lib/functions/lantiq.sh
-
-	lantiq_board_detect
-}
-
-boot_hook_add preinit_main do_lantiq
diff --git a/target/linux/lantiq/base-files/lib/preinit/05_set_preinit_iface_lantiq b/target/linux/lantiq/base-files/lib/preinit/05_set_preinit_iface_lantiq
deleted file mode 100644
index 3d7fabf8e3..0000000000
--- a/target/linux/lantiq/base-files/lib/preinit/05_set_preinit_iface_lantiq
+++ /dev/null
@@ -1,18 +0,0 @@
-#!/bin/sh
-
-. /lib/functions/lantiq.sh
-
-set_preinit_iface() {
-
-	board=$(lantiq_board_name)
-
-	case "$board" in
-	TDW8970)
-		ifname=eth0
-		;;
-	esac
-
-}
-
-boot_hook_add preinit_main set_preinit_iface
-
diff --git a/target/linux/lantiq/base-files/lib/upgrade/platform.sh b/target/linux/lantiq/base-files/lib/upgrade/platform.sh
deleted file mode 100755
index 1688d3af2e..0000000000
--- a/target/linux/lantiq/base-files/lib/upgrade/platform.sh
+++ /dev/null
@@ -1,37 +0,0 @@
-. /lib/functions/lantiq.sh
-
-PART_NAME=firmware
-
-platform_check_image() {
-	[ "$#" -gt 1 ] && return 1
-	local board=$(lantiq_board_name)
-
-	case "$board" in
-		BTHOMEHUBV2B|BTHOMEHUBV3A|P2812HNUF* )
-			nand_do_platform_check $board $1
-			return $?;
-			;;
-	esac
-
-	case "$(get_magic_word "$1")" in
-		# uImage
-		2705) return 0;;
-		# tplink
-		0200) return 0;;
-		*)
-			echo "Invalid image type"
-			return 1
-		;;
-	esac
-}
-
-# use default for platform_do_upgrade()
-
-disable_watchdog() {
-	killall watchdog
-	( ps | grep -v 'grep' | grep '/dev/watchdog' ) && {
-		echo 'Could not disable watchdog'
-		return 1
-	}
-}
-append sysupgrade_pre_upgrade disable_watchdog
diff --git a/target/linux/lantiq/base-files/sbin/dsl_notify.sh b/target/linux/lantiq/base-files/sbin/dsl_notify.sh
deleted file mode 100755
index b514e257d4..0000000000
--- a/target/linux/lantiq/base-files/sbin/dsl_notify.sh
+++ /dev/null
@@ -1,61 +0,0 @@
-#!/bin/sh
-#
-# This script is called by dsl_cpe_control whenever there is a DSL event,
-# we only actually care about the DSL_INTERFACE_STATUS events as these
-# tell us the line has either come up or gone down.
-#
-# The rest of the code is basically the same at the atm hotplug code
-#
-
-[ "$DSL_NOTIFICATION_TYPE" = "DSL_INTERFACE_STATUS" ] || exit 0
-
-. /usr/share/libubox/jshn.sh
-. /lib/functions.sh
-. /lib/functions/leds.sh
-
-include /lib/network
-scan_interfaces
-
-local default
-config_load system
-config_get default led_adsl default
-if [ "$default" != 1 ]; then
-	case "$DSL_INTERFACE_STATUS" in
-	  "HANDSHAKE")  led_timer dsl 500 500;;
-	  "TRAINING")   led_timer dsl 200 200;;
-	  "UP")		led_on dsl;;
-	  *)		led_off dsl
-	esac
-fi
-
-local interfaces=`ubus list network.interface.\* | cut -d"." -f3`
-local ifc
-for ifc in $interfaces; do
-
-	local up
-	json_load "$(ifstatus $ifc)"
-	json_get_var up up
-
-	local auto
-	config_get_bool auto "$ifc" auto 1
-
-	local proto
-	json_get_var proto proto
-
-	if [ "$DSL_INTERFACE_STATUS" = "UP" ]; then
-		if [ "$proto" = "pppoa" ] && [ "$up" != 1 ] && [ "$auto" = 1 ]; then
-			( sleep 1; ifup "$ifc" ) &
-		fi
-	else
-		if [ "$proto" = "pppoa" ] && [ "$up" = 1 ] && [ "$auto" = 1 ]; then
-			( sleep 1; ifdown "$ifc" ) &
-		else
-			json_get_var autostart autostart
-			if [ "$proto" = "pppoa" ] && [ "$up" != 1 ] && [ "$autostart" = 1 ]; then
-				( sleep 1; ifdown "$ifc" ) &
-			fi
-		fi
-	fi
-done
-
-
diff --git a/target/linux/lantiq/config-3.18 b/target/linux/lantiq/config-3.18
deleted file mode 100644
index 1622a03d02..0000000000
--- a/target/linux/lantiq/config-3.18
+++ /dev/null
@@ -1,151 +0,0 @@
-CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
-CONFIG_ARCH_DISCARD_MEMBLOCK=y
-CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
-CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
-CONFIG_ARCH_HIBERNATION_POSSIBLE=y
-CONFIG_ARCH_REQUIRE_GPIOLIB=y
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
-CONFIG_CEVT_R4K=y
-CONFIG_CLKDEV_LOOKUP=y
-CONFIG_CPU_BIG_ENDIAN=y
-CONFIG_CPU_GENERIC_DUMP_TLB=y
-CONFIG_CPU_HAS_PREFETCH=y
-CONFIG_CPU_HAS_SYNC=y
-CONFIG_CPU_MIPS32=y
-# CONFIG_CPU_MIPS32_R1 is not set
-CONFIG_CPU_MIPS32_R2=y
-CONFIG_CPU_MIPSR2=y
-CONFIG_CPU_R4K_CACHE_TLB=y
-CONFIG_CPU_R4K_FPU=y
-CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
-CONFIG_CPU_SUPPORTS_HIGHMEM=y
-CONFIG_CRYPTO_HASH=y
-CONFIG_CRYPTO_HASH2=y
-CONFIG_CSRC_R4K=y
-CONFIG_DMA_NONCOHERENT=y
-CONFIG_DTC=y
-CONFIG_DT_EASY50712=y
-CONFIG_EARLY_PRINTK=y
-CONFIG_ETHERNET_PACKET_MANGLE=y
-CONFIG_GENERIC_ATOMIC64=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_GENERIC_CMOS_UPDATE=y
-CONFIG_GENERIC_IO=y
-CONFIG_GENERIC_IRQ_SHOW=y
-CONFIG_GENERIC_PCI_IOMAP=y
-CONFIG_GENERIC_SMP_IDLE_THREAD=y
-CONFIG_GPIOLIB=y
-CONFIG_GPIO_MM_LANTIQ=y
-CONFIG_GPIO_STP_XWAY=y
-CONFIG_GPIO_SYSFS=y
-CONFIG_HARDWARE_WATCHPOINTS=y
-CONFIG_HAS_DMA=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAVE_ARCH_JUMP_LABEL=y
-CONFIG_HAVE_ARCH_KGDB=y
-CONFIG_HAVE_CLK=y
-CONFIG_HAVE_C_RECORDMCOUNT=y
-CONFIG_HAVE_DEBUG_KMEMLEAK=y
-CONFIG_HAVE_DMA_API_DEBUG=y
-CONFIG_HAVE_DMA_ATTRS=y
-CONFIG_HAVE_DYNAMIC_FTRACE=y
-CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
-CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
-CONFIG_HAVE_FUNCTION_TRACER=y
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_HAVE_IDE=y
-CONFIG_HAVE_KVM=y
-CONFIG_HAVE_MACH_CLKDEV=y
-CONFIG_HAVE_MEMBLOCK=y
-CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
-CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
-CONFIG_HAVE_NET_DSA=y
-CONFIG_HAVE_OPROFILE=y
-CONFIG_HAVE_PERF_EVENTS=y
-CONFIG_HW_HAS_PCI=y
-CONFIG_HW_RANDOM=y
-CONFIG_HZ=250
-# CONFIG_HZ_100 is not set
-CONFIG_HZ_250=y
-# CONFIG_IEEE802154 is not set
-# CONFIG_IFX_UDP_REDIRECT is not set
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_IRQ_CPU=y
-CONFIG_IRQ_DOMAIN=y
-CONFIG_IRQ_FORCED_THREADING=y
-CONFIG_LANTIQ=y
-CONFIG_LANTIQ_ETOP=y
-# CONFIG_LANTIQ_PHY is not set
-CONFIG_LANTIQ_WDT=y
-# CONFIG_LANTIQ_XRX200 is not set
-CONFIG_LEDS_GPIO=y
-CONFIG_MDIO_BOARDINFO=y
-CONFIG_MIPS=y
-# CONFIG_MIPS_HUGE_TLB_SUPPORT is not set
-CONFIG_MIPS_L1_CACHE_SHIFT=5
-# CONFIG_MIPS_MACHINE is not set
-# CONFIG_MIPS_MT_SMP is not set
-# CONFIG_MIPS_VPE_LOADER is not set
-CONFIG_MODULES_USE_ELF_REL=y
-CONFIG_MTD_CFI_ADV_OPTIONS=y
-CONFIG_MTD_CFI_GEOMETRY=y
-CONFIG_MTD_CMDLINE_PARTS=y
-CONFIG_MTD_JEDECPROBE=y
-CONFIG_MTD_LANTIQ=y
-CONFIG_MTD_M25P80=y
-# CONFIG_MTD_NAND_XWAY is not set
-CONFIG_MTD_SPI_NOR=y
-CONFIG_MTD_SPLIT_FIRMWARE=y
-CONFIG_MTD_UIMAGE_SPLIT=y
-CONFIG_NEED_DMA_MAP_STATE=y
-CONFIG_NEED_PER_CPU_KM=y
-CONFIG_NO_GENERIC_PCI_IOPORT_MAP=y
-CONFIG_OF=y
-CONFIG_OF_ADDRESS=y
-CONFIG_OF_EARLY_FLATTREE=y
-CONFIG_OF_FLATTREE=y
-CONFIG_OF_GPIO=y
-CONFIG_OF_IRQ=y
-CONFIG_OF_MDIO=y
-CONFIG_OF_MTD=y
-CONFIG_OF_NET=y
-CONFIG_OF_PCI=y
-CONFIG_OF_PCI_IRQ=y
-CONFIG_PAGEFLAGS_EXTENDED=y
-CONFIG_PCI=y
-# CONFIG_PCIE_LANTIQ is not set
-CONFIG_PCI_DOMAINS=y
-CONFIG_PCI_LANTIQ=y
-CONFIG_PERF_USE_VMALLOC=y
-CONFIG_PHYLIB=y
-CONFIG_PINCTRL=y
-CONFIG_PINCTRL_LANTIQ=y
-# CONFIG_PINCTRL_SINGLE is not set
-CONFIG_PINCTRL_XWAY=y
-# CONFIG_PREEMPT_RCU is not set
-CONFIG_PSB6970_PHY=y
-CONFIG_RTL8366RB_PHY=y
-CONFIG_RTL8366_SMI=y
-# CONFIG_SCSI_DMA is not set
-# CONFIG_SERIAL_8250 is not set
-CONFIG_SERIAL_LANTIQ=y
-# CONFIG_SOC_AMAZON_SE is not set
-# CONFIG_SOC_FALCON is not set
-CONFIG_SOC_TYPE_XWAY=y
-CONFIG_SOC_XWAY=y
-# CONFIG_SPI_XWAY_BV is not set
-# CONFIG_SPI_XWAY_CSI is not set
-CONFIG_SWAP_IO_SPACE=y
-CONFIG_SWCONFIG=y
-CONFIG_SYS_HAS_CPU_MIPS32_R1=y
-CONFIG_SYS_HAS_CPU_MIPS32_R2=y
-CONFIG_SYS_HAS_EARLY_PRINTK=y
-CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
-CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
-CONFIG_SYS_SUPPORTS_BIG_ENDIAN=y
-CONFIG_SYS_SUPPORTS_MULTITHREADING=y
-CONFIG_TICK_CPU_ACCOUNTING=y
-CONFIG_USE_OF=y
-CONFIG_ZONE_DMA_FLAG=0
diff --git a/target/linux/lantiq/dts/ACMP252.dts b/target/linux/lantiq/dts/ACMP252.dts
deleted file mode 100644
index d7d5b32aa5..0000000000
--- a/target/linux/lantiq/dts/ACMP252.dts
+++ /dev/null
@@ -1,96 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "ACMP252 - AudioCodes MediaPack MP-252";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-			gpios = <&gpio 31 0>;
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x0 0x20000>;
-					read-only;
-				};
-
-				partition@20000 {
-					label = "uboot_env";
-					reg = <0x20000 0x20000>;
-				};
-
-				partition@40000 {
-					label = "boardconfig";
-					reg = <0x40000 0x60000>;
-					read-only;
-				};
-
-				partition@a0000 {
-					label = "firmware";
-					reg = <0xa0000 0xf20000>;
-				};
-
-				partition@fc0000 {
-					label = "sysconfig";
-					reg = <0xfc0000 0x40000>;
-				};
-
-				partition@0x1000000 {
-					label = "rootfs_data";
-					reg = <0x1000000 0x1000000>;
-				};
-
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				exin {
-					lantiq,groups = "exin1";
-					lantiq,function = "exin";
-				};
-				pci {
-					lantiq,groups = "gnt1", "req1";
-					lantiq,function = "pci";
-				};
-			};
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 3 0>;
-		};
-
-		etop@E180000 {
-			phy-mode = "rmii";
-		};
-
-		pci@E105400 {
-			status = "okay";
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/ARV4510PW.dts b/target/linux/lantiq/dts/ARV4510PW.dts
deleted file mode 100644
index 47724959a1..0000000000
--- a/target/linux/lantiq/dts/ARV4510PW.dts
+++ /dev/null
@@ -1,211 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "ARV4510PW - Wippies, Elisa";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x2000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x1000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				lantiq,noxip;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x40000>;
-					read-only;
-				};
-
-				partition@40000 {
-					label = "uboot_env";
-					reg = <0x40000 0x20000>;
-					read-only;
-				};
-
-				partition@60000 {
-					label = "firmware";
-					reg = <0x60000 0xfa0000>;
-				};
-			};
-		};
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				ebu {
-					lantiq,groups = "ebu a23";
-					lantiq,function = "ebu";
-					lantiq,open-drain = <0>;
-					lantiq,output = <1>;
-				};
-				stp {
-					lantiq,groups = "stp";
-					lantiq,function = "stp";
-					lantiq,open-drain = <0>;
-					lantiq,output = <1>;
-				};
-				exin {
-					lantiq,groups = "exin1", "exin2";
-					lantiq,function = "exin";
-					lantiq,output = <0>;
-				};
-				pci_in {
-					lantiq,groups = "req1", "req2";
-					lantiq,function = "pci";
-					lantiq,output = <0>;
-				};
-				pci_out {
-					lantiq,groups = "gnt1", "gnt2";
-					lantiq,function = "pci";
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-				pci_rst {
-					lantiq,pins = "io21";
-					lantiq,open-drain = <0>;
-					lantiq,output = <1>;
-				};
-				buttons {
-					lantiq,pins = "io3", "io14";
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-			};
-		};
-
-		gpios: stp@E100BB0 {
-			status = "okay";
-			lantiq,groups = <0x7>;
-		};
-
-		etop@E180000 {
-			phy-mode = "rmii";
-		};
-
-		pci@E105400 {
-			status = "okay";
-			lantiq,external-clock;
-			interrupt-map = <
-				0x6000 0 0 1 &icu0 135
-				0x7800 0 0 1 &icu0 66
-				0x7800 0 0 2 &icu0 66
-				0x7800 0 0 3 &icu0 66
-			>;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0x7>;
-		};
-
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		wps {
-			label = "wps";
-			gpios = <&gpio 14 1>;
-			linux,code = <0x211>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 3 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-		power {
-			label = "power";
-			gpios = <&gpios 21 0>;
-		};
-		power2 {
-			label = "power2";
-			gpios = <&gpios 20 0>;
-		};
-		lan1 {
-			label = "lan1";
-			gpios = <&gpios 19 0>;
-		};
-		lan2 {
-			label = "lan2";
-			gpios = <&gpios 18 0>;
-		};
-		lan3 {
-			label = "lan3";
-			gpios = <&gpios 17 0>;
-		};
-		lan4 {
-			label = "lan4";
-			gpios = <&gpios 16 0>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpios 15 0>;
-		};
-		adsl {
-			label = "adsl";
-			gpios = <&gpios 14 0>;
-		};
-		internet {
-			label = "internet";
-			gpios = <&gpios 13 0>;
-		};
-		internet2 {
-			label = "internet2";
-			gpios = <&gpios 12 0>;
-		};
-		voip {
-			label = "voip";
-			gpios = <&gpios 11 0>;
-		};
-		phone {
-			label = "phone";
-			gpios = <&gpios 10 0>;
-		};
-		phone2 {
-			label = "phone2";
-			gpios = <&gpios 9 0>;
-		};
-		usb {
-			label = "usb";
-			gpios = <&gpios 8 0>;
-		};
-		usb2 {
-			label = "usb2";
-			gpios = <&gpios 7 0>;
-		};
-		usb3 {
-			label = "usb3";
-			gpios = <&gpios 6 0>;
-		};
-		unlabeled {
-			label = "unlabeled";
-			gpios = <&gpios 5 0>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/ARV4518PWR01.dts b/target/linux/lantiq/dts/ARV4518PWR01.dts
deleted file mode 100644
index f2a2e188b9..0000000000
--- a/target/linux/lantiq/dts/ARV4518PWR01.dts
+++ /dev/null
@@ -1,192 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "ARV4518PWR01 - SMC7908A-ISP";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-			gpios = <&gpio 31 0>;
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x10000>; /* 64 KB */
-					read-only;
-				};
-
-				partition@10000 {
-					label = "uboot_env";
-					reg = <0x10000 0x10000>; /* 64 KB */
-					read-only;
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x20000 0x3d0000>;
-				};
-
-				partition@400000 {
-					label = "boardconfig";
-					reg = <0x3f0000 0x10000>;
-					read-only;
-				};
-			};
-
-			gpiomm: gpiomm@4000000 {
-				compatible = "lantiq,gpio-mm";
-				reg = <1 0x0 0x10 >;
-				#address-cells = <1>;
-				#size-cells = <1>;
-				#gpio-cells = <2>;
-				gpio-controller;
-				lantiq,shadow = <0x0>;
-			};
-
-			mac_addr {
-				compatible = "lantiq,eth-mac";
-				reg = <0 0x3f0016 0x6>;
-				mac-increment = <2>;
-			};
-
-			ath5k_eep {
-				compatible = "ath5k,eeprom";
-				reg = <0 0x3f0400 0x1000
-					0 0x3f0016 0x6>;
-				ath,mac-increment = <1>;
-				ath,eep-swap;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				ebu {
-					lantiq,groups = "ebu cs1";
-					lantiq,function = "ebu";
-				};
-				pci_in {
-					lantiq,groups = "req1", "req2";
-					lantiq,function = "pci";
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-				pci_out {
-					lantiq,groups = "gnt1", "gnt2";
-					lantiq,function = "pci";
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "mii";
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 14 0>;
-		};
-
-		pci@E105400 {
-			status = "okay";
-			lantiq,internal-clock;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0xf>;
-		};
-
-	};
-
-/*
-#define ARV4518PW_SWITCH_RESET          13
-*/
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		rfkill {
-			label = "rfkill";
-			gpios = <&gpio 28 1>;
-			linux,code = <0xf7>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 30 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-		power {
-			label = "power";
-			gpios = <&gpio 3 0>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 4 1>;
-		};
-		online {
-			label = "online";
-			gpios = <&gpio 5 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpio 6 1>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 7 1>;
-		};
-		dsl2 {
-			label = "dsl2";
-			gpios = <&gpio 8 1>;
-		};
-		usb {
-			label = "usb";
-			gpios = <&gpio 19 1>;
-		};
-		voice {
-			label = "voice";
-			gpios = <&gpiomm 0 1>;
-		};
-		fxs1 {
-			label = "fxs1";
-			gpios = <&gpiomm 1 1>;
-		};
-		fxs2 {
-			label = "fxs2";
-			gpios = <&gpiomm 2 1>;
-		};
-		fxo {
-			label = "fxo";
-			gpios = <&gpiomm 3 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/ARV4518PWR01A.dts b/target/linux/lantiq/dts/ARV4518PWR01A.dts
deleted file mode 100644
index 221e5a0c25..0000000000
--- a/target/linux/lantiq/dts/ARV4518PWR01A.dts
+++ /dev/null
@@ -1,192 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "ARV4518PWR01A - SMC7908A-ISP, Airties WAV-221";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-			gpios = <&gpio 31 0>;
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x10000>; /* 64 KB */
-					read-only;
-				};
-
-				partition@10000 {
-					label = "uboot_env";
-					reg = <0x10000 0x10000>; /* 64 KB */
-					read-only;
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x20000 0x3d0000>;
-				};
-
-				partition@400000 {
-					label = "boardconfig";
-					reg = <0x3f0000 0x10000>;
-					read-only;
-				};
-			};
-
-			gpiomm: gpiomm@4000000 {
-				compatible = "lantiq,gpio-mm";
-				reg = <1 0x0 0x10 >;
-				#address-cells = <1>;
-				#size-cells = <1>;
-				#gpio-cells = <2>;
-				gpio-controller;
-				lantiq,shadow = <0x0>;
-			};
-
-			mac_addr {
-				compatible = "lantiq,eth-mac";
-				reg = <0 0x3f0016 0x6>;
-				mac-increment = <2>;
-			};
-
-			ath5k_eep {
-				compatible = "ath5k,eeprom";
-				reg = <0 0x3f0400 0x1000
-					0 0x3f0016 0x6>;
-				ath,mac-increment = <1>;
-				ath,eep-swap;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				ebu {
-					lantiq,groups = "ebu cs1";
-					lantiq,function = "ebu";
-				};
-				pci_in {
-					lantiq,groups = "req1", "req2";
-					lantiq,function = "pci";
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-				pci_out {
-					lantiq,groups = "gnt1", "gnt2";
-					lantiq,function = "pci";
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "mii";
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 14 0>;
-		};
-
-		pci@E105400 {
-			status = "okay";
-			lantiq,external-clock;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0xf>;
-		};
-
-	};
-
-/*
-#define ARV4518PW_SWITCH_RESET          13
-*/
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		rfkill {
-			label = "rfkill";
-			gpios = <&gpio 28 1>;
-			linux,code = <0xf7>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 30 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-		power {
-			label = "power";
-			gpios = <&gpio 3 0>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 4 1>;
-		};
-		online {
-			label = "online";
-			gpios = <&gpio 5 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpio 6 1>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 7 1>;
-		};
-		dsl2 {
-			label = "dsl2";
-			gpios = <&gpio 8 1>;
-		};
-		usb {
-			label = "usb";
-			gpios = <&gpio 19 1>;
-		};
-		voice {
-			label = "voice";
-			gpios = <&gpiomm 0 1>;
-		};
-		fxs1 {
-			label = "fxs1";
-			gpios = <&gpiomm 1 1>;
-		};
-		fxs2 {
-			label = "fxs2";
-			gpios = <&gpiomm 2 1>;
-		};
-		fxo {
-			label = "fxo";
-			gpios = <&gpiomm 3 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/ARV4519PW.dts b/target/linux/lantiq/dts/ARV4519PW.dts
deleted file mode 100644
index a0a080378e..0000000000
--- a/target/linux/lantiq/dts/ARV4519PW.dts
+++ /dev/null
@@ -1,178 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "ARV4519PW - Vodafone, Pirelli";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x2000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-			gpios = <&gpio 31 0>;
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x10000>;
-					read-only;
-				};
-
-				partition@10000 {
-					label = "uboot_env";
-					reg = <0x10000 0x10000>;
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x20000 0x3d0000>;
-				};
-
-				partition@3f0000 {
-					label = "boardconfig";
-					reg = <0x3f0000 0x10000>;
-					read-only;
-				};
-			};
-
-			gpiomm: gpiomm@4000000 {
-				compatible = "lantiq,gpio-mm";
-				reg = <1 0x0 0x10 >;
-				#address-cells = <1>;
-				#size-cells = <1>;
-				#gpio-cells = <2>;
-				gpio-controller;
-				lantiq,shadow = <0x400>;
-			};
-
-			mac_addr {
-				compatible = "lantiq,eth-mac";
-				reg = <0 0x3f0016 0x6>;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				ebu {
-					lantiq,groups = "ebu cs1";
-					lantiq,function = "ebu";
-				};
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "mii";
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 14 0>;
-		};
-
-		pci@E105400 {
-			status = "okay";
-			lantiq,external-clock;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0xf>;
-		};
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		rfkill {
-			label = "rfkill";
-			gpios = <&gpio 28 1>;
-			linux,code = <0xf7>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 30 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		power {
-			label = "power";
-			gpios = <&gpio 2 1>;
-		};
-		power2 {
-			label = "power2";
-			gpios = <&gpio 7 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpio 6 1>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 4 1>;
-		};
-		online {
-			label = "online";
-			gpios = <&gpio 5 1>;
-		};
-		online2 {
-			label = "online2";
-			gpios = <&gpio 8 1>;
-		};
-		usb {
-			label = "usb";
-			gpios = <&gpio 19 1>;
-		};
-		voip {
-			label = "voip";
-			gpios = <&gpiomm 0 1>;
-		};
-		fxs1 {
-			label = "fxs1";
-			gpios = <&gpiomm 1 1>;
-		};
-		fxs2 {
-			label = "fxs2";
-			gpios = <&gpiomm 2 1>;
-		};
-		fxo {
-			label = "fxo";
-			gpios = <&gpiomm 3 1>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpiomm 5 1>;
-		};
-		wps2 {
-			label = "wps2";
-			gpios = <&gpiomm 4 1>;
-		};
-		wps3 {
-			label = "wps3";
-			gpios = <&gpiomm 6 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/ARV4520PW.dts b/target/linux/lantiq/dts/ARV4520PW.dts
deleted file mode 100644
index 8a5b7977c4..0000000000
--- a/target/linux/lantiq/dts/ARV4520PW.dts
+++ /dev/null
@@ -1,200 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "ARV4520PW - Easybox 800, WAV-281";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x2000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-			gpios = <&gpio 31 0
-				&gpiomm 7 0>;
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x800000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x20000>;
-					read-only;
-				};
-
-				partition@20000 {
-					label = "uboot_env";
-					reg = <0x20000 0x10000>;
-					read-only;
-				};
-
-				partition@30000 {
-					label = "firmware";
-					reg = <0x30000 0x3c0000>;
-				};
-
-				partition@7f0000 {
-					label = "boardconfig";
-					reg = <0x3f0000 0x10000>;
-					read-only;
-				};
-			};
-
-			mac_addr {
-				compatible = "lantiq,eth-mac";
-				reg = <0 0x3f0016 0x6>;
-				mac-increment = <2>;
-			};
-
-			gpiomm: gpiomm@4000000 {
-				compatible = "lantiq,gpio-mm";
-				reg = <1 0x0 0x10 >;
-				#address-cells = <1>;
-				#size-cells = <1>;
-				#gpio-cells = <2>;
-				gpio-controller;
-				lantiq,shadow = <0x400>;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				ebu {
-					lantiq,groups = "ebu cs1";
-					lantiq,function = "ebu";
-				};
-				pci_in {
-					lantiq,groups = "req1";
-					lantiq,function = "pci";
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-				pci_out {
-					lantiq,groups = "gnt1";
-					lantiq,function = "pci";
-					lantiq,output = <1>;
-				};
-				pci_rst {
-					lantiq,pins = "io21";
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-				};
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "rmii";
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-                        gpios = <&gpio 28 0>;
-		};
-
-		pci@E105400 {
-			status = "okay";
-			lantiq,external-clock;
-			gpio-reset = <&gpio 21 0>;
-		};
-
-	};
-
-// gpiomm 10 - switch
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		rfkill {
-			label = "wps";
-			gpios = <&gpio 29 1>;
-			linux,code = <0x211>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 30 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		power {
-			label = "power";
-			gpios = <&gpio 3 1>;
-		};
-		adsl {
-			label = "adsl";
-			gpios = <&gpio 4 1>;
-		};
-		internet {
-			label = "internet";
-			gpios = <&gpio 5 1>;
-		};
-		power2 {
-			label = "power2";
-			gpios = <&gpio 6 1>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 7 1>;
-		};
-		wps2 {
-			label = "wps2";
-			gpios = <&gpio 9 1>;
-		};
-		fxs1 {
-			label = "fxs1";
-			gpios = <&gpiomm 0 1>;
-		};
-		fxs2 {
-			label = "fxs2";
-			gpios = <&gpiomm 1 1>;
-		};
-		isdn {
-			label = "isdn";
-			gpios = <&gpiomm 2 1>;
-		};
-		fxo {
-			label = "fxo";
-			gpios = <&gpiomm 3 1>;
-		};
-		voice {
-			label = "voice";
-			gpios = <&gpiomm 4 1>;
-		};
-		usb {
-			label = "usb";
-			gpios = <&gpiomm 5 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpiomm 6 1>;
-		};
-		internet2 {
-			label = "internet2";
-			gpios = <&gpiomm 9 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/ARV4525PW.dts b/target/linux/lantiq/dts/ARV4525PW.dts
deleted file mode 100644
index 3c420e7cf2..0000000000
--- a/target/linux/lantiq/dts/ARV4525PW.dts
+++ /dev/null
@@ -1,153 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "ARV4525PW - Speedport W501V Typ A";
-
-	memory@0 {
-		reg = <0x0 0x2000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-			gpios = <&gpio 31 0>;
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x10000>;
-					read-only;
-				};
-
-				partition@10000 {
-					label = "uboot_env";
-					reg = <0x10000 0x10000>;
-					read-only;
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x20000 0x3d0000>;
-				};
-
-				partition@400000 {
-					label = "boardconfig";
-					reg = <0x3f0000 0x10000>;
-					read-only;
-				};
-			};
-
-			mac_addr {
-				compatible = "lantiq,eth-mac";
-				reg = <0 0x3f0016 0x6>;
-				mac-increment = <2>;
-			};
-
-			ath5k_eep {
-				compatible = "ath5k,eeprom";
-				reg = <0 0x3f0400 0x1000>;
-				ath,mac-offset = <0>;
-				ath,eep-swap;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				pci_in {
-					lantiq,groups = "req1";
-					lantiq,function = "pci";
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-				pci_out {
-					lantiq,groups = "gnt1";
-					lantiq,function = "pci";
-					lantiq,output = <1>;
-				};
-				pci_rst {
-					lantiq,pins = "io21";
-					lantiq,pull = <2>;
-					lantiq,output = <1>;
-				};
-				relay {
-					lantiq,pins = "io31";
-					lantiq,output = <1>;
-				};
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "mii";
-		};
-
-		pci@E105400 {
-			status = "okay";
-			gpio-reset = <&gpio 21 0>;
-		};
-
-	};
-
-/*
-#define ARV4525PW_PHYRESET	13
-#define ARV4525PW_RELAY		31
-*/
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		wps {
-			label = "wps";
-			gpios = <&gpio 29 1>;
-			linux,code = <0x211>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 30 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-		fxo {
-			label = "fxo";
-			gpios = <&gpio 4 1>;
-		};
-		fxs {
-			label = "fxs";
-			gpios = <&gpio 5 1>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 6 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpio 8 1>;
-		};
-		online {
-			/*label = "online"; - we dont have a power led, lets use this one */
-			label = "power";
-			gpios = <&gpio 9 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/ARV452CQW.dts b/target/linux/lantiq/dts/ARV452CQW.dts
deleted file mode 100644
index fd7759ec07..0000000000
--- a/target/linux/lantiq/dts/ARV452CQW.dts
+++ /dev/null
@@ -1,219 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "ARV452CQW - Arcor 801";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x2000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-			gpios = <&gpio 31 0
-				&gpiomm 7 0>;
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x400000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x10000>;
-					read-only;
-				};
-
-				partition@10000 {
-					label = "uboot_env";
-					reg = <0x10000 0x10000>;
-					read-only;
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x20000 0x3d0000>;
-				};
-
-				partition@3f0000 {
-					label = "boardconfig";
-					reg = <0x3f0000 0x10000>;
-					read-only;
-				};
-			};
-
-			mac_addr {
-				compatible = "lantiq,eth-mac";
-				reg = <0 0x3f0016 0x6>;
-				mac-increment = <2>;
-			};
-
-			ath5k_eep {
-				compatible = "ath5k,eeprom";
-				reg = <0 0x3f0400 0x1000>;
-				ath,mac-offset = <0>;
-				ath,eep-swap;
-			};
-			gpiomm: gpiomm@4000000 {
-				compatible = "lantiq,gpio-mm";
-				reg = <1 0x0 0x10>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-				#gpio-cells = <2>;
-				gpio-controller;
-				lantiq,shadow = <0x77f>;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				ebu {
-					lantiq,groups = "ebu cs1";
-					lantiq,function = "ebu";
-				};
-				pci_in {
-					lantiq,groups = "req1";
-					lantiq,function = "pci";
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-				pci_out {
-					lantiq,groups = "gnt1";
-					lantiq,function = "pci";
-					lantiq,output = <1>;
-				};
-				pci_rst {
-					lantiq,pins = "io21";
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-				leds {
-					lantiq,pins = "io3", "io5", "io6", "io7", "io9";
-					lantiq,output = <1>;
-				};
-			};
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 28 0>;
-		};
-
-		etop@E180000 {
-			phy-mode = "rmii";
-		};
-
-		pci@E105400 {
-			status = "okay";
-			lantiq,external-clock;
-			gpio-reset = <&gpio 21 0>;
-		};
-
-	};
-
-/*
-#define ARV452CPW_SWITCH_RESET          110
-*/
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled1";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		wps {
-			label = "wps";
-			gpios = <&gpio 11 1>;
-			linux,code = <0x101>;
-		};
-		restart {
-			label = "restart";
-			gpios = <&gpio 12 1>;
-			linux,code = <0x110>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 28 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-		power0 {
-			label = "power0";
-			gpios = <&gpio 3 1>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 4 1>;
-		};
-		isdn {
-			label = "isdn";
-			gpios = <&gpio 5 1>;
-		};
-		power1 {
-			label = "power1";
-			gpios = <&gpio 6 1>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 7 1>;
-		};
-		wps1 {
-			label = "wps1";
-			gpios = <&gpio 9 1>;
-		};
-		fxs1 {
-			label = "fxs1";
-			gpios = <&gpiomm 0 1>;
-		};
-		fxs2 {
-			label = "fxs2";
-			gpios = <&gpiomm 1 1>;
-		};
-		wps2 {
-			label = "wps2";
-			gpios = <&gpiomm 2 1>;
-		};
-		fxo {
-			label = "fxo";
-			gpios = <&gpiomm 3 1>;
-		};
-		voice {
-			label = "voice";
-			gpios = <&gpiomm 4  1>;
-		};
-		usb {
-			label = "usb";
-			gpios = <&gpiomm 5 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpiomm 6 1>;
-		};
-		dsl2 {
-			label = "dsl2";
-			gpios = <&gpiomm 8 1>;
-		};
-		dsl3 {
-			label = "dsl3";
-			gpios = <&gpiomm 9 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/ARV7510PW22.dts b/target/linux/lantiq/dts/ARV7510PW22.dts
deleted file mode 100644
index 24c396d8bb..0000000000
--- a/target/linux/lantiq/dts/ARV7510PW22.dts
+++ /dev/null
@@ -1,179 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "ARV7510PW22 - Astoria Networks";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-			gpios = <&gpio 9 0>;
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x1000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x40000>;
-					read-only;
-				};
-
-				partition@40000 {
-					label = "uboot_env";
-					reg = <0x40000 0x20000>;
-					read-only;
-				};
-
-				partition@60000 {
-					label = "firmware";
-					reg = <0x60000 0xf80000>;
-				};
-
-				partition@fe0000 {
-					label = "board_config";
-					reg = <0xfe0000 0x20000>;
-					read-only;
-				};
-			};
-
-			mac_addr {
-				compatible = "lantiq,eth-mac";
-				reg = <0 0xfe0016 0x6>;
-				mac-increment = <2>;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				exin {
-					lantiq,groups = "exin1";
-					lantiq,function = "exin";
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-				pci_in {
-					lantiq,groups = "req1", "req2";
-					lantiq,function = "pci";
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-				pci_out {
-					lantiq,groups = "gnt1";
-					lantiq,function = "pci";
-					lantiq,output = <1>;
-				};
-				pci_rst {
-					lantiq,pins = "io21";
-					lantiq,pull = <2>;
-					lantiq,output = <1>;
-				};
-				pins_out {
-					lantiq,pins = "io2", "io4", "io8", "io9", "io10", "io15", "io20";
-					lantiq,output = <1>;
-				};
-				pins_in {
-					lantiq,pins = "io11", "io12", "io28";
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-			};
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 8 0>;
-		};
-
-		etop@E180000 {
-			phy-mode = "mii";
-			/* Switch reset 19 */
-		};
-
-		pci@E105400 {
-			status = "okay";
-			lantiq,external-clock;
-			interrupt-map = <
-				0x7000 0 0 1 &icu0 30
-				0x7800 0 0 1 &icu0 135
-				0x7800 0 0 2 &icu0 135
-				0x7800 0 0 3 &icu0 135
-			>;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0x3>;
-		};
-	};
-
-	ralink_eep {
-		compatible = "ralink,eeprom";
-		ralink,eeprom = "RT2860.eeprom";
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		rfkill {
-			label = "rfkill";
-			gpios = <&gpio 11 1>;
-			linux,code = <0xf7>;
-		};
-		restart {
-			label = "restart";
-			gpios = <&gpio 12 1>;
-			linux,code = <0x100>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 28 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-		power {
-			label = "power";
-			gpios = <&gpio 2 1>;
-		};
-		internet {
-			label = "internet";
-			gpios = <&gpio 4 1>;
-		};
-		wlan {
-			label = "wlan";
-			gpios = <&gpio 10 1>;
-		};
-		3g {
-			label = "3g";
-			gpios = <&gpio 15 1>;
-		};
-		message {
-			label = "message";
-			gpios = <&gpio 20 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/ARV7518PW.dts b/target/linux/lantiq/dts/ARV7518PW.dts
deleted file mode 100644
index c6f4759ed4..0000000000
--- a/target/linux/lantiq/dts/ARV7518PW.dts
+++ /dev/null
@@ -1,218 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "ARV7518PW - Astoria Networks";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x10000>;
-					read-only;
-				};
-
-				partition@10000 {
-					label = "uboot_env";
-					reg = <0x10000 0x10000>;
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x20000 0x7d0000>;
-				};
-
-				partition@400000 {
-					label = "boardconfig";
-					reg = <0x7f0000 0x10000>;
-					read-only;
-				};
-			};
-
-			gpiomm: gpiomm@4000000 {
-				compatible = "lantiq,gpio-mm";
-				reg = <1 0x0 0x10 >;
-				#address-cells = <1>;
-				#size-cells = <1>;
-				#gpio-cells = <2>;
-				gpio-controller;
-				lantiq,shadow = <0x0>;
-			};
-
-			mac_addr {
-				compatible = "lantiq,eth-mac";
-				reg = <0 0x7f0016 0x6>;
-				mac-increment = <2>;
-			};
-
-			ath9k_eep {
-				compatible = "ath9k,eeprom";
-				reg = <0 0x7f0400 0x1000
-					0 0x7f0016 0x6>;
-				ath,mac-increment = <1>;
-				ath,pci-slot = <14>;
-				ath,eep-endian;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				ebu {
-					lantiq,groups = "ebu cs1";
-					lantiq,function = "ebu";
-				};
-				pci_in {
-					lantiq,groups = "req1";
-					lantiq,function = "pci";
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-				pci_out {
-					lantiq,groups = "gnt1";
-					lantiq,function = "pci";
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-				pci_rst {
-					lantiq,pins = "io21";
-					lantiq,pull = <2>;
-					lantiq,output = <1>;
-				};
-				leds {
-					lantiq,pins = "io2", "io4", "io5", "io6", "io7", "io8", "io19";
-					lantiq,output = <1>;
-				};
-				keys {
-					lantiq,pins = "io28", "io30";
-					lantiq,output = <0>;
-					lantiq,pull = <2>;
-					lantiq,open-drain = <1>;
-				};
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "mii";
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 14 0>;
-		};
-
-		pci@E105400 {
-			status = "okay";
-			lantiq,external-clock;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0xf>;
-		};
-
-	};
-
-/*
-#define SWITCH_RESET          13
-*/
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		rfkill {
-			label = "rfkill";
-			gpios = <&gpio 28 1>;
-			linux,code = <0xf7>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 30 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-		power {
-			label = "power";
-			gpios = <&gpio 2 1>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 4 1>;
-		};
-		online {
-			label = "online";
-			gpios = <&gpio 5 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpio 6 1>;
-		};
-		power2 {
-			label = "power2";
-			gpios = <&gpio 7 1>;
-		};
-		online2 {
-			label = "online2";
-			gpios = <&gpio 8 1>;
-		};
-		usb {
-			label = "usb";
-			gpios = <&gpio 19 1>;
-		};
-		voice {
-			label = "voice";
-			gpios = <&gpiomm 0 1>;
-		};
-		fxs1 {
-			label = "fxs1";
-			gpios = <&gpiomm 1 1>;
-		};
-		fxs2 {
-			label = "fxs2";
-			gpios = <&gpiomm 2 1>;
-		};
-		fxo {
-			label = "fxo";
-			gpios = <&gpiomm 3 1>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpiomm 4 1>;
-		};
-		wps2 {
-			label = "wps2";
-			gpios = <&gpiomm 5 1>;
-		};
-		wps3 {
-			label = "wps3";
-			gpios = <&gpiomm 6 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/ARV7519PW.dts b/target/linux/lantiq/dts/ARV7519PW.dts
deleted file mode 100644
index 1478192663..0000000000
--- a/target/linux/lantiq/dts/ARV7519PW.dts
+++ /dev/null
@@ -1,213 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "ARV7519PW - Astoria Networks";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x40000>;
-					read-only;
-				};
-
-				partition@40000 {
-					label = "uboot_env";
-					reg = <0x40000 0x20000>;
-				};
-
-				partition@60000 {
-					label = "firmware";
-					reg = <0x60000 0xf80000>;
-				};
-
-				partition@fe0000 {
-					label = "board_config";
-					reg = <0xfe0000 0x20000>;
-					read-only;
-				};
-			};
-
-			mac_addr {
-				compatible = "lantiq,eth-mac";
-				reg = <0 0xfe0016 0x6>;
-				mac-increment = <2>;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				ebu {
-					lantiq,groups = "ebu cs1";
-					lantiq,function = "ebu";
-				};
-				pci_in {
-					lantiq,groups = "req1";
-					lantiq,function = "pci";
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-				pci_out {
-					lantiq,groups = "gnt1";
-					lantiq,function = "pci";
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-				pci_rst {
-					lantiq,pins = "io21";
-					lantiq,pull = <2>;
-					lantiq,output = <1>;
-				};
-				switch_rst {
-					lantiq,pins = "io19";
-					lantiq,pull = <2>;
-					lantiq,output = <1>;
-				};
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "mii";
-		};
-
-		/* warning: passive port
-		only works with active devices */
-		ifxhcd@E101000 {
-			status = "okay";
-		};
-
-		pci@E105400 {
-			status = "okay";
-			lantiq,external-clock;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0xf>;
-		};    
-	};
-
-	ralink_eep {
-		compatible = "ralink,eeprom";
-		ralink,eeprom = "RT2860.eeprom";
-        };
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		rfkill {
-			label = "rfkill";
-			gpios = <&gpio 11 1>;
-			linux,code = <0xf7>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 28 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-		power {
-			label = "power";
-			gpios = <&gpio 2 1>;
-			default-state = "off";
-		};
-		power2 {
-			label = "power2";
-			gpios = <&gpio 14 1>;
-		};
-		online {
-			label = "online";
-			gpios = <&gpio 3 1>;
-		};
-		online2 {
-			label = "online2";
-			gpios = <&gpio 30 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpio 12 1>;
-		};
-		wifi2 {
-			label = "wifi2";
-			gpios = <&gpio 10 1>;
-		};
-		wifi3 {
-			label = "wifi3";
-			gpios = <&gpio 6 1>;
-		};
-		voice {
-			label = "voice";
-			gpios = <&gpio 31 1>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 15 1>;
-		};
-		wps2 {
-			label = "wps2";
-			gpios = <&gpio 7 1>;
-		};
-		wps3 {
-			label = "wps3";
-			gpios = <&gpio 23 1>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 4 1>;
-		};
-		lan {
-			label = "lan";
-			gpios = <&gpio 1 1>;
-		};
-		tv {
-			label = "tv";
-			gpios = <&gpio 20 1>;
-		};
-		upgrade {
-			label = "upgrade";
-			gpios = <&gpio 29 1>;
-		};
-	};
-
-	/* is there another way to "reserve" the GPIO? */
-	gpio_export {
-		compatible = "gpio-export";
-		#size-cells = <0>;
-
-		switch {
-			gpio-export,name = "switch";
-			gpio-export,output = <1>;
-			gpios = <&gpio 19 0>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/ARV7519RW22.dts b/target/linux/lantiq/dts/ARV7519RW22.dts
deleted file mode 100644
index 68237532b4..0000000000
--- a/target/linux/lantiq/dts/ARV7519RW22.dts
+++ /dev/null
@@ -1,231 +0,0 @@
-/dts-v1/;
-
-/include/ "vr9.dtsi"
-
-/ {
-	model = "ARV7519RW22 - Astoria Networks ARV7519RW22-A-LT";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x8000000>;
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>, <1 0x2000000 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x0 0x60000>;
-					read-only;
-				};
-
-				partition@60000 {
-					label = "uboot-env";
-					reg = <0x60000 0x20000>;
-					read-only;
-				};
-
-				partition@80000 {
-					label = "firmware";
-					reg = <0x80000 0x1e00000>;
-				};
-
-				partition@1e80000 {
-					label = "dsl_fw";
-					reg = <0x1e80000 0x100000>;
-				};
-
-				boardconfig: partition@1f80000 {
-					label = "boardconfig";
-					reg = <0x1f80000 0x80000>;
-					read-only;
-				};
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				mdio {
-					lantiq,groups = "mdio";
-					lantiq,function = "mdio";
-				};
-				pcie-rst {
-					lantiq,pins = "io21";
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-			};
-		};
-
-		eth@E108000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "lantiq,xrx200-net";
-			reg = <	0xE108000 0x3000 /* switch */
-				0xE10B100 0x70 /* mdio */
-				0xE10B1D8 0x30 /* mii */
-				0xE10B308 0x30 /* pmac */
-			>;
-			interrupt-parent = <&icu0>;
-			interrupts = <73 72>;
-
-			lan: interface@0 {
-				compatible = "lantiq,xrx200-pdi";
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <0>;
-				mtd-mac-address = <&boardconfig 0x16>;
-				lantiq,switch;
-
-				ethernet@0 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <0>;
-					phy-mode = "rgmii";
-					phy-handle = <&phy0>;
-				};
-				ethernet@1 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <4>;
-					phy-mode = "mii";
-					phy-handle = <&phy13>;
-				};
-				ethernet@2 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <5>;
-					phy-mode = "mii";
-					phy-handle = <&phy14>;
-				};
-				ethernet@3 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <2>;
-					phy-mode = "mii";
-					phy-handle = <&phy11>;
-				};
-				ethernet@4 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <3>;
-					phy-mode = "mii";
-					phy-handle = <&phy12>;
-				};
-			};
-
-			mdio@0 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "lantiq,xrx200-mdio";
-				phy0: ethernet-phy@0 {
-					reg = <0x0>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy11: ethernet-phy@11 {
-					reg = <0x11>;
-					compatible = "lantiq,phy22f", "ethernet-phy-ieee802.3-c22";
-				};
-				phy12: ethernet-phy@12 {
-					reg = <0x12>;
-					compatible = "lantiq,phy22f", "ethernet-phy-ieee802.3-c22";
-				};
-				phy13: ethernet-phy@13 {
-					reg = <0x13>;
-					compatible = "lantiq,phy22f", "ethernet-phy-ieee802.3-c22";
-				};
-				phy14: ethernet-phy@14 {
-					reg = <0x14>;
-					compatible = "lantiq,phy22f", "ethernet-phy-ieee802.3-c22";
-				};
-			};
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 32 0>;
-			lantiq,portmask = <0x3>;
-		};
-
-		pcie@d900000 {
-			status = "disabled";
-			compatible = "lantiq,pcie-xway";
-		};
-
-		pci@E105400 {
-			status = "disabled";
-			compatible = "lantiq,pci-xway";
-		};
-	};
-
-	gphy-xrx200 {
-		compatible = "lantiq,phy-xrx200";
-		firmware1 = "lantiq/vr9_phy22f_a1x.bin";	/*VR9 1.1*/
-		firmware2 = "lantiq/vr9_phy22f_a2x.bin";	/*VR9 1.2*/
-		phys = [ 00 01 ];
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		wps {
-			label = "wps";
-			gpios = <&gpio 20 1>;
-			linux,code = <0x211>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 22 1>;
-			linux,code = <0x198>;
-		};
-		rfkill {
-			label = "rfkill";
-			gpios = <&gpio 45 1>;
-			linux,code = <0xf7>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		lan_green {
-			label = "lan";
-			gpios = <&gpio 2 1>;
-		};
-		message_red {
-			label = "message_red";
-			gpios = <&gpio 10 1>;
-		};
-		power_red {
-			label = "power";
-			gpios = <&gpio 14 1>;
-			default-state = "on";
-		};
-		alarm_blue {
-			label = "alarm";
-			gpios = <&gpio 15 1>;
-		};
-		message_orange {
-			label = "message_orange";
-			gpios = <&gpio 19 1>;
-		};
-		message_green {
-			label = "message_green";
-			gpios = <&gpio 28 1>;
-		};
-		voice_green {
-			label = "voice";
-			gpios = <&gpio 29 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/ARV7525PW.dts b/target/linux/lantiq/dts/ARV7525PW.dts
deleted file mode 100644
index 57aa59cd16..0000000000
--- a/target/linux/lantiq/dts/ARV7525PW.dts
+++ /dev/null
@@ -1,142 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "ARV7525PW - Speedport W303V Typ A";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x2000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-			gpios = <&gpio 31 0>;
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x10000>;
-					read-only;
-				};
-
-				partition@10000 {
-					label = "uboot_env";
-					reg = <0x10000 0x10000>;
-					read-only;
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x20000 0x3d0000>;
-				};
-
-				partition@400000 {
-					label = "board_config";
-					reg = <0x3f0000 0x10000>;
-					read-only;
-				};
-			};
-
-			mac_addr {
-				compatible = "lantiq,eth-mac";
-				reg = <0 0x3f0016 0x6>;
-				mac-increment = <2>;
-			};
-
-			ralink_eep {
-				compatible = "ralink,eeprom";
-				ralink,eeprom = "RT2860.eeprom";
-				reg = <0 0x3f0410 0x110>;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				exin {
-					lantiq,groups = "exin1";
-					lantiq,function = "exin";
-				};
-				pci {
-					lantiq,groups = "gnt1", "req1";
-					lantiq,function = "pci";
-				};
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "mii";
-		};
-
-		pci@E105400 {
-			status = "okay";
-			interrupt-map = <0x7000 0 0 1 &icu0 135 1>;
-			req-mask = <0x1>;
-		};
-
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		wps {
-			label = "wps";
-			gpios = <&gpio 29 1>;
-			linux,code = <0x211>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 30 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-		power {
-			label = "power";
-			gpios = <&gpio 3 1>;
-		};
-		power1 {
-			label = "power1";
-			gpios = <&gpio 4 1>;
-		};
-		online {
-			label = "online";
-			gpios = <&gpio 5 1>;
-		};
-		voice {
-			label = "voice";
-			gpios = <&gpio 6 1>;
-		};
-		voice2 {
-			label = "voice2";
-			gpios = <&gpio 8 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpio 9 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/ARV752DPW.dts b/target/linux/lantiq/dts/ARV752DPW.dts
deleted file mode 100644
index fe478e13b7..0000000000
--- a/target/linux/lantiq/dts/ARV752DPW.dts
+++ /dev/null
@@ -1,219 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "ARV752DPW - Arcor 802";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-			gpios = <&gpiomm 1 0>;
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x800000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x10000>;
-					read-only;
-				};
-
-				partition@10000 {
-					label = "uboot_env";
-					reg = <0x10000 0x10000>;
-					read-only;
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x20000 0x7d0000>;
-				};
-
-				partition@7f0000 {
-					label = "board_config";
-					reg = <0x7f0000 0x10000>;
-					read-only;
-				};
-			};
-
-			mac_addr {
-				compatible = "lantiq,eth-mac";
-				reg = <0 0x7f0016 0x6>;
-				mac-increment = <2>;
-			};
-
-			gpiomm: gpiomm@4000000 {
-				compatible = "lantiq,gpio-mm";
-				reg = <1 0x0 0x10 >;
-				#address-cells = <1>;
-				#size-cells = <1>;
-				#gpio-cells = <2>;
-				gpio-controller;
-				lantiq,shadow = <0x3>;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				ebu {
-					lantiq,groups = "ebu cs1";
-					lantiq,function = "ebu";
-				};
-				exin {
-					lantiq,groups = "exin1";
-					lantiq,function = "exin";
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-				pci_in {
-					lantiq,groups = "req2", "req1";
-					lantiq,function = "pci";
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-				pci_out {
-					lantiq,groups = "gnt1";
-					lantiq,function = "pci";
-					lantiq,output = <1>;
-				};
-				pci_rst {
-					lantiq,pins = "io21";
-					lantiq,pull = <2>;
-					lantiq,output = <1>;
-				};
-				leds {
-					lantiq,pins = "io3", "io5", "io6", "io8";
-					lantiq,output = <1>;
-					lantiq,pull = <0>;
-				};
-				keys {
-					lantiq,pins = "io11", "io12", "io13", "io28";
-					lantiq,output = <0>;
-					lantiq,pull = <2>;
-					lantiq,open-drain = <1>;
-				};
-			};
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpiomm 0 0>;
-		};
-
-		etop@E180000 {
-			phy-mode = "rmii";
-		};
-
-		pci@E105400 {
-			status = "okay";
-			lantiq,external-clock;
-			gpio-reset = <&gpio 21 0>;
-			interrupt-map = <0x7000 0 0 1 &icu0 135>;
-			req-mask = <0x3>;
-		};
-
-	};
-
-	ralink_eep {
-		compatible = "ralink,eeprom";
-		ralink,eeprom = "RT2860.eeprom";
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		/* wps {
-			label = "wps";
-			gpios = <&gpio 11 1>;
-			linux,code = <0x211>;
-		}; */
-		restart {
-			label = "restart";
-			gpios = <&gpio 12 1>;
-			linux,code = <0x110>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 13 1>;
-			linux,code = <0x111>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 28 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-		power {
-			label = "power";
-			gpios = <&gpio 3 1>;
-		};
-		message {
-			label = "message";
-			gpios = <&gpio 5 1>;
-		};
-		power1 {
-			label = "power1";
-			gpios = <&gpio 6 1>;
-		};
-		voice1 {
-			label = "voice1";
-			gpios = <&gpio 8 1>;
-		};
-		microphone {
-			/* use this led as te usb led */
-			label = "usb";
-			gpios = <&gpiomm 3 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpiomm 4 1>;
-		};
-		fxs1 {
-			label = "fxs1";
-			gpios = <&gpiomm 5 1>;
-		};
-		fx2 {
-			label = "fxs2";
-			gpios = <&gpiomm 6 1>;
-		};
-		fxo {
-			label = "fxo";
-			gpios = <&gpiomm 7 1>;
-		};
-		internet {
-			label = "internet";
-			gpios = <&gpiomm 8 1>;
-		};
-		voice2 {
-			label = "voice2";
-			gpios = <&gpiomm 9 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/ARV752DPW22.dts b/target/linux/lantiq/dts/ARV752DPW22.dts
deleted file mode 100644
index ec4a3abf57..0000000000
--- a/target/linux/lantiq/dts/ARV752DPW22.dts
+++ /dev/null
@@ -1,253 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "ARV752DPW22 - Arcor 803";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-			gpios = <&gpiomm 1 0>;
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x800000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x30000>;
-					read-only;
-				};
-
-				partition@10000 {
-					label = "uboot_env";
-					reg = <0x30000 0x10000>;
-					read-only;
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x40000 0x7b0000>;
-				};
-
-				partition@7f0000 {
-					label = "board_config";
-					reg = <0x7f0000 0x10000>;
-					read-only;
-				};
-			};
-
-			mac_addr {
-				compatible = "lantiq,eth-mac";
-				reg = <0 0x7f0016 0x6>;
-				mac-increment = <2>;
-			};
-
-			gpiomm: gpiomm@4000000 {
-				compatible = "lantiq,gpio-mm";
-				reg = <1 0x0 0x10 >;
-				#address-cells = <1>;
-				#size-cells = <1>;
-				#gpio-cells = <2>;
-				gpio-controller;
-				lantiq,shadow = <3>;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				ebu {
-					lantiq,groups = "ebu cs1";
-					lantiq,function = "ebu";
-				};
-				exin {
-					lantiq,groups = "exin1";
-					lantiq,function = "exin";
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-				pci_in {
-					lantiq,groups = "req1";
-					lantiq,function = "pci";
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-				pci_out {
-					lantiq,groups = "gnt1";
-					lantiq,function = "pci";
-					lantiq,open-drain = <1>;
-					lantiq,output = <1>;
-				};
-				pci_rst {
-					lantiq,pins = "io21";
-					lantiq,open-drain = <1>;
-					lantiq,output = <1>;
-				};
-				leds {
-					lantiq,pins = "io3", "io5", "io6", "io8";
-					lantiq,open-drain = <1>;
-					lantiq,output = <1>;
-				};
-				buttons {
-					lantiq,pins = "io11", "io12", "io13", "io28";
-					lantiq,pull = <2>;
-					lantiq,output = <0>;
-				};
-			};
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpiomm 0 0>;
-		};
-
-		etop@E180000 {
-			phy-mode = "mii";
-		};
-
-		pci@E105400 {
-			status = "okay";
-			lantiq,external-clock;
-			interrupt-map = <
-                                0x7000 0 0 1 &icu0 30
-		                0x7800 0 0 1 &icu0 135
-			        0x7800 0 0 2 &icu0 135
-			        0x7800 0 0 3 &icu0 135
-			>;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0x3>;
-		};
-
-	};
-
-	ralink_eep {
-		compatible = "ralink,eeprom";
-		ralink,eeprom = "RT2860.eeprom";
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		wps {
-			label = "wps";
-			gpios = <&gpio 11 1>;
-			linux,code = <0x211>;
-		};
-		restart {
-			label = "restart";
-			gpios = <&gpio 12 1>;
-			linux,code = <0x110>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 13 1>;
-			linux,code = <0x111>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 28 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-		power {
-			label = "power";
-			gpios = <&gpio 3 1>;
-			default-state = "on";
-		};
-		message {
-			label = "message";
-			gpios = <&gpio 5 1>;
-			default-state = "on";
-		};
-		power1 {
-			label = "power1";
-			gpios = <&gpio 6 1>;
-			default-state = "on";
-		};
-		voice1 {
-			label = "voice1";
-			gpios = <&gpio 8 1>;
-			default-state = "on";
-		};
-		microphone {
-			label = "microphone";
-			gpios = <&gpiomm 3 1>;
-			default-state = "on";
-		};
-		wifi {
-			label = "wifi_rt";
-			gpios = <&gpiomm 4 1>;
-			default-state = "on";
-		};
-		fxs1 {
-			label = "fxs1";
-			gpios = <&gpiomm 5 1>;
-			default-state = "on";
-		};
-		fxs2 {
-			label = "fxs2";
-			gpios = <&gpiomm 6 1>;
-			default-state = "on";
-		};
-		fxo {
-			label = "fxo";
-			gpios = <&gpiomm 7 1>;
-			default-state = "on";
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&gpiomm 8 1>;
-			default-state = "on";
-		};
-		voice2 {
-			label = "voice2";
-			gpios = <&gpiomm 9 1>;
-			default-state = "on";
-		};
-		eth1 {
-			 label = "eth1";
-			 gpios = <&gpiomm 11 1>;
-			 default-state = "on";
-		};
-		eth2 {
-			label = "eth2";
-			gpios = <&gpiomm 12 1>;
-			default-state = "on";
-		};
-		eth3 {
-			label = "eth3";
-			gpios = <&gpiomm 13 1>;
-			default-state = "on";
-		};
-		eth4 {
-			label = "eth4";
-			gpios = <&gpiomm 14 1>;
-			default-state = "on";
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/BTHOMEHUBV2B.dts b/target/linux/lantiq/dts/BTHOMEHUBV2B.dts
deleted file mode 100644
index 9b3180c39a..0000000000
--- a/target/linux/lantiq/dts/BTHOMEHUBV2B.dts
+++ /dev/null
@@ -1,280 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "BTHOMEHUBV2B - BT Home Hub 2B";  /* SoC: Lantiq Danube-S PSB 50712 @ 333MHz V1.3/1.5 */
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {				  /* RAM: Samsung K4H511638F-LC 64MB */
-		reg = <0x0 0x4000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-			gpios = <&gpio 31 0>;
-		};
-	};
-
-	fpi@10000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		localbus@0 {
-			#address-cells = <2>;
-			#size-cells = <1>;
-			ranges = <0 0 0x0 0x3ffffff /* addrsel0 */
-				1 0 0x4000000 0x4000010>; /* addsel1 */
-			compatible = "lantiq,localbus", "simple-bus";
-
-			nor-boot@0 {				/* NOR Flash: Spansion S29AL004D 512KB */
-				compatible = "lantiq,nor";	/* "AMD AM29LV400BB" compatible on 3.3.8 */
-				lantiq,cs = <0>;
-				bank-width = <2>;
-				reg = <0 0x0 0x80000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x40000>; /* 256KB */
-				};
-
-				partition@40000 {
-					label = "uboot_env";
-					reg = <0x40000 0x10000>; /* 64KB */
-				};
-
-				partition@50000 {
-					label = "rg_conf_1";
-					reg = <0x50000 0x10000>;
-				};
-
-				partition@60000 {
-					label = "rg_conf_2";
-					reg = <0x60000 0x10000>;
-				};
-
-				partition@70000 {
-					label = "rg_conf_factory";
-					reg = <0x70000 0x10000>;
-				};
-			};
-
-			nand-parts@0 {		  /* NAND Flash: Samsung K9F5608U0D-JIB0 32MB */
-				compatible = "gen_nand", "lantiq,nand-xway";
-				lantiq,cs = <1>;
-				bank-width = <2>;
-				reg = <1 0x0 0x2000000 >;
-				#address-cells = <1>;
-				#size-cells = <1>;
-				req-mask = <0x1>;  /* PCI request lines to mask during NAND access */
-
-				ath9k_cal: partition@0 {
-					label = "art";	   /* Atheros 9160 wifi b/g/n radio EEPROM */
-					reg = <0x00000 0x4000>;
-					read-only;
-				};
-
-				partition@4000 {
-					label = "kernel";
-					reg = <0x4000 0x200000>;
-				};
-
-				partition@164000 {
-					label = "ubi";
-					reg = <0x204000 0x1DFC000>;
-				};
-
-			};
-
-
-			ath9k_eep {
-				compatible = "ath9k,eeprom";
-				ath,eep-flash = <&ath9k_cal 0x0000>;
-				ath,mac-increment = <1>;
-				ath,pci-slot = <14>;
-				ath,eep-endian;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			compatible = "lantiq,pinctrl-xway";
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			#gpio-cells = <2>;
-			gpio-controller;
-			reg = <0xE100B10 0xA0>;
-
-			state_default: pinmux {
-				stp {
-					lantiq,groups = "stp";
-					lantiq,function = "stp";
-					lantiq,output = <1>;
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-				};
-				nand_out {
-					lantiq,groups = "nand cle", "nand ale";
-					lantiq,function = "ebu";
-					lantiq,output = <1>;
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-				};
-				nand_cs1 {
-					lantiq,groups = "nand cs1";
-					lantiq,function = "ebu";
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-				};
-				exin {
-					lantiq,groups = "exin1";
-					lantiq,function = "exin";
-				};
-				pci_in {
-					lantiq,groups = "req1";
-					lantiq,function = "pci";
-					lantiq,output = <0>;
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-				};
-				pci_out {
-					lantiq,groups = "gnt1";
-					lantiq,function = "pci";
-					lantiq,output = <1>;
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-				};
-
-				pci_rst {
-					lantiq,pins = "io21";
-					lantiq,output = <1>;
-					lantiq,open-drain = <0>;
-				};
-
-				btn_in {
-					lantiq,pins = "io2", "io15", "io22";
-					lantiq,output = <0>;
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-				};
-			};
-		};
-
-		etop@E180000 {
-			compatible = "lantiq,etop-xway";
-			reg = <0xE180000 0x40000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <73 78>;
-			phy-mode = "rmii";
-			mac-address = [ 00 11 22 33 44 55 ];
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-		};
-
-		stp0: stp@E100BB0 {
-			status = "okay";
-			#gpio-cells = <2>;
-			compatible = "lantiq,gpio-stp-xway";
-			gpio-controller;
-			reg = <0xE100BB0 0x40>;
-
-			lantiq,shadow = <0xfff>;
-			lantiq,groups = <0x3>;
-		};
-
-		pci@E105400 {
-			status = "okay";
-			lantiq,bus-clock = <33333333>;
-			interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
-			interrupt-map = <0x7000 0 0 1 &icu0 30 1>;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0x1>;		 /* GNT1 */
-		};
-
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		reset {
-			label = "reset";
-			gpios = <&gpio 2 1>;
-			linux,code = <0x198>;
-		};
-		findhandset {
-			label = "findhandset";
-			gpios = <&gpio 15 1>;
-			linux,code = <0x101>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 22 1>;
-			linux,code = <0x211>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		upgrading-orange {
-			label = "soc:orange:upgrading";
-			gpios = <&stp0 5 0>;
-		};
-
-		phone-orange {
-			label = "soc:orange:phone";
-			gpios = <&stp0 6 0>;
-		};
-		phone-blue {
-			label = "soc:blue:phone";
-			gpios = <&stp0 7 0>;
-		};
-
-		wireless-orange {
-			label = "soc:orange:wireless";
-			gpios = <&stp0 8 0>;
-		};
-		wireless-blue {
-			label = "soc:blue:wireless";
-			gpios = <&stp0 9 0>;
-		};
-
-		broadband-red {
-			label = "soc:red:broadband";
-			gpios = <&stp0 10 0>;
-		};
-		broadband-orange {
-			label = "soc:orange:broadband";
-			gpios = <&stp0 11 0>;
-		};
-		broadband-blue {
-			label = "soc:blue:broadband";
-			gpios = <&stp0 12 0>;
-		};
-
-		power-red {
-			label = "soc:red:power";
-			gpios = <&stp0 13 0>;
-		};
-		power-orange {
-			label = "soc:orange:power";
-			gpios = <&stp0 14 0>;
-		};
-		power-blue {
-			label = "soc:blue:power";
-			gpios = <&stp0 15 0>;
-		};
-	};
-
-};
-
diff --git a/target/linux/lantiq/dts/BTHOMEHUBV3A.dts b/target/linux/lantiq/dts/BTHOMEHUBV3A.dts
deleted file mode 100644
index 1ae9840fcb..0000000000
--- a/target/linux/lantiq/dts/BTHOMEHUBV3A.dts
+++ /dev/null
@@ -1,210 +0,0 @@
-/dts-v1/;
-
-/include/ "ar9.dtsi"
-
-/ {
-	model = "BTHOMEHUBV3A - BT Home Hub 3A";  /* SoC: Lantiq ar9 @ 333MHz */
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {				  /* RAM: Samsung K4H511638F-LC 64MB */
-		reg = <0x0 0x4000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-			gpios = <&gpio 31 0>;
-		};
-	};
-
-	fpi@10000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		localbus@0 {
-			#address-cells = <2>;
-			#size-cells = <1>;
-			ranges = <0 0 0x0 0x3ffffff /* addrsel0 */
-				1 0 0x4000000 0x4000010>; /* addsel1 */
-			compatible = "lantiq,localbus", "simple-bus";
-
-			nand-parts@0 {		  /* NAND Flash: Samsung K9F5608U0D-JIB0 32MB */
-				compatible = "gen_nand", "lantiq,nand-xway";
-				lantiq,cs = <1>;
-				bank-width = <2>;
-				reg = <1 0x0 0x2000000 >;
-				#address-cells = <1>;
-				#size-cells = <1>;
-				req-mask = <0x1>;  /* PCI request lines to mask during NAND access */
-
-				partition@0 {
-					label = "preboot";
-					reg = <0x00000 0x8000>;
-					read-only;
-				};
-				partition@8000 {
-					label = "u-boot";
-					reg = <0x8000 0x05c000>;
-					read-only;
-				};
-				partition@64000 {
-					label = "uboot-config";
-					reg = <0x64000 0x004000>;
-					read-only;
-				};
-				ath9k_cal: partition@68000 {
-					label = "art-copy";
-					reg = <0x68000 0x004000>;
-					read-only;
-				};
-				partition@6c000 {
-					label = "kernel";
-					reg = <0x6c000 0x200000>;
-				};
-				partition@26c000 {
-					label = "ubi";
-					reg = <0x26c000 0x1d94000>;
-				};
-			};
-
-			ath9k_eep {
-				compatible = "ath9k,eeprom";
-				ath,eep-flash = <&ath9k_cal 0x0000>;
-				ath,mac-offset = <0x10c>;
-				ath,pci-slot = <14>;
-				ath,eep-endian;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			compatible = "lantiq,pinctrl-xr9";
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			#gpio-cells = <2>;
-			gpio-controller;
-			reg = <0xE100B10 0xA0>;
-
-			state_default: pinmux {
-				nand_out {
-					lantiq,groups = "nand cle", "nand ale";
-					lantiq,function = "ebu";
-					lantiq,output = <1>;
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-				};
-				nand_cs1 {
-					lantiq,groups = "nand cs1";
-					lantiq,function = "ebu";
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-				};
-
-				pci_in {
-					lantiq,groups = "req1";
-					lantiq,function = "pci";
-					lantiq,output = <0>;
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-				};
-				pci_out {
-					lantiq,groups = "gnt1";
-					lantiq,function = "pci";
-					lantiq,output = <1>;
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-				};
-
-				pci_rst {
-					lantiq,pins = "io21";
-					lantiq,output = <1>;
-					lantiq,open-drain = <0>;
-				};
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "rgmii";
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 33 0>;
-		};
-
-		pci@E105400 {
-			status = "okay";
-			gpio-reset = <&gpio 21 0>;
-		};
-
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-		reset {
-			label = "reset";
-			gpios = <&gpio 54 1>;
-			linux,code = <0x198>;
-		};
-		restart {
-			label = "restart";
-			gpios = <&gpio 52 1>;
-			linux,code = <0x198>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 53 1>;
-			linux,code = <0x211>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		wireless-red {
-			label = "soc:red:wireless";
-			gpios = <&gpio 2 1>;
-		};
-		wireless-orange {
-			label = "soc:orange:wireless";
-			gpios = <&gpio 6 1>;
-		};
-		wireless-blue {
-			label = "soc:blue:wireless";
-			gpios = <&gpio 9 1>;
-		};
-
-		broadband-red {
-			label = "soc:red:broadband";
-			gpios = <&gpio 11 1>;
-		};
-		broadband-orange {
-			label = "soc:orange:broadband";
-			gpios = <&gpio 0 1>;
-		};
-		broadband-blue {
-			label = "soc:blue:broadband";
-			gpios = <&gpio 12 1>;
-		};
-
-		power-red {
-			label = "soc:red:power";
-			gpios = <&gpio 14 1>;
-		};
-		power-orange {
-			label = "soc:orange:power";
-			gpios = <&gpio 5 1>;
-		};
-		power-blue {
-			label = "soc:blue:power";
-			gpios = <&gpio 1 1>;
-		};
-	};
-
-};
-
diff --git a/target/linux/lantiq/dts/DGN1000B.dts b/target/linux/lantiq/dts/DGN1000B.dts
deleted file mode 100644
index 3b522acf4b..0000000000
--- a/target/linux/lantiq/dts/DGN1000B.dts
+++ /dev/null
@@ -1,138 +0,0 @@
-/dts-v1/;
-
-/include/ "amazonse.dtsi"
-
-/ {
-	model = "DGN1000B - Netgear DGN1000B";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x1000000>;
-	};
-
-	fpi@10000000 {
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				spi {
-					lantiq,groups = "spi", "spi_cs1";
-					lantiq,function = "spi";
-				};
-				asc {
-					lantiq,groups = "asc";
-					lantiq,function = "asc";
-				};
-				keys_in {
-					lantiq,pins = "io0",/* "io25", */"io29";
-					lantiq,pull = <2>;
-					lantiq,open-drain = <1>;
-				};
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "mii";
-			mac-address = [ 00 11 22 33 44 55 ];
-		};
-
-		spi@E100800 {
-			m25p80@0 {
-				#address-cells = <1>;
-				#size-cells = <1>;
-				compatible = "mx25l3205d";
-				reg = <0 0>;
-				linux,modalias = "m25p80", "mx25l64";
-				spi-max-frequency = <5000000>;
-
-				partition@0 {
-					reg = <0x0 0x20000>;
-					label = "SPI (RO) U-Boot Image";
-					read-only;
-				};
-
-				partition@20000 {
-					reg = <0x20000 0x10000>;
-					label = "ENV_MAC";
-					read-only;
-				};
-
-				partition@30000 {
-					reg = <0x30000 0x10000>;
-					label = "DPF";
-					read-only;
-				};
-
-				partition@40000 {
-					reg = <0x40000 0x10000>;
-					label = "NVRAM";
-					read-only;
-				};
-
-				partition@500000 {
-					reg = <0x50000 0x003a0000>;
-					label = "kernel";
-				};
-			};
-		};
-		ifxhcd@E101000 {
-			status = "okay";
-		};
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		reset {
-			label = "reset";
-			gpios = <&gpio 0 1>;
-			linux,code = <0x198>;
-		};
-		rfkill {
-			label = "rfkill";
-			gpios = <&gpio 25 1>;
-			linux,code = <0xf7>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 29 1>;
-			linux,code = <0x211>;
-		};
-	};
-
-	gpio-leds {
-		cmpatible = "gpio-leds";
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 1 1>;
-			default-state = "on";
-		};
-		online {
-			label = "online";
-			gpios = <&gpio 2 1>;
-			default-state = "on";
-		};
-		online2 {
-			label = "online2";
-			gpios = <&gpio 3 1>;
-			default-state = "on";
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 4 1>;
-			default-state = "on";
-		};
-		power {
-			label = "power";
-			gpios = <&gpio 13 1>;
-			default-state = "on";
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/DGN3500.dts b/target/linux/lantiq/dts/DGN3500.dts
deleted file mode 100644
index d256871913..0000000000
--- a/target/linux/lantiq/dts/DGN3500.dts
+++ /dev/null
@@ -1,7 +0,0 @@
-/dts-v1/;
-
-/include/ "DGN3500.dtsi"
-
-/ {
-	model = "DGN3500 - Netgear DGN3500";
-};
diff --git a/target/linux/lantiq/dts/DGN3500.dtsi b/target/linux/lantiq/dts/DGN3500.dtsi
deleted file mode 100644
index 5d2c456531..0000000000
--- a/target/linux/lantiq/dts/DGN3500.dtsi
+++ /dev/null
@@ -1,183 +0,0 @@
-/include/ "ar9.dtsi"
-
-/ {
-	chosen {
-		bootargs-append = "root= console=ttyLTQ0,115200";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	fpi@10000000 {
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				exin {
-					lantiq,groups = "exin1";
-					lantiq,function = "exin";
-				};
-				pci {
-					lantiq,groups = "gnt1", "req1";
-					lantiq,function = "pci";
-				};
-				pci-in {
-					lantiq,groups = "req1";
-					lantiq,output = <0>;
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-				};
-				pci-out {
-					lantiq,groups = "gnt1";
-					lantiq,output = <1>;
-					lantiq,pull = <0>;
-				};
-				spi-in {
-					lantiq,pins = "io16";
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-				};
-				spi-out {
-					lantiq,pins = "io10", "io17", "io18", "io21";
-					lantiq,open-drain = <0>;
-					lantiq,pull = <2>;
-				};
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "mii";
-			mac-address = [ 00 11 22 33 44 55 ];
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-		};
-
-		pci@E105400 {
-			status = "okay";
-
-			lantiq,bus-clock = <33333333>;
-			interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
-			interrupt-map = <0x7000 0 0 1 &icu0 30 1>;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0x1>; /* GNT1 */
-		};
-	};
-
-	spi {
-		#address-cells = <1>;
-		#size-cells = <1>;
-
-		compatible = "spi-gpio";
-
-		gpio-miso = <&gpio 16 0>;
-		gpio-mosi = <&gpio 17 0>;
-		gpio-sck = <&gpio 18 0>;
-		num-chipselects = <1>;
-		cs-gpios = <&gpio 10 1>;
-
-		m25p80@0 {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "s25fl129p0";
-			reg = <0 0>;
-			linux,modalias = "m25p80", "mx25l3205d";
-			spi-max-frequency = <1000000>;
-
-			partition@0 {
-				reg = <0x0 0x10000>;
-				label = "uboot";
-				read-only;
-			};
-
-			partition@10000 {
-				reg = <0x10000 0x10000>;
-				label = "uboot-env";
-				read-only;
-			};
-
-			ath9k_cal: partition@20000 {
-				reg = <0x20000 0x10000>;
-				label = "calibration";
-				read-only;
-			};
-
-			partition@50000 {
-				reg = <0x50000 0xfa0000>;
-				label = "firmware";
-			};
-		};
-	};
-
-	ath9k_eep {
-		compatible = "ath9k,eeprom";
-		ath,eep-flash = <&ath9k_cal 0xf000>;
-		ath,pci-slot = <14>;
-		ath,eep-endian;
-		ath,eep-swap;
-	};
-
-	rtl8366rb {
-		compatible = "rtl8366rb";
-		gpio-sda = <&gpio 35 0>;
-		gpio-sck = <&gpio 37 0>;
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		rfkill {
-			label = "rfkill";
-			gpios = <&gpio 36 1>;
-			linux,code = <0xf7>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 54 1>;
-			linux,code = <0x211>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 53 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-		internet {
-			label = "internet";
-			gpios = <&gpio 2 1>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 4 1>;
-		};
-		usb {
-			label = "usb";
-			gpios = <&gpio 22 1>;
-		};
-		power {
-			label = "power";
-			gpios = <&gpio 34 1>;
-		};
-		power2 {
-			label = "power2";
-			gpios = <&gpio 39 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpio 51 1>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 52 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/DGN3500B.dts b/target/linux/lantiq/dts/DGN3500B.dts
deleted file mode 100644
index 71a4e58c13..0000000000
--- a/target/linux/lantiq/dts/DGN3500B.dts
+++ /dev/null
@@ -1,7 +0,0 @@
-/dts-v1/;
-
-/include/ "DGN3500.dtsi"
-
-/ {
-	model = "DGN3500B - Netgear DGN3500B";
-};
diff --git a/target/linux/lantiq/dts/EASY50712.dts b/target/linux/lantiq/dts/EASY50712.dts
deleted file mode 100644
index e44267a262..0000000000
--- a/target/linux/lantiq/dts/EASY50712.dts
+++ /dev/null
@@ -1,113 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x2000000>;
-	};
-
-	fpi@10000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		localbus@0 {
-			#address-cells = <2>;
-			#size-cells = <1>;
-			ranges = <0 0 0x0 0x3ffffff /* addrsel0 */
-				1 0 0x4000000 0x4000010>; /* addsel1 */
-			compatible = "lantiq,localbus", "simple-bus";
-
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x10000>; /* 64 KB */
-				};
-
-				partition@10000 {
-					label = "uboot_env";
-					reg = <0x10000 0x10000>; /* 64 KB */
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x20000 0x3d0000>;
-				};
-
-				partition@400000 {
-					label = "rootfs";
-					reg = <0x400000 0x400000>;
-				};
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			compatible = "lantiq,pinctrl-xway";
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			#gpio-cells = <2>;
-			gpio-controller;
-			reg = <0xE100B10 0xA0>;
-
-			state_default: pinmux {
-				stp {
-					lantiq,groups = "stp";
-					lantiq,function = "stp";
-				};
-				exin {
-					lantiq,groups = "exin1";
-					lantiq,function = "exin";
-				};
-				pci {
-					lantiq,groups = "gnt1";
-					lantiq,function = "pci";
-				};
-				conf_out {
-					lantiq,pins = "io4", "io5", "io6"; /* stp */
-					lantiq,open-drain;
-					lantiq,pull = <0>;
-				};
-			};
-		};
-
-		etop@E180000 {
-			compatible = "lantiq,etop-xway";
-			reg = <0xE180000 0x40000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <73 78>;
-			phy-mode = "rmii";
-			mac-address = [ 00 11 22 33 44 55 ];
-		};
-
-		stp0: stp@E100BB0 {
-			#gpio-cells = <2>;
-			compatible = "lantiq,gpio-stp-xway";
-			gpio-controller;
-			reg = <0xE100BB0 0x40>;
-
-			lantiq,shadow = <0xfff>;
-			lantiq,groups = <0x3>;
-		};
-
-		pci@E105400 {
-			lantiq,bus-clock = <33333333>;
-			interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
-			interrupt-map = <
-                                0x7000 0 0 1 &icu0 29 1 // slot 14, irq 29
-			>;
-			gpios-reset = <&gpio 21 0>;
-			req-mask = <0x1>;		/* GNT1 */
-		};
-
-	};
-};
diff --git a/target/linux/lantiq/dts/EASY50810.dts b/target/linux/lantiq/dts/EASY50810.dts
deleted file mode 100644
index 5f4b733775..0000000000
--- a/target/linux/lantiq/dts/EASY50810.dts
+++ /dev/null
@@ -1,114 +0,0 @@
-/dts-v1/;
-
-/include/ "ar9.dtsi"
-
-/ {
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x2000000>;
-	};
-
-	fpi@10000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		localbus@0 {
-			#address-cells = <2>;
-			#size-cells = <1>;
-			ranges = <0 0 0x0 0x3ffffff /* addrsel0 */
-				1 0 0x4000000 0x4000010>; /* addsel1 */
-			compatible = "lantiq,localbus", "simple-bus";
-
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x10000>; /* 64 KB */
-				};
-
-				partition@10000 {
-					label = "uboot_env";
-					reg = <0x10000 0x10000>; /* 64 KB */
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x20000 0x3d0000>;
-				};
-
-				partition@400000 {
-					label = "rootfs";
-					reg = <0x400000 0x400000>;
-				};
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			compatible = "lantiq,pinctrl-xr9";
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			#gpio-cells = <2>;
-			gpio-controller;
-			reg = <0xE100B10 0xA0>;
-
-			state_default: pinmux {
-				stp {
-					lantiq,groups = "stp";
-					lantiq,function = "stp";
-				};
-				exin {
-					lantiq,groups = "exin1";
-					lantiq,function = "exin";
-				};
-				pci {
-					lantiq,groups = "gnt1";
-					lantiq,function = "pci";
-				};
-				conf_out {
-					lantiq,pins = "io4", "io5", "io6"; /* stp */
-					lantiq,open-drain;
-					lantiq,pull = <0>;
-				};
-			};
-		};
-
-		etop@E180000 {
-			compatible = "lantiq,etop-xway";
-			reg = <0xE180000 0x40000
-				0xE108000 0x200>;
-			interrupt-parent = <&icu0>;
-			interrupts = <72 73>;
-			phy-mode = "rmii";
-			mac-address = [ 00 11 22 33 44 55 ];
-		};
-
-		stp0: stp@E100BB0 {
-			#gpio-cells = <2>;
-			compatible = "lantiq,gpio-stp-xway";
-			gpio-controller;
-			reg = <0xE100BB0 0x40>;
-
-			lantiq,shadow = <0xfff>;
-			lantiq,groups = <0x3>;
-		};
-
-		pci@E105400 {
-			lantiq,bus-clock = <33333333>;
-			interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
-			interrupt-map = <
-                                0x7000 0 0 1 &icu0 29 1 // slot 14, irq 29
-			>;
-			gpios-reset = <&gpio 21 0>;
-			req-mask = <0x1>;		/* GNT1 */
-		};
-
-	};
-};
diff --git a/target/linux/lantiq/dts/EASY80920.dtsi b/target/linux/lantiq/dts/EASY80920.dtsi
deleted file mode 100644
index 4013610667..0000000000
--- a/target/linux/lantiq/dts/EASY80920.dtsi
+++ /dev/null
@@ -1,335 +0,0 @@
-/include/ "vr9.dtsi"
-
-/ {
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	fpi@10000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,fpi", "simple-bus";
-		ranges = <0x0 0x10000000 0xEEFFFFF>;
-		reg = <0x10000000 0xEF00000>;
-
-		localbus@0 {
-			#address-cells = <2>;
-			#size-cells = <1>;
-			compatible = "lantiq,localbus", "simple-bus";
-
-		};
-
-		spi@E100800 {
-			compatible = "lantiq,spi-xway-broken";
-			reg = <0xE100800 0x100>;
-			interrupt-parent = <&icu0>;
-			interrupts = <22 23 24>;
-			#address-cells = <1>;
-			#size-cells = <1>;
-
-			m25p80@0 {
-				#address-cells = <1>;
-				#size-cells = <1>;
-				compatible = "s25fl129p0";
-				reg = <0 0>;
-				linux,modalias = "m25p80", "mx25l3205d";
-				spi-max-frequency = <1000000>;
-
-				partition@0 {
-					reg = <0x0 0x20000>;
-					label = "SPI (RO) U-Boot Image";
-					read-only;
-				};
-
-				partition@20000 {
-					reg = <0x20000 0x10000>;
-					label = "ENV_MAC";
-					read-only;
-				};
-
-				partition@30000 {
-					reg = <0x30000 0x10000>;
-					label = "DPF";
-					read-only;
-				};
-
-				partition@40000 {
-					reg = <0x40000 0x10000>;
-					label = "NVRAM";
-					read-only;
-				};
-
-				partition@500000 {
-					reg = <0x50000 0x003a0000>;
-					label = "kernel";
-				};
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			compatible = "lantiq,pinctrl-xr9";
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			interrupt-parent = <&icu0>;
-			interrupts = <166 135 66 40 41 42 38>;
-
-			#gpio-cells = <2>;
-			gpio-controller;
-			reg = <0xE100B10 0xA0>;
-
-			state_default: pinmux {
-				exin3 {
-					lantiq,groups = "exin3";
-					lantiq,function = "exin";
-				};
-				stp {
-					lantiq,groups = "stp";
-					lantiq,function = "stp";
-				};
-				spi {
-					lantiq,groups = "spi", "spi_cs4";
-					lantiq,function = "spi";
-				};
-				nand {
-					lantiq,groups = "nand cle", "nand ale",
-							"nand rd", "nand rdy";
-					lantiq,function = "ebu";
-				};
-				mdio {
-					lantiq,groups = "mdio";
-					lantiq,function = "mdio";
-				};
-				pci {
-					lantiq,groups = "gnt1", "req1";
-					lantiq,function = "pci";
-				};
-				conf_out {
-					lantiq,pins = "io24", "io13", "io49", /* nand cle, ale and rd */
-							"io4", "io5", "io6", /* stp */
-							"io21",
-							"io33";
-					lantiq,open-drain;
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-				pcie-rst {
-					lantiq,pins = "io38";
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-				conf_in {
-					lantiq,pins = "io39", /* exin3 */
-							"io48"; /* nand rdy */
-					lantiq,pull = <2>;
-				};
-			};
-		};
-
-		eth@E108000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "lantiq,xrx200-net";
-			reg = <	0xE108000 0x3000 /* switch */
-				0xE10B100 0x70 /* mdio */
-				0xE10B1D8 0x30 /* mii */
-				0xE10B308 0x30 /* pmac */
-			>;
-			interrupt-parent = <&icu0>;
-			interrupts = <73 72>;
-
-			lan: interface@0 {
-				compatible = "lantiq,xrx200-pdi";
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <0>;
-				mac-address = [ 00 11 22 33 44 55 ];
-
-				ethernet@0 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <0>;
-					phy-mode = "rgmii";
-					phy-handle = <&phy0>;
-				};
-				ethernet@1 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <1>;
-					phy-mode = "rgmii";
-					phy-handle = <&phy1>;
-				};
-				ethernet@2 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <2>;
-					phy-mode = "gmii";
-					phy-handle = <&phy11>;
-				};
-			};
-
-			wan: interface@1 {
-				compatible = "lantiq,xrx200-pdi";
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <1>;
-				mac-address = [ 00 11 22 33 44 56 ];
-				lantiq,wan;
-				ethernet@5 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <5>;
-					phy-mode = "rgmii";
-					phy-handle = <&phy5>;
-				};
-			};
-
-			test: interface@2 {
-				compatible = "lantiq,xrx200-pdi";
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <2>;
-				mac-address = [ 00 11 22 33 44 57 ];
-				ethernet@4 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <4>;
-					phynmode0 = "gmii";
-					phy-handle = <&phy13>;
-				};
-			};
-
-			mdio@0 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "lantiq,xrx200-mdio";
-				phy0: ethernet-phy@0 {
-					reg = <0x0>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy1: ethernet-phy@1 {
-					reg = <0x1>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy5: ethernet-phy@5 {
-					reg = <0x5>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy11: ethernet-phy@11 {
-					reg = <0x11>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy13: ethernet-phy@13 {
-					reg = <0x13>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-			};
-		};
-
-		stp: stp@E100BB0 {
-			compatible = "lantiq,gpio-stp-xway";
-			reg = <0xE100BB0 0x40>;
-			#gpio-cells = <2>;
-			gpio-controller;
-
-			lantiq,shadow = <0xffff>;
-			lantiq,groups = <0x7>;
-			lantiq,dsl = <0x3>;
-			lantiq,phy1 = <0x7>;
-			lantiq,phy2 = <0x7>;
-			/* lantiq,rising; */
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 33 0>;
-			lantiq,portmask = <0x3>;
-		};
-
-		pci@E105400 {
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			compatible = "lantiq,pci-xway1";
-			bus-range = <0x0 0x0>;
-			ranges = <0x2000000 0 0x8000000 0x8000000 0 0x2000000   /* pci memory */
-				0x1000000 0 0x00000000 0xAE00000 0 0x200000>; /* io space */
-			reg = <0x7000000 0x8000         /* config space */
-				0xE105400 0x400>;       /* pci bridge */
-			lantiq,bus-clock = <33333333>;
-			/*lantiq,external-clock;*/
-			lantiq,delay-hi = <0>; /* 0ns delay */
-			lantiq,delay-lo = <0>; /* 0.0ns delay */
-			interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
-			interrupt-map = <
-				0x7000 0 0 1 &icu0 29 1 // slot 14, irq 29
-				>;
-			gpios-reset = <&gpio 21 0>;
-			req-mask = <0x1>;	/* GNT1 */
-		};
-	};
-
-	gphy-xrx200 {
-		compatible = "lantiq,phy-xrx200";
-		firmware = "lantiq/vr9_phy11g_a2x.bin";
-		phys = [ 00 01 ];
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-/*		reset {
-			label = "reset";
-			gpios = <&gpio 7 1>;
-			linux,code = <0x198>;
-		};*/
-		paging {
-			label = "paging";
-			gpios = <&gpio 11 1>;
-			linux,code = <0x100>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		power {
-			label = "power";
-			gpios = <&stp 9 0>;
-			default-state = "on";
-		};
-		warning {
-			label = "warning";
-			gpios = <&stp 22 0>;
-		};
-		fxs1 {
-			label = "fxs1";
-			gpios = <&stp 21 0>;
-		};
-		fxs2 {
-			label = "fxs2";
-			gpios = <&stp 20 0>;
-		};
-		fxo {
-			label = "fxo";
-			gpios = <&stp 19 0>;
-		};
-		usb1 {
-			label = "usb1";
-			gpios = <&stp 18 0>;
-		};
-		usb2 {
-			label = "usb2";
-			gpios = <&stp 15 0>;
-		};
-		sd {
-			label = "sd";
-			gpios = <&stp 14 0>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&stp 12 0>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/EASY80920NAND.dts b/target/linux/lantiq/dts/EASY80920NAND.dts
deleted file mode 100644
index 88fbcaaa6a..0000000000
--- a/target/linux/lantiq/dts/EASY80920NAND.dts
+++ /dev/null
@@ -1,35 +0,0 @@
-/dts-v1/;
-
-
-/include/ "EASY80920.dtsi"
-
-/ {
-	fpi@10000000 {
-		localbus@0 {
-			ranges = <0 0 0x4000000 0x3ffffff>;
-			nand-parts@0 {
-				compatible = "gen_nand", "lantiq,nand-xway";
-				lantiq,cs = <1>;
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x40000>;
-				};
-
-				partition@10000 {
-					label = "uboot_env";
-					reg = <0x40000 0x40000>;
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x80000 0x3f80000>;
-				};
-			};
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/EASY80920NOR.dts b/target/linux/lantiq/dts/EASY80920NOR.dts
deleted file mode 100644
index 212ad5c3a2..0000000000
--- a/target/linux/lantiq/dts/EASY80920NOR.dts
+++ /dev/null
@@ -1,34 +0,0 @@
-/dts-v1/;
-
-
-/include/ "EASY80920.dtsi"
-
-/ {
-	fpi@10000000 {
-		localbus@0 {
-			ranges = <0 0 0x0 0x3ffffff>;
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x10000>;
-				};
-
-				partition@10000 {
-					label = "uboot_env";
-					reg = <0x10000 0x10000>;
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x20000 0x7e0000>;
-				};
-			};
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/EASY88388.dts b/target/linux/lantiq/dts/EASY88388.dts
deleted file mode 100644
index dfec5f8501..0000000000
--- a/target/linux/lantiq/dts/EASY88388.dts
+++ /dev/null
@@ -1,108 +0,0 @@
-/dts-v1/;
-
-/include/ "falcon.dtsi"
-/include/ "falcon-sflash-16M.dtsi"
-
-/ {
-	model = "EASY88388 - Lantiq Falcon FTTDP8 Reference Board";
-	compatible = "lantiq,falcon-easy88388", "lantiq,falcon";
-
-	chosen {
-		bootargs-append = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	aliases {
-		spi0 = &ebu_cs0;
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;  // 64M at 0x0
-	};
-
-	gpio-keys {
-		compatible = "gpio-keys";
-		reset {
-			label = "Reset";
-			gpios = <&gpio0 1 1>; /* GPIO0.1, active low */
-			linux,code = <0x100>; /* BTN_X = 0x100 + X */
-		};
-	};
-
-	pinctrl {
-		led_pins: led-pins {
-			lantiq,pins = "io34", "io35", "io36", "io37", "io38", 
-					"io39", "io40", "io41";
-			lantiq,function = "gpio";
-		};
-	};
-
-	easy88388-leds {
-		compatible = "gpio-leds";
-		pinctrl-names = "default";
-		pinctrl-0 = <&led_pins &bootled_pins>;
-
-		GPON {
-			label = "easy88388:green:0";
-			gpios = <&gpio0 11 0>;
-			default-state = "off";
-		};
-		TEST {
-			label = "easy88388:green:1";
-			gpios = <&gpio0 14 0>;
-			default-state = "off";
-		};
-		STATUS {
-			label = "easy88388:green:2";
-			gpios = <&gpio1 5 0>;
-			default-state = "off";
-		};
-		ERROR {
-			label = "easy88388:red:3";
-			gpios = <&gpio1 6 0>;
-			default-state = "off";
-		};
-
-		DSL1 {
-			label = "easy88388:dsl:1";
-			gpios = <&gpio0 12 0>;
-			default-state = "off";
-		};
-		DSL2 {
-			label = "easy88388:dsl:2";
-			gpios = <&gpio0 13 0>;
-			default-state = "off";
-		};
-		DSL3 {
-			label = "easy88388:dsl:3";
-			gpios = <&gpio1 2 0>;
-			default-state = "off";
-		};
-		DSL4 {
-			label = "easy88388:dsl:4";
-			gpios = <&gpio1 3 0>;
-			default-state = "off";
-		};
-		DSL5 {
-			label = "easy88388:dsl:5";
-			gpios = <&gpio1 4 0>;
-			default-state = "off";
-		};
-		DSL6 {
-			label = "easy88388:dsl:6";
-			gpios = <&gpio1 7 0>;
-			default-state = "off";
-		};
-		DSL7 {
-			label = "easy88388:dsl:7";
-			gpios = <&gpio1 8 0>;
-			default-state = "off";
-		};
-		DSL8 {
-			label = "easy88388:dsl:8";
-			gpios = <&gpio1 9 0>;
-			default-state = "off";
-		};
-
-	};
-};
-
diff --git a/target/linux/lantiq/dts/EASY98000-base.dtsi b/target/linux/lantiq/dts/EASY98000-base.dtsi
deleted file mode 100644
index f8cb516fa6..0000000000
--- a/target/linux/lantiq/dts/EASY98000-base.dtsi
+++ /dev/null
@@ -1,111 +0,0 @@
-
-/ {
-	compatible = "lantiq,falcon-easy98000", "lantiq,falcon";
-
-	chosen {
-		bootargs-append = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		device_type = "memory";
-		reg = <0x0 0x4000000>;
-	};
-
-	easy98000-leds {
-		compatible = "gpio-leds";
-		pinctrl-names = "default";
-		pinctrl-0 = <&bootled_pins>;
-
-		LED_0 {
-			label = "easy98000:green:0";
-			gpios = <&gpio0 9 0>;
-			default-state = "keep";
-		};
-		LED_1 {
-			label = "easy98000:green:1";
-			gpios = <&gpio0 10 0>;
-			default-state = "keep";
-		};
-		LED_2 {
-			label = "easy98000:green:2";
-			gpios = <&gpio0 11 0>;
-			default-state = "keep";
-		};
-		LED_3 {
-			label = "easy98000:green:3";
-			gpios = <&gpio0 12 0>;
-			default-state = "keep";
-		};
-		LED_4 {
-			label = "easy98000:green:4";
-			gpios = <&gpio0 13 0>;
-			default-state = "keep";
-		};
-		LED_5 {
-			label = "easy98000:green:5";
-			gpios = <&gpio0 14 0>;
-			linux,default-trigger = "heartbeat";
-		};
-	};
-};
-
-&ebu_cs1 {
-	eth0: ethernet@0000000 {
-		compatible = "davicom,dm9000";
-		device_type = "network";
-		reg = <0x0000003 0x1>, <0x0000001 0x1>;
-		reg-names = "addr", "data";
-		interrupt-parent = <&gpio1>;
-		#interrupt-cells = <2>;
-		interrupts = <10 0x8>;
-		local-mac-address = [ 00 00 00 00 00 00 ];
-	};
-
-	cpld@3c00000 {
-		compatible = "lantiq,easy98000_addon";
-		reg = <0x3c00000 0x2>;
-	};
-
-	cpld@3c0000c {
-		compatible = "lantiq,easy98000_cpld_led";
-		reg = <0x3c0000c 0x2>,  <0x3c00012 0x2>;
-	};
-};
-
-/* // enable this for second uart:
-&serial1 {
-	status = "okay";
-};*/
-
-&spi {
-	status = "okay";
-
-	eeprom@1 {
-		compatible = "atmel,at25", "atmel,at25160n";
-		reg = <1>;
-		spi-max-frequency = <1000000>;
-		spi-cpha;
-		spi-cpol;
-
-		pagesize = <32>;
-		size = <2048>;
-		address-width = <16>;
-	};
-};
-
-&i2c {
-	status = "okay";
-
-	clock-frequency = <100000>;
-
-	/* eeprom-emulation by OMU */
-	eeprom@50 {
-		compatible = "at,24c02";
-		reg = <0x50>;
-	};
-	eeprom@51 {
-		compatible = "at,24c02";
-		reg = <0x51>;
-	};
-};
-
diff --git a/target/linux/lantiq/dts/EASY98000NAND.dts b/target/linux/lantiq/dts/EASY98000NAND.dts
deleted file mode 100644
index 4a24eb77ff..0000000000
--- a/target/linux/lantiq/dts/EASY98000NAND.dts
+++ /dev/null
@@ -1,40 +0,0 @@
-/dts-v1/;
-
-/include/ "falcon.dtsi"
-/include/ "EASY98000-base.dtsi"
-
-/ {
-	model = "EASY98000 - Lantiq Falcon (NAND)";
-	compatible = "lantiq,falcon-easy98000-nand", "lantiq,falcon-easy98000", "lantiq,falcon";
-
-	aliases {
-		spi0 = &spi;
-	};
-};
-
-&ebu_cs0 {
-	gen_nand@0 {
-		compatible = "gen_nand", "lantiq,nand-falcon";
-		bank-width = <1>;
-		reg = <0x0 0x40000>;
-		#address-cells = <1>;
-		#size-cells = <1>;
-		linux,mtd-name = "gen_nand";
-		bbt-use-flash;
-
-		partition@0 {
-			label = "uboot";
-			reg = <0x00000 0x40000>;
-		};
-
-		partition@10000 {
-			label = "uboot_env";
-			reg = <0x40000 0x40000>;
-		};
-
-		partition@20000 {
-			label = "linux";
-			reg = <0x80000 0x3d0000>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/EASY98000NOR.dts b/target/linux/lantiq/dts/EASY98000NOR.dts
deleted file mode 100644
index 31b78592e4..0000000000
--- a/target/linux/lantiq/dts/EASY98000NOR.dts
+++ /dev/null
@@ -1,38 +0,0 @@
-/dts-v1/;
-
-/include/ "falcon.dtsi"
-/include/ "EASY98000-base.dtsi"
-
-/ {
-	model = "EASY98000 - Lantiq Falcon (NOR)";
-	compatible = "lantiq,falcon-easy98000-nor", "lantiq,falcon-easy98000", "lantiq,falcon";
-
-	aliases {
-		spi0 = &spi;
-	};
-};
-
-&ebu_cs0 {
-	cfi@0 {
-		compatible = "lantiq,nor";
-		bank-width = <2>;
-		reg = <0x0 0x4000000>;
-		#address-cells = <1>;
-		#size-cells = <1>;
-
-		partition@0 {
-			label = "uboot";
-			reg = <0x00000 0x40000>;
-		};
-
-		partition@10000 {
-			label = "uboot_env";
-			reg = <0x40000 0x40000>;
-		};
-
-		partition@20000 {
-			label = "linux";
-			reg = <0x80000 0x3d0000>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/EASY98000SFLASH.dts b/target/linux/lantiq/dts/EASY98000SFLASH.dts
deleted file mode 100644
index 1dfe143d7b..0000000000
--- a/target/linux/lantiq/dts/EASY98000SFLASH.dts
+++ /dev/null
@@ -1,16 +0,0 @@
-/dts-v1/;
-
-/include/ "falcon.dtsi"
-/include/ "EASY98000-base.dtsi"
-/include/ "falcon-sflash-16M.dtsi"
-
-/ {
-	model = "EASY98000 - Lantiq Falcon (SFLASH)";
-	compatible = "lantiq,falcon-easy98000-sflash", "lantiq,falcon-easy98000", "lantiq,falcon";
-
-	aliases {
-		spi0 = &ebu_cs0;
-		spi1 = &spi;
-	};
-};
-
diff --git a/target/linux/lantiq/dts/EASY98020.dts b/target/linux/lantiq/dts/EASY98020.dts
deleted file mode 100644
index 5cba2f9a1e..0000000000
--- a/target/linux/lantiq/dts/EASY98020.dts
+++ /dev/null
@@ -1,97 +0,0 @@
-/dts-v1/;
-
-/include/ "falcon.dtsi"
-/include/ "falcon-sflash-16M.dtsi"
-
-/ {
-	model = "EASY98020 - Lantiq Falcon Reference Board";
-	compatible = "lantiq,falcon-easy98020", "lantiq,falcon";
-
-	chosen {
-		bootargs-append = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	aliases {
-		spi0 = &ebu_cs0;
-	};
-
-	memory@0 {
-		device_type = "memory";
-		reg = <0x0 0x4000000>;  // 64M at 0x0
-	};
-
-	gpio-keys {
-		compatible = "gpio-keys";
-		reset {
-			label = "Reset";
-			gpios = <&gpio0 1 1>; /* GPIO0.1, active low */
-			linux,code = <0x100>; /* BTN_X = 0x100 + X */
-		};
-	};
-
-	pinctrl {
-		led_pins: phy-led-pins {
-			lantiq,pins = "io42", "io41", "io38", "io37";
-			lantiq,function = "gpio";
-		};
-	};
-
-	easy98020-leds {
-		compatible = "gpio-leds";
-		pinctrl-names = "default";
-		pinctrl-0 = <&bootled_pins>;
-
-		GPON {
-			label = "easy98020:green:0";
-			gpios = <&gpio0 9 0>;
-			default-state = "keep";
-		};
-		TEST {
-			label = "easy98020:green:1";
-			gpios = <&gpio0 10 0>;
-			default-state = "keep";
-		};
-		ETH {
-			label = "easy98020:green:2";
-			gpios = <&gpio0 11 0>;
-			default-state = "keep";
-		};
-		VOICE {
-			label = "easy98020:green:3";
-			gpios = <&gpio0 12 0>;
-			default-state = "keep";
-		};
-		VIDEO {
-			label = "easy98020:green:4";
-			gpios = <&gpio0 13 0>;
-			default-state = "keep";
-		};
-	};
-
-	easy98020-phy-leds {
-		compatible = "gpio-leds";
-		pinctrl-names = "default";
-		pinctrl-0 = <&led_pins>;
-
-		GE0_ACT {
-			label = "easy98020:ge0_act";
-			gpios = <&gpio1 10 0>;
-			default-state = "off";
-		};
-		GE0_LINK {
-			label = "easy98020:ge0_link";
-			gpios = <&gpio1 9 0>;
-			default-state = "off";
-		};
-		GE1_ACT {
-			label = "easy98020:ge1_act";
-			gpios = <&gpio1 6 0>;
-			default-state = "off";
-		};
-		GE1_LINK {
-			label = "easy98020:ge1_link";
-			gpios = <&gpio1 5 0>;
-			default-state = "off";
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/EASY98020V18.dts b/target/linux/lantiq/dts/EASY98020V18.dts
deleted file mode 100644
index a776b41670..0000000000
--- a/target/linux/lantiq/dts/EASY98020V18.dts
+++ /dev/null
@@ -1,70 +0,0 @@
-/dts-v1/;
-
-/include/ "falcon.dtsi"
-/include/ "falcon-sflash-16M.dtsi"
-
-/ {
-	model = "EASY98020 - Lantiq Falcon Reference Board V1.8";
-	compatible = "lantiq,falcon-easy98020-V18", "lantiq,falcon-easy98020", "lantiq,falcon";
-
-	chosen {
-		bootargs-append = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	aliases {
-		spi0 = &ebu_cs0;
-	};
-
-	memory@0 {
-		device_type = "memory";
-		reg = <0x0 0x4000000>;  // 64M at 0x0
-	};
-
-	gpio-keys {
-		compatible = "gpio-keys";
-		reset {
-			label = "Reset";
-			gpios = <&gpio0 1 1>; /* GPIO0.1, active low */
-			linux,code = <0x100>; /* BTN_X = 0x100 + X */
-		};
-	};
-
-	pinctrl {
-		led_pins: led-pins {
-			lantiq,pins = "io11", "io14", "io36", "io37", "io38";
-			lantiq,function = "gpio";
-		};
-	};
-
-	easy98020-leds {
-		compatible = "gpio-leds";
-		pinctrl-names = "default";
-		pinctrl-0 = <&led_pins &bootled_pins>;
-
-		GPON {
-			label = "easy98020:green:0";
-			gpios = <&gpio0 11 0>;
-			default-state = "keep";
-		};
-		TEST {
-			label = "easy98020:green:1";
-			gpios = <&gpio0 14 0>;
-			default-state = "keep";
-		};
-		ETH {
-			label = "easy98020:green:2";
-			gpios = <&gpio1 4 0>;
-			default-state = "keep";
-		};
-		VOICE {
-			label = "easy98020:green:3";
-			gpios = <&gpio1 5 0>;
-			default-state = "keep";
-		};
-		VIDEO {
-			label = "easy98020:green:4";
-			gpios = <&gpio1 6 0>;
-			default-state = "keep";
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/EASY98021.dts b/target/linux/lantiq/dts/EASY98021.dts
deleted file mode 100644
index 824b80348c..0000000000
--- a/target/linux/lantiq/dts/EASY98021.dts
+++ /dev/null
@@ -1,83 +0,0 @@
-/dts-v1/;
-
-/include/ "falcon.dtsi"
-/include/ "falcon-sflash-16M.dtsi"
-
-/ {
-	model = "EASY98021 - Lantiq Falcon HGU Reference Board";
-	compatible = "lantiq,falcon-easy98021", "lantiq,falcon-easy98020", "lantiq,falcon";
-
-	chosen {
-		bootargs-append = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	aliases {
-		spi0 = &ebu_cs0;
-	};
-
-	memory@0 {
-		device_type = "memory";
-		reg = <0x0 0x4000000>;  // 64M at 0x0
-	};
-
-	gpio-keys {
-		compatible = "gpio-keys";
-		reset {
-			label = "Reset";
-			gpios = <&gpio0 1 1>; /* GPIO0.1, active low */
-			linux,code = <0x100>; /* BTN_X = 0x100 + X */
-		};
-	};
-
-	gpio-mmc {
-		/* Place-holder for SIM-Card connector,
-		   to list the used GPIOs, no official binding */
-		compatible = "gpio-mmc";
-		gpios =  <&gpio0 3 0>,
-			 <&gpio0 3 0>,
-			 <&gpio0 2 0>,
-			 <0>; /* no CS */
-		gpio-names = "di", "do", "clk", "cs";
-		reset-gpio =  <&gpio3 24 0>;
-	};
-
-	pinctrl {
-		led_pins: led-pins {
-			lantiq,pins = "io11", "io14", "io36", "io37", "io38";
-			lantiq,function = "gpio";
-		};
-	};
-
-	easy98020-leds {
-		compatible = "gpio-leds";
-		pinctrl-names = "default";
-		pinctrl-0 = <&led_pins &bootled_pins>;
-
-		GPON {
-			label = "easy98020:green:0";
-			gpios = <&gpio0 11 0>;
-			default-state = "keep";
-		};
-		TEST {
-			label = "easy98020:green:1";
-			gpios = <&gpio0 14 0>;
-			default-state = "keep";
-		};
-		ETH {
-			label = "easy98020:green:2";
-			gpios = <&gpio1 4 0>;
-			default-state = "keep";
-		};
-		VOICE {
-			label = "easy98020:green:3";
-			gpios = <&gpio1 5 0>;
-			default-state = "keep";
-		};
-		SIMCARD {
-			label = "easy98020:green:4";
-			gpios = <&gpio1 6 0>;
-			default-state = "keep";
-		};
-	};
-};
-
diff --git a/target/linux/lantiq/dts/FALCON-MDU.dts b/target/linux/lantiq/dts/FALCON-MDU.dts
deleted file mode 100644
index 9814d3b08e..0000000000
--- a/target/linux/lantiq/dts/FALCON-MDU.dts
+++ /dev/null
@@ -1,55 +0,0 @@
-/dts-v1/;
-
-/include/ "falcon.dtsi"
-/include/ "falcon-sflash-16M.dtsi"
-
-/ {
-	model = "MDU - Lantiq Falcon / Vinax MDU Board";
-	compatible = "lantiq,falcon-mdu", "lantiq,falcon";
-
-	chosen {
-		bootargs-append = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	aliases {
-		spi0 = &ebu_cs0;
-	};
-
-	memory@0 {
-		device_type = "memory";
-		reg = <0x0 0x4000000>;  // 64M at 0x0
-	};
-
-	mdu-leds {
-		compatible = "gpio-leds";
-		pinctrl-names = "default";
-		pinctrl-0 = <&bootled_pins>;
-
-		LED_0 {
-			label = "mdu:green:0";
-			gpios = <&gpio0 9 0>;
-			default-state = "keep";
-		};
-		LED_1 {
-			label = "mdu:green:1";
-			gpios = <&gpio0 10 0>;
-			default-state = "keep";
-		};
-		LED_2 {
-			label = "mdu:green:2";
-			gpios = <&gpio0 11 0>;
-			default-state = "keep";
-		};
-		LED_3 {
-			label = "mdu:green:3";
-			gpios = <&gpio0 12 0>;
-			default-state = "keep";
-		};
-		LED_4 {
-			label = "mdu:green:4";
-			gpios = <&gpio0 13 0>;
-			default-state = "keep";
-		};
-	};
-};
-
diff --git a/target/linux/lantiq/dts/FALCON-SFP.dts b/target/linux/lantiq/dts/FALCON-SFP.dts
deleted file mode 100644
index 09cf9994ec..0000000000
--- a/target/linux/lantiq/dts/FALCON-SFP.dts
+++ /dev/null
@@ -1,80 +0,0 @@
-/dts-v1/;
-
-/include/ "falcon.dtsi"
-/include/ "falcon-sflash-16M.dtsi"
-
-/ {
-	model = "SFP - Lantiq Falcon SFP Stick";
-	compatible = "lantiq,falcon-sfp", "lantiq,falcon";
-
-	chosen {
-		bootargs-append = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	aliases {
-		spi0 = &ebu_cs0;
-	};
-
-	memory@0 {
-		device_type = "memory";
-		reg = <0x0 0x4000000>;  // 64M at 0x0
-	};
-
-	pinctrl {
-		compatible = "lantiq,pinctrl-falcon";
-
-		asc0_func1: func1 {
-			func1_tx {
-				lantiq,pins = "io32";
-				lantiq,mux = <1>;
-				lantiq,output = <0>;
-			};
-			func1_rx {
-				lantiq,pins = "io33";
-				lantiq,mux = <0>;
-			};
-		};
-		asc0_func2: func2 {
-			func2_tx {
-				lantiq,pins = "io32";
-				lantiq,mux = <0>;
-			};
-			func2_rx {
-				lantiq,pins = "io33";
-				lantiq,mux = <1>;
-				lantiq,input;
-			};
-		};
-		asc0_func3: func3 {
-			func3_tx {
-				lantiq,pins = "io32";
-				lantiq,mux = <1>;
-				lantiq,output = <0>;
-			};
-			func3_rx {
-				lantiq,pins = "io33";
-				lantiq,mux = <1>;
-				lantiq,input;
-			};
-		};
-	};
-
-	pinselect-asc0 {
-		compatible = "lantiq,pinselect-asc0";
-		pinctrl-names = "asc0", "func1", "func2", "func3";
-		pinctrl-0 = <&asc0_pins>;
-		pinctrl-1 = <&asc0_func1>;
-		pinctrl-2 = <&asc0_func2>;
-		pinctrl-3 = <&asc0_func3>;
-	};
-};
-
-&serial0 {
-	pinctrl-names = "default";
-	/* use "empty" pinctrl to leave setting from u-boot enabled */
-	pinctrl-0 = < >;
-};
-
-&i2c {
-	status = "okay";
-};
diff --git a/target/linux/lantiq/dts/FRITZ3370.dts b/target/linux/lantiq/dts/FRITZ3370.dts
deleted file mode 100644
index c0202bab0f..0000000000
--- a/target/linux/lantiq/dts/FRITZ3370.dts
+++ /dev/null
@@ -1,268 +0,0 @@
-/dts-v1/;
-
-/include/ "vr9.dtsi"
-
-/ {
-	model = "FRITZ3370 - Fritz!Box WLAN 3370";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 ubi.mtd=1,512 root=/dev/mtdblock9";
-	};
-
-	memory@0 {
-		reg = <0x0 0x8000000>;
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nand-parts@0 {
-				compatible = "gen_nand", "lantiq,nand-xway";
-				bank-width = <2>;
-				reg = <1 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "kernel";
-					reg = <0x0 0x400000>;
-				};
-
-				partition@400000 {
-					label = "rootfs_ubi";
-					reg = <0x400000 0x3000000>;
-				};
-
-				partition@3400000 {
-					label = "vr9_firmware";
-					reg = <0x3400000 0x400000>;
-				};
-				partition@3800000 {
-					label = "reserved";
-					reg = <0x3800000 0x3000000>;
-				};
-				partition@6800000 {
-					label = "config";
-					reg = <0x6800000 0x200000>;
-				};
-				partition@6a00000 {
-					label = "nand-filesystem";
-					reg = <0x6a00000 0x1600000>;
-				};
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				spi {
-					lantiq,groups = "spi", "spi_cs4";
-					lantiq,function = "gpio";
-				};
-				mdio {
-					lantiq,groups = "mdio";
-					lantiq,function = "mdio";
-				};
-				nand {
-					lantiq,groups = "nand cle", "nand ale",
-							"nand rd", "nand cs1", "nand rdy";
-					lantiq,function = "ebu";
-					lantiq,pull = <1>;
-				};
-				phy-rst {
-					lantiq,pins = "io37", "io44";
-					lantiq,pull = <0>;
-					lantiq,open-drain = <0>;
-					lantiq,output = <1>;
-				};
-				pcie-rst {
-					lantiq,pins = "io38";
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-			};
-		};
-
-		eth@E108000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "lantiq,xrx200-net";
-			reg = <	0xE108000 0x3000 /* switch */
-				0xE10B100 0x70 /* mdio */
-				0xE10B1D8 0x30 /* mii */
-				0xE10B308 0x30 /* pmac */
-			>;
-			interrupt-parent = <&icu0>;
-			interrupts = <73 72>;
-
-			lan: interface@0 {
-				compatible = "lantiq,xrx200-pdi";
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <0>;
-				mac-address = [ 00 11 22 33 44 55 ];
-				lantiq,switch;
-
-				ethernet@0 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <0>;
-					phy-mode = "rgmii";
-					phy-handle = <&phy0>;
-					gpios = <&gpio 37 0>;
-				};
-				ethernet@1 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <1>;
-					phy-mode = "rgmii";
-					phy-handle = <&phy1>;
-					gpios = <&gpio 44 0>;
-				};
-				ethernet@2 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <2>;
-					phy-mode = "gmii";
-					phy-handle = <&phy11>;
-				};
-				ethernet@3 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <4>;
-					phy-mode = "gmii";
-					phy-handle = <&phy13>;
-				};
-			};
-
-			mdio@0 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "lantiq,xrx200-mdio";
-				phy0: ethernet-phy@0 {
-					reg = <0x0>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy1: ethernet-phy@1 {
-					reg = <0x1>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy11: ethernet-phy@11 {
-					reg = <0x11>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy13: ethernet-phy@13 {
-					reg = <0x13>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-			};
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 5 0
-				&gpio 14 0>;
-			lantiq,portmask = <0x3>;
-		};
-	};
-
-	spi {
-		#address-cells = <1>;
-		#size-cells = <1>;
-
-		compatible = "spi-gpio";
-
-		gpio-miso = <&gpio 16 0>;
-		gpio-mosi = <&gpio 17 0>;
-		gpio-sck = <&gpio 18 0>;
-		num-chipselects = <1>;
-		cs-gpios = <&gpio 10 1>;
-
-		m25p80@0 {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "mx25l2005a";
-			reg = <0 0>;
-			linux,modalias = "m25p80", "mx25l2005a";
-			spi-max-frequency = <1000000>;
-
-			ath9k_cal: partition@0 {
-				reg = <0x0 0x20000>;
-				label = "urlader";
-				read-only;
-			};
-
-			partition@20000 {
-				reg = <0x20000 0x10000>;
-				label = "tffs (1)";
-				read-only;
-			};
-
-			partition@30000 {
-				reg = <0x30000 0x10000>;
-				label = "tffs (2)";
-				read-only;
-			};
-		};
-	};
-
-	ath9k_eep {
-		compatible = "ath9k,eeprom";
-		ath,eep-flash = <&ath9k_cal 0x985>;
-		ath,eep-endian;
-		ath,eep-swap;
-	};
-
-	gphy-xrx200 {
-		compatible = "lantiq,phy-xrx200";
-		firmware = "lantiq/vr9_phy11g_a1x.bin";
-		phys = [ 00 01 ];
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-		power {
-			label = "power";
-			gpios = <&gpio 1 0>;
-			linux,code = <0x100>;
-		};
-/*		wifi {
-			label = "wifi";
-			gpios = <&gpio 29 0>;
-			linux,code = <0x101>;
-		};*/
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		power {
-			label = "power";
-			gpios = <&gpio 32 1>;
-		};
-		power2 {
-			label = "power2";
-			gpios = <&gpio 33 1>;
-		};
-		info_red {
-			label = "info_red";
-			gpios = <&gpio 34 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpio 35 1>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 36 1>;
-		};
-		lan {
-			label = "lan";
-			gpios = <&gpio 38 1>;
-		};
-		info_green {
-			label = "info_green";
-			gpios = <&gpio 47 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/FRITZ7320.dts b/target/linux/lantiq/dts/FRITZ7320.dts
deleted file mode 100644
index 13845751e7..0000000000
--- a/target/linux/lantiq/dts/FRITZ7320.dts
+++ /dev/null
@@ -1,138 +0,0 @@
-/dts-v1/;
-
-/include/ "ar9.dtsi"
-
-/ {
-	model = "FRITZ7320 - 1&1 HomeServer";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x1000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "urlader";
-					reg = <0x00000 0x20000>;
-					read-only;
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x20000 0xf60000>;
-				};
-
-				partition@f80000 {
-					label = "tffs (1)";
-					reg = <0xf80000 0x40000>;
-					read-only;
-				};
-
-				partition@fc0000 {
-					label = "tffs (2)";
-					reg = <0xfc0000 0x40000>;
-					read-only;
-				};
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				pci {
-					lantiq,groups = "gnt1", "req1", "req2", "req3", "req4", "gnt2", "gnt3", "gnt4";
-					lantiq,function = "pci";
-				};
-				pci-in {
-					lantiq,groups = "req1", "req2", "req3", "req4";
-					lantiq,output = <0>;
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-				};
-				pci-out {
-					lantiq,groups = "gnt1", "gnt2", "gnt3", "gnt4";
-					lantiq,output = <1>;
-					lantiq,pull = <0>;
-				};
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "mii";
-			mac-address = [ 00 11 22 33 44 55 ];
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-		};
-
-		pci@E105400 {
-			status = "okay";
-			req-mask = <0xf>;
-			lantiq,bus-clock = <33333333>;
-			interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
-			interrupt-map = <0x7000 0 0 1 &icu0 30 1>;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0xf>; /* GNT1 */
-		};
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		rfkill {
-			label = "rfkill";
-			gpios = <&gpio 1 1>;
-			linux,code = <0xf7>;
-		};
-		dect {
-			label = "dect";
-			gpios = <&gpio 2 1>;
-			linux,code = <0x102>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-		power {
-			label = "power";
-			gpios = <&gpio 44 1>;
-		};
-		voice {
-			label = "voice";
-			gpios = <&gpio 47 1>;
-		};
-		dect {
-			label = "dect";
-			gpios = <&gpio 38 1>;
-		};
-		wlan {
-			label = "wlan";
-			gpios = <&gpio 37 1>;
-		};
-		online {
-			label = "online";
-			gpios = <&gpio 35 1>;
-		};
-		online2 {
-			label = "online2";
-			gpios = <&gpio 45 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/GIGASX76X.dts b/target/linux/lantiq/dts/GIGASX76X.dts
deleted file mode 100644
index b4bb95649d..0000000000
--- a/target/linux/lantiq/dts/GIGASX76X.dts
+++ /dev/null
@@ -1,115 +0,0 @@
-/dts-v1/;
-
-/include/ "danube.dtsi"
-
-/ {
-	model = "GIGASX76X - Gigaset SX761,SX762,SX763";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x2000000>;
-	};
-
-	sram@1F000000 {
-		vmmc@107000 {
-			status = "okay";
-			gpios = <&gpiomm 1 0>;
-		};
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x0 0x30000>;
-				};
-
-				partition@10000 {
-					label = "uboot_env";
-					reg = <0x30000 0x10000>;
-				};
-
-				partition@40000 {
-					label = "firmware";
-					reg = <0x40000 0x7c0000>;
-				};
-			};
-
-			gpiomm: gpiomm@4000000 {
-				compatible = "lantiq,gpio-mm";
-				reg = <1 0x0 0x10 >;
-				#address-cells = <1>;
-				#size-cells = <1>;
-				#gpio-cells = <2>;
-				gpio-controller;
-				lantiq,shadow = <0x3>;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				stp {
-					lantiq,groups = "stp";
-					lantiq,function = "stp";
-				};
-			};
-		};
-
-		gpios: stp@E100BB0 {
-			status = "okay";
-		};
-
-		etop@E180000 {
-			phy-mode = "rmii";
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 29 0>;
-		};
-
-		pci@E105400 {
-			status = "okay";
-			lantiq,internal-clock;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0x1>;
-		};
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		reset {
-			label = "reset";
-			gpios = <&gpio 14 0>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio_export {
-		compatible = "gpio-export";
-		#size-cells = <0>;
-
-		switch {
-			gpio-export,name = "switch";
-			gpio-export,output = <1>;
-			gpios = <&gpio 19 0>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/GR7000.dts b/target/linux/lantiq/dts/GR7000.dts
deleted file mode 100644
index fcc27ebacf..0000000000
--- a/target/linux/lantiq/dts/GR7000.dts
+++ /dev/null
@@ -1,135 +0,0 @@
-/dts-v1/;
-
-/include/ "ar9.dtsi"
-
-/ {
-	model = "GR7000 - Aztech GR7000";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x2000000>;
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x0 0x20000>;
-					read-only;
-				};
-
-				partition@20000 {
-					label = "uboot_env";
-					reg = <0x20000 0x10000>;
-					read-only;
-				};
-
-				partition@30000 {
-					label = "firmware";
-					reg = <0x30000 0x7d0000>;
-				};
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			compatible = "lantiq,pinctrl-xr9";
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				stp {
-					lantiq,groups = "stp";
-					lantiq,function = "stp";
-				};
-				pci-in {
-					lantiq,groups = "req1";
-					lantiq,output = <0>;
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-				};
-				pci-out {
-					lantiq,groups = "gnt1";
-					lantiq,output = <1>;
-					lantiq,pull = <0>;
-				};
-				pci_rst {
-					lantiq,pins = "io21";
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-			};
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-		};
-
-		pci@E105400 {
-			status = "okay";
-		};
-
-		stp: stp@E100BB0 {
-			compatible = "lantiq,gpio-stp-xway";
-			#gpio-cells = <2>;
-			gpio-controller;
-			reg = <0xE100BB0 0x40>;
-
-			lantiq,shadow = <0xfff>;
-			lantiq,groups = <0x3>;
-		};
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		reset {
-			label = "reset";
-			gpios = <&gpio 53 1>;
-			linux,code = <0x198>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 54 1>;
-			linux,code = <0x211>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		power2 {
-			label = "power2";
-			gpios = <&stp 4 0>;
-		};
-		internet {
-			label = "internet";
-			gpios = <&stp 2 1>;
-			default-state = "off";
-		};
-		internet2 {
-			label = "internet2";
-			gpios = <&stp 3 1>;
-		};
-		usb {
-			label = "usb";
-			gpios = <&stp 10 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&stp 15 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/H201L.dts b/target/linux/lantiq/dts/H201L.dts
deleted file mode 100644
index 5cb5612a37..0000000000
--- a/target/linux/lantiq/dts/H201L.dts
+++ /dev/null
@@ -1,139 +0,0 @@
-/dts-v1/;
-
-/include/ "ar9.dtsi"
-
-/ {
-	model = "H201L - ZTE H210L";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x2000000>;
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x20000>;
-					read-only;
-				};
-
-				partition@20000 {
-					label = "uboot_env";
-					reg = <0x20000 0x10000>;
-					read-only;
-				};
-
-				partition@30000 {
-					label = "firmware";
-					reg = <0x30000 0x7d0000>;
-				};
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "rgmii";
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 36 0>;
-		};
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		reset {
-			label = "reset";
-			gpios = <&gpio 53 1>;
-			linux,code = <0x198>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 54 1>;
-			linux,code = <0x211>;
-		};
-		rfkill {
-			label = "rfkill";
-			gpios = <&gpio 55 1>;
-			linux,code = <0xf7>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		power {
-			label = "power";
-			gpios = <&gpio 19 1>;
-			default-state = "on";
-		};
-		online {
-			label = "online";
-			gpios = <&gpio 37 1>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 4 1>;
-		};
-		phone {
-			label = "phone";
-			gpios = <&gpio 39 1>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 22 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpio 6 1>;
-		};
-		usb {
-			label = "usb";
-			gpios = <&gpio 14 1>;
-		};
-	};
-
-	gpio_export {
-		compatible = "gpio-export";
-		#size-cells = <0>;
-
-		switch {
-			gpio-export,name = "switch";
-			gpio-export,output = <1>;
-			gpios = <&gpio 38 0>;
-		};
-		usb {
-			gpio-export,name = "usb";
-			gpio-export,output = <1>;
-			gpios = <&gpio 28 0>;
-		};
-		wifi {
-			gpio-export,name = "wifi";
-			gpio-export,output = <1>;
-			gpios = <&gpio 7 0>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/P2601HNFX.dts b/target/linux/lantiq/dts/P2601HNFX.dts
deleted file mode 100644
index bb9193eb1f..0000000000
--- a/target/linux/lantiq/dts/P2601HNFX.dts
+++ /dev/null
@@ -1,192 +0,0 @@
-/dts-v1/;
-
-/include/ "ar9.dtsi"
-
-/ {
-	model = "P2601HNFX - ZyXEL P-2601HN-Fx";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	fpi@10000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		localbus@0 {
-			#address-cells = <2>;
-			#size-cells = <1>;
-			ranges = <0 0 0x0 0x3ffffff
-				  1 0 0x4000000 0x4000010>;
-			compatible = "lantiq,localbus", "simple-bus";
-
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x40000>;
-					read-only;
-				};
-
-				partition@40000 {
-					label = "uboot_env";
-					reg = <0x40000 0x20000>;
-					read-only;
-				};
-
-				partition@60000 {
-					label = "firmware";
-					reg = <0x60000 0xfa0000>;
-				};
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			compatible = "lantiq,pinctrl-xr9";
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			#gpio-cells = <2>;
-			gpio-controller;
-			reg = <0xE100B10 0xA0>;
-
-			state_default: pinmux {
-				stp {
-					lantiq,groups = "stp";
-					lantiq,function = "stp";
-					lantiq,pull = <2>;
-					lantiq,open-drain = <0>;
-					lantiq,output = <1>;
-				};
-				exin {
-					lantiq,groups = "exin1";
-					lantiq,function = "exin";
-				};
-				pci {
-					lantiq,groups = "gnt1";
-					lantiq,function = "pci";
-				};
-				conf_out {
-					lantiq,pins = "io4", "io5", "io6";
-					lantiq,open-drain;
-					lantiq,pull = <0>;
-				};
-				mdio {
-					lantiq,groups = "mdio";
-					lantiq,function = "mdio";
-				};
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "rmii";
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 9 0>;
-		};
-
-		stp: stp@E100BB0 {
-			#gpio-cells = <2>;
-			compatible = "lantiq,gpio-stp-xway";
-			gpio-controller;
-			reg = <0xE100BB0 0x40>;
-
-			lantiq,shadow = <0xfff>;
-			lantiq,groups = <0x3>;
-		};
-
-		pci@E105400 {
-			lantiq,bus-clock = <33333333>;
-			interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
-			interrupt-map = <0x7000 0 0 1 &icu0 29 1>;
-			gpios-reset = <&gpio 21 0>;
-			req-mask = <0x1>;
-		};
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		reset {
-			label = "reset";
-			gpios = <&gpio 53 1>;
-			linux,code = <0x198>;
-		};
-		rfkill {
-			label = "rfkill";
-			gpios = <&gpio 54 1>;
-			linux,code = <0xf7>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		power {
-			label = "power";
-			gpios = <&stp 11 1>;
-			default-state = "on";
-		};
-		power2 {
-			label = "power2";
-			gpios = <&gpio 29 1>;
-		};
-		online {
-			label = "online";
-			gpios = <&stp 13 1>;
-		};
-		online2 {
-			label = "online2";
-			gpios = <&stp 12 1>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&stp 14 1>;
-		};
-		phone {
-			label = "phone";
-			gpios = <&stp 9 1>;
-		};
-		phone2 {
-			label = "phone2";
-			gpios = <&stp 8 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&stp 15 1>;
-		};
-		wifi2 {
-			label = "wifi2";
-			gpios = <&stp 10 1>;
-		};
-	};
-
-	gpio_export {
-		compatible = "gpio-export";
-		#size-cells = <0>;
-
-		switch {
-			gpio-export,name = "switch";
-			gpio-export,output = <1>;
-			gpios = <&gpio 50 0>;
-		};
-		usb {
-			gpio-export,name = "wifi";
-			gpio-export,output = <1>;
-			gpios = <&gpio 9 0>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/P2812HNUF1.dts b/target/linux/lantiq/dts/P2812HNUF1.dts
deleted file mode 100644
index 24ded3e853..0000000000
--- a/target/linux/lantiq/dts/P2812HNUF1.dts
+++ /dev/null
@@ -1,106 +0,0 @@
-/dts-v1/;
-
-/include/ "P2812HNUFX.dtsi"
-
-/ {
-	model = "P2812HNUF1 - ZyXEL P-2812HNU-F1";
-
-	fpi@10000000 {
-		localbus@0 {
-			nand-parts@0 {
-				compatible = "gen_nand", "lantiq,nand-xway";
-				lantiq,cs = <1>;
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x40000>;
-				};
-				partition@40000 {
-					label = "uboot-env";
-					reg = <0x40000 0x20000>;
-				};
-				partition@60000 {
-					label = "kernel";
-					reg = <0x60000 0x200000>;
-				};
-				partition@260000 {
-					label = "ubi";
-					reg = <0x260000 0x7da0000>;
-				};
-			};
-		};
-		pcie@d900000 {
-			status = "disabled";
-		};
-	};
-
-	ralink_eep {
-		compatible = "ralink,eeprom";
-		ralink,eeprom = "RT3062.eeprom";
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		internet_red {				/* red */
-			label = "internet_red";
-			gpios = <&stp 16 1>;
-		};
-		internet_green {
-			label = "internet_green";	/* green */
-			gpios = <&stp 17 1>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&stp 18 1>;
-		};
-		dsl2 {
-			label = "dsl2";
-			gpios = <&stp 19 1>;
-		};
-		wireless_red {				/* red */
-			label = "wireless_red";
-			gpios = <&stp 20 1>;
-		};
-		wireless_green {			/* green */
-			label = "wireless_green";
-			gpios = <&stp 21 1>;
-		};
-		power {					/* red */
-			label = "power";
-			gpios = <&stp 22 1>;
-		};
-		power2 {				/* green */
-			label = "power2";
-			gpios = <&stp 23 1>;
-		};
-		usb1 {					/* green */
-			label = "usb1";
-			gpios = <&gpio 38 1>;
-		};
-		usb2 {					/* green */
-			label = "usb2";
-			gpios = <&gpio 44 1>;
-		};
-		phone1 {				/* green */
-			label = "phone1";
-			gpios = <&gpio 11 1>;
-		};
-		phone1warn {				/* red */
-			label = "phone1warn";
-			gpios = <&gpio 12 1>;
-		};
-		phone2warn {				/* red */
-			label = "phone2warn";
-			gpios = <&gpio 26 1>;
-		};
-		phone2 {				/* green */
-			label = "phone2";
-			gpios = <&gpio 28 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/P2812HNUF3.dts b/target/linux/lantiq/dts/P2812HNUF3.dts
deleted file mode 100644
index 5d25c3c4cb..0000000000
--- a/target/linux/lantiq/dts/P2812HNUF3.dts
+++ /dev/null
@@ -1,109 +0,0 @@
-/dts-v1/;
-
-/include/ "P2812HNUFX.dtsi"
-
-/ {
-	model = "P2812HNUF3 - ZyXEL P-2812HNU-F3";
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x800000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x0 0x50000>;
-					read-only;
-				};
-				partition@50000 {
-					label = "uboot-env";
-					reg = <0x50000 0x10000>;
-				};
-				partition@60000 {
-					label = "unused";
-					reg = <0x60000 0x7a0000>;
-				};
-			};
-
-			nand-parts@0 {
-				compatible = "gen_nand", "lantiq,nand-xway";
-				lantiq,cs = <1>;
-				bank-width = <2>;
-				reg = <1 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "kernel";
-					reg = <0x0 0x200000>;
-				};
-				partition@200000 {
-					label = "ubi";
-					reg = <0x200000 0x7e00000>;
-				};
-			};
-		};
-	};
-
-	ralink_eep {
-		compatible = "ralink,eeprom";
-		ralink,eeprom = "RT3092.eeprom";
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		internet2 {
-			label = "internet2";
-			gpios = <&stp 16 1>;
-		};
-		internet {
-			label = "internet";
-			gpios = <&stp 17 1>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&stp 18 1>;
-		};
-		dsl2 {
-			label = "dsl2";
-			gpios = <&stp 19 1>;
-		};
-		wireless_red {
-			label = "wireless_red";
-			gpios = <&stp 20 1>;
-		};
-		wireless_green {
-			label = "wireless_green";
-			gpios = <&stp 21 1>;
-		};
-		power2 {
-			label = "power2";
-			gpios = <&stp 22 1>;
-		};
-		power {
-			label = "power";
-			gpios = <&stp 23 1>;
-		};
-		phone1 {
-			label = "phone1";
-			gpios = <&gpio 11 1>;
-		};
-		phone1warn {
-			label = "phone1warn";
-			gpios = <&gpio 12 1>;
-		};
-		phone2 {
-			label = "phone2";
-			gpios = <&gpio 28 1>;
-		};
-		phone2warn {
-			label = "phone2warn";
-			gpios = <&gpio 26 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/P2812HNUFX.dtsi b/target/linux/lantiq/dts/P2812HNUFX.dtsi
deleted file mode 100644
index d93e862b3a..0000000000
--- a/target/linux/lantiq/dts/P2812HNUFX.dtsi
+++ /dev/null
@@ -1,262 +0,0 @@
-/include/ "vr9.dtsi"
-
-/ {
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x8000000>;
-	};
-
-        fpi@10000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,fpi", "simple-bus";
-		ranges = <0x0 0x10000000 0xEEFFFFF>;
-		reg = <0x10000000 0xEF00000>;
-
-		localbus@0 {
-			#address-cells = <2>;
-			#size-cells = <1>;
-			ranges = <0 0 0x0 0x3ffffff /* addrsel0 */
-				1 0 0x4000000 0x4000010>; /* addsel1 */
-			compatible = "lantiq,localbus", "simple-bus";
-		};
-
-		gpio: pinmux@E100B10 {
-			compatible = "lantiq,pinctrl-xr9";
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-			
-			interrupt-parent = <&icu0>;
-			interrupts = <166 135 66 40 41 42 38>;
-
-			#gpio-cells = <2>;
-			gpio-controller;
-			reg = <0xE100B10 0xA0>;
-
-			state_default: pinmux {
-				exin3 {
-					lantiq,groups = "exin3";
-					lantiq,function = "exin";
-				};
-				mdio {
-					lantiq,groups = "mdio";
-					lantiq,function = "mdio";
-				};
-				gphy-leds {
-					lantiq,groups = "gphy0 led1", "gphy1 led1",
-							"gphy0 led2", "gphy1 led2";
-					lantiq,function = "gphy";
-					lantiq,pull = <2>;
-					lantiq,open-drain = <0>;
-					lantiq,output = <1>;
-				};
-				stp {
-					lantiq,groups = "stp";
-					lantiq,function = "stp";
-					lantiq,pull = <2>;
-					lantiq,open-drain = <0>;
-					lantiq,output = <1>;
-				};
-				pci-in {
-					lantiq,groups = "req1";
-					lantiq,function = "pci";
-					lantiq,output = <0>;
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-				};
-				pci-out {
-					lantiq,groups = "gnt1";
-					lantiq,function = "pci";
-					lantiq,output = <1>;
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-				};
-				pci_rst {
-					lantiq,pins = "io21";
-					lantiq,output = <1>;
-					lantiq,open-drain = <0>;
-					lantiq,pull = <2>;
-				};
-				pcie-rst {
-					lantiq,pins = "io38";
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-				ifxhcd-rst {
-					lantiq,pins = "io33";
-					lantiq,pull = <0>;
-					lantiq,open-drain = <0>;
-					lantiq,output = <1>;
-				};
-				nand_out {
-					lantiq,groups = "nand cle", "nand ale";
-					lantiq,function = "ebu";
-					lantiq,output = <1>;
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-				};
-				nand_cs1 {
-					lantiq,groups = "nand cs1";
-					lantiq,function = "ebu";
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-				};
-			};
-		};
-
-		eth@E108000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "lantiq,xrx200-net";
-			reg = < 0xE108000 0x3000	/* switch */
-				0xE10B100 0x70		/* mdio */
-				0xE10B1D8 0x30		/* mii */
-				0xE10B308 0x30 >;	/* pmac */
-			interrupt-parent = <&icu0>;
-			interrupts = <73 72>;
-
-			lan: interface@0 {
-				compatible = "lantiq,xrx200-pdi";
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <0>;
-				mac-address = [ 00 11 22 33 44 55 ];
-				lantiq,switch;
-
-				ethernet@0 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <0>;
-					phy-mode = "rgmii";
-					phy-handle = <&phy0>;
-				};
-				ethernet@1 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <1>;
-					phy-mode = "rgmii";
-					phy-handle = <&phy1>;
-				};
-				ethernet@2 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <2>;
-					phy-mode = "gmii";
-					phy-handle = <&phy11>;
-				};
-				ethernet@4 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <4>;
-					phy-mode = "gmii";
-					phy-handle = <&phy13>;
-				};
-				ethernet@5 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <5>;
-					phy-mode = "rgmii";
-					phy-handle = <&phy5>;
-				};
-			};
-
-			mdio@0 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "lantiq,xrx200-mdio";
-
-				phy0: ethernet-phy@0 {
-					reg = <0x0>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy1: ethernet-phy@1 {
-					reg = <0x1>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy5: ethernet-phy@5 {
-					reg = <0x5>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy11: ethernet-phy@11 {
-					reg = <0x11>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy13: ethernet-phy@13 {
-					reg = <0x13>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-			};
-		};
-
-		stp: stp@E100BB0 {
-			compatible = "lantiq,gpio-stp-xway";
-			reg = <0xE100BB0 0x40>;
-			#gpio-cells = <2>;
-			gpio-controller;
-
-			lantiq,shadow = <0xffffff>;
-			lantiq,groups = <0x7>;
-			lantiq,dsl = <0x0>;
-			lantiq,phy1 = <0x0>;
-			lantiq,phy2 = <0x0>;
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 33 0>;
-			lantiq,portmask = <0x3>;
-		};
-
-		ifxhcd@E106000 {
-			status = "okay";
-			gpios = <&gpio 33 0>;
-		};
-
-		pci@E105400 {
-			status = "okay";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			compatible = "lantiq,pci-xway";
-			bus-range = <0x0 0x0>;
-			ranges = <0x2000000 0 0x8000000 0x8000000 0 0x2000000   /* pci memory */
-				0x1000000 0 0x00000000 0xAE00000 0 0x200000>; /* io space */
-			reg = <0x7000000 0x8000         /* config space */
-				0xE105400 0x400>;       /* pci bridge */
-			lantiq,bus-clock = <33333333>;
-			/*lantiq,external-clock;*/
-			lantiq,delay-hi = <0>; /* 0ns delay */
-			lantiq,delay-lo = <0>; /* 0.0ns delay */
-			interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
-			interrupt-map = <
-				0x7000 0 0 1 &icu0 30 1 // slot 14, irq 30
-				>;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0x1>;	/* GNT1 */
-		};
-	};
-
-	gphy-xrx200 {
-		compatible = "lantiq,phy-xrx200";
-		firmware1 = "lantiq/vr9_phy11g_a1x.bin";	/*VR9 1.1*/
-		firmware2 = "lantiq/vr9_phy11g_a2x.bin";	/*VR9 1.2*/
-		phys = [ 00 01 ];
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		reset {
-			label = "reset";
-			gpios = <&gpio 39 1>;
-			linux,code = <0x198>;
-		};
-
-		rfkill {
-			label = "rfkill";
-			gpios = <&gpio 1 1>;
-			linux,code = <0xf7>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/TDW8970.dts b/target/linux/lantiq/dts/TDW8970.dts
deleted file mode 100644
index d8dcb5d836..0000000000
--- a/target/linux/lantiq/dts/TDW8970.dts
+++ /dev/null
@@ -1,256 +0,0 @@
-/dts-v1/;
-
-/include/ "vr9.dtsi"
-
-/ {
-	model = "TDW8970 - TP-LINK TD-W8970";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	fpi@10000000 {
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				mdio {
-					lantiq,groups = "mdio";
-					lantiq,function = "mdio";
-				};
-				gphy-leds {
-					lantiq,groups = "gphy0 led1", "gphy1 led1";
-					lantiq,function = "gphy";
-					lantiq,pull = <2>;
-					lantiq,open-drain = <0>;
-					lantiq,output = <1>;
-				};
-				phy-rst {
-					lantiq,pins = "io42";
-					lantiq,pull = <0>;
-					lantiq,open-drain = <0>;
-					lantiq,output = <1>;
-				};
-				spi-in {
-					lantiq,pins = "io16";
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-				};
-				spi-out {
-					lantiq,pins = "io10", "io17", "io18", "io21";
-					lantiq,open-drain = <0>;
-					lantiq,pull = <2>;
-				};
-				pcie-rst {
-					lantiq,pins = "io38";
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-			};
-		};
-
-		eth@E108000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "lantiq,xrx200-net";
-			reg = <	0xE108000 0x3000 /* switch */
-				0xE10B100 0x70 /* mdio */
-				0xE10B1D8 0x30 /* mii */
-				0xE10B308 0x30 /* pmac */
-			>;
-			interrupt-parent = <&icu0>;
-			interrupts = <73 72>;
-
-			lan: interface@0 {
-				compatible = "lantiq,xrx200-pdi";
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <0>;
-				mtd-mac-address = <&ath9k_cal 0xf100>;
-				lantiq,switch;
-
-				ethernet@0 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <0>;
-					phy-mode = "rgmii";
-					phy-handle = <&phy0>;
-					// gpios = <&gpio 42 1>;
-				};
-				ethernet@5 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <5>;
-					phy-mode = "rgmii";
-					phy-handle = <&phy5>;
-				};
-				ethernet@2 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <2>;
-					phy-mode = "gmii";
-					phy-handle = <&phy11>;
-				};
-				ethernet@3 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <4>;
-					phy-mode = "gmii";
-					phy-handle = <&phy13>;
-				};
-			};
-
-			mdio@0 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "lantiq,xrx200-mdio";
-				phy0: ethernet-phy@0 {
-					reg = <0x0>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy5: ethernet-phy@5 {
-					reg = <0x5>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy11: ethernet-phy@11 {
-					reg = <0x11>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy13: ethernet-phy@13 {
-					reg = <0x13>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-			};
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 33 0>;
-			lantiq,portmask = <0x3>;
-		};
-
-		ifxhcd@E106000 {
-			status = "okay";
-			gpios = <&gpio 33 0>;
-		};
-	};
-
-	gphy-xrx200 {
-		compatible = "lantiq,phy-xrx200";
-		firmware = "lantiq/vr9_phy11g_a2x.bin";
-		phys = [ 00 01 ];
-	};
-
-	pcie {
-		compatible = "lantiq,pcie-xway";
-	};
-
-	spi {
-		#address-cells = <1>;
-		#size-cells = <1>;
-
-		compatible = "spi-gpio";
-
-		gpio-miso = <&gpio 16 0>;
-		gpio-mosi = <&gpio 17 0>;
-		gpio-sck = <&gpio 18 0>;
-		num-chipselects = <1>;
-		cs-gpios = <&gpio 10 1>;
-
-		m25p80@0 {
-			#address-cells = <1>;
-			#size-cells = <1>;
-			compatible = "en25q64", "m25p80";
-			reg = <0 0>;
-			linux,modalias = "en25q64";
-			spi-max-frequency = <1000000>;
-
-			partition@0 {
-				reg = <0x0 0x20000>;
-				label = "u-boot";
-				read-only;
-			};
-
-			partition@20000 {
-				reg = <0x20000 0x6a0000>;
-				label = "firmware";
-			};
-
-			partition@6c0000 {
-				reg = <0x6c0000 0x100000>;
-				label = "dsl_fw";
-			};
-
-			partition@7c0000 {
-				reg = <0x7c0000 0x10000>;
-				label = "config";
-				read-only;
-			};
-
-			ath9k_cal: partition@7d0000 {
-				reg = <0x7d0000 0x30000>;
-				label = "boardconfig";
-				read-only;
-			};
-		};
-	};
-	
-	ath9k_eep {
-		compatible = "ath9k,eeprom";
-		ath,eep-flash = <&ath9k_cal 0x21000>;
-		ath,mac-offset = <0xf100>;
-		ath,mac-increment;
-		ath,led-pin = <0>;
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-		reset {
-			label = "reset";
-			gpios = <&gpio 0 1>;
-			linux,code = <0x198>;
-		};
-
-		wifi {
-			label = "wifi";
-			gpios = <&gpio 9 0>;
-			linux,code = <0xf7>;
-			linux,input-type = <5>; /* EV_SW */
-		};
-
-		wps {
-			label = "wps";
-			gpios = <&gpio 39 1>;
-			linux,code = <0x211>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 4 0>;
-		};
-		internet {
-			label = "internet";
-			gpios = <&gpio 5 0>;
-		};
-		usb0 {
-			label = "usb";
-			gpios = <&gpio 19 0>;
-		};
-		usb2 {
-			label = "usb2";
-			gpios = <&gpio 20 0>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 37 0>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/VG3503J.dts b/target/linux/lantiq/dts/VG3503J.dts
deleted file mode 100644
index b4b3cf5aec..0000000000
--- a/target/linux/lantiq/dts/VG3503J.dts
+++ /dev/null
@@ -1,11 +0,0 @@
-/dts-v1/;
-
-/include/ "VG3503J.dtsi"
-
-/ {
-	gphy-xrx200 {
-		compatible = "lantiq,phy-xrx200";
-		firmware = "lantiq/vr9_phy22f_a1x.bin";
-		phys = [ 00 01 ];
-	};
-};
diff --git a/target/linux/lantiq/dts/VG3503J.dtsi b/target/linux/lantiq/dts/VG3503J.dtsi
deleted file mode 100644
index e9a3c70b29..0000000000
--- a/target/linux/lantiq/dts/VG3503J.dtsi
+++ /dev/null
@@ -1,164 +0,0 @@
-/include/ "vr9.dtsi"
-
-/ {
-	model = "VG3503J - BT OpenReach VDSL Modem";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x2000000>;
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			ranges = <0 0 0x0 0x3ffffff>;
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x20000>;
-				};
-
-				partition@20000 {
-					label = "kernel";
-					reg = <0x20000 0x300000>;
-				};
-
-				partition@1a0000 {
-					label = "rootfs";
-					reg = <0x320000 0x420000>;
-				};
-
-				partition@740000 {
-					label = "btagent";
-					reg = <0x740000 0x80000>;
-				};
-
-				partition@7c0000 {
-					label = "pri_bfocus_cfg";
-					reg = <0x7c0000 0x10000>;
-				};
-
-				partition@7d0000 {
-					label = "sec_bfocus_cfg";
-					reg = <0x7d0000 0x10000>;
-				};
-
-				partition@7e0000 {
-					label = "sysconfig";
-					reg = <0x7e0000 0x10000>;
-				};
-
-				partition@7f0000 {
-					label = "misc_cfg";
-					reg = <0x7f0000 0x10000>;
-				};
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				mdio {
-					lantiq,groups = "mdio";
-					lantiq,function = "mdio";
-				};
-				gphy-leds {
-					lantiq,groups = "gphy0 led0", "gphy0 led1",
-							"gphy0 led2", "gphy1 led0",
-							"gphy1 led1", "gphy1 led2";
-					lantiq,function = "gphy";
-					lantiq,pull = <2>;
-					lantiq,open-drain = <0>;
-					lantiq,output = <1>;
-				};
-			};
-		};
-
-		eth@E108000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "lantiq,xrx200-net";
-			reg = <	0xE108000 0x3000 /* switch */
-				0xE10B100 0x70 /* mdio */
-				0xE10B1D8 0x30 /* mii */
-				0xE10B308 0x30 /* pmac */
-			>;
-			interrupt-parent = <&icu0>;
-			interrupts = <73 72>;
-
-			interface@0 {
-				compatible = "lantiq,xrx200-pdi";
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <0>;
-				mac-address = [ 00 11 22 33 44 55 ];
-				lantiq,switch;
-				ethernet@2 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <2>;
-					phy-mode = "mii";
-					phy-handle = <&phy11>;
-				};
-				ethernet@4 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <4>;
-					phy-mode = "mii";
-					phy-handle = <&phy13>;
-				};
-			};
-
-			mdio@0 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "lantiq,xrx200-mdio";
-				phy11: ethernet-phy@11 {
-					reg = <0x11>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-				phy13: ethernet-phy@13 {
-					reg = <0x13>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-				};
-			};
-		};
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-		reset {
-			label = "reset";
-			gpios = <&gpio 6 1>;
-			linux,code = <0x198>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		power2 {
-			label = "power2";
-			gpios = <&gpio 14 1>;
-		};
-		dsl {
-			label = "bt:green:dsl";
-			gpios = <&gpio 19 1>;
-		};
-		power {
-			label = "power";
-			gpios = <&gpio 28 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/VG3503J_V2.dts b/target/linux/lantiq/dts/VG3503J_V2.dts
deleted file mode 100644
index 005d5bc1ad..0000000000
--- a/target/linux/lantiq/dts/VG3503J_V2.dts
+++ /dev/null
@@ -1,11 +0,0 @@
-/dts-v1/;
-
-/include/ "VG3503J.dtsi"
-
-/ {
-	gphy-xrx200 {
-		compatible = "lantiq,phy-xrx200";
-		firmware = "lantiq/vr9_phy22f_a2x.bin";
-		phys = [ 00 01 ];
-	};
-};
diff --git a/target/linux/lantiq/dts/VGV7510KW22.dtsi b/target/linux/lantiq/dts/VGV7510KW22.dtsi
deleted file mode 100644
index 077ed2372a..0000000000
--- a/target/linux/lantiq/dts/VGV7510KW22.dtsi
+++ /dev/null
@@ -1,256 +0,0 @@
-/include/ "vr9.dtsi"
-
-/ {
-	model = "VGV7510KW22 - o2 Box 6431";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x1000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				boardconfig: partition@fe0000 {
-					label = "board_config";
-					reg = <0xfe0000 0x20000>;
-					read-only;
-				};
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				ip101a-rst {
-					lantiq,pins = "io46";
-					lantiq,output = <0>;
-					lantiq,pull = <1>;
-				};
-				gphy-leds {
-					lantiq,groups = "gphy0 led1",
-							"gphy1 led0", "gphy1 led1";
-					lantiq,function = "gphy";
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-				stp {
-					lantiq,groups = "stp";
-					lantiq,function = "stp";
-					lantiq,pull = <2>;
-					lantiq,open-drain = <0>;
-					lantiq,output = <1>;
-				};
-				mdio {
-					lantiq,groups = "mdio";
-					lantiq,function = "mdio";
-				};
-				pci-rst {
-					lantiq,pins = "io21";
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-				spi {
-					lantiq,groups = "spi";
-					lantiq,function = "spi";
-				};
-			};
-		};
-
-		eth@E108000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "lantiq,xrx200-net";
-			reg = <	0xE108000 0x3000 /* switch */
-				0xE10B100 0x70 /* mdio */
-				0xE10B1D8 0x30 /* mii */
-				0xE10B308 0x30 /* pmac */
-			>;
-			interrupt-parent = <&icu0>;
-			interrupts = <73 72>;
-
-			lan: interface@0 {
-				compatible = "lantiq,xrx200-pdi";
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <0>;
-				mtd-mac-address = <&boardconfig 0x16>;
-				lantiq,switch;
-
-				ethernet@2 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <2>;
-					phy-mode = "mii";
-					phy-handle = <&phy11>;
-				};
-				ethernet@3 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <3>;
-					phy-mode = "mii";
-					phy-handle = <&phy12>;
-				};
-				ethernet@4 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <4>;
-					phy-mode = "mii";
-					phy-handle = <&phy13>;
-				};
-				ethernet@5 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <5>;
-					phy-mode = "mii";
-					phy-handle = <&phy14>;
-				};
-			};
-
-			mdio@0 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "lantiq,xrx200-mdio";
-
-				phy11: ethernet-phy@11 {
-					reg = <0x11>;
-					compatible = "lantiq,phy22f", "ethernet-phy-ieee802.3-c22";
-				};
-				phy12: ethernet-phy@12 {
-					reg = <0x12>;
-					compatible = "lantiq,phy22f", "ethernet-phy-ieee802.3-c22";
-				};
-				phy13: ethernet-phy@13 {
-					reg = <0x13>;
-					compatible = "lantiq,phy22f", "ethernet-phy-ieee802.3-c22";
-				};
-				phy14: ethernet-phy@14 {
-					reg = <0x14>;
-					compatible = "lantiq,phy22f", "ethernet-phy-ieee802.3-c22";
-				};
-			};
-		};
-
-		stp: stp@E100BB0 {
-			compatible = "lantiq,gpio-stp-xway";
-			reg = <0xE100BB0 0x40>;
-			#gpio-cells = <2>;
-			gpio-controller;
-
-			lantiq,shadow = <0xff>;
-			lantiq,groups = <0x1>;
-			lantiq,dsl = <0x0>;
-			lantiq,phy1 = <0x7>;
-			lantiq,phy2 = <0x7>; /* enable gphy0 led2 = LAN2 LED */
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 47 0>;
-		};
-
-		pci@E105400 {
-			status = "okay";
-			lantiq,bus-clock = <33333333>;
-			interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
-			interrupt-map = <
-				0x7000 0 0 1 &icu0 30 1 // slot 14, irq 30
-				>;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0x1>;	/* GNT1 */
-		};
-
-		pcie@d900000 {
-			status = "disabled";
-		};
-	};
-
-	gphy-xrx200 {
-		compatible = "lantiq,phy-xrx200";
-		firmware1 = "lantiq/vr9_phy22f_a1x.bin";	/*VR9 1.1*/
-		firmware2 = "lantiq/vr9_phy22f_a2x.bin";	/*VR9 1.2*/
-		phys = [ 00 01 ];
-	};
-
-	ralink_eep {
-		compatible = "ralink,eeprom";
-		ralink,eeprom = "RT3062.eeprom";
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		reset {
-			label = "reset";
-			gpios = <&gpio 6 1>;
-			linux,code = <0x198>;
-		};
-
-		wps {
-			label = "wps";
-			gpios = <&gpio 9 1>;
-			linux,code = <0x211>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 2 1>;
-		};
-
-		internet_red {
-			label = "internet_red";
-			gpios = <&gpio 10 1>;
-		};
-
-		info_red {
-			label = "info_red";
-			gpios = <&gpio 12 1>;
-		};
-
-		power {
-			label = "power"; /* green */
-			gpios = <&gpio 14 1>;
-		};
-
-		info_green {
-			label = "info_green";
-			gpios = <&gpio 15 1>;
-		};
-
-		internet_green {
-			label = "internet_green";
-			gpios = <&gpio 19 1>;
-		};
-
-		wifi {
-			label = "wifi";
-			gpios = <&gpio 20 1>;
-		};
-
-		power2 {
-			label = "power2"; /* red */
-			gpios = <&gpio 28 1>;
-		};
-
-		phone_red {
-			label = "phone_red";
-			gpios = <&gpio 29 1>;
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/VGV7510KW22BRN.dts b/target/linux/lantiq/dts/VGV7510KW22BRN.dts
deleted file mode 100644
index 1880c8c3b8..0000000000
--- a/target/linux/lantiq/dts/VGV7510KW22BRN.dts
+++ /dev/null
@@ -1,53 +0,0 @@
-/dts-v1/;
-
-/include/ "VGV7510KW22.dtsi"
-
-/ {
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				partition@0 {
-					label = "Boot";
-					reg = <0x00000 0x40000>;
-					read-only;
-				};
-
-				partition@40000 {
-					label = "Configuration";
-					reg = <0x40000 0x40000>;
-					read-only;
-				};
-
-				partition@80000 {
-					label = "Certificate";
-					reg = <0x80000 0x20000>;
-					read-only;
-				};
-
-				partition@a0000 {
-					label = "Special_Area";
-					reg = <0xa0000 0x20000>;
-					read-only;
-				};
-
-				partition@c0000 {
-					label = "Primary_Setting";
-					reg = <0xc0000 0x20000>;
-					read-only;
-				};
-
-				partition@e0000 {
-					label = "firmware"; /* "Code Image 0" in OFW */
-					reg = <0xe0000 0x780000>;
-					read-only;
-				};
-
-				partition@860000 {
-					label = "Code_Image_1";
-					reg = <0x860000 0x780000>;
-					read-only;
-				};
-			};
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/VGV7510KW22NOR.dts b/target/linux/lantiq/dts/VGV7510KW22NOR.dts
deleted file mode 100644
index 57842bbca3..0000000000
--- a/target/linux/lantiq/dts/VGV7510KW22NOR.dts
+++ /dev/null
@@ -1,33 +0,0 @@
-/dts-v1/;
-
-/include/ "VGV7510KW22.dtsi"
-
-/ {
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				partition@0 {
-					label = "uboot";
-					reg = <0x0 0x60000>; /* 384 KiB */
-					read-only;
-				};
-
-				partition@60000 {
-					label = "uboot-env";
-					reg = <0x60000 0x20000>; /* 128 KiB */
-					read-only;
-				};
-
-				partition@80000 {
-					label = "firmware";
-					reg = <0x80000 0xe60000>; /* 14720 KiB */
-				};
-
-				partition@1e80000 {
-					label = "dsl_fw";
-					reg = <0xee0000 0x100000>;  /* 1024 KiB */
-				};
-			};
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/VGV7519.dtsi b/target/linux/lantiq/dts/VGV7519.dtsi
deleted file mode 100644
index 7a7fddb8ed..0000000000
--- a/target/linux/lantiq/dts/VGV7519.dtsi
+++ /dev/null
@@ -1,320 +0,0 @@
-/include/ "vr9.dtsi"
-
-/ {
-
-    model = "VGV7519 - KPN Experiabox V8";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-	
-	fpi@10000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,fpi", "simple-bus";
-		ranges = <0x0 0x10000000 0xEEFFFFF>;
-		reg = <0x10000000 0xEF00000>;
-
-		localbus@0 {
-			#address-cells = <2>;
-			#size-cells = <1>;
-			compatible = "lantiq,localbus", "simple-bus";
-		};
-
-		gpio: pinmux@E100B10 {
-			compatible = "lantiq,pinctrl-xr9";
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-			
-			interrupt-parent = <&icu0>;
-			interrupts = <166 135 66 40 41 42 38>;
-
-			#gpio-cells = <2>;
-			gpio-controller;
-			reg = <0xE100B10 0xA0>;
-
-			state_default: pinmux {
-				stp {
-					lantiq,groups = "stp";
-					lantiq,function = "stp";
-				};
-				spi {
-					lantiq,groups = "spi";
-					lantiq,function = "spi";
-				};
-				mdio {
-					lantiq,groups = "mdio";
-					lantiq,function = "mdio";
-				};
-				gphy-leds_out {
-					lantiq,pins = "io7", "io44";
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-				stp_out {
-					lantiq,pins = "io4", "io5", "io6";
-					lantiq,open-drain = <0>;
-					lantiq,output = <1>;
-					lantiq,pull = <0>;
-				};
-				pci-rst {
-					lantiq,pins = "io21";
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-				gphy-leds {
-					lantiq,groups = "gphy0 led1", "gphy1 led0";
-					lantiq,function = "gphy";
-					lantiq,open-drain = <0>;
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-			};
-		};
-
-		eth@E108000 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "lantiq,xrx200-net";
-			reg = <	0xE108000 0x3000 /* switch */
-				0xE10B100 0x70 /* mdio */
-				0xE10B1D8 0x30 /* mii */
-				0xE10B308 0x30 /* pmac */
-			>;
-			interrupt-parent = <&icu0>;
-			interrupts = <73 72>;
-
-			lan: interface@0 {
-				compatible = "lantiq,xrx200-pdi";
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <0>;
-				mac-address = [ 00 11 22 33 44 55 ];
-
-				ethernet@0 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <0>;
-					phy-mode = "rgmii";
-					phy-handle = <&phy0>;
-				};
-				ethernet@1 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <1>;
-					phy-mode = "rgmii";
-					phy-handle = <&phy1>;
-				};
-				ethernet@2 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <2>;
-					phy-mode = "gmii";
-					phy-handle = <&phy11>;
-				};
-				ethernet@4 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <4>;
-					phy-mode = "gmii";
-					phy-handle = <&phy13>;
-				};
-			};
-
-			wan: interface@1 {
-				compatible = "lantiq,xrx200-pdi";
-				#address-cells = <1>;
-				#size-cells = <0>;
-				reg = <1>;
-				mac-address = [ 00 11 22 33 44 56 ];
-				lantiq,wan;
-				ethernet@5 {
-					compatible = "lantiq,xrx200-pdi-port";
-					reg = <5>;
-					phy-mode = "rgmii";
-					phy-handle = <&phy5>;
-				};
-			};
-
-			mdio@0 {
-				#address-cells = <1>;
-				#size-cells = <0>;
-				compatible = "lantiq,xrx200-mdio";
-				phy0: ethernet-phy@0 {
-					reg = <0x0>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-					lantiq,c45-reg-init = <1 0 0 0>; 
-				};
-				phy1: ethernet-phy@1 {
-					reg = <0x1>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-					lantiq,c45-reg-init = <1 0 0 0>; 
-				};
-				phy5: ethernet-phy@5 {
-					reg = <0x5>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-					lantiq,c45-reg-init = <1 0 0 0>; 
-				};
-				phy11: ethernet-phy@11 {
-					reg = <0x11>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-					lantiq,c45-reg-init = <1 0 0 0>; 
-				};
-				phy13: ethernet-phy@13 {
-					reg = <0x13>;
-					compatible = "lantiq,phy11g", "ethernet-phy-ieee802.3-c22";
-					lantiq,c45-reg-init = <1 0 0 0>; 
-				};
-			};
-		};
-
-		stp: stp@E100BB0 {
-			compatible = "lantiq,gpio-stp-xway";
-			reg = <0xE100BB0 0x40>;
-			#gpio-cells = <2>;
-			gpio-controller;
-
-			lantiq,shadow = <0xffff>;
-			lantiq,groups = <0x3>;
-			lantiq,dsl = <0x0>;
-			lantiq,phy1 = <0x0>;
-			lantiq,phy2 = <0x0>;
-			/* lantiq,rising; */
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 32 0>;
-			lantiq,portmask = <0x3>;
-		};
-
-		pci@E105400 {
-			status = "okay";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			compatible = "lantiq,pci-xway";
-			bus-range = <0x0 0x0>;
-			ranges = <0x2000000 0 0x8000000 0x8000000 0 0x2000000   /* pci memory */
-				0x1000000 0 0x00000000 0xAE00000 0 0x200000>; /* io space */
-			reg = <0x7000000 0x8000         /* config space */
-				0xE105400 0x400>;       /* pci bridge */
-			lantiq,bus-clock = <33333333>;
-			/*lantiq,external-clock;*/
-			lantiq,delay-hi = <0>; /* 0ns delay */
-			lantiq,delay-lo = <0>; /* 0.0ns delay */
-			interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
-			interrupt-map = <
-				0x7000 0 0 1 &icu0 30 1 // slot 14, irq 30
-				>;
-			gpio-reset = <&gpio 21 0>;
-			req-mask = <0x1>;	/* GNT1 */
-		};
-
-		pcie@d900000 {
-			status = "disabled";
-		};
-	};
-
-	gphy-xrx200 {
-		compatible = "lantiq,phy-xrx200";
-		firmware1 = "lantiq/vr9_phy11g_a1x.bin";	/*VR9 1.1*/
-		firmware2 = "lantiq/vr9_phy11g_a2x.bin";	/*VR9 1.2*/
-		phys = [ 00 01 ];
-	};
-
-	ralink_eep {
-		compatible = "ralink,eeprom";
-		ralink,eeprom = "RT2860.eeprom";
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-		reset {
-			label = "reset";
-			gpios = <&gpio 9 1>;
-			linux,code = <0x198>;
-		};
-		eco {
-			label = "eco";
-			gpios = <&gpio 41 1>;
-			linux,code = <247>;
-		};
-		rfkill {
-			label = "rfkill";
-			gpios = <&gpio 45 1>;
-			linux,code = <0xf7>;
-		};
-		wps {
-			label = "wps";
-			gpios = <&gpio 10 1>;
-			linux,code = <0x211>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		eco {					/* blue */
-			label = "eco";
-			gpios = <&stp 2 1>;
-		};
-		wps_red {				/* red */
-			label = "wps_red";
-			gpios = <&stp 3 1>;
-		};
-		wps_yellow {				/* yellow */
-			label = "wps_yellow";
-			gpios = <&stp 4 1>;
-		};
-		upgrade {				/* blue */
-			label = "upgrade";
-			gpios = <&stp 5 1>;
-		};
-		tv {					/* yellow */
-			label = "tv";
-			gpios = <&stp 6 1>;
-		};
-		internet_yellow {			/* yellow */
-			label = "internet_yellow";
-			gpios = <&stp 7 1>;
-		};
-		internet_red {				/* red */
-			label = "internet_red";
-			gpios = <&stp 8 1>;
-		};
-		broadband_red {				/* red */
-			label = "broadband_red";
-			gpios = <&stp 9 1>;
-		};
-		broadband_yellow {			/* yellow */
-			label = "broadband_yellow";
-			gpios = <&stp 10 1>;
-		};
-		voice {					/* yellow */
-			label = "voice";
-			gpios = <&stp 11 1>;
-		};
-		wireless_red {				/* red */
-			label = "wireless_red";
-			gpios = <&stp 12 1>;
-		};
-		wireless_yellow {			/* yellow */
-			label = "wireless_yellow";
-			gpios = <&stp 13 1>;
-		};
-		power2 {				/* yellow */
-			label = "power2";
-			gpios = <&stp 14 1>;
-		};
-		power {					/* red */
-			label = "power";
-			gpios = <&stp 15 1>;
-			default-state = "on";
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/VGV7519BRN.dts b/target/linux/lantiq/dts/VGV7519BRN.dts
deleted file mode 100644
index c90b680490..0000000000
--- a/target/linux/lantiq/dts/VGV7519BRN.dts
+++ /dev/null
@@ -1,33 +0,0 @@
-/dts-v1/;
-
-
-/include/ "VGV7519.dtsi"
-
-/ {
-	fpi@10000000 {
-		localbus@0 {
-			nor-flash@0 {
-				compatible = "lantiq,nor", "cfi-flash";
-				bank-width = <2>;
-				reg = <0 0x0 0x800000>, <1 0x800000 0x800000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@40000 {
-					label = "board_config";
-					reg = <0x40000 0x10000>;
-					read-only;
-				};
-				partition@80000 {
-					label = "firmware";
-					reg = <0x80000 0x780000>;
-					read-only;
-				};
-				partition@880000 {
-					label = "rootfs_data";
-					reg = <0x880000 0x780000>;
-				};
-			};
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/VGV7519NOR.dts b/target/linux/lantiq/dts/VGV7519NOR.dts
deleted file mode 100644
index 355a90c94c..0000000000
--- a/target/linux/lantiq/dts/VGV7519NOR.dts
+++ /dev/null
@@ -1,39 +0,0 @@
-/dts-v1/;
-
-
-/include/ "VGV7519.dtsi"
-
-/ {
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x800000>, <1 0x800000 0x800000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x40000>;
-				};
-				partition@40000 {
-					label = "board_config";
-					reg = <0x40000 0x10000>;
-					read-only;
-				};
-				partition@60000 {
-					label = "uboot_env";
-					reg = <0x60000 0x10000>;
-				};
-				partition@80000 {
-					label = "firmware";
-					reg = <0x80000 0xf80000>;
-					// 0x080000 - 0x01b0000 : kernel
-					// 0x1b0000 - 0x1000000 : rootfs (squashfs)
-					// 0x390000 - 0x1000000 : rootfs_data
-				};
-			};
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/WBMR.dts b/target/linux/lantiq/dts/WBMR.dts
deleted file mode 100644
index 60a7508917..0000000000
--- a/target/linux/lantiq/dts/WBMR.dts
+++ /dev/null
@@ -1,168 +0,0 @@
-/dts-v1/;
-
-/include/ "ar9.dtsi"
-
-/ {
-	model = "WBMR - Buffalo WBMR-HP-G300H";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	memory@0 {
-		reg = <0x0 0x4000000>;
-	};
-
-	fpi@10000000 {
-		localbus@0 {
-			nor-boot@0 {
-				compatible = "lantiq,nor";
-				bank-width = <2>;
-				reg = <0 0x0 0x2000000>;
-				#address-cells = <1>;
-				#size-cells = <1>;
-
-				partition@0 {
-					label = "uboot";
-					reg = <0x00000 0x40000>;
-					read-only;
-				};
-
-				partition@40000 {
-					label = "uboot_env";
-					reg = <0x40000 0x20000>;
-					read-only;
-				};
-
-				partition@20000 {
-					label = "firmware";
-					reg = <0x60000 0x1f20000>;
-				};
-
-				partition@0x1fc0000 {
-					label = "board";
-					reg = <0x1fc0000 0x20000>;
-					read-only;
-				};
-
-				partition@0x1fe0000 {
-					label = "calibration";
-					reg = <0x1fe0000 0x20000>;
-					read-only;
-				};
-			};
-
-			mac_addr {
-				compatible = "lantiq,eth-mac";
-				reg = <0 0x1fd0024 0x6>;
-			};
-		};
-
-		gpio: pinmux@E100B10 {
-			pinctrl-names = "default";
-			pinctrl-0 = <&state_default>;
-
-			state_default: pinmux {
-				pci-in {
-					lantiq,groups = "req1";
-					lantiq,output = <0>;
-					lantiq,open-drain = <1>;
-					lantiq,pull = <2>;
-				};
-				pci-out {
-					lantiq,groups = "gnt1";
-					lantiq,output = <1>;
-					lantiq,pull = <0>;
-				};
-				pci_rst {
-					lantiq,pins = "io21";
-					lantiq,pull = <0>;
-					lantiq,output = <1>;
-				};
-			};
-		};
-
-		etop@E180000 {
-			phy-mode = "rgmii";
-		};
-
-		ifxhcd@E101000 {
-			status = "okay";
-			gpios = <&gpio 36 0>;
-		};
-
-		pci@E105400 {
-			status = "okay";
-		};
-	};
-
-	gpio-keys-polled {
-		compatible = "gpio-keys-polled";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		poll-interval = <100>;
-
-		wps {
-			label = "wps";
-			gpios = <&gpio 0 1>;
-			linux,code = <0x211>;
-		};
-		reset {
-			label = "reset";
-			gpios = <&gpio 37 1>;
-			linux,code = <0x198>;
-		};
-		eject {
-			label = "eject";
-			gpios = <&gpio 34 1>;
-			linux,code = <0xf7>;
-		};
-		movie {
-			label = "movie";
-			gpios = <&gpio 22 1>;
-			linux,code = <0x109>;
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		power {
-			label = "power";
-			gpios = <&gpio 1 1>;
-		};
-		power2 {
-			label = "power2";
-			gpios = <&gpio 5 1>;
-		};
-		security {
-			label = "security";
-			gpios = <&gpio 14 1>;
-		};
-		wifi {
-			label = "wifi";
-			gpios = <&gpio 15 1>;
-		};
-		dsl {
-			label = "dsl";
-			gpios = <&gpio 16 1>;
-		};
-		online {
-			label = "online";
-			gpios = <&gpio 17 1>;
-		};
-		online2 {
-			label = "online2";
-			gpios = <&gpio 18 1>;
-		};
-		movie {
-			label = "movie";
-			gpios = <&gpio 20 1>;
-		};
-		usb {
-			label = "usb";
-			gpios = <&gpio 28 1>;
-			default-state = "on";
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/amazonse.dtsi b/target/linux/lantiq/dts/amazonse.dtsi
deleted file mode 100644
index 13d3e73860..0000000000
--- a/target/linux/lantiq/dts/amazonse.dtsi
+++ /dev/null
@@ -1,148 +0,0 @@
-/ {
-	#address-cells = <1>;
-	#size-cells = <1>;
-	compatible = "lantiq,xway", "lantiq,ase";
-
-	cpus {
-		cpu@0 {
-			compatible = "mips,mips4Kc";
-		};
-	};
-
-	biu@1F800000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,biu", "simple-bus";
-		reg = <0x1F800000 0x800000>;
-		ranges = <0x0 0x1F800000 0x7FFFFF>;
-
-		icu0: icu@80200 {
-			#interrupt-cells = <1>;
-			interrupt-controller;
-			compatible = "lantiq,icu";
-			reg = <0x80200 0x28
-				0x80228 0x28
-				0x80250 0x28
-				0x80278 0x28
-				0x802a0 0x28>;
-		};
-
-		watchdog@803F0 {
-			compatible = "lantiq,wdt";
-			reg = <0x803F0 0x10>;
-		};
-	};
-
-	sram@1F000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,sram", "simple-bus";
-		reg = <0x1F000000 0x800000>;
-		ranges = <0x0 0x1F000000 0x7FFFFF>;
-
-		eiu0: eiu@101000 {
-			#interrupt-cells = <1>;
-			compatible = "lantiq,eiu-xway";
-			reg = <0x101000 0x1000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <29 30 31>;
-		};
-
-		pmu0: pmu@102000 {
-			compatible = "lantiq,pmu-xway";
-			reg = <0x102000 0x1000>;
-		};
-
-		cgu0: cgu@103000 {
-			compatible = "lantiq,cgu-xway";
-			reg = <0x103000 0x1000>;
-			#clock-cells = <1>;
-		};
-
-		rcu0: rcu@203000 {
-			compatible = "lantiq,rcu-xway";
-			reg = <0x203000 0x1000>;
-		};
-	};
-
-	fpi@10000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,fpi", "simple-bus";
-		ranges = <0x0 0x10000000 0xEEFFFFF>;
-		reg = <0x10000000 0xEF00000>;
-
-		spi@E100800 {
-			compatible = "lantiq,spi-xway";
-			reg = <0xE100800 0x100>;
-			interrupt-parent = <&icu0>;
-			interrupts = <24 25 26>;
-			#address-cells = <1>;
-			#size-cells = <1>;
-		};
-
-		gptu@E100A00 {
-			compatible = "lantiq,gptu-xway";
-			reg = <0xE100A00 0x100>;
-			interrupt-parent = <&icu0>;
-                        interrupts = <97 98 99 100 101 102>;
-			status = "disabled";
-		};
-
-		gpio: pinmux@E100B10 {
-			compatible = "lantiq,pinctrl-ase";
-			#gpio-cells = <2>;
-			gpio-controller;
-			reg = <0xE100B10 0xA0>;
-		};
-
-		serial@E100C00 {
-			compatible = "lantiq,asc";
-			reg = <0xE100C00 0x400>;
-			interrupt-parent = <&icu0>;
-			interrupts = <72 74 75>;
-		};
-
-		mei@E116000 {
-			compatible = "lantiq,mei-xway";
-			interrupt-parent = <&icu0>;
-			interrupts = <63>;
-		};
-
-		ifxhcd@E101000 {
-			compatible = "lantiq,ifxhcd-ase";
-			reg = <0xE101000 0x1000
-				0xE120000 0x3f000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <39>;
-			status = "disabled";
-		};
-
-		dma0: dma@E104100 {
-			compatible = "lantiq,dma-xway";
-			reg = <0xE104100 0x800>;
-		};
-
-		ebu0: ebu@E105300 {
-			compatible = "lantiq,ebu-xway";
-			reg = <0xE105300 0x100>;
-		};
-
-		ppe@E234000 {
-			compatible = "lantiq,ppe-ase";
-			interrupt-parent = <&icu0>;
-			interrupts = <85>;
-		};
-
-		etop@E180000 {
-			compatible = "lantiq,etop-xway";
-			reg = <0xE180000 0x40000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <105 109>;
-		};
-	};
-
-	adsl {
-		compatible = "lantiq,adsl-ase";
-	};
-};
diff --git a/target/linux/lantiq/dts/ar9.dtsi b/target/linux/lantiq/dts/ar9.dtsi
deleted file mode 100644
index cc65fd1dd9..0000000000
--- a/target/linux/lantiq/dts/ar9.dtsi
+++ /dev/null
@@ -1,183 +0,0 @@
-/ {
-	#address-cells = <1>;
-	#size-cells = <1>;
-	compatible = "lantiq,xway", "lantiq,ar9";
-
-	cpus {
-		cpu@0 {
-			compatible = "mips,mips34K";
-		};
-	};
-
-	memory@0 {
-		device_type = "memory";
-	};
-
-	biu@1F800000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,biu", "simple-bus";
-		reg = <0x1F800000 0x800000>;
-		ranges = <0x0 0x1F800000 0x7FFFFF>;
-
-		icu0: icu@80200 {
-			#interrupt-cells = <1>;
-			interrupt-controller;
-			compatible = "lantiq,icu";
-			reg = <0x80200 0x28
-				0x80228 0x28
-				0x80250 0x28
-				0x80278 0x28
-				0x802a0 0x28>;
-		};
-
-		watchdog@803F0 {
-			compatible = "lantiq,wdt";
-			reg = <0x803F0 0x10>;
-		};
-	};
-
-	sram@1F000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,sram";
-		reg = <0x1F000000 0x800000>;
-		ranges = <0x0 0x1F000000 0x7FFFFF>;
-
-		eiu0: eiu@101000 {
-			#interrupt-cells = <1>;
-			interrupt-controller;
-			compatible = "lantiq,eiu-xway";
-			reg = <0x101000 0x1000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <166 135 66 40 41 42>;
-		};
-
-		pmu0: pmu@102000 {
-			compatible = "lantiq,pmu-xway";
-			reg = <0x102000 0x1000>;
-		};
-
-		cgu0: cgu@103000 {
-			compatible = "lantiq,cgu-xway";
-			reg = <0x103000 0x1000>;
-			#clock-cells = <1>;
-		};
-
-		rcu0: rcu@203000 {
-			compatible = "lantiq,rcu-xway";
-			reg = <0x203000 0x1000>;
-		};
-	};
-
-	fpi@10000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,fpi", "simple-bus";
-		ranges = <0x0 0x10000000 0xEEFFFFF>;
-		reg = <0x10000000 0xEF00000>;
-
-		localbus@0 {
-			#address-cells = <2>;
-			#size-cells = <1>;
-			ranges = <0 0 0x0 0x3ffffff /* addrsel0 */
-				1 0 0x4000000 0x4000010>; /* addsel1 */
-			compatible = "lantiq,localbus", "simple-bus";
-		};
-
-		gptu@E100A00 {
-			compatible = "lantiq,gptu-xway";
-			reg = <0xE100A00 0x100>;
-			interrupt-parent = <&icu0>;
-			interrupts = <126 127 128 129 130 131>;
-		};
-
-		asc0: serial@E100400 {
-			compatible = "lantiq,asc";
-			reg = <0xE100400 0x400>;
-			interrupt-parent = <&icu0>;
-			interrupts = <104 105 106>;
-			status = "disabled";
-		};
-
-		gpio: pinmux@E100B10 {
-			compatible = "lantiq,pinctrl-xr9";
-			#gpio-cells = <2>;
-			gpio-controller;
-			reg = <0xE100B10 0xA0>;
-		};
-
-		asc1: serial@E100C00 {
-			compatible = "lantiq,asc";
-			reg = <0xE100C00 0x400>;
-			interrupt-parent = <&icu0>;
-			interrupts = <112 113 114>;
-		};
-
-		ifxhcd@E101000 {
-			compatible = "lantiq,ifxhcd-arx100";
-			reg = <0xE101000 0x1000
-				0xE120000 0x3f000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <62 91>;
-			status = "disabled";
-		};
-
-		deu@E103100 {
-			compatible = "lantiq,deu-arx100";
-			reg = <0xE103100 0xf00>;
-		};
-
-		dma0: dma@E104100 {
-			compatible = "lantiq,dma-xway";
-			reg = <0xE104100 0x800>;
-		};
-
-		ebu0: ebu@E105300 {
-			compatible = "lantiq,ebu-xway";
-			reg = <0xE105300 0x100>;
-		};
-
-		mei@E116000 {
-			compatible = "lantiq,mei-xway";
-			interrupt-parent = <&icu0>;
-			interrupts = <63>;
-		};
-
-		etop@E180000 {
-			compatible = "lantiq,etop-xway";
-			reg = <0xE180000 0x40000
-				0xE108000 0x200>;
-			interrupt-parent = <&icu0>;
-			interrupts = <73 72>;
-			mac-address = [ 00 11 22 33 44 55 ];
-		};
-
-		ppe@E234000 {
-			compatible = "lantiq,ppe-arx100";
-			interrupt-parent = <&icu0>;
-			interrupts = <96>;
-		};
-
-		pci0: pci@E105400 {
-			status = "disabled";
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			compatible = "lantiq,pci-xway";
-			bus-range = <0x0 0x0>;
-			ranges = <0x2000000 0 0x8000000 0x8000000 0 0x2000000	/* pci memory */
-				  0x1000000 0 0x00000000 0xAE00000 0 0x200000>;	/* io space */
-			reg = <0x7000000 0x8000		/* config space */
-				0xE105400 0x400>;	/* pci bridge */
-			lantiq,bus-clock = <33333333>;
-			interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
-			interrupt-map = <0x7000 0 0 1 &icu0 30 1>;
-			req-mask = <0x1>;
-		};
-	};
-
-	adsl {
-		compatible = "lantiq,adsl-arx100";
-	};
-};
diff --git a/target/linux/lantiq/dts/danube.dtsi b/target/linux/lantiq/dts/danube.dtsi
deleted file mode 100644
index 698196d9ee..0000000000
--- a/target/linux/lantiq/dts/danube.dtsi
+++ /dev/null
@@ -1,205 +0,0 @@
-/ {
-	#address-cells = <1>;
-	#size-cells = <1>;
-	compatible = "lantiq,xway", "lantiq,danube";
-
-	chosen {
-		bootargs = "console=ttyLTQ0,115200 init=/etc/preinit";
-	};
-
-	cpus {
-		cpu@0 {
-			compatible = "mips,mips24Kc";
-		};
-	};
-
-	memory@0 {
-		device_type = "memory";
-	};
-
-	biu@1F800000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,biu", "simple-bus";
-		reg = <0x1F800000 0x800000>;
-		ranges = <0x0 0x1F800000 0x7FFFFF>;
-
-		icu0: icu@80200 {
-			#interrupt-cells = <1>;
-			interrupt-controller;
-			compatible = "lantiq,icu";
-			reg = <0x80200 0x28
-				0x80228 0x28
-				0x80250 0x28
-				0x80278 0x28
-				0x802a0 0x28>;
-		};
-
-		watchdog@803F0 {
-			compatible = "lantiq,wdt";
-			reg = <0x803F0 0x10>;
-		};
-	};
-
-	sram@1F000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,sram", "simple-bus";
-		reg = <0x1F000000 0x800000>;
-		ranges = <0x0 0x1F000000 0x7FFFFF>;
-
-		eiu0: eiu@101000 {
-			#interrupt-cells = <1>;
-			interrupt-controller;
-			compatible = "lantiq,eiu-xway";
-			reg = <0x101000 0x1000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <166 135 66>;
-		};
-
-		pmu0: pmu@102000 {
-			compatible = "lantiq,pmu-xway";
-			reg = <0x102000 0x1000>;
-		};
-
-		cgu0: cgu@103000 {
-			compatible = "lantiq,cgu-xway";
-			reg = <0x103000 0x1000>;
-			#clock-cells = <1>;
-		};
-
-		vmmc@107000 {
-			status = "disabled";
-			compatible = "lantiq,vmmc";
-			reg = <0x103000 0x400>;
-			interrupt-parent = <&icu0>;
-			interrupts = <150 151 152 153 154 155>;
-		};
-
-		rcu0: rcu@203000 {
-			compatible = "lantiq,rcu-xway";
-			reg = <0x203000 0x1000>;
-		};
-	};
-
-	fpi@10000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,fpi", "simple-bus";
-		ranges = <0x0 0x10000000 0xEEFFFFF>;
-		reg = <0x10000000 0xEF00000>;
-
-		localbus@0 {
-			#address-cells = <2>;
-			#size-cells = <1>;
-			ranges = <0 0 0x0 0x3ffffff /* addrsel0 */
-				1 0 0x4000000 0x4000010>; /* addsel1 */
-			compatible = "lantiq,localbus", "simple-bus";
-		};
-
-		gptu@E100A00 {
-			compatible = "lantiq,gptu-xway";
-			reg = <0xE100A00 0x100>;
-			interrupt-parent = <&icu0>;
-			interrupts = <126 127 128 129 130 131>;
-		};
-
-		gpios: stp@E100BB0 {
-			#gpio-cells = <2>;
-			compatible = "lantiq,gpio-stp-xway";
-			gpio-controller;
-			reg = <0xE100BB0 0x40>;
-			lantiq,shadow = <0xfff>;
-			lantiq,groups = <0x3>;
-			status = "disabled";
-		};
-
-		asc0: serial@E100400 {
-			compatible = "lantiq,asc";
-			reg = <0xE100400 0x400>;
-			interrupt-parent = <&icu0>;
-			interrupts = <104 105 106>;
-			status = "disabled";
-		};
-
-		gpio: pinmux@E100B10 {
-			compatible = "lantiq,pinctrl-xway";
-			#gpio-cells = <2>;
-			gpio-controller;
-			reg = <0xE100B10 0xA0>;
-		};
-
-		asc1: serial@E100C00 {
-			compatible = "lantiq,asc";
-			reg = <0xE100C00 0x400>;
-			interrupt-parent = <&icu0>;
-			interrupts = <112 113 114>;
-		};
-
-		ifxhcd@E101000 {
-			compatible = "lantiq,ifxhcd-danube";
-			reg = <0xE101000 0x1000
-				0xE120000 0x3f000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <62>;
-			status = "disabled";
-		};
-
-		deu@E103100 {
-			compatible = "lantiq,deu-danube";
-			reg = <0xE103100 0xf00>;
-		};
-
-		dma0: dma@E104100 {
-			compatible = "lantiq,dma-xway";
-			reg = <0xE104100 0x800>;
-		};
-
-		ebu0: ebu@E105300 {
-			compatible = "lantiq,ebu-xway";
-			reg = <0xE105300 0x100>;
-		};
-
-		mei@E116000 {
-			compatible = "lantiq,mei-xway";
-			interrupt-parent = <&icu0>;
-			interrupts = <63>;
-		};
-
-		etop@E180000 {
-			compatible = "lantiq,etop-xway";
-			reg = <0xE180000 0x40000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <73 78>;
-			mac-address = [ 00 11 22 33 44 55 ];
-		};
-
-		ppe@E234000 {
-			compatible = "lantiq,ppe-danube";
-			interrupt-parent = <&icu0>;
-			interrupts = <96>;
-		};
-
-		pci0: pci@E105400 {
-			status = "disabled";
-
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			compatible = "lantiq,pci-xway";
-			bus-range = <0x0 0x0>;
-			ranges = <0x2000000 0 0x8000000 0x8000000 0 0x2000000	/* pci memory */
-				  0x1000000 0 0x00000000 0xAE00000 0 0x200000>;	/* io space */
-			reg = <0x7000000 0x8000		/* config space */
-				0xE105400 0x400>;	/* pci bridge */
-			lantiq,bus-clock = <33333333>;
-			interrupt-map-mask = <0xf800 0x0 0x0 0x7>;
-			interrupt-map = <0x7000 0 0 1 &icu0 30 1>;
-			req-mask = <0x1>;
-		};
-	};
-
-	adsl {
-		compatible = "lantiq,adsl-danube";
-	};
-};
diff --git a/target/linux/lantiq/dts/falcon-sflash-16M.dtsi b/target/linux/lantiq/dts/falcon-sflash-16M.dtsi
deleted file mode 100644
index d95acc21ef..0000000000
--- a/target/linux/lantiq/dts/falcon-sflash-16M.dtsi
+++ /dev/null
@@ -1,37 +0,0 @@
-
-&ebu_cs0 {
-	#address-cells = <1>;
-	#size-cells = <1>;
-	compatible = "lantiq,sflash-falcon", "simple-bus";
-
-	flash@0 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "spansion,s25fl129p0", "spansion,s25fl129p1";
-		reg = <0 0>;
-		linux,mtd-name = "sflash";
-		spi-max-frequency = <80000000>;
-		m25p,fast-read;
-
-		partition@0 {
-			reg = <0x0 0x40000>;
-			label = "uboot";
-			read-only;
-		};
-
-		partition@40000 {
-			reg = <0x40000 0x80000>;
-			label = "uboot_env";
-		};
-
-		partition@C0000 {
-			reg = <0xC0000 0x740000>;
-			label = "image0";
-		};
-
-		partition@800000 {
-			reg = <0x800000 0x800000>;
-			label = "image1";
-		};
-	};
-};
diff --git a/target/linux/lantiq/dts/falcon.dtsi b/target/linux/lantiq/dts/falcon.dtsi
deleted file mode 100644
index d5646d9842..0000000000
--- a/target/linux/lantiq/dts/falcon.dtsi
+++ /dev/null
@@ -1,385 +0,0 @@
-/ {
-	#address-cells = <1>;
-	#size-cells = <1>;
-	compatible = "lantiq,falcon";
-
-	cpus {
-		cpu@0 {
-			compatible = "mips,mips34kc";
-		};
-	};
-
-	aliases {
-		serial0 = &serial0;
-		serial1 = &serial1;
-		gpio0 = &gpio0;
-		gpio1 = &gpio1;
-		gpio2 = &gpio2;
-		gpio3 = &gpio3;
-		gpio4 = &gpio4;
-	};
-
-	clocks {
-		compatible = "simple-bus";
-
-		cpu_clk: cpu {
-			compatible = "fixed-clock";
-			#clock-cells = <0>;
-			clock-frequency = <400000000>;
-			clock-output-names = "cpu";
-		};
-
-		io_clk: io {
-			compatible = "fixed-clock";
-			#clock-cells = <0>;
-			clock-frequency = <200000000>;
-			clock-output-names = "io";
-		};
-
-		fpi_clk: fpi {
-			compatible = "fixed-clock";
-			#clock-cells = <0>;
-			clock-frequency = <100000000>;
-			clock-output-names = "fpi";
-		};
-	};
-
-	ebu_cs0: localbus@10000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,localbus", "simple-bus";
-		reg = <0x10000000 0x4000000>;
-		ranges = <0x0 0x10000000 0x4000000>;
-	};
-	ebu_cs1: localbus@14000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,localbus", "simple-bus";
-		reg = <0x14000000 0x4000000>;
-		ranges = <0x0 0x14000000 0x4000000>;
-	};
-
-	ebu@18000000 {
-		compatible = "lantiq,ebu-falcon";
-		reg = <0x18000000 0x100>;
-	};
-
-	sbs2@1D000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,sysb2", "simple-bus";
-		reg = <0x1D000000 0x1000000>;
-		ranges = <0x0 0x1D000000 0x1000000>;
-
-		clock_sysgpe: clock-controller@700000 {
-			compatible = "lantiq,sysgpe-falcon";
-			reg = <0x700000 0x100>;
-			#clock-cells = <1>;
-		};
-
-		mps@4000 {
-			compatible = "lantiq,mps-falcon", "lantiq,mps-xrx100";
-			reg = <0x4000 0x1000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <154 155>;
-			lantiq,mbx = <&mpsmbx>;
-		};
-
-		gpio0: gpio@810000 {
-			compatible = "lantiq,falcon-gpio";
-			gpio-controller;
-			#gpio-cells = <2>;
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			interrupt-parent = <&icu0>;
-			interrupts = <44>;
-			reg = <0x810000 0x80>;
-			clocks = <&clock_syseth 16>;
-		};
-
-		gpio2: gpio@810100 {
-			compatible = "lantiq,falcon-gpio";
-			gpio-controller;
-			#gpio-cells = <2>;
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			interrupt-parent = <&icu0>;
-			interrupts = <46>;
-			reg = <0x810100 0x80>;
-			clocks = <&clock_syseth 17>;
-		};
-
-		clock_syseth: clock-controller@B00000 {
-			compatible = "lantiq,syseth-falcon";
-			reg = <0xB00000 0x100>;
-			#clock-cells = <1>;
-		};
-
-		pad@B01000 {
-			compatible = "lantiq,pad-falcon";
-			reg = <0xB01000 0x100>;
-			lantiq,bank = <0>;
-			clocks = <&clock_syseth 20>;
-		};
-
-		pad@B02000 {
-			compatible = "lantiq,pad-falcon";
-			reg = <0xB02000 0x100>;
-			lantiq,bank = <2>;
-			clocks = <&clock_syseth 21>;
-		};
-	};
-
-	fpi@1E000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,fpi", "simple-bus";
-		reg = <0x1E000000 0x1000000>;
-		ranges = <0x0 0x1E000000 0x1000000>;
-
-		serial1: serial@100B00 {
-			status = "disabled";
-			compatible = "lantiq,asc";
-			reg = <0x100B00 0x100>;
-			interrupt-parent = <&icu0>;
-			interrupts = <112 113 114>;
-			line = <1>;
-			pinctrl-names = "default";
-			pinctrl-0 = <&asc1_pins>;
-			clocks = <&clock_sys1 11>;
-		};
-
-		serial0: serial@100C00 {
-			compatible = "lantiq,asc";
-			reg = <0x100C00 0x100>;
-			interrupt-parent = <&icu0>;
-			interrupts = <104 105 106>;
-			line = <0>;
-			pinctrl-names = "default";
-			pinctrl-0 = <&asc0_pins>;
-			clocks = <&clock_sys1 12>;
-		};
-
-		spi: spi@100D00 {
-			status = "disabled";
-			compatible = "lantiq,spi-lantiq-ssc";
-			interrupts = <23 22 24>;
-			#address-cells = <1>;
-			#size-cells = <0>;
-			reg = <0x100D00 0x100>;
-			interrupt-parent = <&icu0>;
-			clocks = <&clock_sys1 13>;
-		};
-
-		gptc@100E00 {
-			compatible = "lantiq,gptc-falcon";
-			reg = <0x100E00 0x100>;
-		};
-
-		i2c: i2c@200000 {
-			status = "disabled";
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "lantiq,lantiq-i2c";
-			reg = <0x200000 0x10000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <18 19 20 21>;
-			gpios = <&gpio1 7 0 &gpio1 8 0>;
-			pinctrl-names = "default";
-			pinctrl-0 = <&i2c_pins>;
-			clocks = <&clock_sys1 14>;
-		};
-
-		gpio1: gpio@800100 {
-			compatible = "lantiq,falcon-gpio";
-			gpio-controller;
-			#gpio-cells = <2>;
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			interrupt-parent = <&icu0>;
-			interrupts = <45>;
-			reg = <0x800100 0x100>;
-			clocks = <&clock_sys1 16>;
-		};
-
-		gpio3: gpio@800200 {
-			compatible = "lantiq,falcon-gpio";
-			gpio-controller;
-			#gpio-cells = <2>;
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			interrupt-parent = <&icu0>;
-			interrupts = <47>;
-			reg = <0x800200 0x100>;
-			clocks = <&clock_sys1 17>;
-		};
-
-		gpio4: gpio@800300 {
-			compatible = "lantiq,falcon-gpio";
-			gpio-controller;
-			#gpio-cells = <2>;
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			interrupt-parent = <&icu0>;
-			interrupts = <48>;
-			reg = <0x800300 0x100>;
-			clocks = <&clock_sys1 18>;
-		};
-
-		pad@800400 {
-			compatible = "lantiq,pad-falcon";
-			reg = <0x800400 0x100>;
-			lantiq,bank = <1>;
-			clocks = <&clock_sys1 20>;
-		};
-
-		pad@800500 {
-			compatible = "lantiq,pad-falcon";
-			reg = <0x800500 0x100>;
-			lantiq,bank = <3>;
-			clocks = <&clock_sys1 21>;
-		};
-
-		pad@800600 {
-			compatible = "lantiq,pad-falcon";
-			reg = <0x800600 0x100>;
-			lantiq,bank = <4>;
-			clocks = <&clock_sys1 22>;
-		};
-
-		status@802000 {
-			compatible = "lantiq,status-falcon";
-			reg = <0x802000 0x80>;
-		};
-
-		clock_sys1: clock-controller@F00000 {
-			compatible = "lantiq,sys1-falcon";
-			reg = <0xF00000 0x100>;
-			#clock-cells = <1>;
-		};
-	};
-
-	sbs0@1F000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "simple-bus";
-		reg = <0x1F000000 0x400000>;
-		ranges = <0x0 0x1F000000 0x400000>;
-
-		mpsmbx: mpsmbx@200000 {
-			reg = <0x200000 0x200>;
-		};
-	};
-
-	sbs1@1F700000 {
-
-	};
-
-	biu@1F800000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,biu", "simple-bus";
-		reg = <0x1F800000 0x800000>;
-		ranges = <0x0 0x1F800000 0x800000>;
-
-		icu0: icu@80200 {
-			#interrupt-cells = <1>;
-			interrupt-controller;
-			compatible = "lantiq,icu";
-			reg = <0x80200 0x28
-				0x80228 0x28
-				0x80250 0x28
-				0x80278 0x28
-				0x802a0 0x28>;
-		};
-
-		watchdog@803F0 {
-			compatible = "lantiq,wdt";
-			reg = <0x803F0 0x10>;
-			clocks = <&io_clk>; /* currently no effect */
-		};
-	};
-
-	pinctrl {
-		compatible = "lantiq,pinctrl-falcon";
-		pinctrl-names = "default";
-		pinctrl-0 = <&state_default>;
-
-		state_default: pinctrl0 {
-			/*ntr {
-				lantiq,groups = "ntr8k";
-				lantiq,function = "ntr";
-			};*/
-			hrst {
-				lantiq,groups = "hrst";
-				lantiq,function = "rst";
-			};
-		};
-
-		asc0_pins: asc0 {
-			asc0 {
-				lantiq,groups = "asc0";
-				lantiq,function = "asc";
-			};
-		};
-		asc1_pins: asc1 {
-			asc1 {
-				lantiq,groups = "asc1";
-				lantiq,function = "asc";
-			};
-		};
-		i2c_pins: i2c {
-			i2c {
-				lantiq,groups = "i2c";
-				lantiq,function = "i2c";
-			};
-		};
-		bootled_pins: bootled {
-			bootled {
-				lantiq,groups = "bootled";
-				lantiq,function = "led";
-			};
-		};
-		ntr_ntr8k: ntr8k {
-			ntr8k {
-				lantiq,groups = "ntr8k";
-				lantiq,function = "ntr";
-			};
-		};
-		ntr_pps: pps {
-			pps {
-				lantiq,groups = "pps";
-				lantiq,function = "ntr";
-			};
-		};
-		ntr_gpio: gpio {
-			gpio {
-				lantiq,pins = "io5";
-				lantiq,mux = <1>;
-				lantiq,output = <0>;
-			};
-		};
-		slic_pins: slic {
-			slic {
-				lantiq,groups = "slic";
-				lantiq,function = "slic";
-			};
-		};
-	};
-
-	pinselect-ntr {
-		compatible = "lantiq,onu-ntr","lantiq,pinselect-ntr";
-		pinctrl-names = "ntr8k", "pps", "gpio";
-		pinctrl-0 = <&ntr_ntr8k>;
-		pinctrl-1 = <&ntr_pps>;
-		pinctrl-2 = <&ntr_gpio>;
-	};
-
-	pinselect-asc1 {
-		compatible = "lantiq,onu-asc1","lantiq,pinselect-asc1";
-		pinctrl-names = "default", "asc1";
-		pinctrl-0 = <&slic_pins>;
-		pinctrl-1 = <&asc1_pins>;
-	};
-
-};
diff --git a/target/linux/lantiq/dts/vr9.dtsi b/target/linux/lantiq/dts/vr9.dtsi
deleted file mode 100644
index bdb12701eb..0000000000
--- a/target/linux/lantiq/dts/vr9.dtsi
+++ /dev/null
@@ -1,192 +0,0 @@
-/ {
-	#address-cells = <1>;
-	#size-cells = <1>;
-	compatible = "lantiq,xway", "lantiq,vr9";
-
-	cpus {
-		cpu@0 {
-			compatible = "mips,mips34Kc";
-		};
-	};
-
-	memory@0 {
-		device_type = "memory";
-	};
-
-	biu@1F800000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,biu", "simple-bus";
-		reg = <0x1F800000 0x800000>;
-		ranges = <0x0 0x1F800000 0x7FFFFF>;
-
-		icu0: icu@80200 {
-			#interrupt-cells = <1>;
-			interrupt-controller;
-			compatible = "lantiq,icu";
-			reg = <0x80200 0x28
-				0x80228 0x28
-				0x80250 0x28
-				0x80278 0x28
-				0x802a0 0x28>;
-		};
-
-		watchdog@803F0 {
-			compatible = "lantiq,wdt";
-			reg = <0x803F0 0x10>;
-		};
-	};
-
-	sram@1F000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,sram", "simple-bus";
-		reg = <0x1F000000 0x800000>;
-		ranges = <0x0 0x1F000000 0x7FFFFF>;
-
-		eiu0: eiu@101000 {
-			#interrupt-cells = <1>;
-			interrupt-controller;
-			compatible = "lantiq,eiu-xway";
-			reg = <0x101000 0x1000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <166 135 66 40 41 42>;
-		};
-
-		pmu0: pmu@102000 {
-			compatible = "lantiq,pmu-xway";
-			reg = <0x102000 0x1000>;
-		};
-
-		cgu0: cgu@103000 {
-			compatible = "lantiq,cgu-xway";
-			reg = <0x103000 0x1000>;
-		};
-
-		dcdc@106a00 {
-			compatible = "lantiq,dcdc-xrx200";
-			reg = <0x106a00 0x200>;
-		};
-
-		rcu0: rcu@203000 {
-			compatible = "lantiq,rcu-xrx200";
-			reg = <0x203000 0x1000>;
-			/* irq for thermal sensor */
-			interrupt-parent = <&icu0>;
-			interrupts = <115>;
-		};
-	};
-
-	fpi@10000000 {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "lantiq,fpi", "simple-bus";
-		ranges = <0x0 0x10000000 0xEEFFFFF>;
-		reg = <0x10000000 0xEF00000>;
-
-		localbus@0 {
-			#address-cells = <2>;
-			#size-cells = <1>;
-			ranges = <0 0 0x0 0x3ffffff /* addrsel0 */
-				1 0 0x4000000 0x4000010>; /* addsel1 */
-			compatible = "lantiq,localbus", "simple-bus";
-		};
-
-		gptu@E100A00 {
-			compatible = "lantiq,gptu-xway";
-			reg = <0xE100A00 0x100>;
-			interrupt-parent = <&icu0>;
-                        interrupts = <126 127 128 129 130 131>;
-		};
-
-		asc0: serial@E100400 {
-			compatible = "lantiq,asc";
-			reg = <0xE100400 0x400>;
-			interrupt-parent = <&icu0>;
-			interrupts = <104 105 106>;
-			status = "disabled";
-		};
-
-		gpio: pinmux@E100B10 {
-			compatible = "lantiq,pinctrl-xr9";
-			#gpio-cells = <2>;
-			gpio-controller;
-			reg = <0xE100B10 0xA0>;
-		};
-
-		asc1: serial@E100C00 {
-			compatible = "lantiq,asc";
-			reg = <0xE100C00 0x400>;
-			interrupt-parent = <&icu0>;
-			interrupts = <112 113 114>;
-		};
-
-		deu@E103100 {
-			compatible = "lantiq,deu-xrx200";
-			reg = <0xE103100 0xf00>;
-		};
-
-		dma0: dma@E104100 {
-			compatible = "lantiq,dma-xway";
-			reg = <0xE104100 0x800>;
-		};
-
-		ebu0: ebu@E105300 {
-			compatible = "lantiq,ebu-xway";
-			reg = <0xE105300 0x100>;
-		};
-
-		ifxhcd@E101000 {
-			status = "disabled";
-			compatible = "lantiq,ifxhcd-xrx200", "lantiq,ifxhcd-xrx200-dwc2";
-			reg = <0xE101000 0x1000
-				0xE120000 0x3f000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <62 91>;
-		};
-
-		ifxhcd@E106000 {
-			status = "disabled";
-			compatible = "lantiq,ifxhcd-xrx200-dwc2";
-			reg = <0xE106000 0x1000>;
-			interrupt-parent = <&icu0>;
-			interrupts = <91>;
-		};
-
-		mei@E116000 {
-			compatible = "lantiq,mei-xrx200";
-			interrupt-parent = <&icu0>;
-			interrupts = <63>;
-		};
-
-		ppe@E234000 {
-			compatible = "lantiq,ppe-xrx200";
-			interrupt-parent = <&icu0>;
-			interrupts = <96>;
-		};
-
-		pcie@d900000 {
-			interrupt-parent = <&icu0>;
-			interrupts = <161 144>;
-			compatible = "lantiq,pcie-xrx200";
-		};
-
-		pci0: pci@E105400 {
-			#address-cells = <3>;
-			#size-cells = <2>;
-			#interrupt-cells = <1>;
-			compatible = "lantiq,pci-xway";
-			bus-range = <0x0 0x0>;
-			ranges = <0x2000000 0 0x8000000 0x8000000 0 0x2000000   /* pci memory */
-				0x1000000 0 0x00000000 0xAE00000 0 0x200000>; /* io space */
-			reg = <0x7000000 0x8000         /* config space */
-				0xE105400 0x400>;       /* pci bridge */
-			status = "disabled";
-		};
-
-	};
-
-	vdsl {
-		compatible = "lantiq,vdsl-vrx200";
-	};
-};
diff --git a/target/linux/lantiq/falcon/config-default b/target/linux/lantiq/falcon/config-default
deleted file mode 100644
index 99eb695a0c..0000000000
--- a/target/linux/lantiq/falcon/config-default
+++ /dev/null
@@ -1,42 +0,0 @@
-# CONFIG_ARCH_HAS_SG_CHAIN is not set
-CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
-CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
-CONFIG_CLONE_BACKWARDS=y
-CONFIG_CPU_NEEDS_NO_SMARTMIPS_OR_MICROMIPS=y
-CONFIG_CPU_SUPPORTS_MSA=y
-CONFIG_GPIO_DEVRES=y
-CONFIG_GPIO_FALCON=y
-CONFIG_GPIO_GENERIC=y
-CONFIG_HAS_IOPORT_MAP=y
-# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
-CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
-CONFIG_HAVE_ARCH_TRACEHOOK=y
-# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
-CONFIG_HAVE_BPF_JIT=y
-CONFIG_HAVE_CC_STACKPROTECTOR=y
-CONFIG_HAVE_CONTEXT_TRACKING=y
-CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
-CONFIG_HAVE_DMA_CONTIGUOUS=y
-CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
-CONFIG_HZ_PERIODIC=y
-CONFIG_IRQCHIP=y
-CONFIG_IRQ_DOMAIN_DEBUG=y
-CONFIG_IRQ_WORK=y
-CONFIG_LIBFDT=y
-CONFIG_MTD_NAND=y
-CONFIG_MTD_NAND_ECC=y
-CONFIG_MTD_NAND_PLATFORM=y
-CONFIG_MTD_SPLIT_FIRMWARE_NAME="linux"
-# CONFIG_MTD_SPLIT_SQUASHFS_ROOT is not set
-# CONFIG_NO_IOPORT_MAP is not set
-CONFIG_PINCTRL_FALCON=y
-# CONFIG_PSB6970_PHY is not set
-# CONFIG_RCU_STALL_COMMON is not set
-# CONFIG_RTL8366_SMI is not set
-CONFIG_SOC_FALCON=y
-# CONFIG_SOC_TYPE_XWAY is not set
-# CONFIG_SOC_XWAY is not set
-CONFIG_SPI=y
-CONFIG_SPI_FALCON=y
-CONFIG_SPI_MASTER=y
-CONFIG_SYS_SUPPORTS_MIPS16=y
diff --git a/target/linux/lantiq/falcon/profiles/all.mk b/target/linux/lantiq/falcon/profiles/all.mk
deleted file mode 100644
index 45d70943d5..0000000000
--- a/target/linux/lantiq/falcon/profiles/all.mk
+++ /dev/null
@@ -1,41 +0,0 @@
-
-PACKAGES_GENERIC:= \
-	kmod-dm9000-nfs \
-	kmod-i2c-core kmod-i2c-lantiq kmod-eeprom-at24
-
-define Profile/Generic
-  NAME:=All Boards
-  PACKAGES:= $(PACKAGES_GENERIC)
-  SUBPROFILES:= EASY98000 EASY98000NOR EASY98000SFLASH EASY98000NAND \
-	EASY98020 EASY98020V18 EASY98021 SFP MDU EASY88388
-endef
-
-$(eval $(call Profile,Generic))
-
-
-define Profile/EASY98000/Template
-  NAME:=EASY98000 - Lantiq Falcon Eval Board ($(1))
-  PACKAGES:= $(PACKAGES_GENERIC)
-endef
-
-
-define Profile/EASY98000
-  $(call Profile/EASY98000/Template,NOR)
-  DTS:=EASY98000NOR
-endef
-
-$(eval $(call Profile,EASY98000))
-
-
-define Profile/EASY98000NAND
-  $(call Profile/EASY98000/Template,NAND)
-endef
-
-$(eval $(call Profile,EASY98000NAND))
-
-
-define Profile/EASY98000SFLASH
-  $(call Profile/EASY98000/Template,SFLASH)
-endef
-
-$(eval $(call Profile,EASY98000SFLASH))
diff --git a/target/linux/lantiq/falcon/profiles/fttdp.mk b/target/linux/lantiq/falcon/profiles/fttdp.mk
deleted file mode 100644
index 4f09f51940..0000000000
--- a/target/linux/lantiq/falcon/profiles/fttdp.mk
+++ /dev/null
@@ -1,23 +0,0 @@
-
-define Profile/FTTDP
-  NAME:=All FTTDP Boards
-  SUBPROFILES:=MDU EASY88388 EASY98000
-endef
-
-$(eval $(call Profile,FTTDP))
-
-
-define Profile/MDU
-  NAME:=MDU - Lantiq Falcon / VINAXdp MDU Board
-  DTS:=FALCON-MDU
-endef
-
-$(eval $(call Profile,MDU))
-
-
-define Profile/EASY88388
-  NAME:=EASY88388 - Lantiq Falcon FTTDP8 Reference Board
-endef
-
-$(eval $(call Profile,EASY88388))
-
diff --git a/target/linux/lantiq/falcon/profiles/sfp.mk b/target/linux/lantiq/falcon/profiles/sfp.mk
deleted file mode 100644
index 29009b9c60..0000000000
--- a/target/linux/lantiq/falcon/profiles/sfp.mk
+++ /dev/null
@@ -1,8 +0,0 @@
-
-define Profile/SFP
-  NAME:=SFP - Lantiq Falcon SFP Stick
-  PACKAGES:= gpon-sfp-i2c-drv gpon-sfp-i2c-drv-linux kmod-gpon-sfp-i2c-drv
-  DTS:=FALCON-SFP
-endef
-
-$(eval $(call Profile,SFP))
diff --git a/target/linux/lantiq/falcon/profiles/sfu-hgu.mk b/target/linux/lantiq/falcon/profiles/sfu-hgu.mk
deleted file mode 100644
index 82c3ed5e0d..0000000000
--- a/target/linux/lantiq/falcon/profiles/sfu-hgu.mk
+++ /dev/null
@@ -1,20 +0,0 @@
-
-define Profile/EASY98020
-  NAME:=EASY98020 - Lantiq Falcon SFU Reference Board
-endef
-
-$(eval $(call Profile,EASY98020))
-
-
-define Profile/EASY98020V18
-  NAME:=EASY98020V18 - Lantiq Falcon SFU Reference Board V1.8
-endef
-
-$(eval $(call Profile,EASY98020V18))
-
-
-define Profile/EASY98021
-  NAME:=EASY98021 - Lantiq Falcon HGU Reference Board
-endef
-
-$(eval $(call Profile,EASY98021))
diff --git a/target/linux/lantiq/falcon/target.mk b/target/linux/lantiq/falcon/target.mk
deleted file mode 100644
index 229936e929..0000000000
--- a/target/linux/lantiq/falcon/target.mk
+++ /dev/null
@@ -1,15 +0,0 @@
-ARCH:=mips
-SUBTARGET:=falcon
-BOARDNAME:=Falcon
-FEATURES:=squashfs mips16 jffs2
-CPU_TYPE:=34kc
-CPU_SUBTYPE:=dsp 
-DEVICE_TYPE:=other
-
-DEFAULT_PACKAGES+= kmod-ifxos gpon-base-files kmod-leds-gpio kmod-ledtrig-heartbeat \
-	kmod-gpon-optic-drv gpon-optic-drv kmod-gpon-onu-drv gpon-onu-drv \
-	gpon-pe-firmware gpon-omci-api gpon-omci-onu gpon-luci gpon-dti-agent
-
-define Target/Description
-	Lantiq Falcon
-endef
diff --git a/target/linux/lantiq/files/firmware/lantiq/vr9_phy11g_a1x.bin b/target/linux/lantiq/files/firmware/lantiq/vr9_phy11g_a1x.bin
deleted file mode 100644
index cdf3d3063405c1239d15bae873e11f4ad8644e0f..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 65536
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

diff --git a/target/linux/lantiq/files/firmware/lantiq/vr9_phy11g_a2x.bin b/target/linux/lantiq/files/firmware/lantiq/vr9_phy11g_a2x.bin
deleted file mode 100644
index 44fc39ef06458bd554034cbc9a90e7df2f132414..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 65536
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

diff --git a/target/linux/lantiq/files/firmware/lantiq/vr9_phy22f_a1x.bin b/target/linux/lantiq/files/firmware/lantiq/vr9_phy22f_a1x.bin
deleted file mode 100644
index 02b88a078b85fbf73a4e0540ada7d49ea6287cd3..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 65536
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
TC6JatS^{Yaq$TiwrUd>s+;lNd

diff --git a/target/linux/lantiq/files/firmware/lantiq/vr9_phy22f_a2x.bin b/target/linux/lantiq/files/firmware/lantiq/vr9_phy22f_a2x.bin
deleted file mode 100644
index 1fed6ad65e2b6895f21e1ad81b1ef26b13edabff..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 65536
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

diff --git a/target/linux/lantiq/image/Makefile b/target/linux/lantiq/image/Makefile
deleted file mode 100644
index 60e0c3aaf6..0000000000
--- a/target/linux/lantiq/image/Makefile
+++ /dev/null
@@ -1,510 +0,0 @@
-#
-# Copyright (C) 2010-2012 OpenWrt.org
-#
-# This is free software, licensed under the GNU General Public License v2.
-# See /LICENSE for more information.
-#
-
-# boards missing since devicetree update
-#EASY50712 ARV3527P
-
-include $(TOPDIR)/rules.mk
-
-ifndef Profile
-define Profile
-  SUBPROFILES:=
-  DTS:=
-  $(eval $(call Profile/$(1)))
-  ALL_PROFILES += $(1)
-  ifneq ($(DTS),)
-    DTS_$(1):=$(DTS)
-  endif
-  ifneq ($(SUBPROFILES),)
-    SUBPROFILES_$(1):=$(SUBPROFILES)
-  endif
-
-  ifeq ($(CONFIG_TARGET_$(call target_conf,$(BOARD)_$(if $(SUBTARGET),$(SUBTARGET)_))$(1)),y)
-    PROFILE=$(1)
-  endif
-endef
-endif
-
-include $(INCLUDE_DIR)/image.mk
-include $(INCLUDE_DIR)/version.mk
-
-JFFS2_BLOCKSIZE = 64k 128k 256k
-KDIR_TMP:=$(KDIR)/tmp
-
-LOADER_MAKE := $(NO_TRACE_MAKE) -C lzma-loader KDIR=$(KDIR)
-
-IMAGE_NAME_DEFAULT:='MIPS OpenWrt Linux-$(LINUX_VERSION)'
-
-IMAGE_NAME:=$(if $(VERSION_IMAGE_SED),$(VERSION_IMAGE_SED),$(IMAGE_NAME_DEFAULT))
-
-define Image/BuildLoader/Template
-	-rm -rf $(KDIR)/lzma-loader
-	$(LOADER_MAKE) LOADER=loader$(2)-$(1).bin\
-		LZMA_TEXT_START=0x80a00000 \
-		LOADADDR=0x80002000 \
-		LOADER_DATA="$(KDIR)/vmlinux$(2)-$(1).lzma" BOARD="$(1)" \
-		compile loader.bin
-endef
-
-
-define CompressLzma
-	$(STAGING_DIR_HOST)/bin/lzma e $(1) $(2)
-endef
-
-define PatchKernelLzma
-	cp $(KDIR)/vmlinux$(2) $(KDIR)/vmlinux$(2)-$(1)
-	$(LINUX_DIR)/scripts/dtc/dtc -O dtb -o $(KDIR)/$(1).dtb ../dts/$(if $(3),$(3),$(1)).dts
-	$(STAGING_DIR_HOST)/bin/patch-dtb $(KDIR)/vmlinux$(2)-$(1) $(KDIR)/$(1).dtb
-	$(call CompressLzma,$(KDIR)/vmlinux$(2)-$(1),$(KDIR)/vmlinux$(2)-$(1).lzma)
-endef
-
-define MkBrnImage
-	mkbrncmdline -i $(KDIR)/vmlinux-$(5) -o $(KDIR)/vmlinux-$(5)-brn BRN-BOOT $(7)
-	$(call CompressLzma,$(KDIR)/vmlinux-$(5)-brn,$(KDIR)/vmlinux-$(5)-brn.lzma)
-	mkbrnimg -s $(1) -m $(2) -p $(3) -o $(4) $(KDIR)/vmlinux-$(5)-brn.lzma $(KDIR)/root.$(6)
-endef
-
-define MkImageLzma
-	mkimage -A mips -O linux -T kernel -a 0x80002000 -C lzma \
-		-e 0x80002000 -n $(IMAGE_NAME) \
-		-d $(KDIR)/vmlinux$(2)-$(1).lzma $(KDIR)/uImage-$(1)$(2)
-endef
-
-define TPLinkImageLzma
-	mktplinkfw2 -c -B $(2) -s \
-		-k $(KDIR)/vmlinux$(3)-$(1).lzma -o $(KDIR)/uImage-$(1)$(3)
-endef
-
-define MkImageEVA
-	lzma2eva 0x80002000 0x80002000 $(KDIR)/vmlinux$(2)-$(1).lzma $(KDIR)/$(1)$(2).eva.prealign
-	dd if=$(KDIR)/$(1)$(2).eva.prealign of=$(KDIR)/$(1)$(2).eva.align.64k bs=64k conv=sync
-	dd if=$(KDIR)/$(1)$(2).eva.prealign of=$(KDIR)/$(1)$(2).eva.align.128k bs=128k conv=sync
-	cat ./eva.dummy.squashfs >> $(KDIR)/$(1)$(2).eva.align.64k
-endef
-
-define CompressGzip
-	gzip -c $(1) > $(2)
-endef
-
-define PatchKernelGzip
-	cp $(KDIR)/vmlinux$(3) $(KDIR)/vmlinux$(3)-$(1)
-	$(STAGING_DIR_HOST)/bin/patch-cmdline $(KDIR)/vmlinux$(3)-$(1) '$(strip $(2))'
-	$(call CompressGzip,$(KDIR)/vmlinux$(3)-$(1),$(KDIR)/vmlinux$(3)-$(1).gzip)
-endef
-
-define MkImageGzip
-	mkimage -A mips -O linux -T kernel -a 0x80002000 -C gzip \
-		-e 0x80002000 -n $(IMAGE_NAME) \
-		-d $(KDIR)/vmlinux$(2)-$(1).gzip $(KDIR)/uImage-$(1)$(2)
-endef
-
-define Image/Build/squashfs
-	# FIXME: leave this line to allow foreach loops
-	cat $(KDIR)/uImage-$(2) $(KDIR)/root.$(1) > $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1).image
-	$(call prepare_generic_squashfs,$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1).image)
-	$(if $(3),$(call MkBrnImage,$(3),$(4),$(5),$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(3)-brnImage,$(2),$(1),$(6)))
-endef
-
-define Image/BuildNAND/squashfs
-
-ifneq ($($(PROFILE)_UBI_OPTS),)
-	$(call prepare_generic_squashfs,$(KDIR)/root.$(1))
-	$(call Image/Build/UbinizeImage,$(PROFILE),,squashfs,$($(PROFILE)_UBI_OPTS))
-	$(call Image/Build/SysupgradeNAND,$(PROFILE),$(1),$(KDIR)/uImage-$(PROFILE))
-endif
-endef
-
-DGN3500_SKERNEL=0x50000
-DGN3500_SKERNEL_DECIMAL=327680
-define Image/BuildDGN3500/squashfs
-	dd if=/dev/zero of=$(BIN_DIR)/$(IMG_PREFIX)-pad bs=$(DGN3500_SKERNEL_DECIMAL) count=1
-	cat $(BIN_DIR)/$(IMG_PREFIX)-pad $(KDIR)/uImage-$(2) $(KDIR)/root.$(1) > $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepad.img
-	rm -r $(BIN_DIR)/$(IMG_PREFIX)-pad
-	dd if=/dev/zero ibs=16M count=1 | tr "\000" "\377" > $(BIN_DIR)/$(IMG_PREFIX)-pwf
-	cp $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepad.img $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepadNA.img
-	dgn3500sum $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepadNA.img $(DGN3500_SKERNEL) NA
-	$(call prepare_generic_squashfs,$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepadNA.img)
-	cp $(BIN_DIR)/$(IMG_PREFIX)-pwf $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-NA.img
-	dd if=$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepadNA.img of=$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-NA.img conv=notrunc
-	dd if=$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepadNA.img of=$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-sysupgrade-NA.image bs=$(DGN3500_SKERNEL_DECIMAL) skip=1
-	rm -r $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepadNA.img
-	mv $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepad.img $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepadWW.img
-	dgn3500sum $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepadWW.img $(DGN3500_SKERNEL) WW
-	$(call prepare_generic_squashfs,$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepadWW.img)
-	mv $(BIN_DIR)/$(IMG_PREFIX)-pwf $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-WW.img
-	dd if=$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepadWW.img of=$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-WW.img conv=notrunc
-	dd if=$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepadWW.img of=$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-sysupgrade-WW.image bs=$(DGN3500_SKERNEL_DECIMAL) skip=1
-	rm -r $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepadWW.img
-endef
-
-define Image/BuildDGN3500B/squashfs
-	dd if=/dev/zero of=$(BIN_DIR)/$(IMG_PREFIX)-pad bs=327680 count=1
-	cat $(BIN_DIR)/$(IMG_PREFIX)-pad $(KDIR)/uImage-$(2) $(KDIR)/root.$(1) > $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepad.img
-	rm -r $(BIN_DIR)/$(IMG_PREFIX)-pad
-	dd if=/dev/zero ibs=16M count=1 | tr "\000" "\377" > $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory.img
-	dgn3500sum $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepad.img $(DGN3500_SKERNEL) DE
-	$(call prepare_generic_squashfs,$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepad.img)
-	dd if=$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepad.img of=$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory.img conv=notrunc
-	dd if=$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepad.img of=$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-sysupgrade.image bs=$(DGN3500_SKERNEL_DECIMAL) skip=1
-	rm -r $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-factory-prepad.img
-	dgn3500sum $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1)-sysupgrade.image $(DGN3500_SKERNEL) DE
-endef
-
-
-define Image/BuildTPLink/squashfs
-	mktplinkfw2 -B $(3) -s -a 0x4 -j \
-		-k $(KDIR)/vmlinux-$(2).lzma -r $(KDIR)/root.$(1) \
-		-o $(BIN_DIR)/$(IMG_PREFIX)-$(2)-sysupgrade.image
-endef
-
-define Image/BuildEVA/squashfs
-	cat $(KDIR)/$(2).eva.align.64k $(KDIR)/root.$(1) > $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1).image.eva
-	$(call prepare_generic_squashfs,$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1).image.eva)
-endef
-
-define Image/BuildEVA/ubifs
-
-ifneq ($($(PROFILE)_UBIFS_OPTS),)
-	$(CP) $(KDIR)/root.ubifs $(BIN_DIR)/$(IMG_PREFIX)-$(PROFILE)-rootfs.ubifs
-endif
-endef
-
-define Image/BuildEVA/ubi
-
-ifneq ($($(PROFILE)_UBI_OPTS),)
-	$(CP) $(KDIR)/root.ubi $(BIN_DIR)/$(IMG_PREFIX)-$(PROFILE)-rootfs.ubi
-	$(CP) $(KDIR)/root-overlay.ubi $(BIN_DIR)/$(IMG_PREFIX)-$(PROFILE)-rootfs-overlay.ubi
-endif
-endef
-
-define Image/BuildLoader/squashfs
-	dd if=$(KDIR)/loader-$(2).bin of=$(KDIR)/loader-$(2).bin.padded bs=3072k conv=sync
-	cat $(KDIR)/loader-$(2).bin.padded $(KDIR)/root.$(1) > $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1).image
-	$(call prepare_generic_squashfs,$(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1).image)
-endef
-
-define Image/BuildEVA/jffs2-128k
-	cat $(KDIR)/$(2).eva.align.128k $(KDIR)/root.$(1) > $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1).image.eva
-endef
-
-define Image/Build/jffs2-64k
-	# FIXME: leave this line to allow foreach loops
-	dd if=$(KDIR)/uImage-$(2) of=$(KDIR)/uImage-$(2)-$(1) bs=64k conv=sync
-	cat $(KDIR)/uImage-$(2)-$(1) $(KDIR)/root.$(1) > $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1).image
-endef
-
-define Image/Build/jffs2-128k
-	# FIXME: leave this line to allow foreach loops
-	dd if=$(KDIR)/uImage-$(2) of=$(KDIR)/uImage-$(2)-$(1) bs=128k conv=sync
-	cat $(KDIR)/uImage-$(2)-$(1) $(KDIR)/root.$(1) > $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1).image
-endef
-
-define Image/Build/jffs2-256k
-	# FIXME: leave this line to allow foreach loops
-	dd if=$(KDIR)/uImage-$(2) of=$(KDIR)/uImage-$(2)-$(1) bs=256k conv=sync
-	cat $(KDIR)/uImage-$(2)-$(1) $(KDIR)/root.$(1) > $(BIN_DIR)/$(IMG_PREFIX)-$(2)-$(1).image
-endef
-
-define Image/Build/ubifs
-	# FIXME: leave this line to allow foreach loops
-ifneq ($($(PROFILE)_UBIFS_OPTS),)
-	$(CP) $(KDIR)/root.ubifs $(BIN_DIR)/$(IMG_PREFIX)-$(PROFILE)-rootfs.ubifs
-endif
-endef
-
-define Image/Build/ubi
-	# FIXME: leave this line to allow foreach loops
-ifneq ($($(PROFILE)_UBI_OPTS),)
-	$(CP) $(KDIR)/root.ubi $(BIN_DIR)/$(IMG_PREFIX)-$(PROFILE)-rootfs.ubi
-	$(CP) $(KDIR)/root-overlay.ubi $(BIN_DIR)/$(IMG_PREFIX)-$(PROFILE)-rootfs-overlay.ubi
-endif
-endef
-
-
-define Image/BuildNAND/ubifs
-
-ifneq ($($(PROFILE)_UBIFS_OPTS),)
-ifneq ($($(PROFILE)_UBI_OPTS),)
-	$(call Image/Build/UbinizeImage,$(PROFILE),,ubifs,$($(PROFILE)_UBI_OPTS))
-	$(call Image/Build/SysupgradeNAND,$(PROFILE),$(1),$(KDIR)/uImage-$(PROFILE))
-endif
-endif
-endef
-
-
-define Image/InstallKernel/Template
-	# FIXME: leave this line to allow foreach loops
-ifneq ($(CONFIG_TARGET_ROOTFS_INCLUDE_KERNEL),)
-	$(INSTALL_DIR) $(TARGET_DIR)/boot
-
-ifneq ($(CONFIG_TARGET_ROOTFS_INCLUDE_UIMAGE),)
-	$(CP) $(BIN_DIR)/$(IMG_PREFIX)-$(1)-uImage $(TARGET_DIR)/boot/
-	ln -sf $(IMG_PREFIX)-$(1)-uImage $(TARGET_DIR)/boot/uImage
-endif
-
-ifneq ($(CONFIG_TARGET_ROOTFS_INCLUDE_ZIMAGE),)
-	$(CP) $(BIN_DIR)/$(IMG_PREFIX)-$(1)-zImage $(TARGET_DIR)/boot/
-	ln -sf $(IMG_PREFIX)-$(1)-zImage $(TARGET_DIR)/boot/zImage
-endif
-endif
-
-ifneq ($(CONFIG_TARGET_ROOTFS_INCLUDE_DTB),)
-	$(INSTALL_DIR) $(TARGET_DIR)/boot
-
-ifneq ($(1),)
-	$(CP) $(KDIR)/$(1).dtb $(TARGET_DIR)/boot/
-endif
-endif
-endef
-
-define Image/BuildKernel/Template
-	# FIXME: leave this line to allow foreach loops
-	$(call PatchKernelLzma,$(1),,$(if $(DTS_$(1)),$(DTS_$(1))))
-	$(call MkImageLzma,$(1))
-	$(CP) $(KDIR)/uImage-$(1) $(BIN_DIR)/$(IMG_PREFIX)-$(1)-uImage
-ifneq ($(CONFIG_TARGET_ROOTFS_INITRAMFS),)
-	$(call PatchKernelLzma,$(1),-initramfs,$(if $(DTS_$(1)),$(DTS_$(1))))
-	$(call MkImageLzma,$(1),-initramfs)
-	$(CP) $(KDIR)/uImage-$(1)-initramfs $(BIN_DIR)/$(IMG_PREFIX)-$(1)-uImage-initramfs
-endif
-endef
-
-define Image/BuildKernelLoader/Template
-	$(CP) $(KDIR)/loader-$(1).bin $(BIN_DIR)/$(IMG_PREFIX)-$(1)-vmlinux-loader
-	$(CP) $(KDIR)/vmlinux-$(1) $(BIN_DIR)/$(IMG_PREFIX)-$(1)-vmlinux
-ifneq ($(CONFIG_TARGET_ROOTFS_INITRAMFS),)
-	$(CP) $(KDIR)/loader-initramfs-$(1).bin $(BIN_DIR)/$(IMG_PREFIX)-$(1)-vmlinux-initramfs-loader
-	$(CP) $(KDIR)/vmlinux-initramfs-$(1) $(BIN_DIR)/$(IMG_PREFIX)-$(1)-vmlinux-initramfs
-endif
-endef
-
-define Image/Prepare/Profile
-	$(call PatchKernelLzma,$(1))
-	$(call Image/BuildLoader/Template,$(1))
-ifneq ($(CONFIG_TARGET_ROOTFS_INITRAMFS),)
-	$(call PatchKernelLzma,$(1),-initramfs)
-	$(call Image/BuildLoader/Template,$(1),-initramfs)
-endif
-endef
-
-define Image/BuildKernelTPLink/Template
-	$(call PatchKernelLzma,$(1))
-	$(call TPLinkImageLzma,$(1),$(2))
-	$(CP) $(KDIR)/uImage-$(1) $(BIN_DIR)/$(IMG_PREFIX)-$(1)-uImage
-ifneq ($(CONFIG_TARGET_ROOTFS_INITRAMFS),)
-	$(call PatchKernelLzma,$(1),-initramfs)
-	$(call TPLinkImageLzma,$(1),$(2),-initramfs)
-	$(CP) $(KDIR)/uImage-$(1)-initramfs $(BIN_DIR)/$(IMG_PREFIX)-$(1)-uImage-initramfs
-endif
-endef
-
-define Image/BuildKernelEVA/Template
-	$(call PatchKernelLzma,$(1))
-	$(call MkImageEVA,$(1))
-	$(CP) $(KDIR)/$(1).eva.align.64k $(BIN_DIR)/$(IMG_PREFIX)-$(1).eva.align.64k
-	$(CP) $(KDIR)/$(1).eva.align.128k $(BIN_DIR)/$(IMG_PREFIX)-$(1).eva.align.128k
-ifneq ($(CONFIG_TARGET_ROOTFS_INITRAMFS),)
-	$(call PatchKernelLzma,$(1),-initramfs)
-	$(call MkImageEVA,$(1),-initramfs)
-	$(CP) $(KDIR)/$(1)-initramfs.eva.align.64k $(BIN_DIR)/$(IMG_PREFIX)-$(1)-initramfs.eva.align.64k
-	$(CP) $(KDIR)/$(1)-initramfs.eva.align.128k $(BIN_DIR)/$(IMG_PREFIX)-$(1)-initramfs.eva.align.128k
-endif
-endef
-
-define Image/BuildKernelGzip/Template
-	$(call PatchKernelGzip,$(1),$(if $(2),$(2) machtype=$(1),))
-	$(call MkImageGzip,$(1))
-	$(CP) $(KDIR)/uImage-$(1) $(BIN_DIR)/$(IMG_PREFIX)-$(1)-uImage
-ifneq ($(CONFIG_TARGET_ROOTFS_INITRAMFS),)
-	$(call PatchKernelGzip,$(1),$(if $(2),$(2) machtype=$(1),),-initramfs)
-	$(call MkImageGzip,$(1),-initramfs)
-	$(CP) $(KDIR)/uImage-$(1)-initramfs $(BIN_DIR)/$(IMG_PREFIX)-$(1)-uImage-initramfs
-endif
-endef
-
-
-ifeq ($(CONFIG_TARGET_lantiq_falcon),y)
-
-define Falcon/Template
-	Image/BuildKernel/Profile/$(1)=$$(call Image/BuildKernel/Template,$(1))
-	Image/Build/Profile/$(1)=$$(call Image/Build/$$(1),$$(1),$(1))
-endef
-
-$(foreach fb,$(ALL_PROFILES),$(eval $(call Falcon/Template,$(fb))) )
-
-endif
-
-
-ifeq ($(CONFIG_TARGET_lantiq_ase),y)
-
-Image/BuildKernel/Profile/DGN1000B=$(call Image/BuildKernel/Template,DGN1000B)
-Image/Build/Profile/DGN1000B=$(call Image/Build/$(1),$(1),DGN1000B)
-
-endif
-
-
-ifeq ($(CONFIG_TARGET_lantiq_xway),y)
-
-# Danube
-Image/BuildKernel/Profile/BTHOMEHUBV2B=$(call Image/BuildKernel/Template,BTHOMEHUBV2B)
-Image/Build/Profile/BTHOMEHUBV2B=$(call Image/BuildNAND/$(1),$(1),BTHOMEHUBV2B)
-
-Image/BuildKernel/Profile/EASY50712=$(call Image/BuildKernel/Template,EASY50712)
-Image/Build/Profile/EASY50712=$(call Image/Build/$(1),$(1),EASY50712)
-
-Image/BuildKernel/Profile/ACMP252=$(call Image/BuildKernel/Template,ACMP252)
-Image/Build/Profile/ACMP252=$(call Image/Build/$(1),$(1),ACMP252)
-
-Image/BuildKernel/Profile/ARV4510PW=$(call Image/BuildKernel/Template,ARV4510PW)
-Image/Build/Profile/ARV4510PW=$(call Image/Build/$(1),$(1),ARV4510PW)
-
-Image/BuildKernel/Profile/ARV4525PW=$(call Image/BuildKernel/Template,ARV4525PW)
-Image/Build/Profile/ARV4525PW=$(call Image/Build/$(1),$(1),ARV4525PW)
-
-Image/BuildKernel/Profile/ARV7525PW=$(call Image/BuildKernel/Template,ARV7525PW)
-Image/Build/Profile/ARV7525PW=$(call Image/Build/$(1),$(1),ARV7525PW)
-
-Image/BuildKernel/Profile/ARV4518PWR01=$(call Image/BuildKernel/Template,ARV4518PWR01)
-Image/Build/Profile/ARV4518PWR01=$(call Image/Build/$(1),$(1),ARV4518PWR01)
-
-Image/BuildKernel/Profile/ARV4518PWR01A=$(call Image/BuildKernel/Template,ARV4518PWR01A)
-Image/Build/Profile/ARV4518PWR01A=$(call Image/Build/$(1),$(1),ARV4518PWR01A)
-
-Image/BuildKernel/Profile/ARV4519PW=$(call Image/BuildKernel/Template,ARV4519PW)
-Image/Build/Profile/ARV4519PW=$(call Image/Build/$(1),$(1),ARV4519PW)
-
-Image/BuildKernel/Profile/ARV4520PW=$(call Image/BuildKernel/Template,ARV4520PW)
-Image/Build/Profile/ARV4520PW=$(call Image/Build/$(1),$(1),ARV4520PW)
-
-Image/BuildKernel/Profile/ARV452CQW=$(call Image/BuildKernel/Template,ARV452CQW)
-Image/Build/Profile/ARV452CQW=$(call Image/Build/$(1),$(1),ARV452CQW)
-
-Image/BuildKernel/Profile/ARV7510PW22=$(call Image/BuildKernel/Template,ARV7510PW22)
-Image/Build/Profile/ARV7510PW22=$(call Image/Build/$(1),$(1),ARV7510PW22)
-
-Image/BuildKernel/Profile/ARV7518PW=$(call Image/BuildKernel/Template,ARV7518PW)
-Image/Build/Profile/ARV7518PW=$(call Image/Build/$(1),$(1),ARV7518PW)
-
-Image/BuildKernel/Profile/ARV7519PW=$(call Image/BuildKernel/Template,ARV7519PW)
-Image/Build/Profile/ARV7519PW=$(call Image/Build/$(1),$(1),ARV7519PW)
-
-Image/BuildKernel/Profile/ARV752DPW=$(call Image/BuildKernel/Template,ARV752DPW)
-Image/Build/Profile/ARV752DPW=$(call Image/Build/$(1),$(1),ARV752DPW)
-
-Image/BuildKernel/Profile/ARV752DPW22=$(call Image/BuildKernel/Template,ARV752DPW22)
-Image/Build/Profile/ARV752DPW22=$(call Image/Build/$(1),$(1),ARV752DPW22)
-
-Image/BuildKernel/Profile/GIGASX76X=$(call Image/BuildKernel/Template,GIGASX76X)
-Image/Build/Profile/GIGASX76X=$(call Image/Build/$(1),$(1),GIGASX76X)
-
-
-# AR9
-Image/BuildKernel/Profile/BTHOMEHUBV3A=$(call Image/BuildKernel/Template,BTHOMEHUBV3A)
-Image/Build/Profile/BTHOMEHUBV3A=$(call Image/BuildNAND/$(1),$(1),BTHOMEHUBV3A)
-
-Image/BuildKernel/Profile/DGN3500=$(call Image/BuildKernel/Template,DGN3500)
-Image/Build/Profile/DGN3500=$(call Image/BuildDGN3500/$(1),$(1),DGN3500)
-
-Image/BuildKernel/Profile/DGN3500B=$(call Image/BuildKernel/Template,DGN3500B)
-Image/Build/Profile/DGN3500B=$(call Image/BuildDGN3500B/$(1),$(1),DGN3500B)
-
-Image/BuildKernel/Profile/WBMRA=$(call Image/BuildKernel/Template,WBMR)
-Image/Build/Profile/WBMRA=$(call Image/Build/$(1),$(1),WBMR)
-
-Image/BuildKernel/Profile/WBMRB=$(call Image/BuildKernel/Template,WBMR)
-Image/Build/Profile/WBMRB=$(call Image/Build/$(1),$(1),WBMR)
-
-Image/BuildKernel/Profile/FRITZ7320=$(call Image/BuildKernelEVA/Template,FRITZ7320)
-Image/Build/Profile/FRITZ7320=$(call Image/BuildEVA/$(1),$(1),FRITZ7320)
-
-Image/BuildKernel/Profile/GR7000=$(call Image/BuildKernel/Template,GR7000)
-Image/Build/Profile/GR7000=$(call Image/Build/$(1),$(1),GR7000)
-
-Image/BuildKernel/Profile/H201L=$(call Image/BuildKernel/Template,H201L)
-Image/Build/Profile/H201L=$(call Image/Build/$(1),$(1),H201L)
-
-Image/BuildKernel/Profile/P2601HNFX=$(call Image/BuildKernel/Template,P2601HNFX)
-Image/Build/Profile/P2601HNFX=$(call Image/Build/$(1),$(1),P2601HNFX)
-
-endif
-
-
-ifeq ($(CONFIG_TARGET_lantiq_xrx200),y)
-
-# VR9
-Image/BuildKernel/Profile/P2812HNUF1=$(call Image/BuildKernel/Template,P2812HNUF1)
-Image/Build/Profile/P2812HNUF1=$(call Image/BuildNAND/$(1),$(1),P2812HNUF1)
-
-Image/BuildKernel/Profile/P2812HNUF3=$(call Image/BuildKernel/Template,P2812HNUF3)
-Image/Build/Profile/P2812HNUF3=$(call Image/BuildNAND/$(1),$(1),P2812HNUF3)
-
-Image/BuildKernel/Profile/ARV7519RW22=$(call Image/BuildKernel/Template,ARV7519RW22,$(1))
-Image/Build/Profile/ARV7519RW22=$(call Image/Build/$(1),$(1),ARV7519RW22)
-
-Image/BuildKernel/Profile/EASY80920NAND=$(call Image/BuildKernel/Template,EASY80920NAND)
-Image/Build/Profile/EASY80920NAND=$(call Image/Build/$(1),$(1),EASY80920NAND)
-
-Image/BuildKernel/Profile/EASY80920NOR=$(call Image/BuildKernel/Template,EASY80920NOR)
-Image/Build/Profile/EASY80920NOR=$(call Image/Build/$(1),$(1),EASY80920NOR)
-
-Image/BuildKernel/Profile/FRITZ3370=$(call Image/BuildKernelEVA/Template,FRITZ3370)
-Image/Build/Profile/FRITZ3370=$(call Image/BuildEVA/$(1),$(1),FRITZ3370)
-
-Image/BuildKernel/Profile/VG3503J=$(call Image/BuildKernelLoader/Template,VG3503J)
-Image/Build/Profile/VG3503J=$(call Image/BuildLoader/$(1),$(1),VG3503J)
-
-Image/BuildKernel/Profile/VG3503J_V2=$(call Image/BuildKernelLoader/Template,VG3503J_V2)
-Image/Build/Profile/VG3503J_V2=$(call Image/BuildLoader/$(1),$(1),VG3503J_V2)
-
-Image/BuildKernel/Profile/TDW8970=$(call Image/BuildKernelTPLink/Template,TDW8970,TD-W8970v1,$(1))
-Image/Build/Profile/TDW8970=$(call Image/BuildTPLink/$(1),$(1),TDW8970,TD-W8970v1)
-
-Image/BuildKernel/Profile/VGV7510KW22NOR=$(call Image/BuildKernel/Template,VGV7510KW22NOR,$(1))
-Image/Build/Profile/VGV7510KW22NOR=$(call Image/Build/$(1),$(1),VGV7510KW22NOR)
-
-Image/BuildKernel/Profile/VGV7510KW22BRN=$(call Image/BuildKernel/Template,VGV7510KW22BRN,$(1))
-Image/Build/Profile/VGV7510KW22BRN=$(call Image/Build/$(1),$(1),VGV7510KW22BRN,5BRNDA6431,0x12345678,0x04c11db7,$(1))
-
-Image/BuildKernel/Profile/VGV7519NOR=$(call Image/BuildKernel/Template,VGV7519NOR,$(1))
-Image/Build/Profile/VGV7519NOR=$(call Image/Build/$(1),$(1),VGV7519NOR)
-
-Image/BuildKernel/Profile/VGV7519BRN=$(call Image/BuildKernel/Template,VGV7519BRN,$(1))
-Image/Build/Profile/VGV7519BRN=$(call Image/Build/$(1),$(1),VGV7519BRN,5D00008000,0x12345678,0x2083b8ed,$(1))
-
-define Image/Prepare
-	$(call Image/Prepare/Profile,VG3503J)
-	$(call Image/Prepare/Profile,VG3503J_V2)
-endef
-
-endif
-
-
-ifeq ($(CONFIG_TARGET_lantiq_svip_be),y)
-
-Image/BuildKernel/Profile/EASY33016=$(call Image/BuildKernelGzip/Template,EASY33016)
-Image/Build/Profile/EASY33016=$(call Image/Build/$(1),$(1),EASY33016)
-
-endif
-
-
-define Image/BuildKernel
-	$(foreach profile,$(if $(SUBPROFILES_$(PROFILE)),$(SUBPROFILES_$(PROFILE)),$(PROFILE)),\
-		$(call Image/BuildKernel/Profile/$(profile)) )
-endef
-
-define Image/InstallKernel
-	$(foreach profile,$(if $(SUBPROFILES_$(PROFILE)),$(SUBPROFILES_$(PROFILE)),$(PROFILE)),\
-		$(call Image/InstallKernel/Template/$(profile)) )
-endef
-
-
-define Image/Build
-	$(foreach profile,$(if $(SUBPROFILES_$(PROFILE)),$(SUBPROFILES_$(PROFILE)),$(PROFILE)),\
-		$(call Image/Build/Profile/$(profile),$(1)) )
-endef
-
-$(eval $(call BuildImage))
diff --git a/target/linux/lantiq/image/eva.dummy.squashfs b/target/linux/lantiq/image/eva.dummy.squashfs
deleted file mode 100644
index 71c688c93e98ce9bcf6230abb7649f5c51dd9494..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 256
zcmXReEY4tHU|_r>?EZm)q3%DB4F-3vwkj|%GcbxgU=TdO$l#xHA_ykMzyxL0|9=8y
zt%lOe;c6g^awvZ)8a=;3M({1efB%%@uYfX)Knyf90jh|BseuE=gwjC$%rDTysKW&S
D@U9rK

diff --git a/target/linux/lantiq/image/lzma-loader/Makefile b/target/linux/lantiq/image/lzma-loader/Makefile
deleted file mode 100644
index ab6640ac5f..0000000000
--- a/target/linux/lantiq/image/lzma-loader/Makefile
+++ /dev/null
@@ -1,65 +0,0 @@
-#
-# Copyright (C) 2011 OpenWrt.org
-# Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
-#
-# This is free software, licensed under the GNU General Public License v2.
-# See /LICENSE for more information.
-#
-
-include $(TOPDIR)/rules.mk
-
-LZMA_TEXT_START	:= 0x80a00000
-LOADER		:= loader.bin
-LOADER_NAME	:= $(basename $(notdir $(LOADER)))
-LOADER_DATA 	:=
-TARGET_DIR	:=
-FLASH_OFFS	:=
-FLASH_MAX	:=
-BOARD		:=
-
-ifeq ($(TARGET_DIR),)
-TARGET_DIR	:= $(KDIR)
-endif
-
-LOADER_BIN	:= $(TARGET_DIR)/$(LOADER_NAME).bin
-LOADER_GZ	:= $(TARGET_DIR)/$(LOADER_NAME).gz
-LOADER_ELF	:= $(TARGET_DIR)/$(LOADER_NAME).elf
-
-PKG_NAME := lzma-loader
-PKG_BUILD_DIR := $(KDIR)/$(PKG_NAME)
-
-.PHONY : loader-compile loader.bin loader.elf loader.gz
-
-$(PKG_BUILD_DIR)/.prepared:
-	mkdir $(PKG_BUILD_DIR)
-	$(CP) ./src/* $(PKG_BUILD_DIR)/
-	touch $@
-
-loader-compile: $(PKG_BUILD_DIR)/.prepared
-	$(MAKE) -C $(PKG_BUILD_DIR) CROSS_COMPILE="$(TARGET_CROSS)" \
-		LZMA_TEXT_START=$(LZMA_TEXT_START) \
-		LOADER_DATA=$(LOADER_DATA) \
-		FLASH_OFFS=$(FLASH_OFFS) \
-		FLASH_MAX=$(FLASH_MAX) \
-		BOARD="$(BOARD)" \
-		PLATFORM="lantiq" \
-		clean all
-
-loader.gz: $(PKG_BUILD_DIR)/loader.bin
-	gzip -nc9 $< > $(LOADER_GZ)
-
-loader.elf: $(PKG_BUILD_DIR)/loader.elf
-	$(CP) $< $(LOADER_ELF)
-
-loader.bin: $(PKG_BUILD_DIR)/loader.bin
-	$(CP) $< $(LOADER_BIN)
-
-download:
-prepare: $(PKG_BUILD_DIR)/.prepared
-compile: loader-compile
-
-install:
-
-clean:
-	rm -rf $(PKG_BUILD_DIR)
-
diff --git a/target/linux/lantiq/image/lzma-loader/src/LzmaDecode.c b/target/linux/lantiq/image/lzma-loader/src/LzmaDecode.c
deleted file mode 100644
index cb8345377e..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/LzmaDecode.c
+++ /dev/null
@@ -1,584 +0,0 @@
-/*
-  LzmaDecode.c
-  LZMA Decoder (optimized for Speed version)
-  
-  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
-  http://www.7-zip.org/
-
-  LZMA SDK is licensed under two licenses:
-  1) GNU Lesser General Public License (GNU LGPL)
-  2) Common Public License (CPL)
-  It means that you can select one of these two licenses and 
-  follow rules of that license.
-
-  SPECIAL EXCEPTION:
-  Igor Pavlov, as the author of this Code, expressly permits you to 
-  statically or dynamically link your Code (or bind by name) to the 
-  interfaces of this file without subjecting your linked Code to the 
-  terms of the CPL or GNU LGPL. Any modifications or additions 
-  to this file, however, are subject to the LGPL or CPL terms.
-*/
-
-#include "LzmaDecode.h"
-
-#define kNumTopBits 24
-#define kTopValue ((UInt32)1 << kNumTopBits)
-
-#define kNumBitModelTotalBits 11
-#define kBitModelTotal (1 << kNumBitModelTotalBits)
-#define kNumMoveBits 5
-
-#define RC_READ_BYTE (*Buffer++)
-
-#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
-  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
-
-#ifdef _LZMA_IN_CB
-
-#define RC_TEST { if (Buffer == BufferLim) \
-  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) return result; \
-  BufferLim = Buffer + size; if (size == 0) return LZMA_RESULT_DATA_ERROR; }}
-
-#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
-
-#else
-
-#define RC_TEST { if (Buffer == BufferLim) return LZMA_RESULT_DATA_ERROR; }
-
-#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
- 
-#endif
-
-#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
-
-#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
-#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
-#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
-
-#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
-  { UpdateBit0(p); mi <<= 1; A0; } else \
-  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
-  
-#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
-
-#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
-  { int i = numLevels; res = 1; \
-  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
-  res -= (1 << numLevels); }
-
-
-#define kNumPosBitsMax 4
-#define kNumPosStatesMax (1 << kNumPosBitsMax)
-
-#define kLenNumLowBits 3
-#define kLenNumLowSymbols (1 << kLenNumLowBits)
-#define kLenNumMidBits 3
-#define kLenNumMidSymbols (1 << kLenNumMidBits)
-#define kLenNumHighBits 8
-#define kLenNumHighSymbols (1 << kLenNumHighBits)
-
-#define LenChoice 0
-#define LenChoice2 (LenChoice + 1)
-#define LenLow (LenChoice2 + 1)
-#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
-#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
-#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
-
-
-#define kNumStates 12
-#define kNumLitStates 7
-
-#define kStartPosModelIndex 4
-#define kEndPosModelIndex 14
-#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
-
-#define kNumPosSlotBits 6
-#define kNumLenToPosStates 4
-
-#define kNumAlignBits 4
-#define kAlignTableSize (1 << kNumAlignBits)
-
-#define kMatchMinLen 2
-
-#define IsMatch 0
-#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
-#define IsRepG0 (IsRep + kNumStates)
-#define IsRepG1 (IsRepG0 + kNumStates)
-#define IsRepG2 (IsRepG1 + kNumStates)
-#define IsRep0Long (IsRepG2 + kNumStates)
-#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
-#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
-#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
-#define LenCoder (Align + kAlignTableSize)
-#define RepLenCoder (LenCoder + kNumLenProbs)
-#define Literal (RepLenCoder + kNumLenProbs)
-
-#if Literal != LZMA_BASE_SIZE
-StopCompilingDueBUG
-#endif
-
-int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
-{
-  unsigned char prop0;
-  if (size < LZMA_PROPERTIES_SIZE)
-    return LZMA_RESULT_DATA_ERROR;
-  prop0 = propsData[0];
-  if (prop0 >= (9 * 5 * 5))
-    return LZMA_RESULT_DATA_ERROR;
-  {
-    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
-    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
-    propsRes->lc = prop0;
-    /*
-    unsigned char remainder = (unsigned char)(prop0 / 9);
-    propsRes->lc = prop0 % 9;
-    propsRes->pb = remainder / 5;
-    propsRes->lp = remainder % 5;
-    */
-  }
-
-  #ifdef _LZMA_OUT_READ
-  {
-    int i;
-    propsRes->DictionarySize = 0;
-    for (i = 0; i < 4; i++)
-      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
-    if (propsRes->DictionarySize == 0)
-      propsRes->DictionarySize = 1;
-  }
-  #endif
-  return LZMA_RESULT_OK;
-}
-
-#define kLzmaStreamWasFinishedId (-1)
-
-int LzmaDecode(CLzmaDecoderState *vs,
-    #ifdef _LZMA_IN_CB
-    ILzmaInCallback *InCallback,
-    #else
-    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
-    #endif
-    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
-{
-  CProb *p = vs->Probs;
-  SizeT nowPos = 0;
-  Byte previousByte = 0;
-  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
-  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
-  int lc = vs->Properties.lc;
-
-  #ifdef _LZMA_OUT_READ
-  
-  UInt32 Range = vs->Range;
-  UInt32 Code = vs->Code;
-  #ifdef _LZMA_IN_CB
-  const Byte *Buffer = vs->Buffer;
-  const Byte *BufferLim = vs->BufferLim;
-  #else
-  const Byte *Buffer = inStream;
-  const Byte *BufferLim = inStream + inSize;
-  #endif
-  int state = vs->State;
-  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
-  int len = vs->RemainLen;
-  UInt32 globalPos = vs->GlobalPos;
-  UInt32 distanceLimit = vs->DistanceLimit;
-
-  Byte *dictionary = vs->Dictionary;
-  UInt32 dictionarySize = vs->Properties.DictionarySize;
-  UInt32 dictionaryPos = vs->DictionaryPos;
-
-  Byte tempDictionary[4];
-
-  #ifndef _LZMA_IN_CB
-  *inSizeProcessed = 0;
-  #endif
-  *outSizeProcessed = 0;
-  if (len == kLzmaStreamWasFinishedId)
-    return LZMA_RESULT_OK;
-
-  if (dictionarySize == 0)
-  {
-    dictionary = tempDictionary;
-    dictionarySize = 1;
-    tempDictionary[0] = vs->TempDictionary[0];
-  }
-
-  if (len == kLzmaNeedInitId)
-  {
-    {
-      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
-      UInt32 i;
-      for (i = 0; i < numProbs; i++)
-        p[i] = kBitModelTotal >> 1; 
-      rep0 = rep1 = rep2 = rep3 = 1;
-      state = 0;
-      globalPos = 0;
-      distanceLimit = 0;
-      dictionaryPos = 0;
-      dictionary[dictionarySize - 1] = 0;
-      #ifdef _LZMA_IN_CB
-      RC_INIT;
-      #else
-      RC_INIT(inStream, inSize);
-      #endif
-    }
-    len = 0;
-  }
-  while(len != 0 && nowPos < outSize)
-  {
-    UInt32 pos = dictionaryPos - rep0;
-    if (pos >= dictionarySize)
-      pos += dictionarySize;
-    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
-    if (++dictionaryPos == dictionarySize)
-      dictionaryPos = 0;
-    len--;
-  }
-  if (dictionaryPos == 0)
-    previousByte = dictionary[dictionarySize - 1];
-  else
-    previousByte = dictionary[dictionaryPos - 1];
-
-  #else /* if !_LZMA_OUT_READ */
-
-  int state = 0;
-  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
-  int len = 0;
-  const Byte *Buffer;
-  const Byte *BufferLim;
-  UInt32 Range;
-  UInt32 Code;
-
-  #ifndef _LZMA_IN_CB
-  *inSizeProcessed = 0;
-  #endif
-  *outSizeProcessed = 0;
-
-  {
-    UInt32 i;
-    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
-    for (i = 0; i < numProbs; i++)
-      p[i] = kBitModelTotal >> 1;
-  }
-  
-  #ifdef _LZMA_IN_CB
-  RC_INIT;
-  #else
-  RC_INIT(inStream, inSize);
-  #endif
-
-  #endif /* _LZMA_OUT_READ */
-
-  while(nowPos < outSize)
-  {
-    CProb *prob;
-    UInt32 bound;
-    int posState = (int)(
-        (nowPos 
-        #ifdef _LZMA_OUT_READ
-        + globalPos
-        #endif
-        )
-        & posStateMask);
-
-    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
-    IfBit0(prob)
-    {
-      int symbol = 1;
-      UpdateBit0(prob)
-      prob = p + Literal + (LZMA_LIT_SIZE * 
-        (((
-        (nowPos 
-        #ifdef _LZMA_OUT_READ
-        + globalPos
-        #endif
-        )
-        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
-
-      if (state >= kNumLitStates)
-      {
-        int matchByte;
-        #ifdef _LZMA_OUT_READ
-        UInt32 pos = dictionaryPos - rep0;
-        if (pos >= dictionarySize)
-          pos += dictionarySize;
-        matchByte = dictionary[pos];
-        #else
-        matchByte = outStream[nowPos - rep0];
-        #endif
-        do
-        {
-          int bit;
-          CProb *probLit;
-          matchByte <<= 1;
-          bit = (matchByte & 0x100);
-          probLit = prob + 0x100 + bit + symbol;
-          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
-        }
-        while (symbol < 0x100);
-      }
-      while (symbol < 0x100)
-      {
-        CProb *probLit = prob + symbol;
-        RC_GET_BIT(probLit, symbol)
-      }
-      previousByte = (Byte)symbol;
-
-      outStream[nowPos++] = previousByte;
-      #ifdef _LZMA_OUT_READ
-      if (distanceLimit < dictionarySize)
-        distanceLimit++;
-
-      dictionary[dictionaryPos] = previousByte;
-      if (++dictionaryPos == dictionarySize)
-        dictionaryPos = 0;
-      #endif
-      if (state < 4) state = 0;
-      else if (state < 10) state -= 3;
-      else state -= 6;
-    }
-    else             
-    {
-      UpdateBit1(prob);
-      prob = p + IsRep + state;
-      IfBit0(prob)
-      {
-        UpdateBit0(prob);
-        rep3 = rep2;
-        rep2 = rep1;
-        rep1 = rep0;
-        state = state < kNumLitStates ? 0 : 3;
-        prob = p + LenCoder;
-      }
-      else
-      {
-        UpdateBit1(prob);
-        prob = p + IsRepG0 + state;
-        IfBit0(prob)
-        {
-          UpdateBit0(prob);
-          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
-          IfBit0(prob)
-          {
-            #ifdef _LZMA_OUT_READ
-            UInt32 pos;
-            #endif
-            UpdateBit0(prob);
-            
-            #ifdef _LZMA_OUT_READ
-            if (distanceLimit == 0)
-            #else
-            if (nowPos == 0)
-            #endif
-              return LZMA_RESULT_DATA_ERROR;
-            
-            state = state < kNumLitStates ? 9 : 11;
-            #ifdef _LZMA_OUT_READ
-            pos = dictionaryPos - rep0;
-            if (pos >= dictionarySize)
-              pos += dictionarySize;
-            previousByte = dictionary[pos];
-            dictionary[dictionaryPos] = previousByte;
-            if (++dictionaryPos == dictionarySize)
-              dictionaryPos = 0;
-            #else
-            previousByte = outStream[nowPos - rep0];
-            #endif
-            outStream[nowPos++] = previousByte;
-            #ifdef _LZMA_OUT_READ
-            if (distanceLimit < dictionarySize)
-              distanceLimit++;
-            #endif
-
-            continue;
-          }
-          else
-          {
-            UpdateBit1(prob);
-          }
-        }
-        else
-        {
-          UInt32 distance;
-          UpdateBit1(prob);
-          prob = p + IsRepG1 + state;
-          IfBit0(prob)
-          {
-            UpdateBit0(prob);
-            distance = rep1;
-          }
-          else 
-          {
-            UpdateBit1(prob);
-            prob = p + IsRepG2 + state;
-            IfBit0(prob)
-            {
-              UpdateBit0(prob);
-              distance = rep2;
-            }
-            else
-            {
-              UpdateBit1(prob);
-              distance = rep3;
-              rep3 = rep2;
-            }
-            rep2 = rep1;
-          }
-          rep1 = rep0;
-          rep0 = distance;
-        }
-        state = state < kNumLitStates ? 8 : 11;
-        prob = p + RepLenCoder;
-      }
-      {
-        int numBits, offset;
-        CProb *probLen = prob + LenChoice;
-        IfBit0(probLen)
-        {
-          UpdateBit0(probLen);
-          probLen = prob + LenLow + (posState << kLenNumLowBits);
-          offset = 0;
-          numBits = kLenNumLowBits;
-        }
-        else
-        {
-          UpdateBit1(probLen);
-          probLen = prob + LenChoice2;
-          IfBit0(probLen)
-          {
-            UpdateBit0(probLen);
-            probLen = prob + LenMid + (posState << kLenNumMidBits);
-            offset = kLenNumLowSymbols;
-            numBits = kLenNumMidBits;
-          }
-          else
-          {
-            UpdateBit1(probLen);
-            probLen = prob + LenHigh;
-            offset = kLenNumLowSymbols + kLenNumMidSymbols;
-            numBits = kLenNumHighBits;
-          }
-        }
-        RangeDecoderBitTreeDecode(probLen, numBits, len);
-        len += offset;
-      }
-
-      if (state < 4)
-      {
-        int posSlot;
-        state += kNumLitStates;
-        prob = p + PosSlot +
-            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
-            kNumPosSlotBits);
-        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
-        if (posSlot >= kStartPosModelIndex)
-        {
-          int numDirectBits = ((posSlot >> 1) - 1);
-          rep0 = (2 | ((UInt32)posSlot & 1));
-          if (posSlot < kEndPosModelIndex)
-          {
-            rep0 <<= numDirectBits;
-            prob = p + SpecPos + rep0 - posSlot - 1;
-          }
-          else
-          {
-            numDirectBits -= kNumAlignBits;
-            do
-            {
-              RC_NORMALIZE
-              Range >>= 1;
-              rep0 <<= 1;
-              if (Code >= Range)
-              {
-                Code -= Range;
-                rep0 |= 1;
-              }
-            }
-            while (--numDirectBits != 0);
-            prob = p + Align;
-            rep0 <<= kNumAlignBits;
-            numDirectBits = kNumAlignBits;
-          }
-          {
-            int i = 1;
-            int mi = 1;
-            do
-            {
-              CProb *prob3 = prob + mi;
-              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
-              i <<= 1;
-            }
-            while(--numDirectBits != 0);
-          }
-        }
-        else
-          rep0 = posSlot;
-        if (++rep0 == (UInt32)(0))
-        {
-          /* it's for stream version */
-          len = kLzmaStreamWasFinishedId;
-          break;
-        }
-      }
-
-      len += kMatchMinLen;
-      #ifdef _LZMA_OUT_READ
-      if (rep0 > distanceLimit) 
-      #else
-      if (rep0 > nowPos)
-      #endif
-        return LZMA_RESULT_DATA_ERROR;
-
-      #ifdef _LZMA_OUT_READ
-      if (dictionarySize - distanceLimit > (UInt32)len)
-        distanceLimit += len;
-      else
-        distanceLimit = dictionarySize;
-      #endif
-
-      do
-      {
-        #ifdef _LZMA_OUT_READ
-        UInt32 pos = dictionaryPos - rep0;
-        if (pos >= dictionarySize)
-          pos += dictionarySize;
-        previousByte = dictionary[pos];
-        dictionary[dictionaryPos] = previousByte;
-        if (++dictionaryPos == dictionarySize)
-          dictionaryPos = 0;
-        #else
-        previousByte = outStream[nowPos - rep0];
-        #endif
-        len--;
-        outStream[nowPos++] = previousByte;
-      }
-      while(len != 0 && nowPos < outSize);
-    }
-  }
-  RC_NORMALIZE;
-
-  #ifdef _LZMA_OUT_READ
-  vs->Range = Range;
-  vs->Code = Code;
-  vs->DictionaryPos = dictionaryPos;
-  vs->GlobalPos = globalPos + (UInt32)nowPos;
-  vs->DistanceLimit = distanceLimit;
-  vs->Reps[0] = rep0;
-  vs->Reps[1] = rep1;
-  vs->Reps[2] = rep2;
-  vs->Reps[3] = rep3;
-  vs->State = state;
-  vs->RemainLen = len;
-  vs->TempDictionary[0] = tempDictionary[0];
-  #endif
-
-  #ifdef _LZMA_IN_CB
-  vs->Buffer = Buffer;
-  vs->BufferLim = BufferLim;
-  #else
-  *inSizeProcessed = (SizeT)(Buffer - inStream);
-  #endif
-  *outSizeProcessed = nowPos;
-  return LZMA_RESULT_OK;
-}
diff --git a/target/linux/lantiq/image/lzma-loader/src/LzmaDecode.h b/target/linux/lantiq/image/lzma-loader/src/LzmaDecode.h
deleted file mode 100644
index 2870eeb9c9..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/LzmaDecode.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/* 
-  LzmaDecode.h
-  LZMA Decoder interface
-
-  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
-  http://www.7-zip.org/
-
-  LZMA SDK is licensed under two licenses:
-  1) GNU Lesser General Public License (GNU LGPL)
-  2) Common Public License (CPL)
-  It means that you can select one of these two licenses and 
-  follow rules of that license.
-
-  SPECIAL EXCEPTION:
-  Igor Pavlov, as the author of this code, expressly permits you to 
-  statically or dynamically link your code (or bind by name) to the 
-  interfaces of this file without subjecting your linked code to the 
-  terms of the CPL or GNU LGPL. Any modifications or additions 
-  to this file, however, are subject to the LGPL or CPL terms.
-*/
-
-#ifndef __LZMADECODE_H
-#define __LZMADECODE_H
-
-#include "LzmaTypes.h"
-
-/* #define _LZMA_IN_CB */
-/* Use callback for input data */
-
-/* #define _LZMA_OUT_READ */
-/* Use read function for output data */
-
-/* #define _LZMA_PROB32 */
-/* It can increase speed on some 32-bit CPUs, 
-   but memory usage will be doubled in that case */
-
-/* #define _LZMA_LOC_OPT */
-/* Enable local speed optimizations inside code */
-
-#ifdef _LZMA_PROB32
-#define CProb UInt32
-#else
-#define CProb UInt16
-#endif
-
-#define LZMA_RESULT_OK 0
-#define LZMA_RESULT_DATA_ERROR 1
-
-#ifdef _LZMA_IN_CB
-typedef struct _ILzmaInCallback
-{
-  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
-} ILzmaInCallback;
-#endif
-
-#define LZMA_BASE_SIZE 1846
-#define LZMA_LIT_SIZE 768
-
-#define LZMA_PROPERTIES_SIZE 5
-
-typedef struct _CLzmaProperties
-{
-  int lc;
-  int lp;
-  int pb;
-  #ifdef _LZMA_OUT_READ
-  UInt32 DictionarySize;
-  #endif
-}CLzmaProperties;
-
-int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
-
-#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))
-
-#define kLzmaNeedInitId (-2)
-
-typedef struct _CLzmaDecoderState
-{
-  CLzmaProperties Properties;
-  CProb *Probs;
-
-  #ifdef _LZMA_IN_CB
-  const unsigned char *Buffer;
-  const unsigned char *BufferLim;
-  #endif
-
-  #ifdef _LZMA_OUT_READ
-  unsigned char *Dictionary;
-  UInt32 Range;
-  UInt32 Code;
-  UInt32 DictionaryPos;
-  UInt32 GlobalPos;
-  UInt32 DistanceLimit;
-  UInt32 Reps[4];
-  int State;
-  int RemainLen;
-  unsigned char TempDictionary[4];
-  #endif
-} CLzmaDecoderState;
-
-#ifdef _LZMA_OUT_READ
-#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
-#endif
-
-int LzmaDecode(CLzmaDecoderState *vs,
-    #ifdef _LZMA_IN_CB
-    ILzmaInCallback *inCallback,
-    #else
-    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
-    #endif
-    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
-
-#endif
diff --git a/target/linux/lantiq/image/lzma-loader/src/LzmaTypes.h b/target/linux/lantiq/image/lzma-loader/src/LzmaTypes.h
deleted file mode 100644
index 9c27290757..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/LzmaTypes.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/* 
-LzmaTypes.h 
-
-Types for LZMA Decoder
-
-This file written and distributed to public domain by Igor Pavlov.
-This file is part of LZMA SDK 4.40 (2006-05-01)
-*/
-
-#ifndef __LZMATYPES_H
-#define __LZMATYPES_H
-
-#ifndef _7ZIP_BYTE_DEFINED
-#define _7ZIP_BYTE_DEFINED
-typedef unsigned char Byte;
-#endif 
-
-#ifndef _7ZIP_UINT16_DEFINED
-#define _7ZIP_UINT16_DEFINED
-typedef unsigned short UInt16;
-#endif 
-
-#ifndef _7ZIP_UINT32_DEFINED
-#define _7ZIP_UINT32_DEFINED
-#ifdef _LZMA_UINT32_IS_ULONG
-typedef unsigned long UInt32;
-#else
-typedef unsigned int UInt32;
-#endif
-#endif 
-
-/* #define _LZMA_NO_SYSTEM_SIZE_T */
-/* You can use it, if you don't want <stddef.h> */
-
-#ifndef _7ZIP_SIZET_DEFINED
-#define _7ZIP_SIZET_DEFINED
-#ifdef _LZMA_NO_SYSTEM_SIZE_T
-typedef UInt32 SizeT;
-#else
-#include <stddef.h>
-typedef size_t SizeT;
-#endif
-#endif
-
-#endif
diff --git a/target/linux/lantiq/image/lzma-loader/src/Makefile b/target/linux/lantiq/image/lzma-loader/src/Makefile
deleted file mode 100644
index f861666e62..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/Makefile
+++ /dev/null
@@ -1,110 +0,0 @@
-#
-# Makefile for the LZMA compressed kernel loader for
-# Atheros AR7XXX/AR9XXX based boards
-#
-# Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
-#
-# Some parts of this file was based on the OpenWrt specific lzma-loader
-# for the BCM47xx and ADM5120 based boards:
-#	Copyright (C) 2004 Manuel Novoa III (mjn3@codepoet.org)
-#	Copyright (C) 2005 Mineharu Takahara <mtakahar@yahoo.com>
-#	Copyright (C) 2005 by Oleg I. Vdovikin <oleg@cs.msu.su>
-#
-# This program is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 as published
-# by the Free Software Foundation.
-#
-
-LOADADDR	:=
-LZMA_TEXT_START	:= 0x80a00000
-LOADER_DATA	:=
-BOARD		:=
-FLASH_OFFS	:=
-FLASH_MAX	:=
-PLATFORM	:=
-
-CC		:= $(CROSS_COMPILE)gcc
-LD		:= $(CROSS_COMPILE)ld
-OBJCOPY		:= $(CROSS_COMPILE)objcopy
-OBJDUMP		:= $(CROSS_COMPILE)objdump
-
-BIN_FLAGS	:= -O binary -R .reginfo -R .note -R .comment -R .mdebug -S
-
-CFLAGS		= -D__KERNEL__ -Wall -Wstrict-prototypes -Wno-trigraphs -Os \
-		  -fno-strict-aliasing -fno-common -fomit-frame-pointer -G 0 \
-		  -mno-abicalls -fno-pic -ffunction-sections -pipe -mlong-calls \
-		  -fno-common -ffreestanding -fhonour-copts \
-		  -mabi=32 -march=mips32r2 \
-		  -Wa,-32 -Wa,-march=mips32r2 -Wa,-mips32r2 -Wa,--trap
-CFLAGS		+= -D_LZMA_PROB32 -DARCH=$(PLATFORM)
-
-ASFLAGS		= $(CFLAGS) -D__ASSEMBLY__
-
-LDFLAGS		= -static --gc-sections -no-warn-mismatch
-LDFLAGS		+= -e startup -T loader.lds -Ttext $(LZMA_TEXT_START)
-
-O_FORMAT 	= $(shell $(OBJDUMP) -i | head -2 | grep elf32)
-
-OBJECTS		:= head.o loader.o cache.o board-$(PLATFORM).o printf.o LzmaDecode.o
-
-include $(PLATFORM).mk
-CFLAGS+=$(CACHE_FLAGS)
-ASFLAGS+=$(CACHE_FLAGS)
-
-ifneq ($(strip $(LOADER_DATA)),)
-OBJECTS		+= data.o
-CFLAGS		+= -DLZMA_WRAPPER=1 -DLOADADDR=$(LOADADDR)
-endif
-
-ifneq ($(strip $(KERNEL_CMDLINE)),)
-CFLAGS		+= -DCONFIG_KERNEL_CMDLINE='"$(KERNEL_CMDLINE)"'
-endif
-
-ifneq ($(strip $(FLASH_OFFS)),)
-CFLAGS		+= -DCONFIG_FLASH_OFFS=$(FLASH_OFFS)
-endif
-
-ifneq ($(strip $(FLASH_MAX)),)
-CFLAGS		+= -DCONFIG_FLASH_MAX=$(FLASH_MAX)
-endif
-
-BOARD_DEF := $(shell echo $(strip $(BOARD)) | tr a-z A-Z | tr - _)
-ifneq ($(BOARD_DEF),)
-CFLAGS		+= -DCONFIG_BOARD_$(BOARD_DEF)
-endif
-
-all: loader.elf
-
-# Don't build dependencies, this may die if $(CC) isn't gcc
-dep:
-
-install:
-
-%.o : %.c
-	$(CC) $(CFLAGS) -c -o $@ $<
-
-%.o : %.S
-	$(CC) $(ASFLAGS) -c -o $@ $<
-
-data.o: $(LOADER_DATA)
-	$(LD) -r -b binary --oformat $(O_FORMAT) -T lzma-data.lds -o $@ $<
-
-loader: $(OBJECTS)
-	$(LD) $(LDFLAGS) -o $@ $(OBJECTS)
-
-loader.bin: loader
-	$(OBJCOPY) $(BIN_FLAGS) $< $@
-
-loader2.o: loader.bin
-	$(LD) -r -b binary --oformat $(O_FORMAT) -o $@ $<
-
-loader.elf: loader2.o
-	$(LD) -e startup -T loader2.lds -Ttext $(LOADADDR) -o $@ $<
-
-mrproper: clean
-
-clean:
-	rm -f loader *.elf *.bin *.o
-
-
-
diff --git a/target/linux/lantiq/image/lzma-loader/src/ar71xx.mk b/target/linux/lantiq/image/lzma-loader/src/ar71xx.mk
deleted file mode 100644
index 31541d74fd..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/ar71xx.mk
+++ /dev/null
@@ -1 +0,0 @@
-CACHE_FLAGS+=-DCONFIG_ICACHE_SIZE="(32 * 1024)" -DCONFIG_DCACHE_SIZE="(64 * 1024)" -DCONFIG_CACHELINE_SIZE=32
diff --git a/target/linux/lantiq/image/lzma-loader/src/ar71xx_regs.h b/target/linux/lantiq/image/lzma-loader/src/ar71xx_regs.h
deleted file mode 100644
index 19a4785bb4..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/ar71xx_regs.h
+++ /dev/null
@@ -1,725 +0,0 @@
-/*
- *  Atheros AR71XX/AR724X/AR913X SoC register definitions
- *
- *  Copyright (C) 2010-2011 Jaiganesh Narayanan <jnarayanan@atheros.com>
- *  Copyright (C) 2008-2010 Gabor Juhos <juhosg@openwrt.org>
- *  Copyright (C) 2008 Imre Kaloz <kaloz@openwrt.org>
- *
- *  Parts of this file are based on Atheros' 2.6.15/2.6.31 BSP
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 as published
- *  by the Free Software Foundation.
- */
-
-#ifndef __ASM_MACH_AR71XX_REGS_H
-#define __ASM_MACH_AR71XX_REGS_H
-
-#define BIT(_x)			(1UL << (_x))
-
-#define AR71XX_APB_BASE		0x18000000
-#define AR71XX_GE0_BASE		0x19000000
-#define AR71XX_GE0_SIZE		0x10000
-#define AR71XX_GE1_BASE		0x1a000000
-#define AR71XX_GE1_SIZE		0x10000
-#define AR71XX_EHCI_BASE	0x1b000000
-#define AR71XX_EHCI_SIZE	0x1000
-#define AR71XX_OHCI_BASE	0x1c000000
-#define AR71XX_OHCI_SIZE	0x1000
-#define AR71XX_SPI_BASE		0x1f000000
-#define AR71XX_SPI_SIZE		0x01000000
-
-#define AR71XX_DDR_CTRL_BASE	(AR71XX_APB_BASE + 0x00000000)
-#define AR71XX_DDR_CTRL_SIZE	0x100
-#define AR71XX_UART_BASE	(AR71XX_APB_BASE + 0x00020000)
-#define AR71XX_UART_SIZE	0x100
-#define AR71XX_USB_CTRL_BASE	(AR71XX_APB_BASE + 0x00030000)
-#define AR71XX_USB_CTRL_SIZE	0x100
-#define AR71XX_GPIO_BASE        (AR71XX_APB_BASE + 0x00040000)
-#define AR71XX_GPIO_SIZE        0x100
-#define AR71XX_PLL_BASE		(AR71XX_APB_BASE + 0x00050000)
-#define AR71XX_PLL_SIZE		0x100
-#define AR71XX_RESET_BASE	(AR71XX_APB_BASE + 0x00060000)
-#define AR71XX_RESET_SIZE	0x100
-#define AR71XX_MII_BASE		(AR71XX_APB_BASE + 0x00070000)
-#define AR71XX_MII_SIZE		0x100
-
-#define AR71XX_PCI_MEM_BASE	0x10000000
-#define AR71XX_PCI_MEM_SIZE	0x07000000
-
-#define AR71XX_PCI_WIN0_OFFS	0x10000000
-#define AR71XX_PCI_WIN1_OFFS	0x11000000
-#define AR71XX_PCI_WIN2_OFFS	0x12000000
-#define AR71XX_PCI_WIN3_OFFS	0x13000000
-#define AR71XX_PCI_WIN4_OFFS	0x14000000
-#define AR71XX_PCI_WIN5_OFFS	0x15000000
-#define AR71XX_PCI_WIN6_OFFS	0x16000000
-#define AR71XX_PCI_WIN7_OFFS	0x07000000
-
-#define AR71XX_PCI_CFG_BASE	\
-	(AR71XX_PCI_MEM_BASE + AR71XX_PCI_WIN7_OFFS + 0x10000)
-#define AR71XX_PCI_CFG_SIZE	0x100
-
-#define AR7240_USB_CTRL_BASE	(AR71XX_APB_BASE + 0x00030000)
-#define AR7240_USB_CTRL_SIZE	0x100
-#define AR7240_OHCI_BASE	0x1b000000
-#define AR7240_OHCI_SIZE	0x1000
-
-#define AR724X_PCI_MEM_BASE	0x10000000
-#define AR724X_PCI_MEM_SIZE	0x04000000
-
-#define AR724X_PCI_CFG_BASE	0x14000000
-#define AR724X_PCI_CFG_SIZE	0x1000
-#define AR724X_PCI_CRP_BASE	(AR71XX_APB_BASE + 0x000c0000)
-#define AR724X_PCI_CRP_SIZE	0x1000
-#define AR724X_PCI_CTRL_BASE	(AR71XX_APB_BASE + 0x000f0000)
-#define AR724X_PCI_CTRL_SIZE	0x100
-
-#define AR724X_EHCI_BASE	0x1b000000
-#define AR724X_EHCI_SIZE	0x1000
-
-#define AR913X_EHCI_BASE	0x1b000000
-#define AR913X_EHCI_SIZE	0x1000
-#define AR913X_WMAC_BASE	(AR71XX_APB_BASE + 0x000C0000)
-#define AR913X_WMAC_SIZE	0x30000
-
-#define AR933X_UART_BASE	(AR71XX_APB_BASE + 0x00020000)
-#define AR933X_UART_SIZE	0x14
-#define AR933X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
-#define AR933X_GMAC_SIZE	0x04
-#define AR933X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
-#define AR933X_WMAC_SIZE	0x20000
-#define AR933X_EHCI_BASE	0x1b000000
-#define AR933X_EHCI_SIZE	0x1000
-
-#define AR934X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
-#define AR934X_GMAC_SIZE	0x14
-#define AR934X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
-#define AR934X_WMAC_SIZE	0x20000
-#define AR934X_EHCI_BASE	0x1b000000
-#define AR934X_EHCI_SIZE	0x200
-
-#define QCA955X_PCI_MEM_BASE0	0x10000000
-#define QCA955X_PCI_MEM_BASE1	0x12000000
-#define QCA955X_PCI_MEM_SIZE	0x02000000
-#define QCA955X_PCI_CFG_BASE0	0x14000000
-#define QCA955X_PCI_CFG_BASE1	0x16000000
-#define QCA955X_PCI_CFG_SIZE	0x1000
-#define QCA955X_PCI_CRP_BASE0	(AR71XX_APB_BASE + 0x000c0000)
-#define QCA955X_PCI_CRP_BASE1	(AR71XX_APB_BASE + 0x00250000)
-#define QCA955X_PCI_CRP_SIZE	0x1000
-#define QCA955X_PCI_CTRL_BASE0	(AR71XX_APB_BASE + 0x000f0000)
-#define QCA955X_PCI_CTRL_BASE1	(AR71XX_APB_BASE + 0x00280000)
-#define QCA955X_PCI_CTRL_SIZE	0x100
-
-#define QCA955X_WMAC_BASE	(AR71XX_APB_BASE + 0x00100000)
-#define QCA955X_WMAC_SIZE	0x20000
-#define QCA955X_EHCI0_BASE	0x1b000000
-#define QCA955X_EHCI1_BASE	0x1b400000
-#define QCA955X_EHCI_SIZE	0x1000
-#define QCA955X_GMAC_BASE	(AR71XX_APB_BASE + 0x00070000)
-#define QCA955X_GMAC_SIZE	0x40
-
-#define AR9300_OTP_BASE		0x14000
-#define AR9300_OTP_STATUS	0x15f18
-#define AR9300_OTP_STATUS_TYPE		0x7
-#define AR9300_OTP_STATUS_VALID		0x4
-#define AR9300_OTP_STATUS_ACCESS_BUSY	0x2
-#define AR9300_OTP_STATUS_SM_BUSY	0x1
-#define AR9300_OTP_READ_DATA	0x15f1c
-
-/*
- * DDR_CTRL block
- */
-#define AR71XX_DDR_REG_PCI_WIN0		0x7c
-#define AR71XX_DDR_REG_PCI_WIN1		0x80
-#define AR71XX_DDR_REG_PCI_WIN2		0x84
-#define AR71XX_DDR_REG_PCI_WIN3		0x88
-#define AR71XX_DDR_REG_PCI_WIN4		0x8c
-#define AR71XX_DDR_REG_PCI_WIN5		0x90
-#define AR71XX_DDR_REG_PCI_WIN6		0x94
-#define AR71XX_DDR_REG_PCI_WIN7		0x98
-#define AR71XX_DDR_REG_FLUSH_GE0	0x9c
-#define AR71XX_DDR_REG_FLUSH_GE1	0xa0
-#define AR71XX_DDR_REG_FLUSH_USB	0xa4
-#define AR71XX_DDR_REG_FLUSH_PCI	0xa8
-
-#define AR724X_DDR_REG_FLUSH_GE0	0x7c
-#define AR724X_DDR_REG_FLUSH_GE1	0x80
-#define AR724X_DDR_REG_FLUSH_USB	0x84
-#define AR724X_DDR_REG_FLUSH_PCIE	0x88
-
-#define AR913X_DDR_REG_FLUSH_GE0	0x7c
-#define AR913X_DDR_REG_FLUSH_GE1	0x80
-#define AR913X_DDR_REG_FLUSH_USB	0x84
-#define AR913X_DDR_REG_FLUSH_WMAC	0x88
-
-#define AR933X_DDR_REG_FLUSH_GE0	0x7c
-#define AR933X_DDR_REG_FLUSH_GE1	0x80
-#define AR933X_DDR_REG_FLUSH_USB	0x84
-#define AR933X_DDR_REG_FLUSH_WMAC	0x88
-
-#define AR934X_DDR_REG_FLUSH_GE0	0x9c
-#define AR934X_DDR_REG_FLUSH_GE1	0xa0
-#define AR934X_DDR_REG_FLUSH_USB	0xa4
-#define AR934X_DDR_REG_FLUSH_PCIE	0xa8
-#define AR934X_DDR_REG_FLUSH_WMAC	0xac
-
-/*
- * PLL block
- */
-#define AR71XX_PLL_REG_CPU_CONFIG	0x00
-#define AR71XX_PLL_REG_SEC_CONFIG	0x04
-#define AR71XX_PLL_REG_ETH0_INT_CLOCK	0x10
-#define AR71XX_PLL_REG_ETH1_INT_CLOCK	0x14
-
-#define AR71XX_PLL_DIV_SHIFT		3
-#define AR71XX_PLL_DIV_MASK		0x1f
-#define AR71XX_CPU_DIV_SHIFT		16
-#define AR71XX_CPU_DIV_MASK		0x3
-#define AR71XX_DDR_DIV_SHIFT		18
-#define AR71XX_DDR_DIV_MASK		0x3
-#define AR71XX_AHB_DIV_SHIFT		20
-#define AR71XX_AHB_DIV_MASK		0x7
-
-#define AR71XX_ETH0_PLL_SHIFT		17
-#define AR71XX_ETH1_PLL_SHIFT		19
-
-#define AR724X_PLL_REG_CPU_CONFIG	0x00
-#define AR724X_PLL_REG_PCIE_CONFIG	0x18
-
-#define AR724X_PLL_DIV_SHIFT		0
-#define AR724X_PLL_DIV_MASK		0x3ff
-#define AR724X_PLL_REF_DIV_SHIFT	10
-#define AR724X_PLL_REF_DIV_MASK		0xf
-#define AR724X_AHB_DIV_SHIFT		19
-#define AR724X_AHB_DIV_MASK		0x1
-#define AR724X_DDR_DIV_SHIFT		22
-#define AR724X_DDR_DIV_MASK		0x3
-
-#define AR7242_PLL_REG_ETH0_INT_CLOCK	0x2c
-
-#define AR913X_PLL_REG_CPU_CONFIG	0x00
-#define AR913X_PLL_REG_ETH_CONFIG	0x04
-#define AR913X_PLL_REG_ETH0_INT_CLOCK	0x14
-#define AR913X_PLL_REG_ETH1_INT_CLOCK	0x18
-
-#define AR913X_PLL_DIV_SHIFT		0
-#define AR913X_PLL_DIV_MASK		0x3ff
-#define AR913X_DDR_DIV_SHIFT		22
-#define AR913X_DDR_DIV_MASK		0x3
-#define AR913X_AHB_DIV_SHIFT		19
-#define AR913X_AHB_DIV_MASK		0x1
-
-#define AR913X_ETH0_PLL_SHIFT		20
-#define AR913X_ETH1_PLL_SHIFT		22
-
-#define AR933X_PLL_CPU_CONFIG_REG	0x00
-#define AR933X_PLL_CLOCK_CTRL_REG	0x08
-
-#define AR933X_PLL_CPU_CONFIG_NINT_SHIFT	10
-#define AR933X_PLL_CPU_CONFIG_NINT_MASK		0x3f
-#define AR933X_PLL_CPU_CONFIG_REFDIV_SHIFT	16
-#define AR933X_PLL_CPU_CONFIG_REFDIV_MASK	0x1f
-#define AR933X_PLL_CPU_CONFIG_OUTDIV_SHIFT	23
-#define AR933X_PLL_CPU_CONFIG_OUTDIV_MASK	0x7
-
-#define AR933X_PLL_CLOCK_CTRL_BYPASS		BIT(2)
-#define AR933X_PLL_CLOCK_CTRL_CPU_DIV_SHIFT	5
-#define AR933X_PLL_CLOCK_CTRL_CPU_DIV_MASK	0x3
-#define AR933X_PLL_CLOCK_CTRL_DDR_DIV_SHIFT	10
-#define AR933X_PLL_CLOCK_CTRL_DDR_DIV_MASK	0x3
-#define AR933X_PLL_CLOCK_CTRL_AHB_DIV_SHIFT	15
-#define AR933X_PLL_CLOCK_CTRL_AHB_DIV_MASK	0x7
-
-#define AR934X_PLL_CPU_CONFIG_REG		0x00
-#define AR934X_PLL_DDR_CONFIG_REG		0x04
-#define AR934X_PLL_CPU_DDR_CLK_CTRL_REG		0x08
-#define AR934X_PLL_ETH_XMII_CONTROL_REG		0x2c
-
-#define AR934X_PLL_CPU_CONFIG_NFRAC_SHIFT	0
-#define AR934X_PLL_CPU_CONFIG_NFRAC_MASK	0x3f
-#define AR934X_PLL_CPU_CONFIG_NINT_SHIFT	6
-#define AR934X_PLL_CPU_CONFIG_NINT_MASK		0x3f
-#define AR934X_PLL_CPU_CONFIG_REFDIV_SHIFT	12
-#define AR934X_PLL_CPU_CONFIG_REFDIV_MASK	0x1f
-#define AR934X_PLL_CPU_CONFIG_OUTDIV_SHIFT	19
-#define AR934X_PLL_CPU_CONFIG_OUTDIV_MASK	0x3
-
-#define AR934X_PLL_DDR_CONFIG_NFRAC_SHIFT	0
-#define AR934X_PLL_DDR_CONFIG_NFRAC_MASK	0x3ff
-#define AR934X_PLL_DDR_CONFIG_NINT_SHIFT	10
-#define AR934X_PLL_DDR_CONFIG_NINT_MASK		0x3f
-#define AR934X_PLL_DDR_CONFIG_REFDIV_SHIFT	16
-#define AR934X_PLL_DDR_CONFIG_REFDIV_MASK	0x1f
-#define AR934X_PLL_DDR_CONFIG_OUTDIV_SHIFT	23
-#define AR934X_PLL_DDR_CONFIG_OUTDIV_MASK	0x7
-
-#define AR934X_PLL_CPU_DDR_CLK_CTRL_CPU_PLL_BYPASS	BIT(2)
-#define AR934X_PLL_CPU_DDR_CLK_CTRL_DDR_PLL_BYPASS	BIT(3)
-#define AR934X_PLL_CPU_DDR_CLK_CTRL_AHB_PLL_BYPASS	BIT(4)
-#define AR934X_PLL_CPU_DDR_CLK_CTRL_CPU_POST_DIV_SHIFT	5
-#define AR934X_PLL_CPU_DDR_CLK_CTRL_CPU_POST_DIV_MASK	0x1f
-#define AR934X_PLL_CPU_DDR_CLK_CTRL_DDR_POST_DIV_SHIFT	10
-#define AR934X_PLL_CPU_DDR_CLK_CTRL_DDR_POST_DIV_MASK	0x1f
-#define AR934X_PLL_CPU_DDR_CLK_CTRL_AHB_POST_DIV_SHIFT	15
-#define AR934X_PLL_CPU_DDR_CLK_CTRL_AHB_POST_DIV_MASK	0x1f
-#define AR934X_PLL_CPU_DDR_CLK_CTRL_CPUCLK_FROM_CPUPLL	BIT(20)
-#define AR934X_PLL_CPU_DDR_CLK_CTRL_DDRCLK_FROM_DDRPLL	BIT(21)
-#define AR934X_PLL_CPU_DDR_CLK_CTRL_AHBCLK_FROM_DDRPLL	BIT(24)
-
-#define QCA955X_PLL_CPU_CONFIG_REG		0x00
-#define QCA955X_PLL_DDR_CONFIG_REG		0x04
-#define QCA955X_PLL_CLK_CTRL_REG		0x08
-
-#define QCA955X_PLL_CPU_CONFIG_NFRAC_SHIFT	0
-#define QCA955X_PLL_CPU_CONFIG_NFRAC_MASK	0x3f
-#define QCA955X_PLL_CPU_CONFIG_NINT_SHIFT	6
-#define QCA955X_PLL_CPU_CONFIG_NINT_MASK	0x3f
-#define QCA955X_PLL_CPU_CONFIG_REFDIV_SHIFT	12
-#define QCA955X_PLL_CPU_CONFIG_REFDIV_MASK	0x1f
-#define QCA955X_PLL_CPU_CONFIG_OUTDIV_SHIFT	19
-#define QCA955X_PLL_CPU_CONFIG_OUTDIV_MASK	0x3
-
-#define QCA955X_PLL_DDR_CONFIG_NFRAC_SHIFT	0
-#define QCA955X_PLL_DDR_CONFIG_NFRAC_MASK	0x3ff
-#define QCA955X_PLL_DDR_CONFIG_NINT_SHIFT	10
-#define QCA955X_PLL_DDR_CONFIG_NINT_MASK	0x3f
-#define QCA955X_PLL_DDR_CONFIG_REFDIV_SHIFT	16
-#define QCA955X_PLL_DDR_CONFIG_REFDIV_MASK	0x1f
-#define QCA955X_PLL_DDR_CONFIG_OUTDIV_SHIFT	23
-#define QCA955X_PLL_DDR_CONFIG_OUTDIV_MASK	0x7
-
-#define QCA955X_PLL_CLK_CTRL_CPU_PLL_BYPASS		BIT(2)
-#define QCA955X_PLL_CLK_CTRL_DDR_PLL_BYPASS		BIT(3)
-#define QCA955X_PLL_CLK_CTRL_AHB_PLL_BYPASS		BIT(4)
-#define QCA955X_PLL_CLK_CTRL_CPU_POST_DIV_SHIFT		5
-#define QCA955X_PLL_CLK_CTRL_CPU_POST_DIV_MASK		0x1f
-#define QCA955X_PLL_CLK_CTRL_DDR_POST_DIV_SHIFT		10
-#define QCA955X_PLL_CLK_CTRL_DDR_POST_DIV_MASK		0x1f
-#define QCA955X_PLL_CLK_CTRL_AHB_POST_DIV_SHIFT		15
-#define QCA955X_PLL_CLK_CTRL_AHB_POST_DIV_MASK		0x1f
-#define QCA955X_PLL_CLK_CTRL_CPUCLK_FROM_CPUPLL		BIT(20)
-#define QCA955X_PLL_CLK_CTRL_DDRCLK_FROM_DDRPLL		BIT(21)
-#define QCA955X_PLL_CLK_CTRL_AHBCLK_FROM_DDRPLL		BIT(24)
-
-/*
- * USB_CONFIG block
- */
-#define AR71XX_USB_CTRL_REG_FLADJ	0x00
-#define AR71XX_USB_CTRL_REG_CONFIG	0x04
-
-/*
- * RESET block
- */
-#define AR71XX_RESET_REG_TIMER			0x00
-#define AR71XX_RESET_REG_TIMER_RELOAD		0x04
-#define AR71XX_RESET_REG_WDOG_CTRL		0x08
-#define AR71XX_RESET_REG_WDOG			0x0c
-#define AR71XX_RESET_REG_MISC_INT_STATUS	0x10
-#define AR71XX_RESET_REG_MISC_INT_ENABLE	0x14
-#define AR71XX_RESET_REG_PCI_INT_STATUS		0x18
-#define AR71XX_RESET_REG_PCI_INT_ENABLE		0x1c
-#define AR71XX_RESET_REG_GLOBAL_INT_STATUS	0x20
-#define AR71XX_RESET_REG_RESET_MODULE		0x24
-#define AR71XX_RESET_REG_PERFC_CTRL		0x2c
-#define AR71XX_RESET_REG_PERFC0			0x30
-#define AR71XX_RESET_REG_PERFC1			0x34
-#define AR71XX_RESET_REG_REV_ID			0x90
-
-#define AR913X_RESET_REG_GLOBAL_INT_STATUS	0x18
-#define AR913X_RESET_REG_RESET_MODULE		0x1c
-#define AR913X_RESET_REG_PERF_CTRL		0x20
-#define AR913X_RESET_REG_PERFC0			0x24
-#define AR913X_RESET_REG_PERFC1			0x28
-
-#define AR724X_RESET_REG_RESET_MODULE		0x1c
-
-#define AR933X_RESET_REG_RESET_MODULE		0x1c
-#define AR933X_RESET_REG_BOOTSTRAP		0xac
-
-#define AR934X_RESET_REG_RESET_MODULE		0x1c
-#define AR934X_RESET_REG_BOOTSTRAP		0xb0
-#define AR934X_RESET_REG_PCIE_WMAC_INT_STATUS	0xac
-
-#define QCA955X_RESET_REG_BOOTSTRAP		0xb0
-#define QCA955X_RESET_REG_EXT_INT_STATUS	0xac
-
-#define MISC_INT_ETHSW			BIT(12)
-#define MISC_INT_TIMER4			BIT(10)
-#define MISC_INT_TIMER3			BIT(9)
-#define MISC_INT_TIMER2			BIT(8)
-#define MISC_INT_DMA			BIT(7)
-#define MISC_INT_OHCI			BIT(6)
-#define MISC_INT_PERFC			BIT(5)
-#define MISC_INT_WDOG			BIT(4)
-#define MISC_INT_UART			BIT(3)
-#define MISC_INT_GPIO			BIT(2)
-#define MISC_INT_ERROR			BIT(1)
-#define MISC_INT_TIMER			BIT(0)
-
-#define AR71XX_RESET_EXTERNAL		BIT(28)
-#define AR71XX_RESET_FULL_CHIP		BIT(24)
-#define AR71XX_RESET_CPU_NMI		BIT(21)
-#define AR71XX_RESET_CPU_COLD		BIT(20)
-#define AR71XX_RESET_DMA		BIT(19)
-#define AR71XX_RESET_SLIC		BIT(18)
-#define AR71XX_RESET_STEREO		BIT(17)
-#define AR71XX_RESET_DDR		BIT(16)
-#define AR71XX_RESET_GE1_MAC		BIT(13)
-#define AR71XX_RESET_GE1_PHY		BIT(12)
-#define AR71XX_RESET_USBSUS_OVERRIDE	BIT(10)
-#define AR71XX_RESET_GE0_MAC		BIT(9)
-#define AR71XX_RESET_GE0_PHY		BIT(8)
-#define AR71XX_RESET_USB_OHCI_DLL	BIT(6)
-#define AR71XX_RESET_USB_HOST		BIT(5)
-#define AR71XX_RESET_USB_PHY		BIT(4)
-#define AR71XX_RESET_PCI_BUS		BIT(1)
-#define AR71XX_RESET_PCI_CORE		BIT(0)
-
-#define AR7240_RESET_USB_HOST		BIT(5)
-#define AR7240_RESET_OHCI_DLL		BIT(3)
-
-#define AR724X_RESET_GE1_MDIO		BIT(23)
-#define AR724X_RESET_GE0_MDIO		BIT(22)
-#define AR724X_RESET_PCIE_PHY_SERIAL	BIT(10)
-#define AR724X_RESET_PCIE_PHY		BIT(7)
-#define AR724X_RESET_PCIE		BIT(6)
-#define AR724X_RESET_USB_HOST		BIT(5)
-#define AR724X_RESET_USB_PHY		BIT(4)
-#define AR724X_RESET_USBSUS_OVERRIDE	BIT(3)
-
-#define AR913X_RESET_AMBA2WMAC		BIT(22)
-#define AR913X_RESET_USBSUS_OVERRIDE	BIT(10)
-#define AR913X_RESET_USB_HOST		BIT(5)
-#define AR913X_RESET_USB_PHY		BIT(4)
-
-#define AR933X_RESET_GE1_MDIO		BIT(23)
-#define AR933X_RESET_GE0_MDIO		BIT(22)
-#define AR933X_RESET_GE1_MAC		BIT(13)
-#define AR933X_RESET_WMAC		BIT(11)
-#define AR933X_RESET_GE0_MAC		BIT(9)
-#define AR933X_RESET_USB_HOST		BIT(5)
-#define AR933X_RESET_USB_PHY		BIT(4)
-#define AR933X_RESET_USBSUS_OVERRIDE	BIT(3)
-
-#define AR934X_RESET_HOST		BIT(31)
-#define AR934X_RESET_SLIC		BIT(30)
-#define AR934X_RESET_HDMA		BIT(29)
-#define AR934X_RESET_EXTERNAL		BIT(28)
-#define AR934X_RESET_RTC		BIT(27)
-#define AR934X_RESET_PCIE_EP_INT	BIT(26)
-#define AR934X_RESET_CHKSUM_ACC		BIT(25)
-#define AR934X_RESET_FULL_CHIP		BIT(24)
-#define AR934X_RESET_GE1_MDIO		BIT(23)
-#define AR934X_RESET_GE0_MDIO		BIT(22)
-#define AR934X_RESET_CPU_NMI		BIT(21)
-#define AR934X_RESET_CPU_COLD		BIT(20)
-#define AR934X_RESET_HOST_RESET_INT	BIT(19)
-#define AR934X_RESET_PCIE_EP		BIT(18)
-#define AR934X_RESET_UART1		BIT(17)
-#define AR934X_RESET_DDR		BIT(16)
-#define AR934X_RESET_USB_PHY_PLL_PWD_EXT BIT(15)
-#define AR934X_RESET_NANDF		BIT(14)
-#define AR934X_RESET_GE1_MAC		BIT(13)
-#define AR934X_RESET_ETH_SWITCH_ANALOG	BIT(12)
-#define AR934X_RESET_USB_PHY_ANALOG	BIT(11)
-#define AR934X_RESET_HOST_DMA_INT	BIT(10)
-#define AR934X_RESET_GE0_MAC		BIT(9)
-#define AR934X_RESET_ETH_SWITCH		BIT(8)
-#define AR934X_RESET_PCIE_PHY		BIT(7)
-#define AR934X_RESET_PCIE		BIT(6)
-#define AR934X_RESET_USB_HOST		BIT(5)
-#define AR934X_RESET_USB_PHY		BIT(4)
-#define AR934X_RESET_USBSUS_OVERRIDE	BIT(3)
-#define AR934X_RESET_LUT		BIT(2)
-#define AR934X_RESET_MBOX		BIT(1)
-#define AR934X_RESET_I2S		BIT(0)
-
-#define AR933X_BOOTSTRAP_MDIO_GPIO_EN	BIT(18)
-#define AR933X_BOOTSTRAP_EEPBUSY	BIT(4)
-#define AR933X_BOOTSTRAP_REF_CLK_40	BIT(0)
-
-#define AR934X_BOOTSTRAP_SW_OPTION8	BIT(23)
-#define AR934X_BOOTSTRAP_SW_OPTION7	BIT(22)
-#define AR934X_BOOTSTRAP_SW_OPTION6	BIT(21)
-#define AR934X_BOOTSTRAP_SW_OPTION5	BIT(20)
-#define AR934X_BOOTSTRAP_SW_OPTION4	BIT(19)
-#define AR934X_BOOTSTRAP_SW_OPTION3	BIT(18)
-#define AR934X_BOOTSTRAP_SW_OPTION2	BIT(17)
-#define AR934X_BOOTSTRAP_SW_OPTION1	BIT(16)
-#define AR934X_BOOTSTRAP_USB_MODE_DEVICE BIT(7)
-#define AR934X_BOOTSTRAP_PCIE_RC	BIT(6)
-#define AR934X_BOOTSTRAP_EJTAG_MODE	BIT(5)
-#define AR934X_BOOTSTRAP_REF_CLK_40	BIT(4)
-#define AR934X_BOOTSTRAP_BOOT_FROM_SPI	BIT(2)
-#define AR934X_BOOTSTRAP_SDRAM_DISABLED	BIT(1)
-#define AR934X_BOOTSTRAP_DDR1		BIT(0)
-
-#define QCA955X_BOOTSTRAP_REF_CLK_40	BIT(4)
-
-#define AR934X_PCIE_WMAC_INT_WMAC_MISC		BIT(0)
-#define AR934X_PCIE_WMAC_INT_WMAC_TX		BIT(1)
-#define AR934X_PCIE_WMAC_INT_WMAC_RXLP		BIT(2)
-#define AR934X_PCIE_WMAC_INT_WMAC_RXHP		BIT(3)
-#define AR934X_PCIE_WMAC_INT_PCIE_RC		BIT(4)
-#define AR934X_PCIE_WMAC_INT_PCIE_RC0		BIT(5)
-#define AR934X_PCIE_WMAC_INT_PCIE_RC1		BIT(6)
-#define AR934X_PCIE_WMAC_INT_PCIE_RC2		BIT(7)
-#define AR934X_PCIE_WMAC_INT_PCIE_RC3		BIT(8)
-#define AR934X_PCIE_WMAC_INT_WMAC_ALL \
-	(AR934X_PCIE_WMAC_INT_WMAC_MISC | AR934X_PCIE_WMAC_INT_WMAC_TX | \
-	 AR934X_PCIE_WMAC_INT_WMAC_RXLP | AR934X_PCIE_WMAC_INT_WMAC_RXHP)
-
-#define AR934X_PCIE_WMAC_INT_PCIE_ALL \
-	(AR934X_PCIE_WMAC_INT_PCIE_RC | AR934X_PCIE_WMAC_INT_PCIE_RC0 | \
-	 AR934X_PCIE_WMAC_INT_PCIE_RC1 | AR934X_PCIE_WMAC_INT_PCIE_RC2 | \
-	 AR934X_PCIE_WMAC_INT_PCIE_RC3)
-
-#define QCA955X_EXT_INT_WMAC_MISC		BIT(0)
-#define QCA955X_EXT_INT_WMAC_TX			BIT(1)
-#define QCA955X_EXT_INT_WMAC_RXLP		BIT(2)
-#define QCA955X_EXT_INT_WMAC_RXHP		BIT(3)
-#define QCA955X_EXT_INT_PCIE_RC1		BIT(4)
-#define QCA955X_EXT_INT_PCIE_RC1_INT0		BIT(5)
-#define QCA955X_EXT_INT_PCIE_RC1_INT1		BIT(6)
-#define QCA955X_EXT_INT_PCIE_RC1_INT2		BIT(7)
-#define QCA955X_EXT_INT_PCIE_RC1_INT3		BIT(8)
-#define QCA955X_EXT_INT_PCIE_RC2		BIT(12)
-#define QCA955X_EXT_INT_PCIE_RC2_INT0		BIT(13)
-#define QCA955X_EXT_INT_PCIE_RC2_INT1		BIT(14)
-#define QCA955X_EXT_INT_PCIE_RC2_INT2		BIT(15)
-#define QCA955X_EXT_INT_PCIE_RC2_INT3		BIT(16)
-#define QCA955X_EXT_INT_USB1			BIT(24)
-#define QCA955X_EXT_INT_USB2			BIT(28)
-
-#define QCA955X_EXT_INT_WMAC_ALL \
-	(QCA955X_EXT_INT_WMAC_MISC | QCA955X_EXT_INT_WMAC_TX | \
-	 QCA955X_EXT_INT_WMAC_RXLP | QCA955X_EXT_INT_WMAC_RXHP)
-
-#define QCA955X_EXT_INT_PCIE_RC1_ALL \
-	(QCA955X_EXT_INT_PCIE_RC1 | QCA955X_EXT_INT_PCIE_RC1_INT0 | \
-	 QCA955X_EXT_INT_PCIE_RC1_INT1 | QCA955X_EXT_INT_PCIE_RC1_INT2 | \
-	 QCA955X_EXT_INT_PCIE_RC1_INT3)
-
-#define QCA955X_EXT_INT_PCIE_RC2_ALL \
-	(QCA955X_EXT_INT_PCIE_RC2 | QCA955X_EXT_INT_PCIE_RC2_INT0 | \
-	 QCA955X_EXT_INT_PCIE_RC2_INT1 | QCA955X_EXT_INT_PCIE_RC2_INT2 | \
-	 QCA955X_EXT_INT_PCIE_RC2_INT3)
-
-#define REV_ID_MAJOR_MASK		0xfff0
-#define REV_ID_MAJOR_AR71XX		0x00a0
-#define REV_ID_MAJOR_AR913X		0x00b0
-#define REV_ID_MAJOR_AR7240		0x00c0
-#define REV_ID_MAJOR_AR7241		0x0100
-#define REV_ID_MAJOR_AR7242		0x1100
-#define REV_ID_MAJOR_AR9330		0x0110
-#define REV_ID_MAJOR_AR9331		0x1110
-#define REV_ID_MAJOR_AR9341		0x0120
-#define REV_ID_MAJOR_AR9342		0x1120
-#define REV_ID_MAJOR_AR9344		0x2120
-#define REV_ID_MAJOR_QCA9558		0x1130
-
-#define AR71XX_REV_ID_MINOR_MASK	0x3
-#define AR71XX_REV_ID_MINOR_AR7130	0x0
-#define AR71XX_REV_ID_MINOR_AR7141	0x1
-#define AR71XX_REV_ID_MINOR_AR7161	0x2
-#define AR71XX_REV_ID_REVISION_MASK	0x3
-#define AR71XX_REV_ID_REVISION_SHIFT	2
-
-#define AR913X_REV_ID_MINOR_MASK	0x3
-#define AR913X_REV_ID_MINOR_AR9130	0x0
-#define AR913X_REV_ID_MINOR_AR9132	0x1
-#define AR913X_REV_ID_REVISION_MASK	0x3
-#define AR913X_REV_ID_REVISION_SHIFT	2
-
-#define AR933X_REV_ID_REVISION_MASK	0x3
-
-#define AR724X_REV_ID_REVISION_MASK	0x3
-
-#define AR934X_REV_ID_REVISION_MASK     0xf
-
-#define AR944X_REV_ID_REVISION_MASK	0xf
-
-/*
- * SPI block
- */
-#define AR71XX_SPI_REG_FS	0x00	/* Function Select */
-#define AR71XX_SPI_REG_CTRL	0x04	/* SPI Control */
-#define AR71XX_SPI_REG_IOC	0x08	/* SPI I/O Control */
-#define AR71XX_SPI_REG_RDS	0x0c	/* Read Data Shift */
-
-#define AR71XX_SPI_FS_GPIO	BIT(0)	/* Enable GPIO mode */
-
-#define AR71XX_SPI_CTRL_RD	BIT(6)	/* Remap Disable */
-#define AR71XX_SPI_CTRL_DIV_MASK 0x3f
-
-#define AR71XX_SPI_IOC_DO	BIT(0)	/* Data Out pin */
-#define AR71XX_SPI_IOC_CLK	BIT(8)	/* CLK pin */
-#define AR71XX_SPI_IOC_CS(n)	BIT(16 + (n))
-#define AR71XX_SPI_IOC_CS0	AR71XX_SPI_IOC_CS(0)
-#define AR71XX_SPI_IOC_CS1	AR71XX_SPI_IOC_CS(1)
-#define AR71XX_SPI_IOC_CS2	AR71XX_SPI_IOC_CS(2)
-#define AR71XX_SPI_IOC_CS_ALL	(AR71XX_SPI_IOC_CS0 | AR71XX_SPI_IOC_CS1 | \
-				 AR71XX_SPI_IOC_CS2)
-
-/*
- * GPIO block
- */
-#define AR71XX_GPIO_REG_OE		0x00
-#define AR71XX_GPIO_REG_IN		0x04
-#define AR71XX_GPIO_REG_OUT		0x08
-#define AR71XX_GPIO_REG_SET		0x0c
-#define AR71XX_GPIO_REG_CLEAR		0x10
-#define AR71XX_GPIO_REG_INT_MODE	0x14
-#define AR71XX_GPIO_REG_INT_TYPE	0x18
-#define AR71XX_GPIO_REG_INT_POLARITY	0x1c
-#define AR71XX_GPIO_REG_INT_PENDING	0x20
-#define AR71XX_GPIO_REG_INT_ENABLE	0x24
-#define AR71XX_GPIO_REG_FUNC		0x28
-
-#define AR934X_GPIO_REG_OUT_FUNC0	0x2c
-#define AR934X_GPIO_REG_OUT_FUNC1	0x30
-#define AR934X_GPIO_REG_OUT_FUNC2	0x34
-#define AR934X_GPIO_REG_OUT_FUNC3	0x38
-#define AR934X_GPIO_REG_OUT_FUNC4	0x3c
-#define AR934X_GPIO_REG_OUT_FUNC5	0x40
-#define AR934X_GPIO_REG_FUNC		0x6c
-
-#define AR71XX_GPIO_COUNT		16
-#define AR724X_GPIO_COUNT		18
-#define AR913X_GPIO_COUNT		22
-#define AR933X_GPIO_COUNT		30
-#define AR934X_GPIO_COUNT		23
-#define QCA955X_GPIO_COUNT		24
-
-#define AR71XX_GPIO_FUNC_STEREO_EN		BIT(17)
-#define AR71XX_GPIO_FUNC_SLIC_EN		BIT(16)
-#define AR71XX_GPIO_FUNC_SPI_CS2_EN		BIT(13)
-#define AR71XX_GPIO_FUNC_SPI_CS1_EN		BIT(12)
-#define AR71XX_GPIO_FUNC_UART_EN		BIT(8)
-#define AR71XX_GPIO_FUNC_USB_OC_EN		BIT(4)
-#define AR71XX_GPIO_FUNC_USB_CLK_EN		BIT(0)
-
-#define AR724X_GPIO_FUNC_GE0_MII_CLK_EN		BIT(19)
-#define AR724X_GPIO_FUNC_SPI_EN			BIT(18)
-#define AR724X_GPIO_FUNC_SPI_CS_EN2		BIT(14)
-#define AR724X_GPIO_FUNC_SPI_CS_EN1		BIT(13)
-#define AR724X_GPIO_FUNC_CLK_OBS5_EN		BIT(12)
-#define AR724X_GPIO_FUNC_CLK_OBS4_EN		BIT(11)
-#define AR724X_GPIO_FUNC_CLK_OBS3_EN		BIT(10)
-#define AR724X_GPIO_FUNC_CLK_OBS2_EN		BIT(9)
-#define AR724X_GPIO_FUNC_CLK_OBS1_EN		BIT(8)
-#define AR724X_GPIO_FUNC_ETH_SWITCH_LED4_EN	BIT(7)
-#define AR724X_GPIO_FUNC_ETH_SWITCH_LED3_EN	BIT(6)
-#define AR724X_GPIO_FUNC_ETH_SWITCH_LED2_EN	BIT(5)
-#define AR724X_GPIO_FUNC_ETH_SWITCH_LED1_EN	BIT(4)
-#define AR724X_GPIO_FUNC_ETH_SWITCH_LED0_EN	BIT(3)
-#define AR724X_GPIO_FUNC_UART_RTS_CTS_EN	BIT(2)
-#define AR724X_GPIO_FUNC_UART_EN		BIT(1)
-#define AR724X_GPIO_FUNC_JTAG_DISABLE		BIT(0)
-
-#define AR913X_GPIO_FUNC_WMAC_LED_EN		BIT(22)
-#define AR913X_GPIO_FUNC_EXP_PORT_CS_EN		BIT(21)
-#define AR913X_GPIO_FUNC_I2S_REFCLKEN		BIT(20)
-#define AR913X_GPIO_FUNC_I2S_MCKEN		BIT(19)
-#define AR913X_GPIO_FUNC_I2S1_EN		BIT(18)
-#define AR913X_GPIO_FUNC_I2S0_EN		BIT(17)
-#define AR913X_GPIO_FUNC_SLIC_EN		BIT(16)
-#define AR913X_GPIO_FUNC_UART_RTSCTS_EN		BIT(9)
-#define AR913X_GPIO_FUNC_UART_EN		BIT(8)
-#define AR913X_GPIO_FUNC_USB_CLK_EN		BIT(4)
-
-#define AR933X_GPIO_FUNC_SPDIF2TCK		BIT(31)
-#define AR933X_GPIO_FUNC_SPDIF_EN		BIT(30)
-#define AR933X_GPIO_FUNC_I2SO_22_18_EN		BIT(29)
-#define AR933X_GPIO_FUNC_I2S_MCK_EN		BIT(27)
-#define AR933X_GPIO_FUNC_I2SO_EN		BIT(26)
-#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_DUPL	BIT(25)
-#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_COLL	BIT(24)
-#define AR933X_GPIO_FUNC_ETH_SWITCH_LED_ACT	BIT(23)
-#define AR933X_GPIO_FUNC_SPI_EN			BIT(18)
-#define AR933X_GPIO_FUNC_SPI_CS_EN2		BIT(14)
-#define AR933X_GPIO_FUNC_SPI_CS_EN1		BIT(13)
-#define AR933X_GPIO_FUNC_ETH_SWITCH_LED4_EN	BIT(7)
-#define AR933X_GPIO_FUNC_ETH_SWITCH_LED3_EN	BIT(6)
-#define AR933X_GPIO_FUNC_ETH_SWITCH_LED2_EN	BIT(5)
-#define AR933X_GPIO_FUNC_ETH_SWITCH_LED1_EN	BIT(4)
-#define AR933X_GPIO_FUNC_ETH_SWITCH_LED0_EN	BIT(3)
-#define AR933X_GPIO_FUNC_UART_RTS_CTS_EN	BIT(2)
-#define AR933X_GPIO_FUNC_UART_EN		BIT(1)
-#define AR933X_GPIO_FUNC_JTAG_DISABLE		BIT(0)
-
-#define AR934X_GPIO_FUNC_DDR_DQOE_EN	BIT(17)
-#define AR934X_GPIO_FUNC_SPI_CS_1_EN	BIT(14)
-#define AR934X_GPIO_FUNC_SPI_CS_0_EN	BIT(13)
-
-#define AR934X_GPIO_OUT_GPIO		0x00
-
-/*
- * MII_CTRL block
- */
-#define AR71XX_MII_REG_MII0_CTRL	0x00
-#define AR71XX_MII_REG_MII1_CTRL	0x04
-
-#define AR71XX_MII_CTRL_IF_MASK		3
-#define AR71XX_MII_CTRL_SPEED_SHIFT	4
-#define AR71XX_MII_CTRL_SPEED_MASK	3
-#define AR71XX_MII_CTRL_SPEED_10	0
-#define AR71XX_MII_CTRL_SPEED_100	1
-#define AR71XX_MII_CTRL_SPEED_1000	2
-
-#define AR71XX_MII0_CTRL_IF_GMII	0
-#define AR71XX_MII0_CTRL_IF_MII		1
-#define AR71XX_MII0_CTRL_IF_RGMII	2
-#define AR71XX_MII0_CTRL_IF_RMII	3
-
-#define AR71XX_MII1_CTRL_IF_RGMII	0
-#define AR71XX_MII1_CTRL_IF_RMII	1
-
-/*
- * AR933X GMAC interface
- */
-#define AR933X_GMAC_REG_ETH_CFG		0x00
-
-#define AR933X_ETH_CFG_RGMII_GE0	BIT(0)
-#define AR933X_ETH_CFG_MII_GE0		BIT(1)
-#define AR933X_ETH_CFG_GMII_GE0		BIT(2)
-#define AR933X_ETH_CFG_MII_GE0_MASTER	BIT(3)
-#define AR933X_ETH_CFG_MII_GE0_SLAVE	BIT(4)
-#define AR933X_ETH_CFG_MII_GE0_ERR_EN	BIT(5)
-#define AR933X_ETH_CFG_SW_PHY_SWAP	BIT(7)
-#define AR933X_ETH_CFG_SW_PHY_ADDR_SWAP	BIT(8)
-#define AR933X_ETH_CFG_RMII_GE0		BIT(9)
-#define AR933X_ETH_CFG_RMII_GE0_SPD_10	0
-#define AR933X_ETH_CFG_RMII_GE0_SPD_100	BIT(10)
-
-/*
- * AR934X GMAC Interface
- */
-#define AR934X_GMAC_REG_ETH_CFG		0x00
-
-#define AR934X_ETH_CFG_RGMII_GMAC0	BIT(0)
-#define AR934X_ETH_CFG_MII_GMAC0	BIT(1)
-#define AR934X_ETH_CFG_GMII_GMAC0	BIT(2)
-#define AR934X_ETH_CFG_MII_GMAC0_MASTER	BIT(3)
-#define AR934X_ETH_CFG_MII_GMAC0_SLAVE	BIT(4)
-#define AR934X_ETH_CFG_MII_GMAC0_ERR_EN	BIT(5)
-#define AR934X_ETH_CFG_SW_ONLY_MODE	BIT(6)
-#define AR934X_ETH_CFG_SW_PHY_SWAP	BIT(7)
-#define AR934X_ETH_CFG_SW_APB_ACCESS	BIT(9)
-#define AR934X_ETH_CFG_RMII_GMAC0	BIT(10)
-#define AR933X_ETH_CFG_MII_CNTL_SPEED	BIT(11)
-#define AR934X_ETH_CFG_RMII_GMAC0_MASTER BIT(12)
-#define AR933X_ETH_CFG_SW_ACC_MSB_FIRST	BIT(13)
-
-/*
- * QCA955X GMAC Interface
- */
-
-#define QCA955X_GMAC_REG_ETH_CFG	0x00
-
-#define QCA955X_ETH_CFG_RGMII_GMAC0	BIT(0)
-#define QCA955X_ETH_CFG_SGMII_GMAC0	BIT(6)
-
-#endif /* __ASM_MACH_AR71XX_REGS_H */
diff --git a/target/linux/lantiq/image/lzma-loader/src/board-ar71xx.c b/target/linux/lantiq/image/lzma-loader/src/board-ar71xx.c
deleted file mode 100644
index 2f4dd6b1f6..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/board-ar71xx.c
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * LZMA compressed kernel loader for Atheros AR7XXX/AR9XXX based boards
- *
- * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- */
-
-#include <stddef.h>
-#include "config.h"
-#include "ar71xx_regs.h"
-
-#define READREG(r)	*(volatile unsigned int *)(r)
-#define WRITEREG(r,v)	*(volatile unsigned int *)(r) = v
-
-#define KSEG1ADDR(_x)	(((_x) & 0x1fffffff) | 0xa0000000)
-
-#define UART_BASE	0xb8020000
-
-#define UART_TX		0
-#define UART_LSR	5
-
-#define UART_LSR_THRE   0x20
-
-#define UART_READ(r)		READREG(UART_BASE + 4 * (r))
-#define UART_WRITE(r,v)		WRITEREG(UART_BASE + 4 * (r), (v))
-
-void board_putc(int ch)
-{
-	while (((UART_READ(UART_LSR)) & UART_LSR_THRE) == 0);
-	UART_WRITE(UART_TX, ch);
-	while (((UART_READ(UART_LSR)) & UART_LSR_THRE) == 0);
-}
-
-#ifdef CONFIG_BOARD_TL_WR1043ND_V1
-static void tlwr1043nd_init(void)
-{
-	unsigned int reg = KSEG1ADDR(AR71XX_RESET_BASE);
-	unsigned int t;
-
-	t = READREG(reg + AR913X_RESET_REG_RESET_MODULE);
-	t |= AR71XX_RESET_GE0_PHY;
-	WRITEREG(reg + AR913X_RESET_REG_RESET_MODULE, t);
-	/* flush write */
-	t = READREG(reg + AR913X_RESET_REG_RESET_MODULE);
-}
-#else
-static inline void tlwr1043nd_init(void) {}
-#endif
-
-void board_init(void)
-{
-	tlwr1043nd_init();
-}
diff --git a/target/linux/lantiq/image/lzma-loader/src/board-lantiq.c b/target/linux/lantiq/image/lzma-loader/src/board-lantiq.c
deleted file mode 100644
index b1b4373493..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/board-lantiq.c
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Arch specific code for Lantiq based boards
- *
- * Copyright (C) 2013 John Crispin <blogic@openwrt.org>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- */
-
-#include <stddef.h>
-#include "config.h"
-
-#define READREG(r)		*(volatile unsigned int *)(r)
-#define WRITEREG(r,v)		*(volatile unsigned int *)(r) = v
-
-#define UART_BASE		0xbe100c00
-#define ASC_TBUF		(UART_BASE | 0x20)
-#define ASC_FSTAT		(UART_BASE | 0x48)
-
-#define TXMASK          0x3F00
-#define TXOFFSET        8
-
-void board_putc(char c)
-{
-	while ((READREG(ASC_FSTAT) & TXMASK) >> TXOFFSET);
-
-	WRITEREG(ASC_TBUF, c);
-}
-
-void board_init(void)
-{
-}
diff --git a/target/linux/lantiq/image/lzma-loader/src/board-ralink.c b/target/linux/lantiq/image/lzma-loader/src/board-ralink.c
deleted file mode 100644
index 7c947ec6eb..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/board-ralink.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Arch specific code for Ralink based boards
- *
- * Copyright (C) 2013 John Crispin <blogic@openwrt.org>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- */
-
-#include <stddef.h>
-#include "config.h"
-
-#define READREG(r)		*(volatile unsigned int *)(r)
-#define WRITEREG(r,v)		*(volatile unsigned int *)(r) = v
-
-#define KSEG1ADDR(_x)		(((_x) & 0x1fffffff) | 0xa0000000)
-
-#ifdef CONFIG_SOC_RT288X
-#define UART_BASE		0xb0300c00
-#else
-#define UART_BASE		0xb0000c00
-#endif
-
-#define UART_TX			1
-#define UART_LSR		7
-
-#define UART_LSR_THRE		0x20
-
-#define UART_READ(r)		READREG(UART_BASE + 4 * (r))
-#define UART_WRITE(r,v)		WRITEREG(UART_BASE + 4 * (r), (v))
-
-void board_putc(int ch)
-{
-	while (((UART_READ(UART_LSR)) & UART_LSR_THRE) == 0);
-	UART_WRITE(UART_TX, ch);
-	while (((UART_READ(UART_LSR)) & UART_LSR_THRE) == 0);
-}
-
-void board_init(void)
-{
-}
diff --git a/target/linux/lantiq/image/lzma-loader/src/cache.c b/target/linux/lantiq/image/lzma-loader/src/cache.c
deleted file mode 100644
index 28cc848333..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/cache.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * LZMA compressed kernel loader for Atheros AR7XXX/AR9XXX based boards
- *
- * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
- *
- * The cache manipulation routine has been taken from the U-Boot project.
- *	(C) Copyright 2003
- *	Wolfgang Denk, DENX Software Engineering, <wd@denx.de>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- *
- */
-
-#include "cache.h"
-#include "cacheops.h"
-#include "config.h"
-
-#define cache_op(op,addr)						\
-	__asm__ __volatile__(						\
-	"	.set	push					\n"	\
-	"	.set	noreorder				\n"	\
-	"	.set	mips3\n\t				\n"	\
-	"	cache	%0, %1					\n"	\
-	"	.set	pop					\n"	\
-	:								\
-	: "i" (op), "R" (*(unsigned char *)(addr)))
-
-void flush_cache(unsigned long start_addr, unsigned long size)
-{
-	unsigned long lsize = CONFIG_CACHELINE_SIZE;
-	unsigned long addr = start_addr & ~(lsize - 1);
-	unsigned long aend = (start_addr + size - 1) & ~(lsize - 1);
-
-	while (1) {
-		cache_op(Hit_Writeback_Inv_D, addr);
-		cache_op(Hit_Invalidate_I, addr);
-		if (addr == aend)
-			break;
-		addr += lsize;
-	}
-}
diff --git a/target/linux/lantiq/image/lzma-loader/src/cache.h b/target/linux/lantiq/image/lzma-loader/src/cache.h
deleted file mode 100644
index 506a235884..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/cache.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/*
- * LZMA compressed kernel loader for Atheros AR7XXX/AR9XXX based boards
- *
- * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- *
- */
-
-#ifndef __CACHE_H
-#define __CACHE_H
-
-void flush_cache(unsigned long start_addr, unsigned long size);
-
-#endif /* __CACHE_H */
diff --git a/target/linux/lantiq/image/lzma-loader/src/cacheops.h b/target/linux/lantiq/image/lzma-loader/src/cacheops.h
deleted file mode 100644
index 70bcad7694..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/cacheops.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Cache operations for the cache instruction.
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * (C) Copyright 1996, 97, 99, 2002, 03 Ralf Baechle
- * (C) Copyright 1999 Silicon Graphics, Inc.
- */
-#ifndef	__ASM_CACHEOPS_H
-#define	__ASM_CACHEOPS_H
-
-/*
- * Cache Operations available on all MIPS processors with R4000-style caches
- */
-#define Index_Invalidate_I      0x00
-#define Index_Writeback_Inv_D   0x01
-#define Index_Load_Tag_I	0x04
-#define Index_Load_Tag_D	0x05
-#define Index_Store_Tag_I	0x08
-#define Index_Store_Tag_D	0x09
-#if defined(CONFIG_CPU_LOONGSON2)
-#define Hit_Invalidate_I	0x00
-#else
-#define Hit_Invalidate_I	0x10
-#endif
-#define Hit_Invalidate_D	0x11
-#define Hit_Writeback_Inv_D	0x15
-
-/*
- * R4000-specific cacheops
- */
-#define Create_Dirty_Excl_D	0x0d
-#define Fill			0x14
-#define Hit_Writeback_I		0x18
-#define Hit_Writeback_D		0x19
-
-/*
- * R4000SC and R4400SC-specific cacheops
- */
-#define Index_Invalidate_SI     0x02
-#define Index_Writeback_Inv_SD  0x03
-#define Index_Load_Tag_SI	0x06
-#define Index_Load_Tag_SD	0x07
-#define Index_Store_Tag_SI	0x0A
-#define Index_Store_Tag_SD	0x0B
-#define Create_Dirty_Excl_SD	0x0f
-#define Hit_Invalidate_SI	0x12
-#define Hit_Invalidate_SD	0x13
-#define Hit_Writeback_Inv_SD	0x17
-#define Hit_Writeback_SD	0x1b
-#define Hit_Set_Virtual_SI	0x1e
-#define Hit_Set_Virtual_SD	0x1f
-
-/*
- * R5000-specific cacheops
- */
-#define R5K_Page_Invalidate_S	0x17
-
-/*
- * RM7000-specific cacheops
- */
-#define Page_Invalidate_T	0x16
-
-/*
- * R10000-specific cacheops
- *
- * Cacheops 0x02, 0x06, 0x0a, 0x0c-0x0e, 0x16, 0x1a and 0x1e are unused.
- * Most of the _S cacheops are identical to the R4000SC _SD cacheops.
- */
-#define Index_Writeback_Inv_S	0x03
-#define Index_Load_Tag_S	0x07
-#define Index_Store_Tag_S	0x0B
-#define Hit_Invalidate_S	0x13
-#define Cache_Barrier		0x14
-#define Hit_Writeback_Inv_S	0x17
-#define Index_Load_Data_I	0x18
-#define Index_Load_Data_D	0x19
-#define Index_Load_Data_S	0x1b
-#define Index_Store_Data_I	0x1c
-#define Index_Store_Data_D	0x1d
-#define Index_Store_Data_S	0x1f
-
-#endif	/* __ASM_CACHEOPS_H */
diff --git a/target/linux/lantiq/image/lzma-loader/src/config.h b/target/linux/lantiq/image/lzma-loader/src/config.h
deleted file mode 100644
index b7719e9ca8..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/config.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * LZMA compressed kernel loader for Atheros AR7XXX/AR9XXX based boards
- *
- * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- *
- */
-
-#ifndef _CONFIG_H_
-#define _CONFIG_H_
-
-#ifndef CONFIG_FLASH_OFFS
-#define CONFIG_FLASH_OFFS	0
-#endif
-
-#ifndef CONFIG_FLASH_MAX
-#define CONFIG_FLASH_MAX	0
-#endif
-
-#ifndef CONFIG_FLASH_STEP
-#define CONFIG_FLASH_STEP	0x1000
-#endif
-
-#endif /* _CONFIG_H_ */
diff --git a/target/linux/lantiq/image/lzma-loader/src/cp0regdef.h b/target/linux/lantiq/image/lzma-loader/src/cp0regdef.h
deleted file mode 100644
index c1188ad8c8..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/cp0regdef.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 1994, 1995, 1996, 1997, 2000, 2001 by Ralf Baechle
- *
- * Copyright (C) 2001, Monta Vista Software
- * Author: jsun@mvista.com or jsun@junsun.net
- */
-#ifndef _cp0regdef_h_
-#define _cp0regdef_h_
-
-#define CP0_INDEX $0
-#define CP0_RANDOM $1
-#define CP0_ENTRYLO0 $2
-#define CP0_ENTRYLO1 $3
-#define CP0_CONTEXT $4
-#define CP0_PAGEMASK $5
-#define CP0_WIRED $6
-#define CP0_BADVADDR $8
-#define CP0_COUNT $9
-#define CP0_ENTRYHI $10
-#define CP0_COMPARE $11
-#define CP0_STATUS $12
-#define CP0_CAUSE $13
-#define CP0_EPC $14
-#define CP0_PRID $15
-#define CP0_CONFIG $16
-#define CP0_LLADDR $17
-#define CP0_WATCHLO $18
-#define CP0_WATCHHI $19
-#define CP0_XCONTEXT $20
-#define CP0_FRAMEMASK $21
-#define CP0_DIAGNOSTIC $22
-#define CP0_PERFORMANCE $25
-#define CP0_ECC $26
-#define CP0_CACHEERR $27
-#define CP0_TAGLO $28
-#define CP0_TAGHI $29
-#define CP0_ERROREPC $30
-
-#endif
diff --git a/target/linux/lantiq/image/lzma-loader/src/head.S b/target/linux/lantiq/image/lzma-loader/src/head.S
deleted file mode 100644
index 543996a0da..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/head.S
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * LZMA compressed kernel loader for Atheros AR7XXX/AR9XXX based boards
- *
- * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
- *
- * Some parts of this code was based on the OpenWrt specific lzma-loader
- * for the BCM47xx and ADM5120 based boards:
- *	Copyright (C) 2004 Manuel Novoa III (mjn3@codepoet.org)
- *	Copyright (C) 2005 by Oleg I. Vdovikin <oleg@cs.msu.su>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- */
-
-#include <asm/asm.h>
-#include <asm/regdef.h>
-#include "cp0regdef.h"
-#include "cacheops.h"
-#include "config.h"
-
-#define KSEG0		0x80000000
-
-	.macro	ehb
-	sll     zero, 3
-	.endm
-
-	.text
-
-LEAF(startup)
-	.set noreorder
-	.set mips32
-
-	mtc0	zero, CP0_WATCHLO	# clear watch registers
-	mtc0	zero, CP0_WATCHHI
-	mtc0	zero, CP0_CAUSE		# clear before writing status register
-
-	mfc0	t0, CP0_STATUS
-	li	t1, 0x1000001f
-	or	t0, t1
-	xori	t0, 0x1f
-	mtc0	t0, CP0_STATUS
-	ehb
-
-	mtc0	zero, CP0_COUNT
-	mtc0	zero, CP0_COMPARE
-	ehb
-
-	la	t0, __reloc_label	# get linked address of label
-	bal	__reloc_label		# branch and link to label to
-	nop				# get actual address
-__reloc_label:
-	subu	t0, ra, t0		# get reloc_delta
-
-	beqz	t0, __reloc_done         # if delta is 0 we are in the right place
-	nop
-
-	/* Copy our code to the right place */
-	la	t1, _code_start		# get linked address of _code_start
-	la	t2, _code_end		# get linked address of _code_end
-	addu	t0, t0, t1		# calculate actual address of _code_start
-
-__reloc_copy:
-	lw	t3, 0(t0)
-	sw	t3, 0(t1)
-	add	t1, 4
-	blt	t1, t2, __reloc_copy
-	add	t0, 4
-
-	/* flush cache */
-	la	t0, _code_start
-	la	t1, _code_end
-
-	li	t2, ~(CONFIG_CACHELINE_SIZE - 1)
-	and	t0, t2
-	and	t1, t2
-	li	t2, CONFIG_CACHELINE_SIZE
-
-	b	__flush_check
-	nop
-
-__flush_line:
-	cache	Hit_Writeback_Inv_D, 0(t0)
-	cache	Hit_Invalidate_I, 0(t0)
-	add	t0, t2
-
-__flush_check:
-	bne	t0, t1, __flush_line
-	nop
-
-	sync
-
-__reloc_done:
-
-	/* clear bss */
-	la	t0, _bss_start
-	la	t1, _bss_end
-	b	__bss_check
-	nop
-
-__bss_fill:
-	sw	zero, 0(t0)
-	addi	t0, 4
-
-__bss_check:
-	bne	t0, t1, __bss_fill
-	nop
-
-	/* Setup new "C" stack */
-	la	sp, _stack
-
-	/* jump to the decompressor routine */
-	la	t0, loader_main
-	jr	t0
-	nop
-
-	.set reorder
-END(startup)
diff --git a/target/linux/lantiq/image/lzma-loader/src/lantiq.mk b/target/linux/lantiq/image/lzma-loader/src/lantiq.mk
deleted file mode 100644
index 413764593b..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/lantiq.mk
+++ /dev/null
@@ -1 +0,0 @@
-CACHE_FLAGS+=-DCONFIG_ICACHE_SIZE="(32 * 1024)" -DCONFIG_DCACHE_SIZE="(32 * 1024)" -DCONFIG_CACHELINE_SIZE=32
diff --git a/target/linux/lantiq/image/lzma-loader/src/loader.c b/target/linux/lantiq/image/lzma-loader/src/loader.c
deleted file mode 100644
index 1d42bfa2f7..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/loader.c
+++ /dev/null
@@ -1,263 +0,0 @@
-/*
- * LZMA compressed kernel loader for Atheros AR7XXX/AR9XXX based boards
- *
- * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
- *
- * Some parts of this code was based on the OpenWrt specific lzma-loader
- * for the BCM47xx and ADM5120 based boards:
- *	Copyright (C) 2004 Manuel Novoa III (mjn3@codepoet.org)
- *	Copyright (C) 2005 Mineharu Takahara <mtakahar@yahoo.com>
- *	Copyright (C) 2005 by Oleg I. Vdovikin <oleg@cs.msu.su>
- *
- * The image_header structure has been taken from the U-Boot project.
- *	(C) Copyright 2008 Semihalf
- *	(C) Copyright 2000-2005
- *	Wolfgang Denk, DENX Software Engineering, wd@denx.de.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- */
-
-#include <stddef.h>
-#include <stdint.h>
-
-#include "config.h"
-#include "cache.h"
-#include "printf.h"
-#include "LzmaDecode.h"
-
-#define AR71XX_FLASH_START	0x1f000000
-#define AR71XX_FLASH_END	0x1fe00000
-
-#define KSEG0			0x80000000
-#define KSEG1			0xa0000000
-
-#define KSEG1ADDR(a)		((((unsigned)(a)) & 0x1fffffffU) | KSEG1)
-
-#undef LZMA_DEBUG
-
-#ifdef LZMA_DEBUG
-#  define DBG(f, a...)	printf(f, ## a)
-#else
-#  define DBG(f, a...)	do {} while (0)
-#endif
-
-#define IH_MAGIC_OKLI		0x4f4b4c49	/* 'OKLI' */
-
-#define IH_NMLEN		32	/* Image Name Length		*/
-
-typedef struct image_header {
-	uint32_t	ih_magic;	/* Image Header Magic Number	*/
-	uint32_t	ih_hcrc;	/* Image Header CRC Checksum	*/
-	uint32_t	ih_time;	/* Image Creation Timestamp	*/
-	uint32_t	ih_size;	/* Image Data Size		*/
-	uint32_t	ih_load;	/* Data	 Load  Address		*/
-	uint32_t	ih_ep;		/* Entry Point Address		*/
-	uint32_t	ih_dcrc;	/* Image Data CRC Checksum	*/
-	uint8_t		ih_os;		/* Operating System		*/
-	uint8_t		ih_arch;	/* CPU architecture		*/
-	uint8_t		ih_type;	/* Image Type			*/
-	uint8_t		ih_comp;	/* Compression Type		*/
-	uint8_t		ih_name[IH_NMLEN];	/* Image Name		*/
-} image_header_t;
-
-/* beyond the image end, size not known in advance */
-extern unsigned char workspace[];
-extern void board_init(void);
-
-static CLzmaDecoderState lzma_state;
-static unsigned char *lzma_data;
-static unsigned long lzma_datasize;
-static unsigned long lzma_outsize;
-static unsigned long kernel_la;
-
-#ifdef CONFIG_KERNEL_CMDLINE
-#define kernel_argc	1
-static const char kernel_cmdline[] = CONFIG_KERNEL_CMDLINE;
-static const char *kernel_argv[] = {
-	kernel_cmdline,
-	NULL,
-};
-#endif /* CONFIG_KERNEL_CMDLINE */
-
-static void halt(void)
-{
-	printf("\nSystem halted!\n");
-	for(;;);
-}
-
-static __inline__ unsigned long get_be32(void *buf)
-{
-	unsigned char *p = buf;
-
-	return (((unsigned long) p[0] << 24) +
-	        ((unsigned long) p[1] << 16) +
-	        ((unsigned long) p[2] << 8) +
-	        (unsigned long) p[3]);
-}
-
-static __inline__ unsigned char lzma_get_byte(void)
-{
-	unsigned char c;
-
-	lzma_datasize--;
-	c = *lzma_data++;
-
-	return c;
-}
-
-static int lzma_init_props(void)
-{
-	unsigned char props[LZMA_PROPERTIES_SIZE];
-	int res;
-	int i;
-
-	/* read lzma properties */
-	for (i = 0; i < LZMA_PROPERTIES_SIZE; i++)
-		props[i] = lzma_get_byte();
-
-	/* read the lower half of uncompressed size in the header */
-	lzma_outsize = ((SizeT) lzma_get_byte()) +
-		       ((SizeT) lzma_get_byte() << 8) +
-		       ((SizeT) lzma_get_byte() << 16) +
-		       ((SizeT) lzma_get_byte() << 24);
-
-	/* skip rest of the header (upper half of uncompressed size) */
-	for (i = 0; i < 4; i++)
-		lzma_get_byte();
-
-	res = LzmaDecodeProperties(&lzma_state.Properties, props,
-					LZMA_PROPERTIES_SIZE);
-	return res;
-}
-
-static int lzma_decompress(unsigned char *outStream)
-{
-	SizeT ip, op;
-	int ret;
-
-	lzma_state.Probs = (CProb *) workspace;
-
-	ret = LzmaDecode(&lzma_state, lzma_data, lzma_datasize, &ip, outStream,
-			 lzma_outsize, &op);
-
-	if (ret != LZMA_RESULT_OK) {
-		int i;
-
-		DBG("LzmaDecode error %d at %08x, osize:%d ip:%d op:%d\n",
-		    ret, lzma_data + ip, lzma_outsize, ip, op);
-
-		for (i = 0; i < 16; i++)
-			DBG("%02x ", lzma_data[ip + i]);
-
-		DBG("\n");
-	}
-
-	return ret;
-}
-
-#if (LZMA_WRAPPER)
-static void lzma_init_data(void)
-{
-	extern unsigned char _lzma_data_start[];
-	extern unsigned char _lzma_data_end[];
-
-	kernel_la = LOADADDR;
-	lzma_data = _lzma_data_start;
-	lzma_datasize = _lzma_data_end - _lzma_data_start;
-}
-#else
-static void lzma_init_data(void)
-{
-	struct image_header *hdr = NULL;
-	unsigned char *flash_base;
-	unsigned long flash_ofs;
-	unsigned long kernel_ofs;
-	unsigned long kernel_size;
-
-	flash_base = (unsigned char *) KSEG1ADDR(AR71XX_FLASH_START);
-
-	printf("Looking for OpenWrt image... ");
-
-	for (flash_ofs = CONFIG_FLASH_OFFS;
-	     flash_ofs <= (CONFIG_FLASH_OFFS + CONFIG_FLASH_MAX);
-	     flash_ofs += CONFIG_FLASH_STEP) {
-		unsigned long magic;
-		unsigned char *p;
-
-		p = flash_base + flash_ofs;
-		magic = get_be32(p);
-		if (magic == IH_MAGIC_OKLI) {
-			hdr = (struct image_header *) p;
-			break;
-		}
-	}
-
-	if (hdr == NULL) {
-		printf("not found!\n");
-		halt();
-	}
-
-	printf("found at 0x%08x\n", flash_base + flash_ofs);
-
-	kernel_ofs = sizeof(struct image_header);
-	kernel_size = get_be32(&hdr->ih_size);
-	kernel_la = get_be32(&hdr->ih_load);
-
-	lzma_data = flash_base + flash_ofs + kernel_ofs;
-	lzma_datasize = kernel_size;
-}
-#endif /* (LZMA_WRAPPER) */
-
-void loader_main(unsigned long reg_a0, unsigned long reg_a1,
-		 unsigned long reg_a2, unsigned long reg_a3)
-{
-	void (*kernel_entry) (unsigned long, unsigned long, unsigned long,
-			      unsigned long);
-	int res;
-
-	board_init();
-
-	printf("\n\nOpenWrt kernel loader for MIPS based SoC\n");
-	printf("Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>\n");
-
-	lzma_init_data();
-
-	res = lzma_init_props();
-	if (res != LZMA_RESULT_OK) {
-		printf("Incorrect LZMA stream properties!\n");
-		halt();
-	}
-
-	printf("Decompressing kernel... ");
-
-	res = lzma_decompress((unsigned char *) kernel_la);
-	if (res != LZMA_RESULT_OK) {
-		printf("failed, ");
-		switch (res) {
-		case LZMA_RESULT_DATA_ERROR:
-			printf("data error!\n");
-			break;
-		default:
-			printf("unknown error %d!\n", res);
-		}
-		halt();
-	} else {
-		printf("done!\n");
-	}
-
-	flush_cache(kernel_la, lzma_outsize);
-
-	printf("Starting kernel at %08x...\n\n", kernel_la);
-
-#ifdef CONFIG_KERNEL_CMDLINE
-	reg_a0 = kernel_argc;
-	reg_a1 = (unsigned long) kernel_argv;
-	reg_a2 = 0;
-	reg_a3 = 0;
-#endif
-
-	kernel_entry = (void *) kernel_la;
-	kernel_entry(reg_a0, reg_a1, reg_a2, reg_a3);
-}
diff --git a/target/linux/lantiq/image/lzma-loader/src/loader.lds b/target/linux/lantiq/image/lzma-loader/src/loader.lds
deleted file mode 100644
index 80cc7ca3ec..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/loader.lds
+++ /dev/null
@@ -1,35 +0,0 @@
-OUTPUT_ARCH(mips)
-SECTIONS {
-	.text : {
-		_code_start = .;
-		*(.text)
-		*(.text.*)
-		*(.rodata)
-		*(.rodata.*)
-		*(.data.lzma)
-	}
-
-	. = ALIGN(32);
-	.data : {
-		*(.data)
-		*(.data.*)
-		. = . + 524288;		/* workaround for buggy bootloaders */
-	}
-
-	. = ALIGN(32);
-	_code_end = .;
-
-	_bss_start = .;
-	.bss : {
-		*(.bss)
-		*(.bss.*)
-	}
-
-	. = ALIGN(32);
-	_bss_end = .;
-
-	. = . + 8192;
-	_stack = .;
-
-	workspace = .;
-}
diff --git a/target/linux/lantiq/image/lzma-loader/src/loader2.lds b/target/linux/lantiq/image/lzma-loader/src/loader2.lds
deleted file mode 100644
index db0bb46424..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/loader2.lds
+++ /dev/null
@@ -1,10 +0,0 @@
-OUTPUT_ARCH(mips)
-SECTIONS {
-	.text : {
-		startup = .;
-		*(.text)
-		*(.text.*)
-		*(.data)
-		*(.data.*)
-	}
-}
diff --git a/target/linux/lantiq/image/lzma-loader/src/lzma-data.lds b/target/linux/lantiq/image/lzma-loader/src/lzma-data.lds
deleted file mode 100644
index abf756ba13..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/lzma-data.lds
+++ /dev/null
@@ -1,8 +0,0 @@
-OUTPUT_ARCH(mips)
-SECTIONS {
-	.data.lzma : {
-		_lzma_data_start = .;
-		*(.data)
-		_lzma_data_end = .;
-	}
-}
diff --git a/target/linux/lantiq/image/lzma-loader/src/printf.c b/target/linux/lantiq/image/lzma-loader/src/printf.c
deleted file mode 100644
index 7bb5a86e18..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/printf.c
+++ /dev/null
@@ -1,350 +0,0 @@
-/*
- * Copyright (C) 2001 MontaVista Software Inc.
- * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- *
- */
-
-#include	"printf.h"
-
-extern void board_putc(int ch);
-
-/* this is the maximum width for a variable */
-#define		LP_MAX_BUF	256
-
-/* macros */
-#define		IsDigit(x)	( ((x) >= '0') && ((x) <= '9') )
-#define		Ctod(x)		( (x) - '0')
-
-/* forward declaration */
-static int PrintChar(char *, char, int, int);
-static int PrintString(char *, char *, int, int);
-static int PrintNum(char *, unsigned long, int, int, int, int, char, int);
-
-/* private variable */
-static const char theFatalMsg[] = "fatal error in lp_Print!";
-
-/* -*-
- * A low level printf() function.
- */
-static void
-lp_Print(void (*output)(void *, char *, int),
-	 void * arg,
-	 char *fmt,
-	 va_list ap)
-{
-
-#define 	OUTPUT(arg, s, l)  \
-  { if (((l) < 0) || ((l) > LP_MAX_BUF)) { \
-       (*output)(arg, (char*)theFatalMsg, sizeof(theFatalMsg)-1); for(;;); \
-    } else { \
-      (*output)(arg, s, l); \
-    } \
-  }
-
-    char buf[LP_MAX_BUF];
-
-    char c;
-    char *s;
-    long int num;
-
-    int longFlag;
-    int negFlag;
-    int width;
-    int prec;
-    int ladjust;
-    char padc;
-
-    int length;
-
-    for(;;) {
-	{
-	    /* scan for the next '%' */
-	    char *fmtStart = fmt;
-	    while ( (*fmt != '\0') && (*fmt != '%')) {
-		fmt ++;
-	    }
-
-	    /* flush the string found so far */
-	    OUTPUT(arg, fmtStart, fmt-fmtStart);
-
-	    /* are we hitting the end? */
-	    if (*fmt == '\0') break;
-	}
-
-	/* we found a '%' */
-	fmt ++;
-
-	/* check for long */
-	if (*fmt == 'l') {
-	    longFlag = 1;
-	    fmt ++;
-	} else {
-	    longFlag = 0;
-	}
-
-	/* check for other prefixes */
-	width = 0;
-	prec = -1;
-	ladjust = 0;
-	padc = ' ';
-
-	if (*fmt == '-') {
-	    ladjust = 1;
-	    fmt ++;
-	}
-
-	if (*fmt == '0') {
-	    padc = '0';
-	    fmt++;
-	}
-
-	if (IsDigit(*fmt)) {
-	    while (IsDigit(*fmt)) {
-		width = 10 * width + Ctod(*fmt++);
-	    }
-	}
-
-	if (*fmt == '.') {
-	    fmt ++;
-	    if (IsDigit(*fmt)) {
-		prec = 0;
-		while (IsDigit(*fmt)) {
-		    prec = prec*10 + Ctod(*fmt++);
-		}
-	    }
-	}
-
-
-	/* check format flag */
-	negFlag = 0;
-	switch (*fmt) {
-	 case 'b':
-	    if (longFlag) {
-		num = va_arg(ap, long int);
-	    } else {
-		num = va_arg(ap, int);
-	    }
-	    length = PrintNum(buf, num, 2, 0, width, ladjust, padc, 0);
-	    OUTPUT(arg, buf, length);
-	    break;
-
-	 case 'd':
-	 case 'D':
-	    if (longFlag) {
-		num = va_arg(ap, long int);
-	    } else {
-		num = va_arg(ap, int);
-	    }
-	    if (num < 0) {
-		num = - num;
-		negFlag = 1;
-	    }
-	    length = PrintNum(buf, num, 10, negFlag, width, ladjust, padc, 0);
-	    OUTPUT(arg, buf, length);
-	    break;
-
-	 case 'o':
-	 case 'O':
-	    if (longFlag) {
-		num = va_arg(ap, long int);
-	    } else {
-		num = va_arg(ap, int);
-	    }
-	    length = PrintNum(buf, num, 8, 0, width, ladjust, padc, 0);
-	    OUTPUT(arg, buf, length);
-	    break;
-
-	 case 'u':
-	 case 'U':
-	    if (longFlag) {
-		num = va_arg(ap, long int);
-	    } else {
-		num = va_arg(ap, int);
-	    }
-	    length = PrintNum(buf, num, 10, 0, width, ladjust, padc, 0);
-	    OUTPUT(arg, buf, length);
-	    break;
-
-	 case 'x':
-	    if (longFlag) {
-		num = va_arg(ap, long int);
-	    } else {
-		num = va_arg(ap, int);
-	    }
-	    length = PrintNum(buf, num, 16, 0, width, ladjust, padc, 0);
-	    OUTPUT(arg, buf, length);
-	    break;
-
-	 case 'X':
-	    if (longFlag) {
-		num = va_arg(ap, long int);
-	    } else {
-		num = va_arg(ap, int);
-	    }
-	    length = PrintNum(buf, num, 16, 0, width, ladjust, padc, 1);
-	    OUTPUT(arg, buf, length);
-	    break;
-
-	 case 'c':
-	    c = (char)va_arg(ap, int);
-	    length = PrintChar(buf, c, width, ladjust);
-	    OUTPUT(arg, buf, length);
-	    break;
-
-	 case 's':
-	    s = (char*)va_arg(ap, char *);
-	    length = PrintString(buf, s, width, ladjust);
-	    OUTPUT(arg, buf, length);
-	    break;
-
-	 case '\0':
-	    fmt --;
-	    break;
-
-	 default:
-	    /* output this char as it is */
-	    OUTPUT(arg, fmt, 1);
-	}	/* switch (*fmt) */
-
-	fmt ++;
-    }		/* for(;;) */
-
-    /* special termination call */
-    OUTPUT(arg, "\0", 1);
-}
-
-
-/* --------------- local help functions --------------------- */
-static int
-PrintChar(char * buf, char c, int length, int ladjust)
-{
-    int i;
-
-    if (length < 1) length = 1;
-    if (ladjust) {
-	*buf = c;
-	for (i=1; i< length; i++) buf[i] = ' ';
-    } else {
-	for (i=0; i< length-1; i++) buf[i] = ' ';
-	buf[length - 1] = c;
-    }
-    return length;
-}
-
-static int
-PrintString(char * buf, char* s, int length, int ladjust)
-{
-    int i;
-    int len=0;
-    char* s1 = s;
-    while (*s1++) len++;
-    if (length < len) length = len;
-
-    if (ladjust) {
-	for (i=0; i< len; i++) buf[i] = s[i];
-	for (i=len; i< length; i++) buf[i] = ' ';
-    } else {
-	for (i=0; i< length-len; i++) buf[i] = ' ';
-	for (i=length-len; i < length; i++) buf[i] = s[i-length+len];
-    }
-    return length;
-}
-
-static int
-PrintNum(char * buf, unsigned long u, int base, int negFlag,
-	 int length, int ladjust, char padc, int upcase)
-{
-    /* algorithm :
-     *  1. prints the number from left to right in reverse form.
-     *  2. fill the remaining spaces with padc if length is longer than
-     *     the actual length
-     *     TRICKY : if left adjusted, no "0" padding.
-     *		    if negtive, insert  "0" padding between "0" and number.
-     *  3. if (!ladjust) we reverse the whole string including paddings
-     *  4. otherwise we only reverse the actual string representing the num.
-     */
-
-    int actualLength =0;
-    char *p = buf;
-    int i;
-
-    do {
-	int tmp = u %base;
-	if (tmp <= 9) {
-	    *p++ = '0' + tmp;
-	} else if (upcase) {
-	    *p++ = 'A' + tmp - 10;
-	} else {
-	    *p++ = 'a' + tmp - 10;
-	}
-	u /= base;
-    } while (u != 0);
-
-    if (negFlag) {
-	*p++ = '-';
-    }
-
-    /* figure out actual length and adjust the maximum length */
-    actualLength = p - buf;
-    if (length < actualLength) length = actualLength;
-
-    /* add padding */
-    if (ladjust) {
-	padc = ' ';
-    }
-    if (negFlag && !ladjust && (padc == '0')) {
-	for (i = actualLength-1; i< length-1; i++) buf[i] = padc;
-	buf[length -1] = '-';
-    } else {
-	for (i = actualLength; i< length; i++) buf[i] = padc;
-    }
-
-
-    /* prepare to reverse the string */
-    {
-	int begin = 0;
-	int end;
-	if (ladjust) {
-	    end = actualLength - 1;
-	} else {
-	    end = length -1;
-	}
-
-	while (end > begin) {
-	    char tmp = buf[begin];
-	    buf[begin] = buf[end];
-	    buf[end] = tmp;
-	    begin ++;
-	    end --;
-	}
-    }
-
-    /* adjust the string pointer */
-    return length;
-}
-
-static void printf_output(void *arg, char *s, int l)
-{
-    int i;
-
-    // special termination call
-    if ((l==1) && (s[0] == '\0')) return;
-
-    for (i=0; i< l; i++) {
-	board_putc(s[i]);
-	if (s[i] == '\n') board_putc('\r');
-    }
-}
-
-void printf(char *fmt, ...)
-{
-    va_list ap;
-    va_start(ap, fmt);
-    lp_Print(printf_output, 0, fmt, ap);
-    va_end(ap);
-}
diff --git a/target/linux/lantiq/image/lzma-loader/src/printf.h b/target/linux/lantiq/image/lzma-loader/src/printf.h
deleted file mode 100644
index 9b1c1df232..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/printf.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Copyright (C) 2001 MontaVista Software Inc.
- * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- *
- */
-
-#ifndef _printf_h_
-#define _printf_h_
-
-#include <stdarg.h>
-void printf(char *fmt, ...);
-
-#endif /* _printf_h_ */
diff --git a/target/linux/lantiq/image/lzma-loader/src/ralink.mk b/target/linux/lantiq/image/lzma-loader/src/ralink.mk
deleted file mode 100644
index 3ff5fddf98..0000000000
--- a/target/linux/lantiq/image/lzma-loader/src/ralink.mk
+++ /dev/null
@@ -1 +0,0 @@
-CACHE_FLAGS+=-DCONFIG_ICACHE_SIZE="(32 * 1024)" -DCONFIG_DCACHE_SIZE="(16 * 1024)" -DCONFIG_CACHELINE_SIZE=32
diff --git a/target/linux/lantiq/image/ubinize-overlay.cfg b/target/linux/lantiq/image/ubinize-overlay.cfg
deleted file mode 100644
index 65f0f42c5b..0000000000
--- a/target/linux/lantiq/image/ubinize-overlay.cfg
+++ /dev/null
@@ -1,23 +0,0 @@
-[rootfs]
-# Volume mode (other option is static)
-mode=ubi
-# Source image
-image=root.squashfs
-# Volume ID in UBI image
-vol_id=0
-# Allow for dynamic resize
-vol_type=dynamic
-# Volume name
-vol_name=rootfs
-[rootfs_data]
-# Volume mode (other option is static)
-mode=ubi
-# Volume ID in UBI image
-vol_id=1
-# Allow for dynamic resize
-vol_type=dynamic
-# Volume name
-vol_name=rootfs_data
-vol_size=1MiB
-# Autoresize volume at first mount
-vol_flags=autoresize
diff --git a/target/linux/lantiq/image/ubinize.cfg b/target/linux/lantiq/image/ubinize.cfg
deleted file mode 100644
index 49d55b9840..0000000000
--- a/target/linux/lantiq/image/ubinize.cfg
+++ /dev/null
@@ -1,14 +0,0 @@
-[rootfs]
-# Volume mode (other option is static)
-mode=ubi
-# Source image
-image=root.ubifs
-# Volume ID in UBI image
-vol_id=0
-# Allow for dynamic resize
-vol_type=dynamic
-# Volume name
-vol_name=rootfs
-# Autoresize volume at first mount
-vol_flags=autoresize
-
diff --git a/target/linux/lantiq/modules.mk b/target/linux/lantiq/modules.mk
deleted file mode 100644
index 130b4bd3ed..0000000000
--- a/target/linux/lantiq/modules.mk
+++ /dev/null
@@ -1,80 +0,0 @@
-#
-# Copyright (C) 2010 OpenWrt.org
-#
-# This is free software, licensed under the GNU General Public License v2.
-# See /LICENSE for more information.
-#
-
-I2C_LANTIQ_MODULES:= \
-  CONFIG_I2C_LANTIQ:drivers/i2c/busses/i2c-lantiq
-
-define KernelPackage/i2c-lantiq
-  TITLE:=Lantiq I2C controller
-  $(call i2c_defaults,$(I2C_LANTIQ_MODULES),52)
-  DEPENDS:=kmod-i2c-core @TARGET_lantiq_falcon
-endef
-
-define KernelPackage/i2c-lantiq/description
-  Kernel support for the Lantiq/Falcon I2C controller
-endef
-
-$(eval $(call KernelPackage,i2c-lantiq))
-
-define KernelPackage/lantiq-vpe
-  TITLE:=Lantiq VPE extensions
-  SUBMENU:=Lantiq
-  DEPENDS:=@TARGET_lantiq +kmod-vpe
-  KCONFIG:=CONFIG_IFX_VPE_CACHE_SPLIT=y \
-	  CONFIG_IFX_VPE_EXT=y \
-	  CONFIG_VPE_SOFTDOG=n \
-	  CONFIG_MTSCHED=y \
-	  CONFIG_PERFCTRS=n
-endef
-
-define KernelPackage/lantiq-vpe/description
-  Kernel extensions for the Lantiq SoC
-endef
-
-$(eval $(call KernelPackage,lantiq-vpe))
-
-define KernelPackage/lantiq-nf
-  TITLE:=Lantiq NF extensions
-  SUBMENU:=Lantiq
-  DEPENDS:=@TARGET_lantiq
-  KCONFIG:=CONFIG_NF_CONNTRACK_EVENTS=y
-endef
-
-define KernelPackage/lantiq-nf/description
-  Netfilter extensions for the Lantiq SoC
-endef
-
-$(eval $(call KernelPackage,lantiq-nf))
-
-define KernelPackage/spi-lantiq-ssc
-  SUBMENU:=$(SPI_MENU)
-  TITLE:=Lantiq SPI controller
-  DEPENDS:=@TARGET_lantiq +kmod-spi-bitbang
-  KCONFIG:=CONFIG_SPI_XWAY \
-	  CONFIG_SPI_XWAY_BV=y
-  FILES:=$(LINUX_DIR)/drivers/spi/spi-xway.ko
-endef
-
-define KernelPackage/spi-lantiq-ssc/description
-  Lantiq SPI controller
-endef
-
-$(eval $(call KernelPackage,spi-lantiq-ssc))
-
-define KernelPackage/spi-lantiq-ssc-csi
-  SUBMENU:=$(SPI_MENU)
-  TITLE:=Lantiq SPI controller for CSI
-  DEPENDS:=@TARGET_lantiq +kmod-spi-bitbang
-  KCONFIG:=CONFIG_SPI_XWAY_CSI
-  FILES:=$(LINUX_DIR)/drivers/spi/spi-xway-csi.ko
-endef
-
-define KernelPackage/spi-lantiq-ssc-csi/description
-  Lantiq SPI controller for CSI
-endef
-
-$(eval $(call KernelPackage,spi-lantiq-ssc-csi))
diff --git a/target/linux/lantiq/patches-3.18/0001-MIPS-lantiq-add-pcie-driver.patch b/target/linux/lantiq/patches-3.18/0001-MIPS-lantiq-add-pcie-driver.patch
deleted file mode 100644
index a123ce384f..0000000000
--- a/target/linux/lantiq/patches-3.18/0001-MIPS-lantiq-add-pcie-driver.patch
+++ /dev/null
@@ -1,5540 +0,0 @@
-From 6f933347d0b4ed02d9534f5fa07f7b99f13eeaa1 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Thu, 7 Aug 2014 18:12:28 +0200
-Subject: [PATCH 01/36] MIPS: lantiq: add pcie driver
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- arch/mips/lantiq/Kconfig           |   10 +
- arch/mips/lantiq/xway/sysctrl.c    |    2 +
- arch/mips/pci/Makefile             |    2 +
- arch/mips/pci/fixup-lantiq-pcie.c  |   82 +++
- arch/mips/pci/fixup-lantiq.c       |    5 +-
- arch/mips/pci/ifxmips_pci_common.h |   57 ++
- arch/mips/pci/ifxmips_pcie.c       | 1099 ++++++++++++++++++++++++++++++
- arch/mips/pci/ifxmips_pcie.h       |  135 ++++
- arch/mips/pci/ifxmips_pcie_ar10.h  |  290 ++++++++
- arch/mips/pci/ifxmips_pcie_msi.c   |  392 +++++++++++
- arch/mips/pci/ifxmips_pcie_phy.c   |  478 +++++++++++++
- arch/mips/pci/ifxmips_pcie_pm.c    |  176 +++++
- arch/mips/pci/ifxmips_pcie_pm.h    |   36 +
- arch/mips/pci/ifxmips_pcie_reg.h   | 1001 +++++++++++++++++++++++++++
- arch/mips/pci/ifxmips_pcie_vr9.h   |  271 ++++++++
- arch/mips/pci/pci.c                |   25 +
- arch/mips/pci/pcie-lantiq.h        | 1305 ++++++++++++++++++++++++++++++++++++
- drivers/pci/pcie/aer/Kconfig       |    2 +-
- include/linux/pci.h                |    2 +
- include/linux/pci_ids.h            |    6 +
- 20 files changed, 5374 insertions(+), 2 deletions(-)
- create mode 100644 arch/mips/pci/fixup-lantiq-pcie.c
- create mode 100644 arch/mips/pci/ifxmips_pci_common.h
- create mode 100644 arch/mips/pci/ifxmips_pcie.c
- create mode 100644 arch/mips/pci/ifxmips_pcie.h
- create mode 100644 arch/mips/pci/ifxmips_pcie_ar10.h
- create mode 100644 arch/mips/pci/ifxmips_pcie_msi.c
- create mode 100644 arch/mips/pci/ifxmips_pcie_phy.c
- create mode 100644 arch/mips/pci/ifxmips_pcie_pm.c
- create mode 100644 arch/mips/pci/ifxmips_pcie_pm.h
- create mode 100644 arch/mips/pci/ifxmips_pcie_reg.h
- create mode 100644 arch/mips/pci/ifxmips_pcie_vr9.h
- create mode 100644 arch/mips/pci/pcie-lantiq.h
-
---- a/arch/mips/lantiq/Kconfig
-+++ b/arch/mips/lantiq/Kconfig
-@@ -17,6 +17,7 @@ config SOC_XWAY
- 	bool "XWAY"
- 	select SOC_TYPE_XWAY
- 	select HW_HAS_PCI
-+	select ARCH_SUPPORTS_MSI
- 
- config SOC_FALCON
- 	bool "FALCON"
-@@ -37,6 +38,15 @@ config PCI_LANTIQ
- 	bool "PCI Support"
- 	depends on SOC_XWAY && PCI
- 
-+config PCIE_LANTIQ
-+	bool "PCIE Support"
-+	depends on SOC_XWAY && PCI
-+
-+config PCIE_LANTIQ_MSI
-+	bool
-+	depends on PCIE_LANTIQ && PCI_MSI
-+	default y
-+
- config XRX200_PHY_FW
- 	bool "XRX200 PHY firmware loader"
- 	depends on SOC_XWAY
---- a/arch/mips/lantiq/xway/sysctrl.c
-+++ b/arch/mips/lantiq/xway/sysctrl.c
-@@ -377,6 +377,8 @@ void __init ltq_soc_init(void)
- 				PMU_PPE_EMA | PMU_PPE_TC | PMU_PPE_SLL01 |
- 				PMU_PPE_QSB | PMU_PPE_TOP);
- 		clkdev_add_pmu("1f203000.rcu", "gphy", 0, PMU_GPHY);
-+		pmu_w32(~0, PMU_PWDSR1);
-+		pmu_w32(pmu_r32(PMU_PWDSR) & ~PMU_PCIE_CLK, PMU_PWDSR);
- 	} else if (of_machine_is_compatible("lantiq,ar9")) {
- 		clkdev_add_static(ltq_ar9_cpu_hz(), ltq_ar9_fpi_hz(),
- 				ltq_ar9_fpi_hz(), CLOCK_250M);
---- a/arch/mips/pci/Makefile
-+++ b/arch/mips/pci/Makefile
-@@ -43,6 +43,8 @@ obj-$(CONFIG_SNI_RM)		+= fixup-sni.o ops
- obj-$(CONFIG_LANTIQ)		+= fixup-lantiq.o
- obj-$(CONFIG_PCI_LANTIQ)	+= pci-lantiq.o ops-lantiq.o
- obj-$(CONFIG_SOC_RT3883)	+= pci-rt3883.o
-+obj-$(CONFIG_PCIE_LANTIQ)	+= ifxmips_pcie_phy.o ifxmips_pcie.o fixup-lantiq-pcie.o
-+obj-$(CONFIG_PCIE_LANTIQ_MSI)	+= pcie-lantiq-msi.o
- obj-$(CONFIG_TANBAC_TB0219)	+= fixup-tb0219.o
- obj-$(CONFIG_TANBAC_TB0226)	+= fixup-tb0226.o
- obj-$(CONFIG_TANBAC_TB0287)	+= fixup-tb0287.o
---- /dev/null
-+++ b/arch/mips/pci/fixup-lantiq-pcie.c
-@@ -0,0 +1,82 @@
-+/******************************************************************************
-+**
-+** FILE NAME    : ifxmips_fixup_pcie.c
-+** PROJECT      : IFX UEIP for VRX200
-+** MODULES      : PCIe 
-+**
-+** DATE         : 02 Mar 2009
-+** AUTHOR       : Lei Chuanhua
-+** DESCRIPTION  : PCIe Root Complex Driver
-+** COPYRIGHT    :       Copyright (c) 2009
-+**                      Infineon Technologies AG
-+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-+**
-+**    This program is free software; you can redistribute it and/or modify
-+**    it under the terms of the GNU General Public License as published by
-+**    the Free Software Foundation; either version 2 of the License, or
-+**    (at your option) any later version.
-+** HISTORY
-+** $Version $Date        $Author         $Comment
-+** 0.0.1    17 Mar,2009  Lei Chuanhua    Initial version
-+*******************************************************************************/
-+/*!
-+ \file ifxmips_fixup_pcie.c
-+ \ingroup IFX_PCIE  
-+ \brief PCIe Fixup functions source file
-+*/
-+#include <linux/pci.h>
-+#include <linux/pci_regs.h>
-+#include <linux/pci_ids.h>
-+
-+#include <lantiq_soc.h>
-+
-+#include "pcie-lantiq.h"
-+
-+#define PCI_VENDOR_ID_INFINEON         0x15D1
-+#define PCI_DEVICE_ID_INFINEON_DANUBE  0x000F
-+#define PCI_DEVICE_ID_INFINEON_PCIE    0x0011
-+#define PCI_VENDOR_ID_LANTIQ        0x1BEF
-+#define PCI_DEVICE_ID_LANTIQ_PCIE       0x0011
-+
-+
-+
-+static void
-+ifx_pcie_fixup_resource(struct pci_dev *dev)
-+{
-+    u32 reg;
-+
-+    IFX_PCIE_PRINT(PCIE_MSG_FIXUP, "%s dev %s: enter\n", __func__, pci_name(dev));
-+
-+    printk("%s: fixup host controller %s (%04x:%04x)\n", 
-+        __func__, pci_name(dev), dev->vendor, dev->device); 
-+
-+   /* Setup COMMAND register */
-+    reg = PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER /* | 
-+          PCI_COMMAND_INTX_DISABLE */| PCI_COMMAND_SERR;
-+    pci_write_config_word(dev, PCI_COMMAND, reg);
-+    IFX_PCIE_PRINT(PCIE_MSG_FIXUP, "%s dev %s: exit\n", __func__, pci_name(dev));
-+}
-+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INFINEON, PCI_DEVICE_ID_INFINEON_PCIE, ifx_pcie_fixup_resource);
-+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LANTIQ, PCI_VENDOR_ID_LANTIQ, ifx_pcie_fixup_resource);
-+
-+static void
-+ifx_pcie_rc_class_early_fixup(struct pci_dev *dev)
-+{
-+    IFX_PCIE_PRINT(PCIE_MSG_FIXUP, "%s dev %s: enter\n", __func__, pci_name(dev));
-+
-+    if (dev->devfn == PCI_DEVFN(0, 0) &&
-+        (dev->class >> 8) == PCI_CLASS_BRIDGE_HOST) {
-+
-+        dev->class = (PCI_CLASS_BRIDGE_PCI << 8) | (dev->class & 0xff);
-+
-+        printk(KERN_INFO "%s: fixed pcie host bridge to pci-pci bridge\n", __func__);
-+    }
-+    IFX_PCIE_PRINT(PCIE_MSG_FIXUP, "%s dev %s: exit\n", __func__, pci_name(dev));
-+    mdelay(10);
-+}
-+
-+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INFINEON, PCI_DEVICE_ID_INFINEON_PCIE,
-+     ifx_pcie_rc_class_early_fixup);
-+
-+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_LANTIQ, PCI_DEVICE_ID_LANTIQ_PCIE,
-+     ifx_pcie_rc_class_early_fixup);
---- a/arch/mips/pci/fixup-lantiq.c
-+++ b/arch/mips/pci/fixup-lantiq.c
-@@ -8,12 +8,18 @@
- 
- #include <linux/of_irq.h>
- #include <linux/of_pci.h>
-+#include "ifxmips_pci_common.h"
- 
- int (*ltq_pci_plat_arch_init)(struct pci_dev *dev) = NULL;
- int (*ltq_pci_plat_dev_init)(struct pci_dev *dev) = NULL;
- 
- int pcibios_plat_dev_init(struct pci_dev *dev)
- {
-+#ifdef CONFIG_PCIE_LANTIQ
-+	if (pci_find_capability(dev, PCI_CAP_ID_EXP))
-+		ifx_pcie_bios_plat_dev_init(dev);
-+#endif
-+
- 	if (ltq_pci_plat_arch_init)
- 		return ltq_pci_plat_arch_init(dev);
- 
-@@ -25,5 +31,10 @@ int pcibios_plat_dev_init(struct pci_dev
- 
- int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
- {
-+#ifdef CONFIG_PCIE_LANTIQ
-+	if (pci_find_capability(dev, PCI_CAP_ID_EXP))
-+		return ifx_pcie_bios_map_irq(dev, slot, pin);
-+#endif
-+
- 	return of_irq_parse_and_map_pci(dev, slot, pin);
- }
---- /dev/null
-+++ b/arch/mips/pci/ifxmips_pci_common.h
-@@ -0,0 +1,57 @@
-+/******************************************************************************
-+**
-+** FILE NAME    : ifxmips_pci_common.h
-+** PROJECT      : IFX UEIP
-+** MODULES      : PCI subsystem
-+**
-+** DATE         : 30 June 2009
-+** AUTHOR       : Lei Chuanhua
-+** DESCRIPTION  : PCIe Root Complex Driver
-+** COPYRIGHT    :       Copyright (c) 2009
-+**                      Infineon Technologies AG
-+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-+**
-+**    This program is free software; you can redistribute it and/or modify
-+**    it under the terms of the GNU General Public License as published by
-+**    the Free Software Foundation; either version 2 of the License, or
-+**    (at your option) any later version.
-+** HISTORY
-+** $Version $Date        $Author         $Comment
-+** 0.0.1    30 June,2009  Lei Chuanhua    Initial version
-+*******************************************************************************/
-+
-+#ifndef IFXMIPS_PCI_COMMON_H
-+#define IFXMIPS_PCI_COMMON_H
-+#include <linux/version.h>
-+/*!
-+ \defgroup IFX_PCI_COM  IFX PCI/PCIe common parts for OS integration  
-+ \brief  PCI/PCIe common parts
-+*/
-+
-+/*!
-+ \defgroup IFX_PCI_COM_OS OS APIs
-+ \ingroup IFX_PCI_COM
-+ \brief PCI/PCIe bus driver OS interface functions
-+*/
-+/*!
-+  \file ifxmips_pci_common.h
-+  \ingroup IFX_PCI_COM
-+  \brief PCI/PCIe bus driver common OS header file
-+*/
-+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-+#define IFX_PCI_CONST
-+#else
-+#define IFX_PCI_CONST const
-+#endif
-+#ifdef CONFIG_IFX_PCI
-+extern int ifx_pci_bios_map_irq(IFX_PCI_CONST struct pci_dev *dev, u8 slot, u8 pin);
-+extern int ifx_pci_bios_plat_dev_init(struct pci_dev *dev);
-+#endif /* COFNIG_IFX_PCI */
-+
-+#ifdef CONFIG_PCIE_LANTIQ
-+extern int ifx_pcie_bios_map_irq(IFX_PCI_CONST struct pci_dev *dev, u8 slot, u8 pin);
-+extern int ifx_pcie_bios_plat_dev_init(struct pci_dev *dev);
-+#endif
-+
-+#endif /* IFXMIPS_PCI_COMMON_H */
-+
---- /dev/null
-+++ b/arch/mips/pci/ifxmips_pcie.c
-@@ -0,0 +1,1092 @@
-+/*
-+ *  This program is free software; you can redistribute it and/or modify it
-+ *  under the terms of the GNU General Public License version 2 as published
-+ *  by the Free Software Foundation.
-+ *
-+ *  Copyright (C) 2009 Lei Chuanhua <chuanhua.lei@infineon.com>
-+ *  Copyright (C) 2013 John Crispin <blogic@openwrt.org>
-+ */
-+
-+#include <linux/types.h>
-+#include <linux/pci.h>
-+#include <linux/kernel.h>
-+#include <linux/init.h>
-+#include <linux/delay.h>
-+#include <linux/mm.h>
-+#include <asm/paccess.h>
-+#include <linux/pci.h>
-+#include <linux/pci_regs.h>
-+#include <linux/module.h>
-+
-+#include "ifxmips_pcie.h"
-+#include "ifxmips_pcie_reg.h"
-+
-+/* Enable 32bit io due to its mem mapped io nature */
-+#define IFX_PCIE_ERROR_INT
-+#define IFX_PCIE_IO_32BIT
-+
-+#define IFX_PCIE_IR                     (INT_NUM_IM4_IRL0 + 25)
-+#define IFX_PCIE_INTA                   (INT_NUM_IM4_IRL0 + 8)
-+#define IFX_PCIE_INTB                   (INT_NUM_IM4_IRL0 + 9)
-+#define IFX_PCIE_INTC                   (INT_NUM_IM4_IRL0 + 10)
-+#define IFX_PCIE_INTD                   (INT_NUM_IM4_IRL0 + 11)
-+#define MS(_v, _f)  (((_v) & (_f)) >> _f##_S)
-+#define SM(_v, _f)  (((_v) << _f##_S) & (_f))
-+#define IFX_REG_SET_BIT(_f, _r) \
-+	IFX_REG_W32((IFX_REG_R32((_r)) &~ (_f)) | (_f), (_r))
-+
-+#define IFX_PCIE_LTSSM_ENABLE_TIMEOUT 10
-+
-+static DEFINE_SPINLOCK(ifx_pcie_lock);
-+
-+u32 g_pcie_debug_flag = PCIE_MSG_ANY & (~PCIE_MSG_CFG);
-+
-+static ifx_pcie_irq_t pcie_irqs[IFX_PCIE_CORE_NR] = {
-+    {
-+        .ir_irq = {
-+            .irq  = IFX_PCIE_IR,
-+            .name = "ifx_pcie_rc0",
-+        },
-+
-+        .legacy_irq = {
-+            {
-+                .irq_bit = PCIE_IRN_INTA,
-+                .irq     = IFX_PCIE_INTA,
-+            },
-+            {
-+                .irq_bit = PCIE_IRN_INTB,
-+                .irq     = IFX_PCIE_INTB,
-+            },
-+            {
-+                .irq_bit = PCIE_IRN_INTC,
-+                .irq     = IFX_PCIE_INTC,
-+            },
-+            {
-+                .irq_bit = PCIE_IRN_INTD,
-+                .irq     = IFX_PCIE_INTD,
-+            },
-+        },
-+    },
-+
-+};
-+
-+void ifx_pcie_debug(const char *fmt, ...)
-+{
-+	static char buf[256] = {0};      /* XXX */
-+	va_list ap;
-+
-+	va_start(ap, fmt);
-+	vsnprintf(buf, sizeof(buf), fmt, ap);
-+	va_end(ap);
-+
-+	printk("%s", buf);
-+}
-+
-+
-+static inline int pcie_ltssm_enable(int pcie_port)
-+{
-+	int i;
-+
-+	/* Enable LTSSM */
-+	IFX_REG_W32(PCIE_RC_CCR_LTSSM_ENABLE, PCIE_RC_CCR(pcie_port));
-+
-+	/* Wait for the link to come up */
-+	for (i = 0; i < IFX_PCIE_LTSSM_ENABLE_TIMEOUT; i++) {
-+		if (!(IFX_REG_R32(PCIE_LCTLSTS(pcie_port)) & PCIE_LCTLSTS_RETRAIN_PENDING))
-+			return 0;
-+		udelay(10);
-+	}
-+
-+	printk("%s link timeout!!!!!\n", __func__);
-+	return -1;
-+}
-+
-+static inline void pcie_status_register_clear(int pcie_port)
-+{
-+	IFX_REG_W32(0, PCIE_RC_DR(pcie_port));
-+	IFX_REG_W32(0, PCIE_PCICMDSTS(pcie_port));
-+	IFX_REG_W32(0, PCIE_DCTLSTS(pcie_port));
-+	IFX_REG_W32(0, PCIE_LCTLSTS(pcie_port));
-+	IFX_REG_W32(0, PCIE_SLCTLSTS(pcie_port));
-+	IFX_REG_W32(0, PCIE_RSTS(pcie_port));
-+	IFX_REG_W32(0, PCIE_UES_R(pcie_port));
-+	IFX_REG_W32(0, PCIE_UEMR(pcie_port));
-+	IFX_REG_W32(0, PCIE_UESR(pcie_port));
-+	IFX_REG_W32(0, PCIE_CESR(pcie_port));
-+	IFX_REG_W32(0, PCIE_CEMR(pcie_port));
-+	IFX_REG_W32(0, PCIE_RESR(pcie_port));
-+	IFX_REG_W32(0, PCIE_PVCCRSR(pcie_port));
-+	IFX_REG_W32(0, PCIE_VC0_RSR0(pcie_port));
-+	IFX_REG_W32(0, PCIE_TPFCS(pcie_port));
-+	IFX_REG_W32(0, PCIE_TNPFCS(pcie_port));
-+	IFX_REG_W32(0, PCIE_TCFCS(pcie_port));
-+	IFX_REG_W32(0, PCIE_QSR(pcie_port));
-+	IFX_REG_W32(0, PCIE_IOBLSECS(pcie_port));
-+}
-+
-+static inline int ifx_pcie_link_up(int pcie_port)
-+{
-+    return (IFX_REG_R32(PCIE_PHY_SR(pcie_port)) & PCIE_PHY_SR_PHY_LINK_UP) ? 1 : 0;
-+}
-+
-+
-+static inline void pcie_mem_io_setup(int pcie_port)
-+{
-+    u32 reg;
-+    /*
-+     * BAR[0:1] readonly register 
-+     * RC contains only minimal BARs for packets mapped to this device 
-+     * Mem/IO filters defines a range of memory occupied by memory mapped IO devices that
-+     * reside on the downstream side fo the bridge.
-+     */
-+    reg = SM((PCIE_MEM_PHY_PORT_TO_END(pcie_port) >> 20), PCIE_MBML_MEM_LIMIT_ADDR)
-+        | SM((PCIE_MEM_PHY_PORT_TO_BASE(pcie_port) >> 20), PCIE_MBML_MEM_BASE_ADDR);
-+
-+    IFX_REG_W32(reg, PCIE_MBML(pcie_port));
-+
-+
-+#ifdef IFX_PCIE_PREFETCH_MEM_64BIT
-+    reg = SM((PCIE_MEM_PHY_PORT_TO_END(pcie_port) >> 20), PCIE_PMBL_END_ADDR)
-+        | SM((PCIE_MEM_PHY_PORT_TO_BASE(pcie_port) >> 20), PCIE_PMBL_UPPER_12BIT)
-+        | PCIE_PMBL_64BIT_ADDR;
-+    IFX_REG_W32(reg, PCIE_PMBL(pcie_port));
-+
-+    /* Must configure upper 32bit */
-+    IFX_REG_W32(0, PCIE_PMBU32(pcie_port));
-+    IFX_REG_W32(0, PCIE_PMLU32(pcie_port));
-+#else
-+    /* PCIe_PBML, same as MBML */
-+    IFX_REG_W32(IFX_REG_R32(PCIE_MBML(pcie_port)), PCIE_PMBL(pcie_port));
-+#endif 
-+
-+    /* IO Address Range */
-+    reg = SM((PCIE_IO_PHY_PORT_TO_END(pcie_port) >> 12), PCIE_IOBLSECS_IO_LIMIT_ADDR)
-+        | SM((PCIE_IO_PHY_PORT_TO_BASE(pcie_port) >> 12), PCIE_IOBLSECS_IO_BASE_ADDR);
-+#ifdef IFX_PCIE_IO_32BIT    
-+    reg |= PCIE_IOBLSECS_32BIT_IO_ADDR;
-+#endif /* IFX_PCIE_IO_32BIT */
-+    IFX_REG_W32(reg, PCIE_IOBLSECS(pcie_port));
-+
-+#ifdef IFX_PCIE_IO_32BIT
-+    reg = SM((PCIE_IO_PHY_PORT_TO_END(pcie_port) >> 16), PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT)
-+        | SM((PCIE_IO_PHY_PORT_TO_BASE(pcie_port) >> 16), PCIE_IO_BANDL_UPPER_16BIT_IO_BASE);
-+    IFX_REG_W32(reg, PCIE_IO_BANDL(pcie_port));
-+
-+#endif /* IFX_PCIE_IO_32BIT */
-+}
-+
-+static inline void
-+pcie_device_setup(int pcie_port)
-+{
-+    u32 reg;
-+
-+    /* Device capability register, set up Maximum payload size */
-+    reg = IFX_REG_R32(PCIE_DCAP(pcie_port));
-+    reg |= PCIE_DCAP_ROLE_BASE_ERR_REPORT;
-+    reg |= SM(PCIE_MAX_PAYLOAD_128, PCIE_DCAP_MAX_PAYLOAD_SIZE);
-+
-+    /* Only available for EP */
-+    reg &= ~(PCIE_DCAP_EP_L0S_LATENCY | PCIE_DCAP_EP_L1_LATENCY);
-+    IFX_REG_W32(reg, PCIE_DCAP(pcie_port));
-+
-+    /* Device control and status register */
-+    /* Set Maximum Read Request size for the device as a Requestor */
-+    reg = IFX_REG_R32(PCIE_DCTLSTS(pcie_port));
-+
-+    /* 
-+     * Request size can be larger than the MPS used, but the completions returned 
-+     * for the read will be bounded by the MPS size.
-+     * In our system, Max request size depends on AHB burst size. It is 64 bytes.
-+     * but we set it as 128 as minimum one.
-+     */
-+    reg |= SM(PCIE_MAX_PAYLOAD_128, PCIE_DCTLSTS_MAX_READ_SIZE)
-+            | SM(PCIE_MAX_PAYLOAD_128, PCIE_DCTLSTS_MAX_PAYLOAD_SIZE);
-+
-+    /* Enable relaxed ordering, no snoop, and all kinds of errors */
-+    reg |= PCIE_DCTLSTS_RELAXED_ORDERING_EN | PCIE_DCTLSTS_ERR_EN | PCIE_DCTLSTS_NO_SNOOP_EN;
-+
-+    IFX_REG_W32(reg, PCIE_DCTLSTS(pcie_port));
-+}
-+
-+static inline void
-+pcie_link_setup(int pcie_port)
-+{
-+    u32 reg;
-+
-+    /*
-+     * XXX, Link capability register, bit 18 for EP CLKREQ# dynamic clock management for L1, L2/3 CPM 
-+     * L0s is reported during link training via TS1 order set by N_FTS
-+     */
-+    reg = IFX_REG_R32(PCIE_LCAP(pcie_port));
-+    reg &= ~PCIE_LCAP_L0S_EIXT_LATENCY;
-+    reg |= SM(3, PCIE_LCAP_L0S_EIXT_LATENCY);
-+    IFX_REG_W32(reg, PCIE_LCAP(pcie_port));
-+
-+    /* Link control and status register */
-+    reg = IFX_REG_R32(PCIE_LCTLSTS(pcie_port));
-+
-+    /* Link Enable, ASPM enabled  */
-+    reg &= ~PCIE_LCTLSTS_LINK_DISABLE;
-+
-+#ifdef CONFIG_PCIEASPM
-+    /*  
-+     * We use the same physical reference clock that the platform provides on the connector 
-+     * It paved the way for ASPM to calculate the new exit Latency
-+     */
-+    reg |= PCIE_LCTLSTS_SLOT_CLK_CFG;
-+    reg |= PCIE_LCTLSTS_COM_CLK_CFG;
-+    /*
-+     * We should disable ASPM by default except that we have dedicated power management support
-+     * Enable ASPM will cause the system hangup/instability, performance degration
-+     */
-+    reg |= PCIE_LCTLSTS_ASPM_ENABLE;
-+#else
-+    reg &= ~PCIE_LCTLSTS_ASPM_ENABLE;
-+#endif /* CONFIG_PCIEASPM */
-+
-+    /* 
-+     * The maximum size of any completion with data packet is bounded by the MPS setting 
-+     * in  device control register 
-+     */
-+
-+    /* RCB may cause multiple split transactions, two options available, we use 64 byte RCB */
-+    reg &= ~ PCIE_LCTLSTS_RCB128;
-+
-+    IFX_REG_W32(reg, PCIE_LCTLSTS(pcie_port));
-+}
-+
-+static inline void pcie_error_setup(int pcie_port)
-+{
-+	u32 reg;
-+
-+	/* 
-+	* Forward ERR_COR, ERR_NONFATAL, ERR_FATAL to the backbone 
-+	* Poisoned write TLPs and completions indicating poisoned TLPs will set the PCIe_PCICMDSTS.MDPE 
-+	*/
-+	reg = IFX_REG_R32(PCIE_INTRBCTRL(pcie_port));
-+	reg |= PCIE_INTRBCTRL_SERR_ENABLE | PCIE_INTRBCTRL_PARITY_ERR_RESP_ENABLE;
-+
-+	IFX_REG_W32(reg, PCIE_INTRBCTRL(pcie_port));
-+
-+	/* Uncorrectable Error Mask Register, Unmask <enable> all bits in PCIE_UESR */
-+	reg = IFX_REG_R32(PCIE_UEMR(pcie_port));
-+	reg &= ~PCIE_ALL_UNCORRECTABLE_ERR;
-+	IFX_REG_W32(reg, PCIE_UEMR(pcie_port));
-+
-+	/* Uncorrectable Error Severity Register, ALL errors are FATAL */
-+	IFX_REG_W32(PCIE_ALL_UNCORRECTABLE_ERR, PCIE_UESR(pcie_port));
-+
-+	/* Correctable Error Mask Register, unmask <enable> all bits */
-+	reg = IFX_REG_R32(PCIE_CEMR(pcie_port));
-+	reg &= ~PCIE_CORRECTABLE_ERR;
-+	IFX_REG_W32(reg, PCIE_CEMR(pcie_port));
-+
-+	/* Advanced Error Capabilities and Control Registr */
-+	reg = IFX_REG_R32(PCIE_AECCR(pcie_port));
-+	reg |= PCIE_AECCR_ECRC_CHECK_EN | PCIE_AECCR_ECRC_GEN_EN;
-+	IFX_REG_W32(reg, PCIE_AECCR(pcie_port));
-+
-+	/* Root Error Command Register, Report all types of errors */
-+	reg = IFX_REG_R32(PCIE_RECR(pcie_port));
-+	reg |= PCIE_RECR_ERR_REPORT_EN;
-+	IFX_REG_W32(reg, PCIE_RECR(pcie_port));
-+
-+	/* Clear the Root status register */
-+	reg = IFX_REG_R32(PCIE_RESR(pcie_port));
-+	IFX_REG_W32(reg, PCIE_RESR(pcie_port));
-+}
-+
-+static inline void pcie_port_logic_setup(int pcie_port)
-+{
-+	u32 reg;
-+
-+	/* FTS number, default 12, increase to 63, may increase time from/to L0s to L0  */
-+	reg = IFX_REG_R32(PCIE_AFR(pcie_port));
-+	reg &= ~(PCIE_AFR_FTS_NUM | PCIE_AFR_COM_FTS_NUM);
-+	reg |= SM(PCIE_AFR_FTS_NUM_DEFAULT, PCIE_AFR_FTS_NUM)
-+		| SM(PCIE_AFR_FTS_NUM_DEFAULT, PCIE_AFR_COM_FTS_NUM);
-+	/* L0s and L1 entry latency */
-+	reg &= ~(PCIE_AFR_L0S_ENTRY_LATENCY | PCIE_AFR_L1_ENTRY_LATENCY);
-+	reg |= SM(PCIE_AFR_L0S_ENTRY_LATENCY_DEFAULT, PCIE_AFR_L0S_ENTRY_LATENCY)
-+		| SM(PCIE_AFR_L1_ENTRY_LATENCY_DEFAULT, PCIE_AFR_L1_ENTRY_LATENCY);
-+	IFX_REG_W32(reg, PCIE_AFR(pcie_port));
-+
-+
-+	/* Port Link Control Register */
-+	reg = IFX_REG_R32(PCIE_PLCR(pcie_port));
-+	reg |= PCIE_PLCR_DLL_LINK_EN;  /* Enable the DLL link */
-+	IFX_REG_W32(reg, PCIE_PLCR(pcie_port));
-+
-+	/* Lane Skew Register */
-+	reg = IFX_REG_R32(PCIE_LSR(pcie_port));
-+	/* Enable ACK/NACK and FC */
-+	reg &= ~(PCIE_LSR_ACKNAK_DISABLE | PCIE_LSR_FC_DISABLE);
-+	IFX_REG_W32(reg, PCIE_LSR(pcie_port));
-+
-+	/* Symbol Timer Register and Filter Mask Register 1 */
-+	reg = IFX_REG_R32(PCIE_STRFMR(pcie_port));
-+
-+	/* Default SKP interval is very accurate already, 5us */
-+	/* Enable IO/CFG transaction */
-+	reg |= PCIE_STRFMR_RX_CFG_TRANS_ENABLE | PCIE_STRFMR_RX_IO_TRANS_ENABLE;
-+	/* Disable FC WDT */
-+	reg &= ~PCIE_STRFMR_FC_WDT_DISABLE;
-+	IFX_REG_W32(reg, PCIE_STRFMR(pcie_port));
-+
-+	/* Filter Masker Register 2 */
-+	reg = IFX_REG_R32(PCIE_FMR2(pcie_port));
-+	reg |= PCIE_FMR2_VENDOR_MSG1_PASSED_TO_TRGT1 | PCIE_FMR2_VENDOR_MSG0_PASSED_TO_TRGT1;
-+	IFX_REG_W32(reg, PCIE_FMR2(pcie_port));
-+
-+	/* VC0 Completion Receive Queue Control Register */
-+	reg = IFX_REG_R32(PCIE_VC0_CRQCR(pcie_port));
-+	reg &= ~PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE;
-+	reg |= SM(PCIE_VC0_TLP_QUEUE_MODE_BYPASS, PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE);
-+	IFX_REG_W32(reg, PCIE_VC0_CRQCR(pcie_port));
-+}
-+
-+static inline void pcie_rc_cfg_reg_setup(int pcie_port)
-+{
-+	u32 reg;
-+
-+	/* Disable LTSSM */
-+	IFX_REG_W32(0, PCIE_RC_CCR(pcie_port)); /* Disable LTSSM */
-+
-+	pcie_mem_io_setup(pcie_port);
-+
-+	/* XXX, MSI stuff should only apply to EP */
-+	/* MSI Capability: Only enable 32-bit addresses */
-+	reg = IFX_REG_R32(PCIE_MCAPR(pcie_port));
-+	reg &= ~PCIE_MCAPR_ADDR64_CAP;
-+
-+	reg |= PCIE_MCAPR_MSI_ENABLE;
-+
-+	/* Disable multiple message */
-+	reg &= ~(PCIE_MCAPR_MULTI_MSG_CAP | PCIE_MCAPR_MULTI_MSG_ENABLE);
-+	IFX_REG_W32(reg, PCIE_MCAPR(pcie_port));
-+
-+
-+	/* Enable PME, Soft reset enabled */
-+	reg = IFX_REG_R32(PCIE_PM_CSR(pcie_port));
-+	reg |= PCIE_PM_CSR_PME_ENABLE | PCIE_PM_CSR_SW_RST;
-+	IFX_REG_W32(reg, PCIE_PM_CSR(pcie_port));
-+
-+	/* setup the bus */
-+	reg = SM(0, PCIE_BNR_PRIMARY_BUS_NUM) | SM(1, PCIE_PNR_SECONDARY_BUS_NUM) | SM(0xFF, PCIE_PNR_SUB_BUS_NUM);
-+	IFX_REG_W32(reg, PCIE_BNR(pcie_port));
-+
-+
-+	pcie_device_setup(pcie_port);
-+	pcie_link_setup(pcie_port);
-+	pcie_error_setup(pcie_port);
-+
-+	/* Root control and capabilities register */
-+	reg = IFX_REG_R32(PCIE_RCTLCAP(pcie_port));
-+	reg |= PCIE_RCTLCAP_SERR_ENABLE | PCIE_RCTLCAP_PME_INT_EN;
-+	IFX_REG_W32(reg, PCIE_RCTLCAP(pcie_port));
-+
-+	/* Port VC Capability Register 2 */
-+	reg = IFX_REG_R32(PCIE_PVC2(pcie_port));
-+	reg &= ~PCIE_PVC2_VC_ARB_WRR;
-+	reg |= PCIE_PVC2_VC_ARB_16P_FIXED_WRR;
-+	IFX_REG_W32(reg, PCIE_PVC2(pcie_port));
-+
-+	/* VC0 Resource Capability Register */
-+	reg = IFX_REG_R32(PCIE_VC0_RC(pcie_port));
-+	reg &= ~PCIE_VC0_RC_REJECT_SNOOP;
-+	IFX_REG_W32(reg, PCIE_VC0_RC(pcie_port));
-+
-+	pcie_port_logic_setup(pcie_port);
-+}
-+
-+static int ifx_pcie_wait_phy_link_up(int pcie_port)
-+{
-+#define IFX_PCIE_PHY_LINK_UP_TIMEOUT  1000 /* XXX, tunable */
-+    int i;
-+
-+    /* Wait for PHY link is up */
-+    for (i = 0; i < IFX_PCIE_PHY_LINK_UP_TIMEOUT; i++) {
-+        if (ifx_pcie_link_up(pcie_port)) {
-+            break;
-+        }
-+        udelay(100);
-+    }
-+    if (i >= IFX_PCIE_PHY_LINK_UP_TIMEOUT) {
-+        printk(KERN_ERR "%s timeout\n", __func__);
-+        return -1;
-+    }
-+
-+    /* Check data link up or not */
-+    if (!(IFX_REG_R32(PCIE_RC_DR(pcie_port)) & PCIE_RC_DR_DLL_UP)) {
-+        printk(KERN_ERR "%s DLL link is still down\n", __func__);
-+        return -1;
-+    }
-+
-+    /* Check Data link active or not */
-+    if (!(IFX_REG_R32(PCIE_LCTLSTS(pcie_port)) & PCIE_LCTLSTS_DLL_ACTIVE)) {
-+        printk(KERN_ERR "%s DLL is not active\n", __func__);
-+        return -1;
-+    }
-+    return 0;
-+}
-+
-+static inline int pcie_app_loigc_setup(int pcie_port)
-+{
-+	/* supress ahb bus errrors */
-+	IFX_REG_W32(PCIE_AHB_CTRL_BUS_ERROR_SUPPRESS, PCIE_AHB_CTRL(pcie_port));
-+
-+	/* Pull PCIe EP out of reset */
-+	pcie_device_rst_deassert(pcie_port);
-+
-+	/* Start LTSSM training between RC and EP */
-+	pcie_ltssm_enable(pcie_port);
-+
-+	/* Check PHY status after enabling LTSSM */
-+	if (ifx_pcie_wait_phy_link_up(pcie_port) != 0)
-+		return -1;
-+
-+	return 0;
-+}
-+
-+/*
-+ * The numbers below are directly from the PCIe spec table 3-4/5. 
-+ */
-+static inline void pcie_replay_time_update(int pcie_port)
-+{
-+	u32 reg;
-+	int nlw;
-+	int rtl;
-+
-+	reg = IFX_REG_R32(PCIE_LCTLSTS(pcie_port));
-+
-+	nlw = MS(reg, PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH);
-+	switch (nlw) {
-+	case PCIE_MAX_LENGTH_WIDTH_X1:
-+		rtl = 1677;
-+		break;
-+	case PCIE_MAX_LENGTH_WIDTH_X2:
-+		rtl = 867;
-+		break;
-+	case PCIE_MAX_LENGTH_WIDTH_X4:
-+		rtl = 462;
-+		break;
-+	case PCIE_MAX_LENGTH_WIDTH_X8:
-+		rtl = 258;
-+		break;
-+	default:
-+		rtl = 1677;
-+		break;
-+	}
-+	reg = IFX_REG_R32(PCIE_ALTRT(pcie_port));
-+	reg &= ~PCIE_ALTRT_REPLAY_TIME_LIMIT;
-+	reg |= SM(rtl, PCIE_ALTRT_REPLAY_TIME_LIMIT);
-+	IFX_REG_W32(reg, PCIE_ALTRT(pcie_port));
-+}
-+
-+/*
-+ * Table 359 Enhanced Configuration Address Mapping1)
-+ * 1) This table is defined in Table 7-1, page 341, PCI Express Base Specification v1.1
-+ * Memory Address PCI Express Configuration Space
-+ * A[(20+n-1):20] Bus Number 1 < n < 8
-+ * A[19:15] Device Number
-+ * A[14:12] Function Number
-+ * A[11:8] Extended Register Number
-+ * A[7:2] Register Number
-+ * A[1:0] Along with size of the access, used to generate Byte Enables
-+ * For VR9, only the address bits [22:0] are mapped to the configuration space:
-+ * . Address bits [22:20] select the target bus (1-of-8)1)
-+ * . Address bits [19:15] select the target device (1-of-32) on the bus
-+ * . Address bits [14:12] select the target function (1-of-8) within the device.
-+ * . Address bits [11:2] selects the target dword (1-of-1024) within the selected function.s configuration space
-+ * . Address bits [1:0] define the start byte location within the selected dword.
-+ */
-+static inline u32 pcie_bus_addr(u8 bus_num, u16 devfn, int where)
-+{
-+	u32 addr;
-+	u8  bus;
-+
-+	if (!bus_num) {
-+		/* type 0 */
-+		addr = ((PCI_SLOT(devfn) & 0x1F) << 15) | ((PCI_FUNC(devfn) & 0x7) << 12) | ((where & 0xFFF)& ~3);
-+	} else {
-+		bus = bus_num;
-+		/* type 1, only support 8 buses  */
-+		addr = ((bus & 0x7) << 20) | ((PCI_SLOT(devfn) & 0x1F) << 15) |
-+			((PCI_FUNC(devfn) & 0x7) << 12) | ((where & 0xFFF) & ~3);
-+	}
-+	return addr;
-+}
-+
-+static int pcie_valid_config(int pcie_port, int bus, int dev)
-+{
-+	/* RC itself */
-+	if ((bus == 0) && (dev == 0)) {
-+		return 1;
-+	}
-+
-+	/* No physical link */
-+	if (!ifx_pcie_link_up(pcie_port)) {
-+		return 0;
-+	}
-+
-+	/* Bus zero only has RC itself
-+	* XXX, check if EP will be integrated 
-+	*/
-+	if ((bus == 0) && (dev != 0)) {
-+		return 0;
-+	}
-+
-+	/* Maximum 8 buses supported for VRX */
-+	if (bus > 9) {
-+		return 0;
-+	}
-+
-+	/* 
-+	 * PCIe is PtP link, one bus only supports only one device 
-+	 * except bus zero and PCIe switch which is virtual bus device
-+	 * The following two conditions really depends on the system design
-+	 * and attached the device.
-+	 * XXX, how about more new switch
-+	*/
-+	if ((bus == 1) && (dev != 0)) {
-+		return 0;
-+	}
-+
-+	if ((bus >= 3) && (dev != 0)) {
-+		return 0;
-+	}
-+	return 1;
-+}
-+
-+static inline u32 ifx_pcie_cfg_rd(int pcie_port, u32 reg)
-+{
-+    return IFX_REG_R32((volatile u32 *)(PCIE_CFG_PORT_TO_BASE(pcie_port) + reg));
-+}
-+
-+static inline void ifx_pcie_cfg_wr(int pcie_port, unsigned int reg, u32 val)
-+{
-+    IFX_REG_W32( val, (volatile u32 *)(PCIE_CFG_PORT_TO_BASE(pcie_port) + reg));
-+}
-+
-+static inline u32 ifx_pcie_rc_cfg_rd(int pcie_port, u32 reg)
-+{
-+    return IFX_REG_R32((volatile u32 *)(PCIE_RC_PORT_TO_BASE(pcie_port) + reg));
-+}
-+
-+static inline void ifx_pcie_rc_cfg_wr(int pcie_port, unsigned int reg, u32 val)
-+{
-+	IFX_REG_W32(val, (volatile u32 *)(PCIE_RC_PORT_TO_BASE(pcie_port) + reg));
-+}
-+
-+u32 ifx_pcie_bus_enum_read_hack(int where, u32 value)
-+{
-+	u32 tvalue = value;
-+
-+	if (where == PCI_PRIMARY_BUS) {
-+		u8 primary, secondary, subordinate;
-+
-+		primary = tvalue & 0xFF;
-+		secondary = (tvalue >> 8) & 0xFF;
-+		subordinate = (tvalue >> 16) & 0xFF;
-+		primary += pcibios_1st_host_bus_nr();
-+		secondary += pcibios_1st_host_bus_nr();
-+		subordinate += pcibios_1st_host_bus_nr();
-+		tvalue = (tvalue & 0xFF000000) | (u32)primary | (u32)(secondary << 8) | (u32)(subordinate << 16);
-+	}
-+	return tvalue;
-+}
-+
-+u32 ifx_pcie_bus_enum_write_hack(int where, u32 value)
-+{
-+    u32 tvalue = value;
-+
-+    if (where == PCI_PRIMARY_BUS) {
-+        u8 primary, secondary, subordinate;
-+
-+        primary = tvalue & 0xFF;
-+        secondary = (tvalue >> 8) & 0xFF;
-+        subordinate = (tvalue >> 16) & 0xFF;
-+        if (primary > 0 && primary != 0xFF) {
-+            primary -= pcibios_1st_host_bus_nr();
-+        }
-+
-+        if (secondary > 0 && secondary != 0xFF) {
-+            secondary -= pcibios_1st_host_bus_nr();
-+        }
-+        if (subordinate > 0 && subordinate != 0xFF) {
-+            subordinate -= pcibios_1st_host_bus_nr();
-+        }
-+        tvalue = (tvalue & 0xFF000000) | (u32)primary | (u32)(secondary << 8) | (u32)(subordinate << 16);
-+    }
-+    else if (where == PCI_SUBORDINATE_BUS) {
-+        u8 subordinate = tvalue & 0xFF;
-+
-+        subordinate = subordinate > 0 ? subordinate - pcibios_1st_host_bus_nr() : 0;
-+        tvalue = subordinate;
-+    }
-+    return tvalue;
-+}
-+
-+static int ifx_pcie_read_config(struct pci_bus *bus, u32 devfn,
-+				int where, int size, u32 *value)
-+{
-+    u32 data = 0;
-+    int bus_number = bus->number;
-+    static const u32 mask[8] = {0, 0xff, 0xffff, 0, 0xffffffff, 0, 0, 0};
-+    int ret = PCIBIOS_SUCCESSFUL;
-+    struct ifx_pci_controller *ctrl = bus->sysdata;
-+    int pcie_port = ctrl->port;
-+
-+    if (unlikely(size != 1 && size != 2 && size != 4)){
-+        ret = PCIBIOS_BAD_REGISTER_NUMBER;
-+        goto out;
-+    }
-+
-+    /* Make sure the address is aligned to natural boundary */
-+    if (unlikely(((size - 1) & where))) {
-+        ret = PCIBIOS_BAD_REGISTER_NUMBER;
-+        goto out;
-+    }
-+
-+    /* 
-+     * If we are second controller, we have to cheat OS so that it assume 
-+     * its bus number starts from 0 in host controller
-+     */
-+    bus_number = ifx_pcie_bus_nr_deduct(bus_number, pcie_port);
-+
-+    /* 
-+     * We need to force the bus number to be zero on the root 
-+     * bus. Linux numbers the 2nd root bus to start after all 
-+     * busses on root 0. 
-+     */ 
-+    if (bus->parent == NULL) {
-+        bus_number = 0; 
-+    }
-+
-+    /* 
-+     * PCIe only has a single device connected to it. It is 
-+     * always device ID 0. Don't bother doing reads for other 
-+     * device IDs on the first segment. 
-+     */ 
-+    if ((bus_number == 0) && (PCI_SLOT(devfn) != 0)) {
-+        ret = PCIBIOS_FUNC_NOT_SUPPORTED;
-+        goto out; 
-+    }
-+
-+    if (pcie_valid_config(pcie_port, bus_number, PCI_SLOT(devfn)) == 0) {
-+        *value = 0xffffffff;
-+        ret = PCIBIOS_DEVICE_NOT_FOUND;
-+        goto out;
-+    }
-+
-+    PCIE_IRQ_LOCK(ifx_pcie_lock);
-+    if (bus_number == 0) { /* RC itself */
-+        u32 t;
-+
-+        t = (where & ~3);
-+        data = ifx_pcie_rc_cfg_rd(pcie_port, t);
-+    } else {
-+        u32 addr = pcie_bus_addr(bus_number, devfn, where);
-+
-+        data = ifx_pcie_cfg_rd(pcie_port, addr);
-+    #ifdef CONFIG_IFX_PCIE_HW_SWAP
-+            data = le32_to_cpu(data);
-+    #endif /* CONFIG_IFX_PCIE_HW_SWAP */
-+    }
-+    /* To get a correct PCI topology, we have to restore the bus number to OS */
-+    data = ifx_pcie_bus_enum_hack(bus, devfn, where, data, pcie_port, 1);
-+
-+    PCIE_IRQ_UNLOCK(ifx_pcie_lock);
-+
-+    *value = (data >> (8 * (where & 3))) & mask[size & 7];
-+out:
-+    return ret;
-+}
-+
-+static u32 ifx_pcie_size_to_value(int where, int size, u32 data, u32 value)
-+{
-+	u32 shift;
-+	u32 tdata = data;
-+
-+	switch (size) {
-+	case 1:
-+		shift = (where & 0x3) << 3;
-+		tdata &= ~(0xffU << shift);
-+		tdata |= ((value & 0xffU) << shift);
-+		break;
-+	case 2:
-+		shift = (where & 3) << 3;
-+		tdata &= ~(0xffffU << shift);
-+		tdata |= ((value & 0xffffU) << shift);
-+		break;
-+	case 4:
-+		tdata = value;
-+		break;
-+	}
-+	return tdata;
-+}
-+
-+static int ifx_pcie_write_config(struct pci_bus *bus, u32 devfn,
-+				int where, int size, u32 value)
-+{
-+	int bus_number = bus->number;
-+	int ret = PCIBIOS_SUCCESSFUL;
-+	struct ifx_pci_controller *ctrl = bus->sysdata;
-+	int pcie_port = ctrl->port;
-+	u32 tvalue = value;
-+	u32 data;
-+
-+	/* Make sure the address is aligned to natural boundary */
-+	if (unlikely(((size - 1) & where))) {
-+		ret = PCIBIOS_BAD_REGISTER_NUMBER;
-+		goto out;
-+	}
-+	/* 
-+	* If we are second controller, we have to cheat OS so that it assume 
-+	* its bus number starts from 0 in host controller
-+	*/
-+	bus_number = ifx_pcie_bus_nr_deduct(bus_number, pcie_port);
-+
-+	/* 
-+	* We need to force the bus number to be zero on the root 
-+	* bus. Linux numbers the 2nd root bus to start after all 
-+	* busses on root 0. 
-+	*/ 
-+	if (bus->parent == NULL) {
-+		bus_number = 0; 
-+	}
-+
-+	if (pcie_valid_config(pcie_port, bus_number, PCI_SLOT(devfn)) == 0) {
-+		ret = PCIBIOS_DEVICE_NOT_FOUND;
-+		goto out;
-+	}
-+
-+	/* XXX, some PCIe device may need some delay */
-+	PCIE_IRQ_LOCK(ifx_pcie_lock);
-+
-+	/* 
-+	* To configure the correct bus topology using native way, we have to cheat Os so that
-+	* it can configure the PCIe hardware correctly.
-+	*/
-+	tvalue = ifx_pcie_bus_enum_hack(bus, devfn, where, value, pcie_port, 0);
-+
-+	if (bus_number == 0) { /* RC itself */
-+		u32 t;
-+
-+		t = (where & ~3);
-+		data = ifx_pcie_rc_cfg_rd(pcie_port, t);
-+
-+		data = ifx_pcie_size_to_value(where, size, data, tvalue);
-+
-+		ifx_pcie_rc_cfg_wr(pcie_port, t, data);
-+	} else {
-+		u32 addr = pcie_bus_addr(bus_number, devfn, where);
-+
-+		data = ifx_pcie_cfg_rd(pcie_port, addr);
-+#ifdef CONFIG_IFX_PCIE_HW_SWAP
-+		data = le32_to_cpu(data);
-+#endif
-+
-+		data = ifx_pcie_size_to_value(where, size, data, tvalue);
-+#ifdef CONFIG_IFX_PCIE_HW_SWAP
-+		data = cpu_to_le32(data);
-+#endif
-+		ifx_pcie_cfg_wr(pcie_port, addr, data);
-+	}
-+	PCIE_IRQ_UNLOCK(ifx_pcie_lock);
-+out:
-+	return ret;
-+}
-+
-+static struct resource ifx_pcie_io_resource = {
-+	.name	= "PCIe0 I/O space",
-+	.start	= PCIE_IO_PHY_BASE,
-+	.end	= PCIE_IO_PHY_END,
-+	.flags	= IORESOURCE_IO,
-+};
-+
-+static struct resource ifx_pcie_mem_resource = {
-+	.name	= "PCIe0 Memory space",
-+	.start	= PCIE_MEM_PHY_BASE,
-+	.end	= PCIE_MEM_PHY_END,
-+	.flags	= IORESOURCE_MEM,
-+};
-+
-+static struct pci_ops ifx_pcie_ops = {
-+	.read	= ifx_pcie_read_config,
-+	.write	= ifx_pcie_write_config,
-+};
-+
-+static struct ifx_pci_controller ifx_pcie_controller[IFX_PCIE_CORE_NR] = {
-+    {
-+        .pcic = {
-+            .pci_ops      = &ifx_pcie_ops,
-+            .mem_resource = &ifx_pcie_mem_resource,
-+            .io_resource  = &ifx_pcie_io_resource,
-+         },
-+         .port = IFX_PCIE_PORT0,
-+    },
-+};
-+
-+#ifdef IFX_PCIE_ERROR_INT
-+
-+static irqreturn_t pcie_rc_core_isr(int irq, void *dev_id)
-+{
-+	struct ifx_pci_controller *ctrl = (struct ifx_pci_controller *)dev_id;
-+	int pcie_port = ctrl->port;
-+	u32 reg;
-+
-+	printk("PCIe RC error intr %d\n", irq);
-+	reg = IFX_REG_R32(PCIE_IRNCR(pcie_port));
-+	reg &= PCIE_RC_CORE_COMBINED_INT;
-+	IFX_REG_W32(reg, PCIE_IRNCR(pcie_port));
-+
-+	return IRQ_HANDLED;
-+}
-+
-+static int
-+pcie_rc_core_int_init(int pcie_port)
-+{
-+	int ret;
-+
-+	/* Enable core interrupt */
-+	IFX_REG_SET_BIT(PCIE_RC_CORE_COMBINED_INT, PCIE_IRNEN(pcie_port));
-+
-+	/* Clear it first */
-+	IFX_REG_SET_BIT(PCIE_RC_CORE_COMBINED_INT, PCIE_IRNCR(pcie_port));
-+	ret = request_irq(pcie_irqs[pcie_port].ir_irq.irq, pcie_rc_core_isr, 0,
-+		pcie_irqs[pcie_port].ir_irq.name, &ifx_pcie_controller[pcie_port]);
-+	if (ret)
-+		printk(KERN_ERR "%s request irq %d failed\n", __func__, IFX_PCIE_IR);
-+
-+	return ret;
-+}
-+#endif
-+
-+int ifx_pcie_bios_map_irq(IFX_PCI_CONST struct pci_dev *dev, u8 slot, u8 pin)
-+{
-+	u32 irq_bit = 0;
-+	int irq = 0;
-+	struct ifx_pci_controller *ctrl = dev->bus->sysdata;
-+	int pcie_port = ctrl->port;
-+
-+	printk("%s port %d dev %s slot %d pin %d \n", __func__, pcie_port, pci_name(dev), slot, pin);
-+
-+	if ((pin == PCIE_LEGACY_DISABLE) || (pin > PCIE_LEGACY_INT_MAX)) {
-+		printk(KERN_WARNING "WARNING: dev %s: invalid interrupt pin %d\n", pci_name(dev), pin);
-+		return -1;
-+	}
-+
-+	/* Pin index so minus one */
-+	irq_bit = pcie_irqs[pcie_port].legacy_irq[pin - 1].irq_bit;
-+	irq = pcie_irqs[pcie_port].legacy_irq[pin - 1].irq;
-+	IFX_REG_SET_BIT(irq_bit, PCIE_IRNEN(pcie_port));
-+	IFX_REG_SET_BIT(irq_bit, PCIE_IRNCR(pcie_port));
-+	printk("%s dev %s irq %d assigned\n", __func__, pci_name(dev), irq);
-+	return irq;
-+}
-+
-+int  ifx_pcie_bios_plat_dev_init(struct pci_dev *dev)
-+{
-+    u16 config;
-+#ifdef IFX_PCIE_ERROR_INT
-+    u32 dconfig; 
-+    int pos;
-+#endif
-+
-+    /* Enable reporting System errors and parity errors on all devices */ 
-+    /* Enable parity checking and error reporting */ 
-+    pci_read_config_word(dev, PCI_COMMAND, &config);
-+    config |= PCI_COMMAND_PARITY | PCI_COMMAND_SERR /*| PCI_COMMAND_INVALIDATE |
-+          PCI_COMMAND_FAST_BACK*/;
-+    pci_write_config_word(dev, PCI_COMMAND, config);
-+
-+    if (dev->subordinate) {
-+        /* Set latency timers on sub bridges */
-+        pci_write_config_byte(dev, PCI_SEC_LATENCY_TIMER, 0x40); /* XXX, */
-+        /* More bridge error detection */
-+        pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &config);
-+        config |= PCI_BRIDGE_CTL_PARITY | PCI_BRIDGE_CTL_SERR;
-+        pci_write_config_word(dev, PCI_BRIDGE_CONTROL, config);
-+    }
-+#ifdef IFX_PCIE_ERROR_INT
-+    /* Enable the PCIe normal error reporting */
-+    pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
-+    if (pos) {
-+
-+        /* Disable system error generation in response to error messages */
-+        pci_read_config_word(dev, pos + PCI_EXP_RTCTL, &config);
-+        config &= ~(PCI_EXP_RTCTL_SECEE | PCI_EXP_RTCTL_SENFEE | PCI_EXP_RTCTL_SEFEE);
-+        pci_write_config_word(dev, pos + PCI_EXP_RTCTL, config);
-+
-+        /* Clear PCIE Capability's Device Status */
-+        pci_read_config_word(dev, pos + PCI_EXP_DEVSTA, &config);
-+        pci_write_config_word(dev, pos + PCI_EXP_DEVSTA, config);
-+
-+        /* Update Device Control */ 
-+        pci_read_config_word(dev, pos + PCI_EXP_DEVCTL, &config);
-+        /* Correctable Error Reporting */
-+        config |= PCI_EXP_DEVCTL_CERE;
-+        /* Non-Fatal Error Reporting */
-+        config |= PCI_EXP_DEVCTL_NFERE;
-+        /* Fatal Error Reporting */
-+        config |= PCI_EXP_DEVCTL_FERE;
-+        /* Unsupported Request */
-+        config |= PCI_EXP_DEVCTL_URRE;
-+        pci_write_config_word(dev, pos + PCI_EXP_DEVCTL, config);
-+    }
-+
-+    /* Find the Advanced Error Reporting capability */
-+    pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);
-+    if (pos) {
-+        /* Clear Uncorrectable Error Status */ 
-+        pci_read_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS, &dconfig);
-+        pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_STATUS, dconfig);
-+        /* Enable reporting of all uncorrectable errors */
-+        /* Uncorrectable Error Mask - turned on bits disable errors */
-+        pci_write_config_dword(dev, pos + PCI_ERR_UNCOR_MASK, 0);
-+        /* 
-+        * Leave severity at HW default. This only controls if 
-+        * errors are reported as uncorrectable or 
-+        * correctable, not if the error is reported. 
-+        */ 
-+        /* PCI_ERR_UNCOR_SEVER - Uncorrectable Error Severity */
-+        /* Clear Correctable Error Status */
-+        pci_read_config_dword(dev, pos + PCI_ERR_COR_STATUS, &dconfig);
-+        pci_write_config_dword(dev, pos + PCI_ERR_COR_STATUS, dconfig);
-+        /* Enable reporting of all correctable errors */
-+        /* Correctable Error Mask - turned on bits disable errors */
-+        pci_write_config_dword(dev, pos + PCI_ERR_COR_MASK, 0);
-+        /* Advanced Error Capabilities */ 
-+        pci_read_config_dword(dev, pos + PCI_ERR_CAP, &dconfig);
-+        /* ECRC Generation Enable */
-+        if (dconfig & PCI_ERR_CAP_ECRC_GENC) {
-+            dconfig |= PCI_ERR_CAP_ECRC_GENE;
-+        }
-+        /* ECRC Check Enable */
-+        if (dconfig & PCI_ERR_CAP_ECRC_CHKC) {
-+            dconfig |= PCI_ERR_CAP_ECRC_CHKE;
-+        }
-+        pci_write_config_dword(dev, pos + PCI_ERR_CAP, dconfig);
-+
-+        /* PCI_ERR_HEADER_LOG - Header Log Register (16 bytes) */
-+        /* Enable Root Port's interrupt in response to error messages */
-+        pci_write_config_dword(dev, pos + PCI_ERR_ROOT_COMMAND,
-+              PCI_ERR_ROOT_CMD_COR_EN |
-+              PCI_ERR_ROOT_CMD_NONFATAL_EN |
-+              PCI_ERR_ROOT_CMD_FATAL_EN); 
-+        /* Clear the Root status register */
-+        pci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &dconfig);
-+        pci_write_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, dconfig);
-+    }
-+#endif /* IFX_PCIE_ERROR_INT */
-+    /* WAR, only 128 MRRS is supported, force all EPs to support this value */
-+    pcie_set_readrq(dev, 128);
-+    return 0;
-+}
-+
-+static int
-+pcie_rc_initialize(int pcie_port)
-+{
-+	int i;
-+#define IFX_PCIE_PHY_LOOP_CNT  5
-+
-+	pcie_rcu_endian_setup(pcie_port);
-+
-+	pcie_ep_gpio_rst_init(pcie_port);
-+
-+	/* 
-+	* XXX, PCIe elastic buffer bug will cause not to be detected. One more 
-+	* reset PCIe PHY will solve this issue 
-+	*/
-+	for (i = 0; i < IFX_PCIE_PHY_LOOP_CNT; i++) {
-+		/* Disable PCIe PHY Analog part for sanity check */
-+		pcie_phy_pmu_disable(pcie_port);
-+
-+		pcie_phy_rst_assert(pcie_port);
-+		pcie_phy_rst_deassert(pcie_port);
-+
-+		/* Make sure PHY PLL is stable */
-+		udelay(20);
-+
-+		/* PCIe Core reset enabled, low active, sw programmed */
-+		pcie_core_rst_assert(pcie_port);
-+
-+		/* Put PCIe EP in reset status */
-+		pcie_device_rst_assert(pcie_port);
-+
-+		/* PCI PHY & Core reset disabled, high active, sw programmed */
-+		pcie_core_rst_deassert(pcie_port);
-+
-+		/* Already in a quiet state, program PLL, enable PHY, check ready bit */
-+		pcie_phy_clock_mode_setup(pcie_port);
-+
-+		/* Enable PCIe PHY and Clock */
-+		pcie_core_pmu_setup(pcie_port);
-+
-+		/* Clear status registers */
-+		pcie_status_register_clear(pcie_port);
-+
-+#ifdef CONFIG_PCI_MSI
-+		pcie_msi_init(pcie_port);
-+#endif /* CONFIG_PCI_MSI */
-+		pcie_rc_cfg_reg_setup(pcie_port);
-+
-+		/* Once link is up, break out */
-+		if (pcie_app_loigc_setup(pcie_port) == 0)
-+			break;
-+	}
-+	if (i >= IFX_PCIE_PHY_LOOP_CNT) {
-+		printk(KERN_ERR "%s link up failed!!!!!\n", __func__);
-+		return -EIO;
-+	}
-+	/* NB, don't increase ACK/NACK timer timeout value, which will cause a lot of COR errors */
-+	pcie_replay_time_update(pcie_port);
-+	return 0;
-+}
-+
-+static int __init ifx_pcie_bios_init(void)
-+{
-+    void __iomem *io_map_base;
-+    int pcie_port;
-+    int startup_port;
-+
-+    /* Enable AHB Master/ Slave */
-+    pcie_ahb_pmu_setup();
-+
-+    startup_port = IFX_PCIE_PORT0;
-+    
-+    for (pcie_port = startup_port; pcie_port < IFX_PCIE_CORE_NR; pcie_port++){
-+	if (pcie_rc_initialize(pcie_port) == 0) {
-+	    IFX_PCIE_PRINT(PCIE_MSG_INIT, "%s: ifx_pcie_cfg_base 0x%p\n", 
-+                 __func__, PCIE_CFG_PORT_TO_BASE(pcie_port));
-+            /* Otherwise, warning will pop up */
-+            io_map_base = ioremap(PCIE_IO_PHY_PORT_TO_BASE(pcie_port), PCIE_IO_SIZE);
-+            if (io_map_base == NULL) {
-+                IFX_PCIE_PRINT(PCIE_MSG_ERR, "%s io space ioremap failed\n", __func__);
-+                return -ENOMEM;
-+            }
-+            ifx_pcie_controller[pcie_port].pcic.io_map_base = (unsigned long)io_map_base;
-+
-+            register_pci_controller(&ifx_pcie_controller[pcie_port].pcic);
-+            /* XXX, clear error status */
-+
-+            IFX_PCIE_PRINT(PCIE_MSG_INIT, "%s: mem_resource 0x%p, io_resource 0x%p\n", 
-+                              __func__, &ifx_pcie_controller[pcie_port].pcic.mem_resource, 
-+                              &ifx_pcie_controller[pcie_port].pcic.io_resource);
-+
-+        #ifdef IFX_PCIE_ERROR_INT
-+            pcie_rc_core_int_init(pcie_port);
-+        #endif /* IFX_PCIE_ERROR_INT */
-+        }
-+    }
-+
-+    return 0;
-+}
-+arch_initcall(ifx_pcie_bios_init);
-+
-+MODULE_LICENSE("GPL");
-+MODULE_AUTHOR("Chuanhua.Lei@infineon.com");
-+MODULE_SUPPORTED_DEVICE("Infineon builtin PCIe RC module");
-+MODULE_DESCRIPTION("Infineon builtin PCIe RC driver");
-+
---- /dev/null
-+++ b/arch/mips/pci/ifxmips_pcie.h
-@@ -0,0 +1,135 @@
-+/******************************************************************************
-+**
-+** FILE NAME    : ifxmips_pcie.h
-+** PROJECT      : IFX UEIP for VRX200
-+** MODULES      : PCIe module
-+**
-+** DATE         : 02 Mar 2009
-+** AUTHOR       : Lei Chuanhua
-+** DESCRIPTION  : PCIe Root Complex Driver
-+** COPYRIGHT    :       Copyright (c) 2009
-+**                      Infineon Technologies AG
-+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-+**
-+**    This program is free software; you can redistribute it and/or modify
-+**    it under the terms of the GNU General Public License as published by
-+**    the Free Software Foundation; either version 2 of the License, or
-+**    (at your option) any later version.
-+** HISTORY
-+** $Version $Date        $Author         $Comment
-+** 0.0.1    17 Mar,2009  Lei Chuanhua    Initial version
-+*******************************************************************************/
-+#ifndef IFXMIPS_PCIE_H
-+#define IFXMIPS_PCIE_H
-+#include <linux/version.h>
-+#include <linux/types.h>
-+#include <linux/pci.h>
-+#include <linux/interrupt.h>
-+#include "ifxmips_pci_common.h"
-+#include "ifxmips_pcie_reg.h"
-+
-+/*!
-+ \defgroup IFX_PCIE  PCI Express bus driver module   
-+ \brief  PCI Express IP module support VRX200 
-+*/
-+
-+/*!
-+ \defgroup IFX_PCIE_OS OS APIs
-+ \ingroup IFX_PCIE
-+ \brief PCIe bus driver OS interface functions
-+*/
-+
-+/*!
-+ \file ifxmips_pcie.h
-+ \ingroup IFX_PCIE  
-+ \brief header file for PCIe module common header file
-+*/
-+#define PCIE_IRQ_LOCK(lock) do {             \
-+    unsigned long flags;                     \
-+    spin_lock_irqsave(&(lock), flags);
-+#define PCIE_IRQ_UNLOCK(lock)                \
-+    spin_unlock_irqrestore(&(lock), flags);  \
-+} while (0)
-+
-+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
-+#define IRQF_SHARED SA_SHIRQ
-+#endif
-+
-+#define PCIE_MSG_MSI        0x00000001
-+#define PCIE_MSG_ISR        0x00000002
-+#define PCIE_MSG_FIXUP      0x00000004
-+#define PCIE_MSG_READ_CFG   0x00000008
-+#define PCIE_MSG_WRITE_CFG  0x00000010
-+#define PCIE_MSG_CFG        (PCIE_MSG_READ_CFG | PCIE_MSG_WRITE_CFG)
-+#define PCIE_MSG_REG        0x00000020
-+#define PCIE_MSG_INIT       0x00000040
-+#define PCIE_MSG_ERR        0x00000080
-+#define PCIE_MSG_PHY        0x00000100
-+#define PCIE_MSG_ANY        0x000001ff
-+
-+#define IFX_PCIE_PORT0      0
-+#define IFX_PCIE_PORT1      1
-+
-+#ifdef CONFIG_IFX_PCIE_2ND_CORE
-+#define IFX_PCIE_CORE_NR    2
-+#else
-+#define IFX_PCIE_CORE_NR    1
-+#endif
-+
-+#define IFX_PCIE_ERROR_INT
-+
-+//#define IFX_PCIE_DBG
-+
-+#if defined(IFX_PCIE_DBG)
-+#define IFX_PCIE_PRINT(_m, _fmt, args...) do {   \
-+        ifx_pcie_debug((_fmt), ##args);          \
-+} while (0)
-+
-+#define INLINE 
-+#else
-+#define IFX_PCIE_PRINT(_m, _fmt, args...)   \
-+    do {} while(0)
-+#define INLINE inline
-+#endif
-+
-+struct ifx_pci_controller {
-+	struct pci_controller   pcic;
-+    
-+	/* RC specific, per host bus information */
-+	u32   port;  /* Port index, 0 -- 1st core, 1 -- 2nd core */
-+};
-+
-+typedef struct ifx_pcie_ir_irq {
-+    const unsigned int irq;
-+    const char name[16];
-+}ifx_pcie_ir_irq_t;
-+
-+typedef struct ifx_pcie_legacy_irq{
-+    const u32 irq_bit;
-+    const int irq;
-+}ifx_pcie_legacy_irq_t;
-+
-+typedef struct ifx_pcie_irq {
-+    ifx_pcie_ir_irq_t ir_irq;
-+    ifx_pcie_legacy_irq_t legacy_irq[PCIE_LEGACY_INT_MAX];
-+}ifx_pcie_irq_t;
-+
-+extern u32 g_pcie_debug_flag;
-+extern void ifx_pcie_debug(const char *fmt, ...);
-+extern void pcie_phy_clock_mode_setup(int pcie_port);
-+extern void pcie_msi_pic_init(int pcie_port);
-+extern u32 ifx_pcie_bus_enum_read_hack(int where, u32 value);
-+extern u32 ifx_pcie_bus_enum_write_hack(int where, u32 value);
-+
-+#define CONFIG_VR9
-+
-+#ifdef CONFIG_VR9
-+#include "ifxmips_pcie_vr9.h"
-+#elif defined (CONFIG_AR10)
-+#include "ifxmips_pcie_ar10.h"
-+#else
-+#error "PCIE: platform not defined"
-+#endif /* CONFIG_VR9 */
-+
-+#endif  /* IFXMIPS_PCIE_H */
-+
---- /dev/null
-+++ b/arch/mips/pci/ifxmips_pcie_ar10.h
-@@ -0,0 +1,290 @@
-+/****************************************************************************
-+                              Copyright (c) 2010
-+                            Lantiq Deutschland GmbH
-+                     Am Campeon 3; 85579 Neubiberg, Germany
-+
-+  For licensing information, see the file 'LICENSE' in the root folder of
-+  this software module.
-+
-+ *****************************************************************************/
-+/*!
-+  \file ifxmips_pcie_ar10.h
-+  \ingroup IFX_PCIE
-+  \brief PCIe RC driver ar10 specific file
-+*/
-+
-+#ifndef IFXMIPS_PCIE_AR10_H
-+#define IFXMIPS_PCIE_AR10_H
-+#ifndef AUTOCONF_INCLUDED
-+#include <linux/config.h>
-+#endif /* AUTOCONF_INCLUDED */
-+#include <linux/types.h>
-+#include <linux/delay.h>
-+
-+/* Project header file */
-+#include <asm/ifx/ifx_types.h>
-+#include <asm/ifx/ifx_pmu.h>
-+#include <asm/ifx/ifx_gpio.h>
-+#include <asm/ifx/ifx_ebu_led.h>
-+
-+static inline void pcie_ep_gpio_rst_init(int pcie_port)
-+{
-+    ifx_ebu_led_enable();
-+    if (pcie_port == 0) {
-+        ifx_ebu_led_set_data(11, 1);        
-+    }
-+    else {
-+        ifx_ebu_led_set_data(12, 1);  
-+    }
-+}
-+
-+static inline void pcie_ahb_pmu_setup(void) 
-+{
-+    /* XXX, moved to CGU to control AHBM */
-+}
-+
-+static inline void pcie_rcu_endian_setup(int pcie_port)
-+{
-+    u32 reg;
-+
-+    reg = IFX_REG_R32(IFX_RCU_AHB_ENDIAN);
-+    /* Inbound, big endian */
-+    reg |= IFX_RCU_BE_AHB4S;
-+    if (pcie_port == 0) {
-+        reg |= IFX_RCU_BE_PCIE0M;
-+
-+    #ifdef CONFIG_IFX_PCIE_HW_SWAP
-+        /* Outbound, software swap needed */
-+        reg |= IFX_RCU_BE_AHB3M;
-+        reg &= ~IFX_RCU_BE_PCIE0S;
-+    #else
-+        /* Outbound little endian  */
-+        reg &= ~IFX_RCU_BE_AHB3M;
-+        reg &= ~IFX_RCU_BE_PCIE0S;
-+    #endif
-+    }
-+    else {
-+        reg |= IFX_RCU_BE_PCIE1M;
-+    #ifdef CONFIG_IFX_PCIE1_HW_SWAP
-+        /* Outbound, software swap needed */
-+        reg |= IFX_RCU_BE_AHB3M;
-+        reg &= ~IFX_RCU_BE_PCIE1S;
-+    #else
-+        /* Outbound little endian  */
-+        reg &= ~IFX_RCU_BE_AHB3M;
-+        reg &= ~IFX_RCU_BE_PCIE1S;
-+    #endif
-+    }
-+
-+    IFX_REG_W32(reg, IFX_RCU_AHB_ENDIAN);
-+    IFX_PCIE_PRINT(PCIE_MSG_REG, "%s IFX_RCU_AHB_ENDIAN: 0x%08x\n", __func__, IFX_REG_R32(IFX_RCU_AHB_ENDIAN));
-+}
-+
-+static inline void pcie_phy_pmu_enable(int pcie_port)
-+{
-+    if (pcie_port == 0) { /* XXX, should use macro*/
-+        PCIE0_PHY_PMU_SETUP(IFX_PMU_ENABLE);
-+    }
-+    else {
-+        PCIE1_PHY_PMU_SETUP(IFX_PMU_ENABLE);
-+    }
-+}
-+
-+static inline void pcie_phy_pmu_disable(int pcie_port)
-+{
-+    if (pcie_port == 0) { /* XXX, should use macro*/
-+        PCIE0_PHY_PMU_SETUP(IFX_PMU_DISABLE);
-+    }
-+    else {
-+        PCIE1_PHY_PMU_SETUP(IFX_PMU_DISABLE);
-+    }
-+}
-+
-+static inline void pcie_pdi_big_endian(int pcie_port)
-+{
-+    u32 reg;
-+
-+    reg = IFX_REG_R32(IFX_RCU_AHB_ENDIAN);
-+    if (pcie_port == 0) {
-+        /* Config AHB->PCIe and PDI endianness */
-+        reg |= IFX_RCU_BE_PCIE0_PDI;
-+    }
-+    else {
-+        /* Config AHB->PCIe and PDI endianness */
-+        reg |= IFX_RCU_BE_PCIE1_PDI;
-+    }
-+    IFX_REG_W32(reg, IFX_RCU_AHB_ENDIAN);
-+}
-+
-+static inline void pcie_pdi_pmu_enable(int pcie_port)
-+{
-+    if (pcie_port == 0) {
-+        /* Enable PDI to access PCIe PHY register */
-+        PDI0_PMU_SETUP(IFX_PMU_ENABLE);
-+    }
-+    else {
-+        PDI1_PMU_SETUP(IFX_PMU_ENABLE);
-+    }
-+}
-+
-+static inline void pcie_core_rst_assert(int pcie_port)
-+{
-+    u32 reg;
-+
-+    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-+
-+    /* Reset Core, bit 22 */
-+    if (pcie_port == 0) {
-+        reg |= 0x00400000;
-+    }
-+    else {
-+        reg |= 0x08000000; /* Bit 27 */
-+    }
-+    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-+}
-+
-+static inline void pcie_core_rst_deassert(int pcie_port)
-+{
-+    u32 reg;
-+
-+    /* Make sure one micro-second delay */
-+    udelay(1);
-+
-+    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-+    if (pcie_port == 0) {
-+        reg &= ~0x00400000; /* bit 22 */
-+    }
-+    else {
-+        reg &= ~0x08000000; /* Bit 27 */
-+    }
-+    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-+}
-+
-+static inline void pcie_phy_rst_assert(int pcie_port)
-+{
-+    u32 reg;
-+
-+    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-+    if (pcie_port == 0) {
-+        reg |= 0x00001000; /* Bit 12 */
-+    }
-+    else {
-+        reg |= 0x00002000; /* Bit 13 */
-+    }
-+    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-+}
-+
-+static inline void pcie_phy_rst_deassert(int pcie_port)
-+{
-+    u32 reg;
-+
-+    /* Make sure one micro-second delay */
-+    udelay(1);
-+
-+    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-+    if (pcie_port == 0) {
-+        reg &= ~0x00001000; /* Bit 12 */
-+    }
-+    else {
-+        reg &= ~0x00002000; /* Bit 13 */
-+    }
-+    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-+}
-+
-+static inline void pcie_device_rst_assert(int pcie_port)
-+{
-+    if (pcie_port == 0) {
-+        ifx_ebu_led_set_data(11, 0);
-+    }
-+    else {
-+        ifx_ebu_led_set_data(12, 0);
-+    }
-+}
-+
-+static inline void pcie_device_rst_deassert(int pcie_port)
-+{
-+    mdelay(100);
-+    if (pcie_port == 0) {
-+        ifx_ebu_led_set_data(11, 1);
-+    }
-+    else {
-+        ifx_ebu_led_set_data(12, 1);
-+    }
-+    ifx_ebu_led_disable();
-+}
-+
-+static inline void pcie_core_pmu_setup(int pcie_port)
-+{
-+    if (pcie_port == 0) {
-+        PCIE0_CTRL_PMU_SETUP(IFX_PMU_ENABLE);
-+    }
-+    else {
-+        PCIE1_CTRL_PMU_SETUP(IFX_PMU_ENABLE); 
-+    }
-+}
-+
-+static inline void pcie_msi_init(int pcie_port)
-+{
-+    pcie_msi_pic_init(pcie_port);
-+    if (pcie_port == 0) {
-+        MSI0_PMU_SETUP(IFX_PMU_ENABLE);
-+    }
-+    else {
-+        MSI1_PMU_SETUP(IFX_PMU_ENABLE);
-+    }
-+}
-+
-+static inline u32
-+ifx_pcie_bus_nr_deduct(u32 bus_number, int pcie_port)
-+{
-+    u32 tbus_number = bus_number;
-+
-+#ifdef CONFIG_IFX_PCIE_2ND_CORE
-+    if (pcie_port == IFX_PCIE_PORT1) { /* Port 1 must check if there are two cores enabled */
-+        if (pcibios_host_nr() > 1) {
-+            tbus_number -= pcibios_1st_host_bus_nr();
-+        }        
-+    }
-+#endif /* CONFIG_IFX_PCI */
-+    return tbus_number;
-+}
-+
-+static inline u32
-+ifx_pcie_bus_enum_hack(struct pci_bus *bus, u32 devfn, int where, u32 value, int pcie_port, int read)
-+{
-+    struct pci_dev *pdev;
-+    u32 tvalue = value;
-+
-+    /* Sanity check */
-+    pdev = pci_get_slot(bus, devfn);
-+    if (pdev == NULL) {
-+        return tvalue;
-+    }
-+
-+    /* Only care about PCI bridge */
-+    if (pdev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {
-+        return tvalue;
-+    }
-+
-+    if (read) { /* Read hack */
-+    #ifdef CONFIG_IFX_PCIE_2ND_CORE
-+        if (pcie_port == IFX_PCIE_PORT1) { /* Port 1 must check if there are two cores enabled */
-+            if (pcibios_host_nr() > 1) {
-+                tvalue = ifx_pcie_bus_enum_read_hack(where, tvalue);
-+            }
-+        }
-+    #endif /* CONFIG_IFX_PCIE_2ND_CORE */
-+    }
-+    else { /* Write hack */
-+    #ifdef CONFIG_IFX_PCIE_2ND_CORE
-+        if (pcie_port == IFX_PCIE_PORT1) { /* Port 1 must check if there are two cores enabled */
-+            if (pcibios_host_nr() > 1) {
-+                tvalue = ifx_pcie_bus_enum_write_hack(where, tvalue);
-+            }
-+        }
-+    #endif
-+    }
-+    return tvalue;
-+}
-+
-+#endif /* IFXMIPS_PCIE_AR10_H */
---- /dev/null
-+++ b/arch/mips/pci/ifxmips_pcie_msi.c
-@@ -0,0 +1,392 @@
-+/******************************************************************************
-+**
-+** FILE NAME    : ifxmips_pcie_msi.c
-+** PROJECT      : IFX UEIP for VRX200
-+** MODULES      : PCI MSI sub module
-+**
-+** DATE         : 02 Mar 2009
-+** AUTHOR       : Lei Chuanhua
-+** DESCRIPTION  : PCIe MSI Driver
-+** COPYRIGHT    :       Copyright (c) 2009
-+**                      Infineon Technologies AG
-+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-+**
-+**    This program is free software; you can redistribute it and/or modify
-+**    it under the terms of the GNU General Public License as published by
-+**    the Free Software Foundation; either version 2 of the License, or
-+**    (at your option) any later version.
-+** HISTORY
-+** $Date        $Author         $Comment
-+** 02 Mar,2009  Lei Chuanhua    Initial version
-+*******************************************************************************/
-+/*!
-+ \defgroup IFX_PCIE_MSI MSI OS APIs
-+ \ingroup IFX_PCIE
-+ \brief PCIe bus driver OS interface functions
-+*/
-+
-+/*!
-+ \file ifxmips_pcie_msi.c
-+ \ingroup IFX_PCIE 
-+ \brief PCIe MSI OS interface file
-+*/
-+
-+#ifndef AUTOCONF_INCLUDED
-+#include <linux/config.h>
-+#endif /* AUTOCONF_INCLUDED */
-+#include <linux/init.h>
-+#include <linux/sched.h>
-+#include <linux/slab.h>
-+#include <linux/interrupt.h>
-+#include <linux/kernel_stat.h>
-+#include <linux/pci.h>
-+#include <linux/msi.h>
-+#include <linux/module.h>
-+#include <asm/bootinfo.h>
-+#include <asm/irq.h>
-+#include <asm/traps.h>
-+
-+#include <asm/ifx/ifx_types.h>
-+#include <asm/ifx/ifx_regs.h>
-+#include <asm/ifx/common_routines.h>
-+#include <asm/ifx/irq.h>
-+
-+#include "ifxmips_pcie_reg.h"
-+#include "ifxmips_pcie.h"
-+
-+#define IFX_MSI_IRQ_NUM    16
-+
-+enum {
-+    IFX_PCIE_MSI_IDX0 = 0,
-+    IFX_PCIE_MSI_IDX1,
-+    IFX_PCIE_MSI_IDX2,
-+    IFX_PCIE_MSI_IDX3,
-+};
-+
-+typedef struct ifx_msi_irq_idx {
-+    const int irq;
-+    const int idx;
-+}ifx_msi_irq_idx_t;
-+
-+struct ifx_msi_pic {
-+    volatile u32  pic_table[IFX_MSI_IRQ_NUM];
-+    volatile u32  pic_endian;    /* 0x40  */
-+};
-+typedef struct ifx_msi_pic *ifx_msi_pic_t;
-+
-+typedef struct ifx_msi_irq {
-+    const volatile ifx_msi_pic_t msi_pic_p;
-+    const u32 msi_phy_base;
-+    const ifx_msi_irq_idx_t msi_irq_idx[IFX_MSI_IRQ_NUM];
-+    /*
-+     * Each bit in msi_free_irq_bitmask represents a MSI interrupt that is 
-+     * in use.
-+     */
-+    u16 msi_free_irq_bitmask;
-+
-+    /*
-+     * Each bit in msi_multiple_irq_bitmask tells that the device using 
-+     * this bit in msi_free_irq_bitmask is also using the next bit. This 
-+     * is used so we can disable all of the MSI interrupts when a device 
-+     * uses multiple.
-+     */
-+    u16 msi_multiple_irq_bitmask;
-+}ifx_msi_irq_t;
-+
-+static ifx_msi_irq_t msi_irqs[IFX_PCIE_CORE_NR] = {
-+    {
-+        .msi_pic_p = (const volatile ifx_msi_pic_t)IFX_MSI_PIC_REG_BASE,
-+        .msi_phy_base = PCIE_MSI_PHY_BASE,
-+        .msi_irq_idx = {
-+            {IFX_PCIE_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE_MSI_IR1, IFX_PCIE_MSI_IDX1},
-+            {IFX_PCIE_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE_MSI_IR3, IFX_PCIE_MSI_IDX3},
-+            {IFX_PCIE_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE_MSI_IR1, IFX_PCIE_MSI_IDX1},
-+            {IFX_PCIE_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE_MSI_IR3, IFX_PCIE_MSI_IDX3},
-+            {IFX_PCIE_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE_MSI_IR1, IFX_PCIE_MSI_IDX1},
-+            {IFX_PCIE_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE_MSI_IR3, IFX_PCIE_MSI_IDX3},
-+            {IFX_PCIE_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE_MSI_IR1, IFX_PCIE_MSI_IDX1},
-+            {IFX_PCIE_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE_MSI_IR3, IFX_PCIE_MSI_IDX3},
-+        },
-+        .msi_free_irq_bitmask = 0,
-+        .msi_multiple_irq_bitmask= 0,
-+    },
-+#ifdef CONFIG_IFX_PCIE_2ND_CORE
-+    {
-+        .msi_pic_p = (const volatile ifx_msi_pic_t)IFX_MSI1_PIC_REG_BASE,
-+        .msi_phy_base = PCIE1_MSI_PHY_BASE,
-+        .msi_irq_idx = {
-+            {IFX_PCIE1_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE1_MSI_IR1, IFX_PCIE_MSI_IDX1},
-+            {IFX_PCIE1_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE1_MSI_IR3, IFX_PCIE_MSI_IDX3},
-+            {IFX_PCIE1_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE1_MSI_IR1, IFX_PCIE_MSI_IDX1},
-+            {IFX_PCIE1_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE1_MSI_IR3, IFX_PCIE_MSI_IDX3},
-+            {IFX_PCIE1_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE1_MSI_IR1, IFX_PCIE_MSI_IDX1},
-+            {IFX_PCIE1_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE1_MSI_IR3, IFX_PCIE_MSI_IDX3},
-+            {IFX_PCIE1_MSI_IR0, IFX_PCIE_MSI_IDX0}, {IFX_PCIE1_MSI_IR1, IFX_PCIE_MSI_IDX1},
-+            {IFX_PCIE1_MSI_IR2, IFX_PCIE_MSI_IDX2}, {IFX_PCIE1_MSI_IR3, IFX_PCIE_MSI_IDX3},
-+        },
-+        .msi_free_irq_bitmask = 0,
-+        .msi_multiple_irq_bitmask= 0,
-+
-+    },
-+#endif /* CONFIG_IFX_PCIE_2ND_CORE */
-+};
-+
-+/* 
-+ * This lock controls updates to msi_free_irq_bitmask, 
-+ * msi_multiple_irq_bitmask and pic register settting
-+ */ 
-+static DEFINE_SPINLOCK(ifx_pcie_msi_lock);
-+
-+void pcie_msi_pic_init(int pcie_port)
-+{
-+    spin_lock(&ifx_pcie_msi_lock);
-+    msi_irqs[pcie_port].msi_pic_p->pic_endian = IFX_MSI_PIC_BIG_ENDIAN;
-+    spin_unlock(&ifx_pcie_msi_lock);
-+}
-+
-+/** 
-+ * \fn int arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
-+ * \brief Called when a driver request MSI interrupts instead of the 
-+ * legacy INT A-D. This routine will allocate multiple interrupts 
-+ * for MSI devices that support them. A device can override this by 
-+ * programming the MSI control bits [6:4] before calling 
-+ * pci_enable_msi(). 
-+ * 
-+ * \param[in] pdev   Device requesting MSI interrupts 
-+ * \param[in] desc   MSI descriptor 
-+ * 
-+ * \return   -EINVAL Invalid pcie root port or invalid msi bit
-+ * \return    0        OK
-+ * \ingroup IFX_PCIE_MSI
-+ */
-+int 
-+arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
-+{
-+    int  irq, pos;
-+    u16  control;
-+    int  irq_idx;
-+    int  irq_step;
-+    int configured_private_bits;
-+    int request_private_bits;
-+    struct msi_msg msg;
-+    u16 search_mask;
-+    struct ifx_pci_controller *ctrl = pdev->bus->sysdata;
-+    int pcie_port = ctrl->port;
-+
-+    IFX_PCIE_PRINT(PCIE_MSG_MSI, "%s %s enter\n", __func__, pci_name(pdev));
-+
-+    /* XXX, skip RC MSI itself */
-+    if (pdev->pcie_type == PCI_EXP_TYPE_ROOT_PORT) {
-+        IFX_PCIE_PRINT(PCIE_MSG_MSI, "%s RC itself doesn't use MSI interrupt\n", __func__);
-+        return -EINVAL;
-+    }
-+
-+    /*
-+     * Read the MSI config to figure out how many IRQs this device 
-+     * wants.  Most devices only want 1, which will give 
-+     * configured_private_bits and request_private_bits equal 0. 
-+     */
-+    pci_read_config_word(pdev, desc->msi_attrib.pos + PCI_MSI_FLAGS, &control);
-+
-+    /*
-+     * If the number of private bits has been configured then use 
-+     * that value instead of the requested number. This gives the 
-+     * driver the chance to override the number of interrupts 
-+     * before calling pci_enable_msi(). 
-+     */
-+    configured_private_bits = (control & PCI_MSI_FLAGS_QSIZE) >> 4; 
-+    if (configured_private_bits == 0) {
-+        /* Nothing is configured, so use the hardware requested size */
-+        request_private_bits = (control & PCI_MSI_FLAGS_QMASK) >> 1;
-+    }
-+    else {
-+        /*
-+         * Use the number of configured bits, assuming the 
-+         * driver wanted to override the hardware request 
-+         * value.
-+         */
-+        request_private_bits = configured_private_bits;
-+    }
-+
-+    /*
-+     * The PCI 2.3 spec mandates that there are at most 32
-+     * interrupts. If this device asks for more, only give it one.
-+     */
-+    if (request_private_bits > 5) {
-+        request_private_bits = 0;
-+    }
-+again:
-+    /*
-+     * The IRQs have to be aligned on a power of two based on the
-+     * number being requested.
-+     */
-+    irq_step = (1 << request_private_bits);
-+
-+    /* Mask with one bit for each IRQ */
-+    search_mask = (1 << irq_step) - 1;
-+
-+    /*
-+     * We're going to search msi_free_irq_bitmask_lock for zero 
-+     * bits. This represents an MSI interrupt number that isn't in 
-+     * use.
-+     */
-+    spin_lock(&ifx_pcie_msi_lock);
-+    for (pos = 0; pos < IFX_MSI_IRQ_NUM; pos += irq_step) {
-+        if ((msi_irqs[pcie_port].msi_free_irq_bitmask & (search_mask << pos)) == 0) {
-+            msi_irqs[pcie_port].msi_free_irq_bitmask |= search_mask << pos; 
-+            msi_irqs[pcie_port].msi_multiple_irq_bitmask |= (search_mask >> 1) << pos;
-+            break; 
-+        }
-+    }
-+    spin_unlock(&ifx_pcie_msi_lock); 
-+
-+    /* Make sure the search for available interrupts didn't fail */ 
-+    if (pos >= IFX_MSI_IRQ_NUM) {
-+        if (request_private_bits) {
-+            IFX_PCIE_PRINT(PCIE_MSG_MSI, "%s: Unable to find %d free "
-+                  "interrupts, trying just one", __func__, 1 << request_private_bits);
-+            request_private_bits = 0;
-+            goto again;
-+        }
-+        else {
-+            printk(KERN_ERR "%s: Unable to find a free MSI interrupt\n", __func__);
-+            return -EINVAL;
-+        }
-+    } 
-+    irq = msi_irqs[pcie_port].msi_irq_idx[pos].irq;
-+    irq_idx = msi_irqs[pcie_port].msi_irq_idx[pos].idx;
-+
-+    IFX_PCIE_PRINT(PCIE_MSG_MSI, "pos %d, irq %d irq_idx %d\n", pos, irq, irq_idx);
-+
-+    /*
-+     * Initialize MSI. This has to match the memory-write endianess from the device 
-+     * Address bits [23:12]
-+     */
-+    spin_lock(&ifx_pcie_msi_lock); 
-+    msi_irqs[pcie_port].msi_pic_p->pic_table[pos] = SM(irq_idx, IFX_MSI_PIC_INT_LINE) |
-+                    SM((msi_irqs[pcie_port].msi_phy_base >> 12), IFX_MSI_PIC_MSG_ADDR) |
-+                    SM((1 << pos), IFX_MSI_PIC_MSG_DATA);
-+
-+    /* Enable this entry */
-+    msi_irqs[pcie_port].msi_pic_p->pic_table[pos] &= ~IFX_MSI_PCI_INT_DISABLE;
-+    spin_unlock(&ifx_pcie_msi_lock);
-+
-+    IFX_PCIE_PRINT(PCIE_MSG_MSI, "pic_table[%d]: 0x%08x\n",
-+        pos, msi_irqs[pcie_port].msi_pic_p->pic_table[pos]);
-+
-+    /* Update the number of IRQs the device has available to it */
-+    control &= ~PCI_MSI_FLAGS_QSIZE;
-+    control |= (request_private_bits << 4);
-+    pci_write_config_word(pdev, desc->msi_attrib.pos + PCI_MSI_FLAGS, control);
-+
-+    set_irq_msi(irq, desc);
-+    msg.address_hi = 0x0;
-+    msg.address_lo = msi_irqs[pcie_port].msi_phy_base;
-+    msg.data = SM((1 << pos), IFX_MSI_PIC_MSG_DATA);
-+    IFX_PCIE_PRINT(PCIE_MSG_MSI, "msi_data: pos %d 0x%08x\n", pos, msg.data);
-+
-+    write_msi_msg(irq, &msg);
-+    IFX_PCIE_PRINT(PCIE_MSG_MSI, "%s exit\n", __func__);
-+    return 0;
-+}
-+
-+static int
-+pcie_msi_irq_to_port(unsigned int irq, int *port)
-+{
-+    int ret = 0;
-+
-+    if (irq == IFX_PCIE_MSI_IR0 || irq == IFX_PCIE_MSI_IR1 ||
-+        irq == IFX_PCIE_MSI_IR2 || irq == IFX_PCIE_MSI_IR3) {
-+        *port = IFX_PCIE_PORT0;
-+    }
-+#ifdef CONFIG_IFX_PCIE_2ND_CORE
-+    else if (irq == IFX_PCIE1_MSI_IR0 || irq == IFX_PCIE1_MSI_IR1 ||
-+        irq == IFX_PCIE1_MSI_IR2 || irq == IFX_PCIE1_MSI_IR3) {
-+        *port = IFX_PCIE_PORT1;
-+    }
-+#endif /* CONFIG_IFX_PCIE_2ND_CORE */
-+    else {
-+        printk(KERN_ERR "%s: Attempted to teardown illegal " 
-+            "MSI interrupt (%d)\n", __func__, irq);
-+        ret = -EINVAL;
-+    }
-+    return ret;
-+}
-+
-+/** 
-+ * \fn void arch_teardown_msi_irq(unsigned int irq)
-+ * \brief Called when a device no longer needs its MSI interrupts. All 
-+ * MSI interrupts for the device are freed. 
-+ * 
-+ * \param irq   The devices first irq number. There may be multple in sequence.
-+ * \return none
-+ * \ingroup IFX_PCIE_MSI
-+ */
-+void 
-+arch_teardown_msi_irq(unsigned int irq)
-+{
-+    int pos;
-+    int number_irqs; 
-+    u16 bitmask;
-+    int pcie_port;
-+
-+    IFX_PCIE_PRINT(PCIE_MSG_MSI, "%s enter\n", __func__);
-+
-+    BUG_ON(irq > INT_NUM_IM4_IRL31);
-+
-+    if (pcie_msi_irq_to_port(irq, &pcie_port) != 0) {
-+        return;
-+    }
-+
-+    /* Shift the mask to the correct bit location, not always correct 
-+     * Probally, the first match will be chosen.
-+     */
-+    for (pos = 0; pos < IFX_MSI_IRQ_NUM; pos++) {
-+        if ((msi_irqs[pcie_port].msi_irq_idx[pos].irq == irq) 
-+            && (msi_irqs[pcie_port].msi_free_irq_bitmask & ( 1 << pos))) {
-+            break;
-+        }
-+    }
-+    if (pos >= IFX_MSI_IRQ_NUM) {
-+        printk(KERN_ERR "%s: Unable to find a matched MSI interrupt\n", __func__);
-+        return;
-+    }
-+    spin_lock(&ifx_pcie_msi_lock);
-+    /* Disable this entry */
-+    msi_irqs[pcie_port].msi_pic_p->pic_table[pos] |= IFX_MSI_PCI_INT_DISABLE;
-+    msi_irqs[pcie_port].msi_pic_p->pic_table[pos] &= ~(IFX_MSI_PIC_INT_LINE | IFX_MSI_PIC_MSG_ADDR | IFX_MSI_PIC_MSG_DATA);
-+    spin_unlock(&ifx_pcie_msi_lock); 
-+    /*
-+     * Count the number of IRQs we need to free by looking at the
-+     * msi_multiple_irq_bitmask. Each bit set means that the next
-+     * IRQ is also owned by this device.
-+     */ 
-+    number_irqs = 0; 
-+    while (((pos + number_irqs) < IFX_MSI_IRQ_NUM) && 
-+        (msi_irqs[pcie_port].msi_multiple_irq_bitmask & (1 << (pos + number_irqs)))) {
-+        number_irqs++;
-+    }
-+    number_irqs++;
-+
-+    /* Mask with one bit for each IRQ */
-+    bitmask = (1 << number_irqs) - 1;
-+
-+    bitmask <<= pos;
-+    if ((msi_irqs[pcie_port].msi_free_irq_bitmask & bitmask) != bitmask) {
-+        printk(KERN_ERR "%s: Attempted to teardown MSI "
-+             "interrupt (%d) not in use\n", __func__, irq);
-+        return;
-+    }
-+    /* Checks are done, update the in use bitmask */
-+    spin_lock(&ifx_pcie_msi_lock);
-+    msi_irqs[pcie_port].msi_free_irq_bitmask &= ~bitmask;
-+    msi_irqs[pcie_port].msi_multiple_irq_bitmask &= ~(bitmask >> 1);
-+    spin_unlock(&ifx_pcie_msi_lock);
-+    IFX_PCIE_PRINT(PCIE_MSG_MSI, "%s exit\n", __func__);
-+}
-+
-+MODULE_LICENSE("GPL");
-+MODULE_AUTHOR("Chuanhua.Lei@infineon.com");
-+MODULE_SUPPORTED_DEVICE("Infineon PCIe IP builtin MSI PIC module");
-+MODULE_DESCRIPTION("Infineon PCIe IP builtin MSI PIC driver");
-+
---- /dev/null
-+++ b/arch/mips/pci/ifxmips_pcie_phy.c
-@@ -0,0 +1,478 @@
-+/******************************************************************************
-+**
-+** FILE NAME    : ifxmips_pcie_phy.c
-+** PROJECT      : IFX UEIP for VRX200
-+** MODULES      : PCIe PHY sub module
-+**
-+** DATE         : 14 May 2009
-+** AUTHOR       : Lei Chuanhua
-+** DESCRIPTION  : PCIe Root Complex Driver
-+** COPYRIGHT    :       Copyright (c) 2009
-+**                      Infineon Technologies AG
-+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-+**
-+**    This program is free software; you can redistribute it and/or modify
-+**    it under the terms of the GNU General Public License as published by
-+**    the Free Software Foundation; either version 2 of the License, or
-+**    (at your option) any later version.
-+** HISTORY
-+** $Version $Date        $Author         $Comment
-+** 0.0.1    14 May,2009  Lei Chuanhua    Initial version
-+*******************************************************************************/
-+/*!
-+ \file ifxmips_pcie_phy.c
-+ \ingroup IFX_PCIE  
-+ \brief PCIe PHY PLL register programming source file
-+*/
-+#include <linux/types.h>
-+#include <linux/kernel.h>
-+#include <asm/paccess.h>
-+#include <linux/delay.h>
-+
-+#include "ifxmips_pcie_reg.h"
-+#include "ifxmips_pcie.h"
-+
-+/* PCIe PDI only supports 16 bit operation */
-+
-+#define IFX_PCIE_PHY_REG_WRITE16(__addr, __data) \
-+    ((*(volatile u16 *) (__addr)) = (__data))
-+    
-+#define IFX_PCIE_PHY_REG_READ16(__addr)  \
-+    (*(volatile u16 *) (__addr))
-+
-+#define IFX_PCIE_PHY_REG16(__addr)   \
-+    (*(volatile u16 *) (__addr))
-+
-+#define IFX_PCIE_PHY_REG(__reg, __value, __mask) do { \
-+    u16 read_data;                                    \
-+    u16 write_data;                                   \
-+    read_data = IFX_PCIE_PHY_REG_READ16((__reg));      \
-+    write_data = (read_data & ((u16)~(__mask))) | (((u16)(__value)) & ((u16)(__mask)));\
-+    IFX_PCIE_PHY_REG_WRITE16((__reg), write_data);               \
-+} while (0)
-+
-+#define IFX_PCIE_PLL_TIMEOUT 1000 /* Tunnable */
-+
-+//#define IFX_PCI_PHY_REG_DUMP
-+
-+#ifdef IFX_PCI_PHY_REG_DUMP
-+static void
-+pcie_phy_reg_dump(int pcie_port) 
-+{
-+    printk("PLL REGFILE\n");
-+    printk("PCIE_PHY_PLL_CTRL1    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_CTRL1(pcie_port)));
-+    printk("PCIE_PHY_PLL_CTRL2    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_CTRL2(pcie_port)));
-+    printk("PCIE_PHY_PLL_CTRL3    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_CTRL3(pcie_port)));
-+    printk("PCIE_PHY_PLL_CTRL4    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_CTRL4(pcie_port)));
-+    printk("PCIE_PHY_PLL_CTRL5    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_CTRL5(pcie_port)));
-+    printk("PCIE_PHY_PLL_CTRL6    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_CTRL6(pcie_port)));
-+    printk("PCIE_PHY_PLL_CTRL7    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_CTRL7(pcie_port)));
-+    printk("PCIE_PHY_PLL_A_CTRL1  0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_A_CTRL1(pcie_port)));
-+    printk("PCIE_PHY_PLL_A_CTRL2  0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_A_CTRL2(pcie_port)));
-+    printk("PCIE_PHY_PLL_A_CTRL3  0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_A_CTRL3(pcie_port)));
-+    printk("PCIE_PHY_PLL_STATUS   0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_STATUS(pcie_port)));
-+
-+    printk("TX1 REGFILE\n");
-+    printk("PCIE_PHY_TX1_CTRL1    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_CTRL1(pcie_port)));
-+    printk("PCIE_PHY_TX1_CTRL2    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_CTRL2(pcie_port)));
-+    printk("PCIE_PHY_TX1_CTRL3    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_CTRL3(pcie_port)));
-+    printk("PCIE_PHY_TX1_A_CTRL1  0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_A_CTRL1(pcie_port)));
-+    printk("PCIE_PHY_TX1_A_CTRL2  0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_A_CTRL2(pcie_port)));
-+    printk("PCIE_PHY_TX1_MOD1     0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_MOD1(pcie_port)));
-+    printk("PCIE_PHY_TX1_MOD2     0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_MOD2(pcie_port)));
-+    printk("PCIE_PHY_TX1_MOD3     0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX1_MOD3(pcie_port)));
-+
-+    printk("TX2 REGFILE\n");
-+    printk("PCIE_PHY_TX2_CTRL1    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX2_CTRL1(pcie_port)));
-+    printk("PCIE_PHY_TX2_CTRL2    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX2_CTRL2(pcie_port)));
-+    printk("PCIE_PHY_TX2_A_CTRL1  0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX2_A_CTRL1(pcie_port)));
-+    printk("PCIE_PHY_TX2_A_CTRL2  0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX2_A_CTRL2(pcie_port)));
-+    printk("PCIE_PHY_TX2_MOD1     0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX2_MOD1(pcie_port)));
-+    printk("PCIE_PHY_TX2_MOD2     0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX2_MOD2(pcie_port)));
-+    printk("PCIE_PHY_TX2_MOD3     0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_TX2_MOD3(pcie_port)));
-+
-+    printk("RX1 REGFILE\n");
-+    printk("PCIE_PHY_RX1_CTRL1    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_RX1_CTRL1(pcie_port)));
-+    printk("PCIE_PHY_RX1_CTRL2    0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_RX1_CTRL2(pcie_port)));
-+    printk("PCIE_PHY_RX1_CDR      0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_RX1_CDR(pcie_port)));
-+    printk("PCIE_PHY_RX1_EI       0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_RX1_EI(pcie_port)));
-+    printk("PCIE_PHY_RX1_A_CTRL   0x%04x\n", IFX_PCIE_PHY_REG16(PCIE_PHY_RX1_A_CTRL(pcie_port)));
-+}
-+#endif /* IFX_PCI_PHY_REG_DUMP */
-+
-+static void
-+pcie_phy_comm_setup(int pcie_port)
-+{
-+   /* PLL Setting */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL1(pcie_port), 0x120e, 0xFFFF);
-+
-+    /* increase the bias reference voltage */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL2(pcie_port), 0x39D7, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL3(pcie_port), 0x0900, 0xFFFF);
-+
-+    /* Endcnt */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_RX1_EI(pcie_port), 0x0004, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_RX1_A_CTRL(pcie_port), 0x6803, 0xFFFF);
-+
-+    /* force */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL1(pcie_port), 0x0008, 0x0008);
-+
-+    /* predrv_ser_en */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_A_CTRL2(pcie_port), 0x0706, 0xFFFF);
-+
-+    /* ctrl_lim */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL3(pcie_port), 0x1FFF, 0xFFFF);
-+
-+    /* ctrl */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_A_CTRL1(pcie_port), 0x0800, 0xFF00);
-+
-+    /* predrv_ser_en */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_A_CTRL2(pcie_port), 0x4702, 0x7F00);
-+
-+    /* RTERM*/
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL2(pcie_port), 0x2e00, 0xFFFF);
-+
-+    /* Improved 100MHz clock output  */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_CTRL2(pcie_port), 0x3096, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_A_CTRL2(pcie_port), 0x4707, 0xFFFF);
-+
-+    /* Reduced CDR BW to avoid glitches */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_RX1_CDR(pcie_port), 0x0235, 0xFFFF);
-+}
-+
-+#ifdef CONFIG_IFX_PCIE_PHY_36MHZ_MODE
-+static void 
-+pcie_phy_36mhz_mode_setup(int pcie_port) 
-+{
-+    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d enter\n", __func__, pcie_port);
-+#ifdef IFX_PCI_PHY_REG_DUMP
-+    IFX_PCIE_PRINT(PCIE_MSG_PHY, "Initial PHY register dump\n");
-+    pcie_phy_reg_dump(pcie_port);
-+#endif
-+
-+    /* en_ext_mmd_div_ratio */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0000, 0x0002);
-+
-+    /* ext_mmd_div_ratio*/
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0000, 0x0070);
-+
-+    /* pll_ensdm */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0200, 0x0200);
-+
-+    /* en_const_sdm */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0100, 0x0100);
-+
-+    /* mmd */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL3(pcie_port), 0x2000, 0xe000);
-+
-+    /* lf_mode */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL2(pcie_port), 0x0000, 0x4000);
-+
-+    /* const_sdm */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL1(pcie_port), 0x38e4, 0xFFFF);
-+
-+    /* const sdm */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x00ee, 0x00FF);
-+
-+    /* pllmod */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL7(pcie_port), 0x0002, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL6(pcie_port), 0x3a04, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL5(pcie_port), 0xfae3, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL4(pcie_port), 0x1b72, 0xFFFF);
-+
-+    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d exit\n", __func__, pcie_port);
-+}
-+#endif /* CONFIG_IFX_PCIE_PHY_36MHZ_MODE */
-+
-+#ifdef CONFIG_IFX_PCIE_PHY_36MHZ_SSC_MODE
-+static void 
-+pcie_phy_36mhz_ssc_mode_setup(int pcie_port) 
-+{
-+    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d enter\n", __func__, pcie_port);
-+#ifdef IFX_PCI_PHY_REG_DUMP
-+    IFX_PCIE_PRINT(PCIE_MSG_PHY, "Initial PHY register dump\n");
-+    pcie_phy_reg_dump(pcie_port);
-+#endif
-+
-+    /* PLL Setting */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL1(pcie_port), 0x120e, 0xFFFF);
-+
-+    /* Increase the bias reference voltage */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL2(pcie_port), 0x39D7, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL3(pcie_port), 0x0900, 0xFFFF);
-+
-+    /* Endcnt */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_RX1_EI(pcie_port), 0x0004, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_RX1_A_CTRL(pcie_port), 0x6803, 0xFFFF);
-+
-+    /* Force */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL1(pcie_port), 0x0008, 0x0008);
-+
-+    /* Predrv_ser_en */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_A_CTRL2(pcie_port), 0x0706, 0xFFFF);
-+
-+    /* ctrl_lim */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL3(pcie_port), 0x1FFF, 0xFFFF);
-+
-+    /* ctrl */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_A_CTRL1(pcie_port), 0x0800, 0xFF00);
-+
-+    /* predrv_ser_en */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_A_CTRL2(pcie_port), 0x4702, 0x7F00);
-+
-+    /* RTERM*/
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL2(pcie_port), 0x2e00, 0xFFFF);
-+
-+    /* en_ext_mmd_div_ratio */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0000, 0x0002);
-+
-+    /* ext_mmd_div_ratio*/
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0000, 0x0070);
-+
-+    /* pll_ensdm */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0400, 0x0400);
-+
-+    /* en_const_sdm */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0200, 0x0200);
-+
-+    /* mmd */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL3(pcie_port), 0x2000, 0xe000);
-+
-+    /* lf_mode */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL2(pcie_port), 0x0000, 0x4000);
-+
-+    /* const_sdm */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL1(pcie_port), 0x38e4, 0xFFFF);
-+
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0000, 0x0100);
-+    /* const sdm */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x00ee, 0x00FF);
-+
-+    /* pllmod */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL7(pcie_port), 0x0002, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL6(pcie_port), 0x3a04, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL5(pcie_port), 0xfae3, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL4(pcie_port), 0x1c72, 0xFFFF);
-+
-+    /* improved 100MHz clock output  */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_CTRL2(pcie_port), 0x3096, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_A_CTRL2(pcie_port), 0x4707, 0xFFFF);
-+
-+    /* reduced CDR BW to avoid glitches */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_RX1_CDR(pcie_port), 0x0235, 0xFFFF);
-+    
-+    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d exit\n", __func__, pcie_port);
-+}
-+#endif /* CONFIG_IFX_PCIE_PHY_36MHZ_SSC_MODE */
-+
-+#ifdef CONFIG_IFX_PCIE_PHY_25MHZ_MODE
-+static void 
-+pcie_phy_25mhz_mode_setup(int pcie_port) 
-+{
-+    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d enter\n", __func__, pcie_port);
-+#ifdef IFX_PCI_PHY_REG_DUMP
-+    IFX_PCIE_PRINT(PCIE_MSG_PHY, "Initial PHY register dump\n");
-+    pcie_phy_reg_dump(pcie_port);
-+#endif
-+    /* en_const_sdm */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0100, 0x0100);
-+
-+    /* pll_ensdm */    
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0000, 0x0200);
-+
-+    /* en_ext_mmd_div_ratio*/
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0002, 0x0002);
-+
-+    /* ext_mmd_div_ratio*/
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0040, 0x0070);
-+
-+    /* mmd */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL3(pcie_port), 0x6000, 0xe000);
-+
-+    /* lf_mode */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL2(pcie_port), 0x4000, 0x4000);
-+
-+    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d exit\n", __func__, pcie_port);
-+}
-+#endif /* CONFIG_IFX_PCIE_PHY_25MHZ_MODE */
-+
-+#ifdef CONFIG_IFX_PCIE_PHY_100MHZ_MODE
-+static void 
-+pcie_phy_100mhz_mode_setup(int pcie_port) 
-+{
-+    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d enter\n", __func__, pcie_port);
-+#ifdef IFX_PCI_PHY_REG_DUMP
-+    IFX_PCIE_PRINT(PCIE_MSG_PHY, "Initial PHY register dump\n");
-+    pcie_phy_reg_dump(pcie_port);
-+#endif 
-+    /* en_ext_mmd_div_ratio */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0000, 0x0002);
-+
-+    /* ext_mmd_div_ratio*/
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL3(pcie_port), 0x0000, 0x0070);
-+
-+    /* pll_ensdm */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0200, 0x0200);
-+
-+    /* en_const_sdm */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x0100, 0x0100);
-+
-+    /* mmd */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL3(pcie_port), 0x2000, 0xe000);
-+
-+    /* lf_mode */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_A_CTRL2(pcie_port), 0x0000, 0x4000);
-+
-+    /* const_sdm */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL1(pcie_port), 0x38e4, 0xFFFF);
-+
-+    /* const sdm */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL2(pcie_port), 0x00ee, 0x00FF);
-+
-+    /* pllmod */
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL7(pcie_port), 0x0002, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL6(pcie_port), 0x3a04, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL5(pcie_port), 0xfae3, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_PLL_CTRL4(pcie_port), 0x1b72, 0xFFFF);
-+
-+    IFX_PCIE_PRINT(PCIE_MSG_PHY, "%s pcie_port %d exit\n", __func__, pcie_port);
-+}
-+#endif /* CONFIG_IFX_PCIE_PHY_100MHZ_MODE */
-+
-+static int
-+pcie_phy_wait_startup_ready(int pcie_port)
-+{
-+    int i;
-+
-+    for (i = 0; i < IFX_PCIE_PLL_TIMEOUT; i++) {
-+        if ((IFX_PCIE_PHY_REG16(PCIE_PHY_PLL_STATUS(pcie_port)) & 0x0040) != 0) {
-+            break;
-+        }
-+        udelay(10);
-+    }
-+    if (i >= IFX_PCIE_PLL_TIMEOUT) {
-+        printk(KERN_ERR "%s PLL Link timeout\n", __func__);
-+        return -1;
-+    }
-+    return 0;
-+}
-+
-+static void 
-+pcie_phy_load_enable(int pcie_port, int slice) 
-+{
-+    /* Set the load_en of tx/rx slice to '1' */
-+    switch (slice) {
-+        case 1:
-+            IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL1(pcie_port), 0x0010, 0x0010);
-+            break;
-+        case 2:
-+            IFX_PCIE_PHY_REG(PCIE_PHY_TX2_CTRL1(pcie_port), 0x0010, 0x0010);
-+            break;
-+        case 3:
-+            IFX_PCIE_PHY_REG(PCIE_PHY_RX1_CTRL1(pcie_port), 0x0002, 0x0002);
-+            break;
-+    }
-+}
-+
-+static void 
-+pcie_phy_load_disable(int pcie_port, int slice) 
-+{ 
-+    /* set the load_en of tx/rx slice to '0' */ 
-+    switch (slice) {
-+        case 1:
-+            IFX_PCIE_PHY_REG(PCIE_PHY_TX1_CTRL1(pcie_port), 0x0000, 0x0010);
-+            break;
-+        case 2:
-+            IFX_PCIE_PHY_REG(PCIE_PHY_TX2_CTRL1(pcie_port), 0x0000, 0x0010);
-+            break;
-+        case 3: 
-+            IFX_PCIE_PHY_REG(PCIE_PHY_RX1_CTRL1(pcie_port), 0x0000, 0x0002);
-+            break;
-+    }
-+}
-+
-+static void 
-+pcie_phy_load_war(int pcie_port)
-+{
-+    int slice;
-+
-+    for (slice = 1; slice < 4; slice++) {
-+        pcie_phy_load_enable(pcie_port, slice);
-+        udelay(1);
-+        pcie_phy_load_disable(pcie_port, slice);
-+    }
-+}
-+
-+static void 
-+pcie_phy_tx2_modulation(int pcie_port)
-+{
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_MOD1(pcie_port), 0x1FFE, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_MOD2(pcie_port), 0xFFFE, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_MOD3(pcie_port), 0x0601, 0xFFFF);
-+    mdelay(1);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX2_MOD3(pcie_port), 0x0001, 0xFFFF);
-+}
-+
-+static void 
-+pcie_phy_tx1_modulation(int pcie_port)
-+{
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_MOD1(pcie_port), 0x1FFE, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_MOD2(pcie_port), 0xFFFE, 0xFFFF);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_MOD3(pcie_port), 0x0601, 0xFFFF);
-+    mdelay(1);
-+    IFX_PCIE_PHY_REG(PCIE_PHY_TX1_MOD3(pcie_port), 0x0001, 0xFFFF);
-+}
-+
-+static void
-+pcie_phy_tx_modulation_war(int pcie_port)
-+{
-+    int i;
-+
-+#define PCIE_PHY_MODULATION_NUM 5 
-+    for (i = 0; i < PCIE_PHY_MODULATION_NUM; i++) {
-+        pcie_phy_tx2_modulation(pcie_port);
-+        pcie_phy_tx1_modulation(pcie_port);
-+    }
-+#undef PCIE_PHY_MODULATION_NUM
-+}
-+
-+void
-+pcie_phy_clock_mode_setup(int pcie_port)
-+{
-+    pcie_pdi_big_endian(pcie_port);
-+
-+    /* Enable PDI to access PCIe PHY register */
-+    pcie_pdi_pmu_enable(pcie_port);
-+
-+    /* Configure PLL and PHY clock */
-+    pcie_phy_comm_setup(pcie_port);
-+
-+#ifdef CONFIG_IFX_PCIE_PHY_36MHZ_MODE
-+    pcie_phy_36mhz_mode_setup(pcie_port);
-+#elif defined(CONFIG_IFX_PCIE_PHY_36MHZ_SSC_MODE)
-+    pcie_phy_36mhz_ssc_mode_setup(pcie_port);
-+#elif defined(CONFIG_IFX_PCIE_PHY_25MHZ_MODE)
-+    pcie_phy_25mhz_mode_setup(pcie_port);
-+#elif defined (CONFIG_IFX_PCIE_PHY_100MHZ_MODE)
-+    pcie_phy_100mhz_mode_setup(pcie_port);
-+#else
-+    #error "PCIE PHY Clock Mode must be chosen first!!!!"
-+#endif /* CONFIG_IFX_PCIE_PHY_36MHZ_MODE */
-+
-+    /* Enable PCIe PHY and make PLL setting take effect */
-+    pcie_phy_pmu_enable(pcie_port);
-+
-+    /* Check if we are in startup_ready status */
-+    pcie_phy_wait_startup_ready(pcie_port);
-+
-+    pcie_phy_load_war(pcie_port);
-+
-+    /* Apply TX modulation workarounds */
-+    pcie_phy_tx_modulation_war(pcie_port);
-+
-+#ifdef IFX_PCI_PHY_REG_DUMP
-+    IFX_PCIE_PRINT(PCIE_MSG_PHY, "Modified PHY register dump\n");
-+    pcie_phy_reg_dump(pcie_port);
-+#endif
-+}
-+
---- /dev/null
-+++ b/arch/mips/pci/ifxmips_pcie_pm.c
-@@ -0,0 +1,176 @@
-+/******************************************************************************
-+**
-+** FILE NAME    : ifxmips_pcie_pm.c
-+** PROJECT      : IFX UEIP
-+** MODULES      : PCIE Root Complex Driver
-+**
-+** DATE         : 21 Dec 2009
-+** AUTHOR       : Lei Chuanhua
-+** DESCRIPTION  : PCIE Root Complex Driver Power Managment
-+** COPYRIGHT    :       Copyright (c) 2009
-+**                      Lantiq Deutschland GmbH
-+**                      Am Campeon 3, 85579 Neubiberg, Germany
-+**
-+**    This program is free software; you can redistribute it and/or modify
-+**    it under the terms of the GNU General Public License as published by
-+**    the Free Software Foundation; either version 2 of the License, or
-+**    (at your option) any later version.
-+**
-+** HISTORY
-+** $Date        $Author         $Comment
-+** 21 Dec,2009   Lei Chuanhua    First UEIP release
-+*******************************************************************************/
-+/*!
-+  \defgroup IFX_PCIE_PM Power Management functions
-+  \ingroup IFX_PCIE
-+  \brief IFX PCIE Root Complex Driver power management functions
-+*/
-+
-+/*!
-+ \file ifxmips_pcie_pm.c
-+ \ingroup IFX_PCIE    
-+ \brief source file for PCIE Root Complex Driver Power Management
-+*/
-+
-+#ifndef EXPORT_SYMTAB
-+#define EXPORT_SYMTAB
-+#endif
-+#ifndef AUTOCONF_INCLUDED
-+#include <linux/config.h>
-+#endif /* AUTOCONF_INCLUDED */
-+#include <linux/version.h>
-+#include <linux/module.h>
-+#include <linux/types.h>
-+#include <linux/kernel.h>
-+#include <asm/system.h>
-+
-+/* Project header */
-+#include <asm/ifx/ifx_types.h>
-+#include <asm/ifx/ifx_regs.h>
-+#include <asm/ifx/common_routines.h>
-+#include <asm/ifx/ifx_pmcu.h>
-+#include "ifxmips_pcie_pm.h"
-+
-+/** 
-+ * \fn static IFX_PMCU_RETURN_t ifx_pcie_pmcu_state_change(IFX_PMCU_STATE_t pmcuState)
-+ * \brief the callback function to request pmcu state in the power management hardware-dependent module
-+ *
-+ * \param pmcuState This parameter is a PMCU state.
-+ *
-+ * \return IFX_PMCU_RETURN_SUCCESS Set Power State successfully
-+ * \return IFX_PMCU_RETURN_ERROR   Failed to set power state.
-+ * \return IFX_PMCU_RETURN_DENIED  Not allowed to operate power state
-+ * \ingroup IFX_PCIE_PM
-+ */
-+static IFX_PMCU_RETURN_t 
-+ifx_pcie_pmcu_state_change(IFX_PMCU_STATE_t pmcuState)
-+{
-+    switch(pmcuState) 
-+    {
-+        case IFX_PMCU_STATE_D0:
-+            return IFX_PMCU_RETURN_SUCCESS;
-+        case IFX_PMCU_STATE_D1: // Not Applicable
-+            return IFX_PMCU_RETURN_DENIED;
-+        case IFX_PMCU_STATE_D2: // Not Applicable
-+            return IFX_PMCU_RETURN_DENIED;
-+        case IFX_PMCU_STATE_D3: // Module clock gating and Power gating
-+            return IFX_PMCU_RETURN_SUCCESS;
-+        default:
-+            return IFX_PMCU_RETURN_DENIED;
-+    }
-+}
-+
-+/** 
-+ * \fn static IFX_PMCU_RETURN_t ifx_pcie_pmcu_state_get(IFX_PMCU_STATE_t *pmcuState)
-+ * \brief the callback function to get pmcu state in the power management hardware-dependent module
-+
-+ * \param pmcuState Pointer to return power state.
-+ *
-+ * \return IFX_PMCU_RETURN_SUCCESS Set Power State successfully
-+ * \return IFX_PMCU_RETURN_ERROR   Failed to set power state.
-+ * \return IFX_PMCU_RETURN_DENIED  Not allowed to operate power state
-+ * \ingroup IFX_PCIE_PM
-+ */
-+static IFX_PMCU_RETURN_t 
-+ifx_pcie_pmcu_state_get(IFX_PMCU_STATE_t *pmcuState)
-+{
-+    return IFX_PMCU_RETURN_SUCCESS;
-+}
-+
-+/**
-+ * \fn IFX_PMCU_RETURN_t ifx_pcie_pmcu_prechange(IFX_PMCU_MODULE_t pmcuModule, IFX_PMCU_STATE_t newState, IFX_PMCU_STATE_t oldState)
-+ * \brief Apply all callbacks registered to be executed before a state change for pmcuModule
-+ * 
-+ * \param   pmcuModule      Module
-+ * \param   newState        New state
-+ * \param   oldState        Old state
-+ * \return  IFX_PMCU_RETURN_SUCCESS Set Power State successfully
-+ * \return  IFX_PMCU_RETURN_ERROR   Failed to set power state.
-+ * \ingroup IFX_PCIE_PM
-+ */
-+static IFX_PMCU_RETURN_t 
-+ifx_pcie_pmcu_prechange(IFX_PMCU_MODULE_t pmcuModule, IFX_PMCU_STATE_t newState, IFX_PMCU_STATE_t oldState)
-+{
-+    return IFX_PMCU_RETURN_SUCCESS;
-+}
-+
-+/**
-+ * \fn IFX_PMCU_RETURN_t ifx_pcie_pmcu_postchange(IFX_PMCU_MODULE_t pmcuModule, IFX_PMCU_STATE_t newState, IFX_PMCU_STATE_t oldState)
-+ * \brief Apply all callbacks registered to be executed before a state change for pmcuModule
-+ * 
-+ * \param   pmcuModule      Module
-+ * \param   newState        New state
-+ * \param   oldState        Old state
-+ * \return IFX_PMCU_RETURN_SUCCESS Set Power State successfully
-+ * \return IFX_PMCU_RETURN_ERROR   Failed to set power state.
-+ * \ingroup IFX_PCIE_PM
-+ */
-+static IFX_PMCU_RETURN_t 
-+ifx_pcie_pmcu_postchange(IFX_PMCU_MODULE_t pmcuModule, IFX_PMCU_STATE_t newState, IFX_PMCU_STATE_t oldState)
-+{
-+    return IFX_PMCU_RETURN_SUCCESS;
-+}
-+
-+/** 
-+ * \fn static void ifx_pcie_pmcu_init(void)
-+ * \brief Register with central PMCU module
-+ * \return none
-+ * \ingroup IFX_PCIE_PM
-+ */
-+void
-+ifx_pcie_pmcu_init(void)
-+{
-+    IFX_PMCU_REGISTER_t pmcuRegister;
-+
-+    /* XXX, hook driver context */
-+
-+    /* State function register */
-+    memset(&pmcuRegister, 0, sizeof(IFX_PMCU_REGISTER_t));
-+    pmcuRegister.pmcuModule = IFX_PMCU_MODULE_PCIE;
-+    pmcuRegister.pmcuModuleNr = 0;
-+    pmcuRegister.ifx_pmcu_state_change = ifx_pcie_pmcu_state_change;
-+    pmcuRegister.ifx_pmcu_state_get = ifx_pcie_pmcu_state_get;
-+    pmcuRegister.pre = ifx_pcie_pmcu_prechange;
-+    pmcuRegister.post= ifx_pcie_pmcu_postchange;
-+    ifx_pmcu_register(&pmcuRegister); 
-+}
-+
-+/** 
-+ * \fn static void ifx_pcie_pmcu_exit(void)
-+ * \brief Unregister with central PMCU module
-+ *
-+ * \return none
-+ * \ingroup IFX_PCIE_PM
-+ */
-+void
-+ifx_pcie_pmcu_exit(void)
-+{
-+    IFX_PMCU_REGISTER_t pmcuUnRegister;
-+
-+   /* XXX, hook driver context */
-+   
-+    pmcuUnRegister.pmcuModule = IFX_PMCU_MODULE_PCIE;
-+    pmcuUnRegister.pmcuModuleNr = 0;
-+    ifx_pmcu_unregister(&pmcuUnRegister);
-+}
-+
---- /dev/null
-+++ b/arch/mips/pci/ifxmips_pcie_pm.h
-@@ -0,0 +1,36 @@
-+/******************************************************************************
-+**
-+** FILE NAME    : ifxmips_pcie_pm.h
-+** PROJECT      : IFX UEIP
-+** MODULES      : PCIe Root Complex Driver
-+**
-+** DATE         : 21 Dec 2009
-+** AUTHOR       : Lei Chuanhua
-+** DESCRIPTION  : PCIe Root Complex Driver Power Managment
-+** COPYRIGHT    :       Copyright (c) 2009
-+**                      Lantiq Deutschland GmbH
-+**                      Am Campeon 3, 85579 Neubiberg, Germany
-+**
-+**    This program is free software; you can redistribute it and/or modify
-+**    it under the terms of the GNU General Public License as published by
-+**    the Free Software Foundation; either version 2 of the License, or
-+**    (at your option) any later version.
-+**
-+** HISTORY
-+** $Date        $Author         $Comment
-+** 21 Dec,2009   Lei Chuanhua    First UEIP release
-+*******************************************************************************/
-+/*!
-+ \file ifxmips_pcie_pm.h
-+ \ingroup IFX_PCIE 
-+ \brief header file for PCIe Root Complex Driver Power Management
-+*/
-+
-+#ifndef IFXMIPS_PCIE_PM_H
-+#define IFXMIPS_PCIE_PM_H
-+
-+void ifx_pcie_pmcu_init(void);
-+void ifx_pcie_pmcu_exit(void);
-+
-+#endif /* IFXMIPS_PCIE_PM_H  */
-+
---- /dev/null
-+++ b/arch/mips/pci/ifxmips_pcie_reg.h
-@@ -0,0 +1,1001 @@
-+/******************************************************************************
-+**
-+** FILE NAME    : ifxmips_pcie_reg.h
-+** PROJECT      : IFX UEIP for VRX200
-+** MODULES      : PCIe module
-+**
-+** DATE         : 02 Mar 2009
-+** AUTHOR       : Lei Chuanhua
-+** DESCRIPTION  : PCIe Root Complex Driver
-+** COPYRIGHT    :       Copyright (c) 2009
-+**                      Infineon Technologies AG
-+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-+**
-+**    This program is free software; you can redistribute it and/or modify
-+**    it under the terms of the GNU General Public License as published by
-+**    the Free Software Foundation; either version 2 of the License, or
-+**    (at your option) any later version.
-+** HISTORY
-+** $Version $Date        $Author         $Comment
-+** 0.0.1    17 Mar,2009  Lei Chuanhua    Initial version
-+*******************************************************************************/
-+#ifndef IFXMIPS_PCIE_REG_H
-+#define IFXMIPS_PCIE_REG_H
-+/*!
-+ \file ifxmips_pcie_reg.h
-+ \ingroup IFX_PCIE  
-+ \brief header file for PCIe module register definition
-+*/
-+/* PCIe Address Mapping Base */
-+#define PCIE_CFG_PHY_BASE        0x1D000000UL
-+#define PCIE_CFG_BASE           (KSEG1 + PCIE_CFG_PHY_BASE)
-+#define PCIE_CFG_SIZE           (8 * 1024 * 1024)
-+
-+#define PCIE_MEM_PHY_BASE        0x1C000000UL
-+#define PCIE_MEM_BASE           (KSEG1 + PCIE_MEM_PHY_BASE)
-+#define PCIE_MEM_SIZE           (16 * 1024 * 1024)
-+#define PCIE_MEM_PHY_END        (PCIE_MEM_PHY_BASE + PCIE_MEM_SIZE - 1)
-+
-+#define PCIE_IO_PHY_BASE         0x1D800000UL
-+#define PCIE_IO_BASE            (KSEG1 + PCIE_IO_PHY_BASE)
-+#define PCIE_IO_SIZE            (1 * 1024 * 1024)
-+#define PCIE_IO_PHY_END         (PCIE_IO_PHY_BASE + PCIE_IO_SIZE - 1)
-+
-+#define PCIE_RC_CFG_BASE        (KSEG1 + 0x1D900000)
-+#define PCIE_APP_LOGIC_REG      (KSEG1 + 0x1E100900)
-+#define PCIE_MSI_PHY_BASE        0x1F600000UL
-+
-+#define PCIE_PDI_PHY_BASE        0x1F106800UL
-+#define PCIE_PDI_BASE           (KSEG1 + PCIE_PDI_PHY_BASE)
-+#define PCIE_PDI_SIZE            0x400
-+
-+#define PCIE1_CFG_PHY_BASE        0x19000000UL
-+#define PCIE1_CFG_BASE           (KSEG1 + PCIE1_CFG_PHY_BASE)
-+#define PCIE1_CFG_SIZE           (8 * 1024 * 1024)
-+
-+#define PCIE1_MEM_PHY_BASE        0x18000000UL
-+#define PCIE1_MEM_BASE           (KSEG1 + PCIE1_MEM_PHY_BASE)
-+#define PCIE1_MEM_SIZE           (16 * 1024 * 1024)
-+#define PCIE1_MEM_PHY_END        (PCIE1_MEM_PHY_BASE + PCIE1_MEM_SIZE - 1)
-+
-+#define PCIE1_IO_PHY_BASE         0x19800000UL
-+#define PCIE1_IO_BASE            (KSEG1 + PCIE1_IO_PHY_BASE)
-+#define PCIE1_IO_SIZE            (1 * 1024 * 1024)
-+#define PCIE1_IO_PHY_END         (PCIE1_IO_PHY_BASE + PCIE1_IO_SIZE - 1)
-+
-+#define PCIE1_RC_CFG_BASE        (KSEG1 + 0x19900000)
-+#define PCIE1_APP_LOGIC_REG      (KSEG1 + 0x1E100700)
-+#define PCIE1_MSI_PHY_BASE        0x1F400000UL
-+
-+#define PCIE1_PDI_PHY_BASE        0x1F700400UL
-+#define PCIE1_PDI_BASE           (KSEG1 + PCIE1_PDI_PHY_BASE)
-+#define PCIE1_PDI_SIZE            0x400
-+
-+#define PCIE_CFG_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_CFG_BASE) : (PCIE_CFG_BASE))
-+#define PCIE_MEM_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_MEM_BASE) : (PCIE_MEM_BASE))
-+#define PCIE_IO_PORT_TO_BASE(X)      ((X) > 0 ? (PCIE1_IO_BASE) : (PCIE_IO_BASE))
-+#define PCIE_MEM_PHY_PORT_TO_BASE(X) ((X) > 0 ? (PCIE1_MEM_PHY_BASE) : (PCIE_MEM_PHY_BASE))
-+#define PCIE_MEM_PHY_PORT_TO_END(X)  ((X) > 0 ? (PCIE1_MEM_PHY_END) : (PCIE_MEM_PHY_END))
-+#define PCIE_IO_PHY_PORT_TO_BASE(X)  ((X) > 0 ? (PCIE1_IO_PHY_BASE) : (PCIE_IO_PHY_BASE))
-+#define PCIE_IO_PHY_PORT_TO_END(X)   ((X) > 0 ? (PCIE1_IO_PHY_END) : (PCIE_IO_PHY_END))
-+#define PCIE_APP_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_APP_LOGIC_REG) : (PCIE_APP_LOGIC_REG))
-+#define PCIE_RC_PORT_TO_BASE(X)      ((X) > 0 ? (PCIE1_RC_CFG_BASE) : (PCIE_RC_CFG_BASE))
-+#define PCIE_PHY_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_PDI_BASE) : (PCIE_PDI_BASE))
-+
-+/* PCIe Application Logic Register */
-+/* RC Core Control Register */
-+#define PCIE_RC_CCR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x10)
-+/* This should be enabled after initializing configuratin registers
-+ * Also should check link status retraining bit
-+ */
-+#define PCIE_RC_CCR_LTSSM_ENABLE             0x00000001    /* Enable LTSSM to continue link establishment */
-+
-+/* RC Core Debug Register */
-+#define PCIE_RC_DR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x14)
-+#define PCIE_RC_DR_DLL_UP                    0x00000001  /* Data Link Layer Up */
-+#define PCIE_RC_DR_CURRENT_POWER_STATE       0x0000000E  /* Current Power State */
-+#define PCIE_RC_DR_CURRENT_POWER_STATE_S     1
-+#define PCIE_RC_DR_CURRENT_LTSSM_STATE       0x000001F0  /* Current LTSSM State */
-+#define PCIE_RC_DR_CURRENT_LTSSM_STATE_S     4
-+
-+#define PCIE_RC_DR_PM_DEV_STATE              0x00000E00  /* Power Management D-State */
-+#define PCIE_RC_DR_PM_DEV_STATE_S            9
-+
-+#define PCIE_RC_DR_PM_ENABLED                0x00001000  /* Power Management State from PMU */
-+#define PCIE_RC_DR_PME_EVENT_ENABLED         0x00002000  /* Power Management Event Enable State */
-+#define PCIE_RC_DR_AUX_POWER_ENABLED         0x00004000  /* Auxiliary Power Enable */
-+
-+/* Current Power State Definition */
-+enum {
-+    PCIE_RC_DR_D0 = 0,
-+    PCIE_RC_DR_D1,   /* Not supported */
-+    PCIE_RC_DR_D2,   /* Not supported */
-+    PCIE_RC_DR_D3,
-+    PCIE_RC_DR_UN,
-+};
-+
-+/* PHY Link Status Register */
-+#define PCIE_PHY_SR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x18)
-+#define PCIE_PHY_SR_PHY_LINK_UP              0x00000001   /* PHY Link Up/Down Indicator */
-+
-+/* Electromechanical Control Register */
-+#define PCIE_EM_CR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x1C)
-+#define PCIE_EM_CR_CARD_IS_PRESENT           0x00000001  /* Card Presence Detect State */
-+#define PCIE_EM_CR_MRL_OPEN                  0x00000002  /* MRL Sensor State */
-+#define PCIE_EM_CR_POWER_FAULT_SET           0x00000004  /* Power Fault Detected */
-+#define PCIE_EM_CR_MRL_SENSOR_SET            0x00000008  /* MRL Sensor Changed */
-+#define PCIE_EM_CR_PRESENT_DETECT_SET        0x00000010  /* Card Presense Detect Changed */
-+#define PCIE_EM_CR_CMD_CPL_INT_SET           0x00000020  /* Command Complete Interrupt */
-+#define PCIE_EM_CR_SYS_INTERLOCK_SET         0x00000040  /* System Electromechanical IterLock Engaged */
-+#define PCIE_EM_CR_ATTENTION_BUTTON_SET      0x00000080  /* Attention Button Pressed */
-+
-+/* Interrupt Status Register */
-+#define PCIE_IR_SR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x20)
-+#define PCIE_IR_SR_PME_CAUSE_MSI             0x00000002  /* MSI caused by PME */
-+#define PCIE_IR_SR_HP_PME_WAKE_GEN           0x00000004  /* Hotplug PME Wake Generation */
-+#define PCIE_IR_SR_HP_MSI                    0x00000008  /* Hotplug MSI */
-+#define PCIE_IR_SR_AHB_LU_ERR                0x00000030  /* AHB Bridge Lookup Error Signals */
-+#define PCIE_IR_SR_AHB_LU_ERR_S              4
-+#define PCIE_IR_SR_INT_MSG_NUM               0x00003E00  /* Interrupt Message Number */
-+#define PCIE_IR_SR_INT_MSG_NUM_S             9
-+#define PCIE_IR_SR_AER_INT_MSG_NUM           0xF8000000  /* Advanced Error Interrupt Message Number */
-+#define PCIE_IR_SR_AER_INT_MSG_NUM_S         27
-+
-+/* Message Control Register */
-+#define PCIE_MSG_CR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x30)
-+#define PCIE_MSG_CR_GEN_PME_TURN_OFF_MSG     0x00000001  /* Generate PME Turn Off Message */
-+#define PCIE_MSG_CR_GEN_UNLOCK_MSG           0x00000002  /* Generate Unlock Message */
-+
-+#define PCIE_VDM_DR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x34)
-+
-+/* Vendor-Defined Message Requester ID Register */
-+#define PCIE_VDM_RID(X)                     (PCIE_APP_PORT_TO_BASE (X) + 0x38)
-+#define PCIE_VDM_RID_VENROR_MSG_REQ_ID       0x0000FFFF
-+#define PCIE_VDM_RID_VDMRID_S                0
-+
-+/* ASPM Control Register */
-+#define PCIE_ASPM_CR(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x40)
-+#define PCIE_ASPM_CR_HOT_RST                 0x00000001  /* Hot Reset Request to the downstream device */
-+#define PCIE_ASPM_CR_REQ_EXIT_L1             0x00000002  /* Request to Exit L1 */
-+#define PCIE_ASPM_CR_REQ_ENTER_L1            0x00000004  /* Request to Enter L1 */
-+
-+/* Vendor Message DW0 Register */
-+#define PCIE_VM_MSG_DW0(X)                  (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x50)
-+#define PCIE_VM_MSG_DW0_TYPE                 0x0000001F  /* Message type */
-+#define PCIE_VM_MSG_DW0_TYPE_S               0
-+#define PCIE_VM_MSG_DW0_FORMAT               0x00000060  /* Format */
-+#define PCIE_VM_MSG_DW0_FORMAT_S             5
-+#define PCIE_VM_MSG_DW0_TC                   0x00007000  /* Traffic Class */
-+#define PCIE_VM_MSG_DW0_TC_S                 12
-+#define PCIE_VM_MSG_DW0_ATTR                 0x000C0000  /* Atrributes */
-+#define PCIE_VM_MSG_DW0_ATTR_S               18
-+#define PCIE_VM_MSG_DW0_EP_TLP               0x00100000  /* Poisoned TLP */
-+#define PCIE_VM_MSG_DW0_TD                   0x00200000  /* TLP Digest */
-+#define PCIE_VM_MSG_DW0_LEN                  0xFFC00000  /* Length */
-+#define PCIE_VM_MSG_DW0_LEN_S                22
-+
-+/* Format Definition */
-+enum {
-+    PCIE_VM_MSG_FORMAT_00 = 0,  /* 3DW Hdr, no data*/
-+    PCIE_VM_MSG_FORMAT_01,      /* 4DW Hdr, no data */
-+    PCIE_VM_MSG_FORMAT_10,      /* 3DW Hdr, with data */
-+    PCIE_VM_MSG_FORMAT_11,      /* 4DW Hdr, with data */
-+};
-+
-+/* Traffic Class Definition */
-+enum {
-+    PCIE_VM_MSG_TC0 = 0,
-+    PCIE_VM_MSG_TC1,
-+    PCIE_VM_MSG_TC2,
-+    PCIE_VM_MSG_TC3,
-+    PCIE_VM_MSG_TC4,
-+    PCIE_VM_MSG_TC5,
-+    PCIE_VM_MSG_TC6,
-+    PCIE_VM_MSG_TC7,
-+};
-+
-+/* Attributes Definition */
-+enum {
-+    PCIE_VM_MSG_ATTR_00 = 0,   /* RO and No Snoop cleared */
-+    PCIE_VM_MSG_ATTR_01,       /* RO cleared , No Snoop set */
-+    PCIE_VM_MSG_ATTR_10,       /* RO set, No Snoop cleared*/
-+    PCIE_VM_MSG_ATTR_11,       /* RO and No Snoop set */
-+};
-+
-+/* Payload Size Definition */
-+#define PCIE_VM_MSG_LEN_MIN  0
-+#define PCIE_VM_MSG_LEN_MAX  1024
-+
-+/* Vendor Message DW1 Register */
-+#define PCIE_VM_MSG_DW1(X)                 (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x54)
-+#define PCIE_VM_MSG_DW1_FUNC_NUM            0x00000070  /* Function Number */
-+#define PCIE_VM_MSG_DW1_FUNC_NUM_S          8
-+#define PCIE_VM_MSG_DW1_CODE                0x00FF0000  /* Message Code */
-+#define PCIE_VM_MSG_DW1_CODE_S              16
-+#define PCIE_VM_MSG_DW1_TAG                 0xFF000000  /* Tag */
-+#define PCIE_VM_MSG_DW1_TAG_S               24
-+
-+#define PCIE_VM_MSG_DW2(X)                  (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x58)
-+#define PCIE_VM_MSG_DW3(X)                  (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x5C)
-+
-+/* Vendor Message Request Register */
-+#define PCIE_VM_MSG_REQR(X)                 (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x60)
-+#define PCIE_VM_MSG_REQR_REQ                 0x00000001  /* Vendor Message Request */
-+
-+
-+/* AHB Slave Side Band Control Register */
-+#define PCIE_AHB_SSB(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x70)
-+#define PCIE_AHB_SSB_REQ_BCM                0x00000001 /* Slave Reques BCM filed */
-+#define PCIE_AHB_SSB_REQ_EP                 0x00000002 /* Slave Reques EP filed */
-+#define PCIE_AHB_SSB_REQ_TD                 0x00000004 /* Slave Reques TD filed */
-+#define PCIE_AHB_SSB_REQ_ATTR               0x00000018 /* Slave Reques Attribute number */
-+#define PCIE_AHB_SSB_REQ_ATTR_S             3
-+#define PCIE_AHB_SSB_REQ_TC                 0x000000E0 /* Slave Request TC Field */
-+#define PCIE_AHB_SSB_REQ_TC_S               5
-+
-+/* AHB Master SideBand Ctrl Register */
-+#define PCIE_AHB_MSB(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x74)
-+#define PCIE_AHB_MSB_RESP_ATTR               0x00000003 /* Master Response Attribute number */
-+#define PCIE_AHB_MSB_RESP_ATTR_S             0
-+#define PCIE_AHB_MSB_RESP_BAD_EOT            0x00000004 /* Master Response Badeot filed */
-+#define PCIE_AHB_MSB_RESP_BCM                0x00000008 /* Master Response BCM filed */
-+#define PCIE_AHB_MSB_RESP_EP                 0x00000010 /* Master Response EP filed */
-+#define PCIE_AHB_MSB_RESP_TD                 0x00000020 /* Master Response TD filed */
-+#define PCIE_AHB_MSB_RESP_FUN_NUM            0x000003C0 /* Master Response Function number */
-+#define PCIE_AHB_MSB_RESP_FUN_NUM_S          6
-+
-+/* AHB Control Register, fixed bus enumeration exception */
-+#define PCIE_AHB_CTRL(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x78)
-+#define PCIE_AHB_CTRL_BUS_ERROR_SUPPRESS     0x00000001 
-+
-+/* Interrupt Enalbe Register */
-+#define PCIE_IRNEN(X)                        (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0xF4)
-+#define PCIE_IRNCR(X)                        (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0xF8)
-+#define PCIE_IRNICR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0xFC)
-+
-+/* PCIe interrupt enable/control/capture register definition */
-+#define PCIE_IRN_AER_REPORT                 0x00000001  /* AER Interrupt */
-+#define PCIE_IRN_AER_MSIX                   0x00000002  /* Advanced Error MSI-X Interrupt */
-+#define PCIE_IRN_PME                        0x00000004  /* PME Interrupt */
-+#define PCIE_IRN_HOTPLUG                    0x00000008  /* Hotplug Interrupt */
-+#define PCIE_IRN_RX_VDM_MSG                 0x00000010  /* Vendor-Defined Message Interrupt */
-+#define PCIE_IRN_RX_CORRECTABLE_ERR_MSG     0x00000020  /* Correctable Error Message Interrupt */
-+#define PCIE_IRN_RX_NON_FATAL_ERR_MSG       0x00000040  /* Non-fatal Error Message */
-+#define PCIE_IRN_RX_FATAL_ERR_MSG           0x00000080  /* Fatal Error Message */
-+#define PCIE_IRN_RX_PME_MSG                 0x00000100  /* PME Message Interrupt */
-+#define PCIE_IRN_RX_PME_TURNOFF_ACK         0x00000200  /* PME Turnoff Ack Message Interrupt */
-+#define PCIE_IRN_AHB_BR_FATAL_ERR           0x00000400  /* AHB Fatal Error Interrupt */
-+#define PCIE_IRN_LINK_AUTO_BW_STATUS        0x00000800  /* Link Auto Bandwidth Status Interrupt */
-+#define PCIE_IRN_BW_MGT                     0x00001000  /* Bandwidth Managment Interrupt */
-+#define PCIE_IRN_INTA                       0x00002000  /* INTA */
-+#define PCIE_IRN_INTB                       0x00004000  /* INTB */
-+#define PCIE_IRN_INTC                       0x00008000  /* INTC */
-+#define PCIE_IRN_INTD                       0x00010000  /* INTD */
-+#define PCIE_IRN_WAKEUP                     0x00020000  /* Wake up Interrupt */
-+
-+#define PCIE_RC_CORE_COMBINED_INT    (PCIE_IRN_AER_REPORT |  PCIE_IRN_AER_MSIX | PCIE_IRN_PME | \
-+                                      PCIE_IRN_HOTPLUG | PCIE_IRN_RX_VDM_MSG | PCIE_IRN_RX_CORRECTABLE_ERR_MSG |\
-+                                      PCIE_IRN_RX_NON_FATAL_ERR_MSG | PCIE_IRN_RX_FATAL_ERR_MSG | \
-+                                      PCIE_IRN_RX_PME_MSG | PCIE_IRN_RX_PME_TURNOFF_ACK | PCIE_IRN_AHB_BR_FATAL_ERR | \
-+                                      PCIE_IRN_LINK_AUTO_BW_STATUS | PCIE_IRN_BW_MGT)
-+/* PCIe RC Configuration Register */
-+#define PCIE_VDID(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x00)
-+
-+/* Bit definition from pci_reg.h */
-+#define PCIE_PCICMDSTS(X)           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x04)
-+#define PCIE_CCRID(X)               (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x08)
-+#define PCIE_CLSLTHTBR(X)           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x0C) /* EP only */
-+/* BAR0, BAR1,Only necessary if the bridges implements a device-specific register set or memory buffer */
-+#define PCIE_BAR0(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x10) /* Not used*/
-+#define PCIE_BAR1(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x14) /* Not used */
-+
-+#define PCIE_BNR(X)                 (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x18) /* Mandatory */
-+/* Bus Number Register bits */
-+#define PCIE_BNR_PRIMARY_BUS_NUM             0x000000FF
-+#define PCIE_BNR_PRIMARY_BUS_NUM_S           0
-+#define PCIE_PNR_SECONDARY_BUS_NUM           0x0000FF00
-+#define PCIE_PNR_SECONDARY_BUS_NUM_S         8
-+#define PCIE_PNR_SUB_BUS_NUM                 0x00FF0000
-+#define PCIE_PNR_SUB_BUS_NUM_S               16
-+
-+/* IO Base/Limit Register bits */
-+#define PCIE_IOBLSECS(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x1C)  /* RC only */
-+#define PCIE_IOBLSECS_32BIT_IO_ADDR             0x00000001
-+#define PCIE_IOBLSECS_IO_BASE_ADDR              0x000000F0
-+#define PCIE_IOBLSECS_IO_BASE_ADDR_S            4
-+#define PCIE_IOBLSECS_32BIT_IOLIMT              0x00000100
-+#define PCIE_IOBLSECS_IO_LIMIT_ADDR             0x0000F000
-+#define PCIE_IOBLSECS_IO_LIMIT_ADDR_S           12
-+
-+/* Non-prefetchable Memory Base/Limit Register bit */
-+#define PCIE_MBML(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x20)  /* RC only */
-+#define PCIE_MBML_MEM_BASE_ADDR                 0x0000FFF0
-+#define PCIE_MBML_MEM_BASE_ADDR_S               4
-+#define PCIE_MBML_MEM_LIMIT_ADDR                0xFFF00000
-+#define PCIE_MBML_MEM_LIMIT_ADDR_S              20
-+
-+/* Prefetchable Memory Base/Limit Register bit */
-+#define PCIE_PMBL(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x24)  /* RC only */
-+#define PCIE_PMBL_64BIT_ADDR                    0x00000001
-+#define PCIE_PMBL_UPPER_12BIT                   0x0000FFF0
-+#define PCIE_PMBL_UPPER_12BIT_S                 4
-+#define PCIE_PMBL_E64MA                         0x00010000
-+#define PCIE_PMBL_END_ADDR                      0xFFF00000
-+#define PCIE_PMBL_END_ADDR_S                    20
-+#define PCIE_PMBU32(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x28)  /* RC only */
-+#define PCIE_PMLU32(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x2C)  /* RC only */
-+
-+/* I/O Base/Limit Upper 16 bits register */
-+#define PCIE_IO_BANDL(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x30)  /* RC only */
-+#define PCIE_IO_BANDL_UPPER_16BIT_IO_BASE        0x0000FFFF
-+#define PCIE_IO_BANDL_UPPER_16BIT_IO_BASE_S      0
-+#define PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT       0xFFFF0000
-+#define PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT_S     16
-+
-+#define PCIE_CPR(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x34)
-+#define PCIE_EBBAR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x38)
-+
-+/* Interrupt and Secondary Bridge Control Register */
-+#define PCIE_INTRBCTRL(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x3C)
-+
-+#define PCIE_INTRBCTRL_INT_LINE                 0x000000FF
-+#define PCIE_INTRBCTRL_INT_LINE_S               0
-+#define PCIE_INTRBCTRL_INT_PIN                  0x0000FF00
-+#define PCIE_INTRBCTRL_INT_PIN_S                8
-+#define PCIE_INTRBCTRL_PARITY_ERR_RESP_ENABLE   0x00010000    /* #PERR */
-+#define PCIE_INTRBCTRL_SERR_ENABLE              0x00020000    /* #SERR */
-+#define PCIE_INTRBCTRL_ISA_ENABLE               0x00040000    /* ISA enable, IO 64KB only */
-+#define PCIE_INTRBCTRL_VGA_ENABLE               0x00080000    /* VGA enable */
-+#define PCIE_INTRBCTRL_VGA_16BIT_DECODE         0x00100000    /* VGA 16bit decode */
-+#define PCIE_INTRBCTRL_RST_SECONDARY_BUS        0x00400000    /* Secondary bus rest, hot rest, 1ms */
-+/* Others are read only */
-+enum {
-+    PCIE_INTRBCTRL_INT_NON = 0,
-+    PCIE_INTRBCTRL_INTA,
-+    PCIE_INTRBCTRL_INTB,
-+    PCIE_INTRBCTRL_INTC,
-+    PCIE_INTRBCTRL_INTD,
-+};
-+
-+#define PCIE_PM_CAPR(X)                  (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x40)
-+
-+/* Power Management Control and Status Register */
-+#define PCIE_PM_CSR(X)                   (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x44)
-+
-+#define PCIE_PM_CSR_POWER_STATE           0x00000003   /* Power State */
-+#define PCIE_PM_CSR_POWER_STATE_S         0
-+#define PCIE_PM_CSR_SW_RST                0x00000008   /* Soft Reset Enabled */
-+#define PCIE_PM_CSR_PME_ENABLE            0x00000100   /* PME Enable */
-+#define PCIE_PM_CSR_PME_STATUS            0x00008000   /* PME status */
-+
-+/* MSI Capability Register for EP */
-+#define PCIE_MCAPR(X)                    (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x50)
-+
-+#define PCIE_MCAPR_MSI_CAP_ID             0x000000FF  /* MSI Capability ID */
-+#define PCIE_MCAPR_MSI_CAP_ID_S           0
-+#define PCIE_MCAPR_MSI_NEXT_CAP_PTR       0x0000FF00  /* Next Capability Pointer */
-+#define PCIE_MCAPR_MSI_NEXT_CAP_PTR_S     8
-+#define PCIE_MCAPR_MSI_ENABLE             0x00010000  /* MSI Enable */
-+#define PCIE_MCAPR_MULTI_MSG_CAP          0x000E0000  /* Multiple Message Capable */
-+#define PCIE_MCAPR_MULTI_MSG_CAP_S        17
-+#define PCIE_MCAPR_MULTI_MSG_ENABLE       0x00700000  /* Multiple Message Enable */
-+#define PCIE_MCAPR_MULTI_MSG_ENABLE_S     20
-+#define PCIE_MCAPR_ADDR64_CAP             0X00800000  /* 64-bit Address Capable */
-+
-+/* MSI Message Address Register */
-+#define PCIE_MA(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x54)
-+
-+#define PCIE_MA_ADDR_MASK                 0xFFFFFFFC  /* Message Address */
-+
-+/* MSI Message Upper Address Register */
-+#define PCIE_MUA(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x58)
-+
-+/* MSI Message Data Register */
-+#define PCIE_MD(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x5C)
-+
-+#define PCIE_MD_DATA                      0x0000FFFF  /* Message Data */
-+#define PCIE_MD_DATA_S                    0
-+
-+/* PCI Express Capability Register */
-+#define PCIE_XCAP(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x70)
-+
-+#define PCIE_XCAP_ID                      0x000000FF  /* PCI Express Capability ID */
-+#define PCIE_XCAP_ID_S                    0
-+#define PCIE_XCAP_NEXT_CAP                0x0000FF00  /* Next Capability Pointer */
-+#define PCIE_XCAP_NEXT_CAP_S              8
-+#define PCIE_XCAP_VER                     0x000F0000  /* PCI Express Capability Version */
-+#define PCIE_XCAP_VER_S                   16
-+#define PCIE_XCAP_DEV_PORT_TYPE           0x00F00000  /* Device Port Type */
-+#define PCIE_XCAP_DEV_PORT_TYPE_S         20
-+#define PCIE_XCAP_SLOT_IMPLEMENTED        0x01000000  /* Slot Implemented */
-+#define PCIE_XCAP_MSG_INT_NUM             0x3E000000  /* Interrupt Message Number */
-+#define PCIE_XCAP_MSG_INT_NUM_S           25
-+
-+/* Device Capability Register */
-+#define PCIE_DCAP(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x74)
-+
-+#define PCIE_DCAP_MAX_PAYLOAD_SIZE        0x00000007   /* Max Payload size */
-+#define PCIE_DCAP_MAX_PAYLOAD_SIZE_S      0
-+#define PCIE_DCAP_PHANTOM_FUNC            0x00000018   /* Phanton Function, not supported */
-+#define PCIE_DCAP_PHANTOM_FUNC_S          3
-+#define PCIE_DCAP_EXT_TAG                 0x00000020   /* Extended Tag Field */
-+#define PCIE_DCAP_EP_L0S_LATENCY          0x000001C0   /* EP L0s latency only */
-+#define PCIE_DCAP_EP_L0S_LATENCY_S        6
-+#define PCIE_DCAP_EP_L1_LATENCY           0x00000E00   /* EP L1 latency only */
-+#define PCIE_DCAP_EP_L1_LATENCY_S         9
-+#define PCIE_DCAP_ROLE_BASE_ERR_REPORT    0x00008000   /* Role Based ERR */
-+
-+/* Maximum payload size supported */
-+enum {
-+    PCIE_MAX_PAYLOAD_128 = 0,
-+    PCIE_MAX_PAYLOAD_256,
-+    PCIE_MAX_PAYLOAD_512,
-+    PCIE_MAX_PAYLOAD_1024,
-+    PCIE_MAX_PAYLOAD_2048,
-+    PCIE_MAX_PAYLOAD_4096,
-+};
-+
-+/* Device Control and Status Register */
-+#define PCIE_DCTLSTS(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x78)
-+
-+#define PCIE_DCTLSTS_CORRECTABLE_ERR_EN        0x00000001   /* COR-ERR */
-+#define PCIE_DCTLSTS_NONFATAL_ERR_EN           0x00000002   /* Non-fatal ERR */
-+#define PCIE_DCTLSTS_FATAL_ERR_EN              0x00000004   /* Fatal ERR */
-+#define PCIE_DCTLSYS_UR_REQ_EN                 0x00000008   /* UR ERR */
-+#define PCIE_DCTLSTS_RELAXED_ORDERING_EN       0x00000010   /* Enable relaxing ordering */
-+#define PCIE_DCTLSTS_MAX_PAYLOAD_SIZE          0x000000E0   /* Max payload mask */
-+#define PCIE_DCTLSTS_MAX_PAYLOAD_SIZE_S        5
-+#define PCIE_DCTLSTS_EXT_TAG_EN                0x00000100   /* Extended tag field */
-+#define PCIE_DCTLSTS_PHANTOM_FUNC_EN           0x00000200   /* Phantom Function Enable */
-+#define PCIE_DCTLSTS_AUX_PM_EN                 0x00000400   /* AUX Power PM Enable */
-+#define PCIE_DCTLSTS_NO_SNOOP_EN               0x00000800   /* Enable no snoop, except root port*/
-+#define PCIE_DCTLSTS_MAX_READ_SIZE             0x00007000   /* Max Read Request size*/
-+#define PCIE_DCTLSTS_MAX_READ_SIZE_S           12
-+#define PCIE_DCTLSTS_CORRECTABLE_ERR           0x00010000   /* COR-ERR Detected */
-+#define PCIE_DCTLSTS_NONFATAL_ERR              0x00020000   /* Non-Fatal ERR Detected */
-+#define PCIE_DCTLSTS_FATAL_ER                  0x00040000   /* Fatal ERR Detected */
-+#define PCIE_DCTLSTS_UNSUPPORTED_REQ           0x00080000   /* UR Detected */
-+#define PCIE_DCTLSTS_AUX_POWER                 0x00100000   /* Aux Power Detected */
-+#define PCIE_DCTLSTS_TRANSACT_PENDING          0x00200000   /* Transaction pending */
-+
-+#define PCIE_DCTLSTS_ERR_EN      (PCIE_DCTLSTS_CORRECTABLE_ERR_EN | \
-+                                  PCIE_DCTLSTS_NONFATAL_ERR_EN | PCIE_DCTLSTS_FATAL_ERR_EN | \
-+                                  PCIE_DCTLSYS_UR_REQ_EN)
-+
-+/* Link Capability Register */
-+#define PCIE_LCAP(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7C)
-+#define PCIE_LCAP_MAX_LINK_SPEED               0x0000000F  /* Max link speed, 0x1 by default */
-+#define PCIE_LCAP_MAX_LINK_SPEED_S             0
-+#define PCIE_LCAP_MAX_LENGTH_WIDTH             0x000003F0  /* Maxium Length Width */
-+#define PCIE_LCAP_MAX_LENGTH_WIDTH_S           4
-+#define PCIE_LCAP_ASPM_LEVEL                   0x00000C00  /* Active State Link PM Support */
-+#define PCIE_LCAP_ASPM_LEVEL_S                 10
-+#define PCIE_LCAP_L0S_EIXT_LATENCY             0x00007000  /* L0s Exit Latency */
-+#define PCIE_LCAP_L0S_EIXT_LATENCY_S           12
-+#define PCIE_LCAP_L1_EXIT_LATENCY              0x00038000  /* L1 Exit Latency */
-+#define PCIE_LCAP_L1_EXIT_LATENCY_S            15
-+#define PCIE_LCAP_CLK_PM                       0x00040000  /* Clock Power Management */
-+#define PCIE_LCAP_SDER                         0x00080000  /* Surprise Down Error Reporting */
-+#define PCIE_LCAP_DLL_ACTIVE_REPROT            0x00100000  /* Data Link Layer Active Reporting Capable */
-+#define PCIE_LCAP_PORT_NUM                     0xFF0000000  /* Port number */
-+#define PCIE_LCAP_PORT_NUM_S                   24
-+
-+/* Maximum Length width definition */
-+#define PCIE_MAX_LENGTH_WIDTH_RES  0x00
-+#define PCIE_MAX_LENGTH_WIDTH_X1   0x01  /* Default */
-+#define PCIE_MAX_LENGTH_WIDTH_X2   0x02
-+#define PCIE_MAX_LENGTH_WIDTH_X4   0x04
-+#define PCIE_MAX_LENGTH_WIDTH_X8   0x08
-+#define PCIE_MAX_LENGTH_WIDTH_X12  0x0C
-+#define PCIE_MAX_LENGTH_WIDTH_X16  0x10
-+#define PCIE_MAX_LENGTH_WIDTH_X32  0x20
-+
-+/* Active State Link PM definition */
-+enum {
-+    PCIE_ASPM_RES0                = 0,
-+    PCIE_ASPM_L0S_ENTRY_SUPPORT,        /* L0s */
-+    PCIE_ASPM_RES1,
-+    PCIE_ASPM_L0S_L1_ENTRY_SUPPORT,     /* L0s and L1, default */
-+};
-+
-+/* L0s Exit Latency definition */
-+enum {
-+    PCIE_L0S_EIXT_LATENCY_L64NS    = 0, /* < 64 ns */
-+    PCIE_L0S_EIXT_LATENCY_B64A128,      /* > 64 ns < 128 ns */
-+    PCIE_L0S_EIXT_LATENCY_B128A256,     /* > 128 ns < 256 ns */
-+    PCIE_L0S_EIXT_LATENCY_B256A512,     /* > 256 ns < 512 ns */
-+    PCIE_L0S_EIXT_LATENCY_B512TO1U,     /* > 512 ns < 1 us */
-+    PCIE_L0S_EIXT_LATENCY_B1A2U,        /* > 1 us < 2 us */
-+    PCIE_L0S_EIXT_LATENCY_B2A4U,        /* > 2 us < 4 us */
-+    PCIE_L0S_EIXT_LATENCY_M4US,         /* > 4 us  */
-+};
-+
-+/* L1 Exit Latency definition */
-+enum {
-+    PCIE_L1_EXIT_LATENCY_L1US  = 0,  /* < 1 us */
-+    PCIE_L1_EXIT_LATENCY_B1A2,       /* > 1 us < 2 us */
-+    PCIE_L1_EXIT_LATENCY_B2A4,       /* > 2 us < 4 us */
-+    PCIE_L1_EXIT_LATENCY_B4A8,       /* > 4 us < 8 us */
-+    PCIE_L1_EXIT_LATENCY_B8A16,      /* > 8 us < 16 us */
-+    PCIE_L1_EXIT_LATENCY_B16A32,     /* > 16 us < 32 us */
-+    PCIE_L1_EXIT_LATENCY_B32A64,     /* > 32 us < 64 us */
-+    PCIE_L1_EXIT_LATENCY_M64US,      /* > 64 us */
-+};
-+
-+/* Link Control and Status Register */
-+#define PCIE_LCTLSTS(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x80)
-+#define PCIE_LCTLSTS_ASPM_ENABLE            0x00000003  /* Active State Link PM Control */
-+#define PCIE_LCTLSTS_ASPM_ENABLE_S          0
-+#define PCIE_LCTLSTS_RCB128                 0x00000008  /* Read Completion Boundary 128*/
-+#define PCIE_LCTLSTS_LINK_DISABLE           0x00000010  /* Link Disable */
-+#define PCIE_LCTLSTS_RETRIAN_LINK           0x00000020  /* Retrain Link */
-+#define PCIE_LCTLSTS_COM_CLK_CFG            0x00000040  /* Common Clock Configuration */
-+#define PCIE_LCTLSTS_EXT_SYNC               0x00000080  /* Extended Synch */
-+#define PCIE_LCTLSTS_CLK_PM_EN              0x00000100  /* Enable Clock Powerm Management */
-+#define PCIE_LCTLSTS_LINK_SPEED             0x000F0000  /* Link Speed */
-+#define PCIE_LCTLSTS_LINK_SPEED_S           16
-+#define PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH  0x03F00000  /* Negotiated Link Width */
-+#define PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH_S 20
-+#define PCIE_LCTLSTS_RETRAIN_PENDING        0x08000000  /* Link training is ongoing */
-+#define PCIE_LCTLSTS_SLOT_CLK_CFG           0x10000000  /* Slot Clock Configuration */
-+#define PCIE_LCTLSTS_DLL_ACTIVE             0x20000000  /* Data Link Layer Active */
-+
-+/* Slot Capabilities Register */
-+#define PCIE_SLCAP(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x84)
-+
-+/* Slot Capabilities */
-+#define PCIE_SLCTLSTS(X)                    (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x88)
-+
-+/* Root Control and Capability Register */
-+#define PCIE_RCTLCAP(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x8C)
-+#define PCIE_RCTLCAP_SERR_ON_CORRECTABLE_ERR  0x00000001   /* #SERR on COR-ERR */
-+#define PCIE_RCTLCAP_SERR_ON_NONFATAL_ERR     0x00000002   /* #SERR on Non-Fatal ERR */
-+#define PCIE_RCTLCAP_SERR_ON_FATAL_ERR        0x00000004   /* #SERR on Fatal ERR */
-+#define PCIE_RCTLCAP_PME_INT_EN               0x00000008   /* PME Interrupt Enable */
-+#define PCIE_RCTLCAP_SERR_ENABLE    (PCIE_RCTLCAP_SERR_ON_CORRECTABLE_ERR | \
-+                                     PCIE_RCTLCAP_SERR_ON_NONFATAL_ERR | PCIE_RCTLCAP_SERR_ON_FATAL_ERR)
-+/* Root Status Register */
-+#define PCIE_RSTS(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x90)
-+#define PCIE_RSTS_PME_REQ_ID                   0x0000FFFF   /* PME Request ID */
-+#define PCIE_RSTS_PME_REQ_ID_S                 0
-+#define PCIE_RSTS_PME_STATUS                   0x00010000   /* PME Status */
-+#define PCIE_RSTS_PME_PENDING                  0x00020000   /* PME Pending */
-+
-+/* PCI Express Enhanced Capability Header */
-+#define PCIE_ENHANCED_CAP(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x100)
-+#define PCIE_ENHANCED_CAP_ID                 0x0000FFFF  /* PCI Express Extended Capability ID */
-+#define PCIE_ENHANCED_CAP_ID_S               0
-+#define PCIE_ENHANCED_CAP_VER                0x000F0000  /* Capability Version */
-+#define PCIE_ENHANCED_CAP_VER_S              16
-+#define PCIE_ENHANCED_CAP_NEXT_OFFSET        0xFFF00000  /* Next Capability Offset */
-+#define PCIE_ENHANCED_CAP_NEXT_OFFSET_S      20
-+
-+/* Uncorrectable Error Status Register */
-+#define PCIE_UES_R(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x104)
-+#define PCIE_DATA_LINK_PROTOCOL_ERR          0x00000010  /* Data Link Protocol Error Status */
-+#define PCIE_SURPRISE_DOWN_ERROR             0x00000020  /* Surprise Down Error Status */
-+#define PCIE_POISONED_TLP                    0x00001000  /* Poisoned TLP Status */
-+#define PCIE_FC_PROTOCOL_ERR                 0x00002000  /* Flow Control Protocol Error Status */
-+#define PCIE_COMPLETION_TIMEOUT              0x00004000  /* Completion Timeout Status */
-+#define PCIE_COMPLETOR_ABORT                 0x00008000  /* Completer Abort Error */
-+#define PCIE_UNEXPECTED_COMPLETION           0x00010000  /* Unexpected Completion Status */
-+#define PCIE_RECEIVER_OVERFLOW               0x00020000  /* Receive Overflow Status */
-+#define PCIE_MALFORNED_TLP                   0x00040000  /* Malformed TLP Stauts */
-+#define PCIE_ECRC_ERR                        0x00080000  /* ECRC Error Stauts */
-+#define PCIE_UR_REQ                          0x00100000  /* Unsupported Request Error Status */
-+#define PCIE_ALL_UNCORRECTABLE_ERR    (PCIE_DATA_LINK_PROTOCOL_ERR | PCIE_SURPRISE_DOWN_ERROR | \
-+                         PCIE_POISONED_TLP | PCIE_FC_PROTOCOL_ERR | PCIE_COMPLETION_TIMEOUT |   \
-+                         PCIE_COMPLETOR_ABORT | PCIE_UNEXPECTED_COMPLETION | PCIE_RECEIVER_OVERFLOW |\
-+                         PCIE_MALFORNED_TLP | PCIE_ECRC_ERR | PCIE_UR_REQ)
-+
-+/* Uncorrectable Error Mask Register, Mask means no report */
-+#define PCIE_UEMR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x108)
-+
-+/* Uncorrectable Error Severity Register */
-+#define PCIE_UESR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x10C)
-+
-+/* Correctable Error Status Register */
-+#define PCIE_CESR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x110)
-+#define PCIE_RX_ERR                          0x00000001  /* Receive Error Status */
-+#define PCIE_BAD_TLP                         0x00000040  /* Bad TLP Status */
-+#define PCIE_BAD_DLLP                        0x00000080  /* Bad DLLP Status */
-+#define PCIE_REPLAY_NUM_ROLLOVER             0x00000100  /* Replay Number Rollover Status */
-+#define PCIE_REPLAY_TIMER_TIMEOUT_ERR        0x00001000  /* Reply Timer Timeout Status */
-+#define PCIE_ADVISORY_NONFTAL_ERR            0x00002000  /* Advisory Non-Fatal Error Status */
-+#define PCIE_CORRECTABLE_ERR        (PCIE_RX_ERR | PCIE_BAD_TLP | PCIE_BAD_DLLP | PCIE_REPLAY_NUM_ROLLOVER |\
-+                                     PCIE_REPLAY_TIMER_TIMEOUT_ERR | PCIE_ADVISORY_NONFTAL_ERR)
-+
-+/* Correctable Error Mask Register */
-+#define PCIE_CEMR(X)                        (volatile u32*)(PCIE_RC_CFG_BASE + 0x114)
-+
-+/* Advanced Error Capabilities and Control Register */
-+#define PCIE_AECCR(X)                       (volatile u32*)(PCIE_RC_CFG_BASE + 0x118)
-+#define PCIE_AECCR_FIRST_ERR_PTR            0x0000001F  /* First Error Pointer */
-+#define PCIE_AECCR_FIRST_ERR_PTR_S          0
-+#define PCIE_AECCR_ECRC_GEN_CAP             0x00000020  /* ECRC Generation Capable */
-+#define PCIE_AECCR_ECRC_GEN_EN              0x00000040  /* ECRC Generation Enable */
-+#define PCIE_AECCR_ECRC_CHECK_CAP           0x00000080  /* ECRC Check Capable */
-+#define PCIE_AECCR_ECRC_CHECK_EN            0x00000100  /* ECRC Check Enable */
-+
-+/* Header Log Register 1 */
-+#define PCIE_HLR1(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x11C)
-+
-+/* Header Log Register 2 */
-+#define PCIE_HLR2(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x120)
-+
-+/* Header Log Register 3 */
-+#define PCIE_HLR3(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x124)
-+
-+/* Header Log Register 4 */
-+#define PCIE_HLR4(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x128)
-+
-+/* Root Error Command Register */
-+#define PCIE_RECR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x12C)
-+#define PCIE_RECR_CORRECTABLE_ERR_REPORT_EN  0x00000001 /* COR-ERR */
-+#define PCIE_RECR_NONFATAL_ERR_REPORT_EN     0x00000002 /* Non-Fatal ERR */
-+#define PCIE_RECR_FATAL_ERR_REPORT_EN        0x00000004 /* Fatal ERR */
-+#define PCIE_RECR_ERR_REPORT_EN  (PCIE_RECR_CORRECTABLE_ERR_REPORT_EN | \
-+                PCIE_RECR_NONFATAL_ERR_REPORT_EN | PCIE_RECR_FATAL_ERR_REPORT_EN)
-+
-+/* Root Error Status Register */
-+#define PCIE_RESR(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x130)
-+#define PCIE_RESR_CORRECTABLE_ERR                0x00000001   /* COR-ERR Receveid */
-+#define PCIE_RESR_MULTI_CORRECTABLE_ERR          0x00000002   /* Multiple COR-ERR Received */
-+#define PCIE_RESR_FATAL_NOFATAL_ERR              0x00000004   /* ERR Fatal/Non-Fatal Received */
-+#define PCIE_RESR_MULTI_FATAL_NOFATAL_ERR        0x00000008   /* Multiple ERR Fatal/Non-Fatal Received */
-+#define PCIE_RESR_FIRST_UNCORRECTABLE_FATAL_ERR  0x00000010   /* First UN-COR Fatal */
-+#define PCIR_RESR_NON_FATAL_ERR                  0x00000020   /* Non-Fatal Error Message Received */
-+#define PCIE_RESR_FATAL_ERR                      0x00000040   /* Fatal Message Received */
-+#define PCIE_RESR_AER_INT_MSG_NUM                0xF8000000   /* Advanced Error Interrupt Message Number */
-+#define PCIE_RESR_AER_INT_MSG_NUM_S              27
-+
-+/* Error Source Indentification Register */
-+#define PCIE_ESIR(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x134)
-+#define PCIE_ESIR_CORRECTABLE_ERR_SRC_ID         0x0000FFFF
-+#define PCIE_ESIR_CORRECTABLE_ERR_SRC_ID_S       0
-+#define PCIE_ESIR_FATAL_NON_FATAL_SRC_ID         0xFFFF0000
-+#define PCIE_ESIR_FATAL_NON_FATAL_SRC_ID_S       16
-+
-+/* VC Enhanced Capability Header */
-+#define PCIE_VC_ECH(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x140)
-+
-+/* Port VC Capability Register */
-+#define PCIE_PVC1(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x144)
-+#define PCIE_PVC1_EXT_VC_CNT                    0x00000007  /* Extended VC Count */
-+#define PCIE_PVC1_EXT_VC_CNT_S                  0
-+#define PCIE_PVC1_LOW_PRI_EXT_VC_CNT            0x00000070  /* Low Priority Extended VC Count */
-+#define PCIE_PVC1_LOW_PRI_EXT_VC_CNT_S          4
-+#define PCIE_PVC1_REF_CLK                       0x00000300  /* Reference Clock */
-+#define PCIE_PVC1_REF_CLK_S                     8
-+#define PCIE_PVC1_PORT_ARB_TAB_ENTRY_SIZE       0x00000C00  /* Port Arbitration Table Entry Size */
-+#define PCIE_PVC1_PORT_ARB_TAB_ENTRY_SIZE_S     10
-+
-+/* Extended Virtual Channel Count Defintion */
-+#define PCIE_EXT_VC_CNT_MIN   0
-+#define PCIE_EXT_VC_CNT_MAX   7
-+
-+/* Port Arbitration Table Entry Size Definition */
-+enum {
-+    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S1BIT = 0,
-+    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S2BIT,
-+    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S4BIT,
-+    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S8BIT,
-+};
-+
-+/* Port VC Capability Register 2 */
-+#define PCIE_PVC2(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x148)
-+#define PCIE_PVC2_VC_ARB_16P_FIXED_WRR      0x00000001  /* HW Fixed arbitration, 16 phase WRR */
-+#define PCIE_PVC2_VC_ARB_32P_WRR            0x00000002  /* 32 phase WRR */
-+#define PCIE_PVC2_VC_ARB_64P_WRR            0x00000004  /* 64 phase WRR */
-+#define PCIE_PVC2_VC_ARB_128P_WRR           0x00000008  /* 128 phase WRR */
-+#define PCIE_PVC2_VC_ARB_WRR                0x0000000F
-+#define PCIE_PVC2_VC_ARB_TAB_OFFSET         0xFF000000  /* VC arbitration table offset, not support */
-+#define PCIE_PVC2_VC_ARB_TAB_OFFSET_S       24
-+
-+/* Port VC Control and Status Register */     
-+#define PCIE_PVCCRSR(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x14C)
-+#define PCIE_PVCCRSR_LOAD_VC_ARB_TAB         0x00000001  /* Load VC Arbitration Table */
-+#define PCIE_PVCCRSR_VC_ARB_SEL              0x0000000E  /* VC Arbitration Select */
-+#define PCIE_PVCCRSR_VC_ARB_SEL_S            1
-+#define PCIE_PVCCRSR_VC_ARB_TAB_STATUS       0x00010000  /* Arbitration Status */
-+
-+/* VC0 Resource Capability Register */
-+#define PCIE_VC0_RC(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x150)
-+#define PCIE_VC0_RC_PORT_ARB_HW_FIXED        0x00000001  /* HW Fixed arbitration */
-+#define PCIE_VC0_RC_PORT_ARB_32P_WRR         0x00000002  /* 32 phase WRR */
-+#define PCIE_VC0_RC_PORT_ARB_64P_WRR         0x00000004  /* 64 phase WRR */
-+#define PCIE_VC0_RC_PORT_ARB_128P_WRR        0x00000008  /* 128 phase WRR */
-+#define PCIE_VC0_RC_PORT_ARB_TM_128P_WRR     0x00000010  /* Time-based 128 phase WRR */
-+#define PCIE_VC0_RC_PORT_ARB_TM_256P_WRR     0x00000020  /* Time-based 256 phase WRR */
-+#define PCIE_VC0_RC_PORT_ARB          (PCIE_VC0_RC_PORT_ARB_HW_FIXED | PCIE_VC0_RC_PORT_ARB_32P_WRR |\
-+                        PCIE_VC0_RC_PORT_ARB_64P_WRR | PCIE_VC0_RC_PORT_ARB_128P_WRR | \
-+                        PCIE_VC0_RC_PORT_ARB_TM_128P_WRR | PCIE_VC0_RC_PORT_ARB_TM_256P_WRR)
-+
-+#define PCIE_VC0_RC_REJECT_SNOOP             0x00008000  /* Reject Snoop Transactioin */
-+#define PCIE_VC0_RC_MAX_TIMESLOTS            0x007F0000  /* Maximum time Slots */
-+#define PCIE_VC0_RC_MAX_TIMESLOTS_S          16
-+#define PCIE_VC0_RC_PORT_ARB_TAB_OFFSET      0xFF000000  /* Port Arbitration Table Offset */
-+#define PCIE_VC0_RC_PORT_ARB_TAB_OFFSET_S    24
-+
-+/* VC0 Resource Control Register */
-+#define PCIE_VC0_RC0(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x154)
-+#define PCIE_VC0_RC0_TVM0                    0x00000001  /* TC0 and VC0 */
-+#define PCIE_VC0_RC0_TVM1                    0x00000002  /* TC1 and VC1 */
-+#define PCIE_VC0_RC0_TVM2                    0x00000004  /* TC2 and VC2 */
-+#define PCIE_VC0_RC0_TVM3                    0x00000008  /* TC3 and VC3 */
-+#define PCIE_VC0_RC0_TVM4                    0x00000010  /* TC4 and VC4 */
-+#define PCIE_VC0_RC0_TVM5                    0x00000020  /* TC5 and VC5 */
-+#define PCIE_VC0_RC0_TVM6                    0x00000040  /* TC6 and VC6 */
-+#define PCIE_VC0_RC0_TVM7                    0x00000080  /* TC7 and VC7 */
-+#define PCIE_VC0_RC0_TC_VC                   0x000000FF  /* TC/VC mask */
-+
-+#define PCIE_VC0_RC0_LOAD_PORT_ARB_TAB       0x00010000  /* Load Port Arbitration Table */
-+#define PCIE_VC0_RC0_PORT_ARB_SEL            0x000E0000  /* Port Arbitration Select */
-+#define PCIE_VC0_RC0_PORT_ARB_SEL_S          17
-+#define PCIE_VC0_RC0_VC_ID                   0x07000000  /* VC ID */
-+#define PCIE_VC0_RC0_VC_ID_S                 24
-+#define PCIE_VC0_RC0_VC_EN                   0x80000000  /* VC Enable */
-+
-+/* VC0 Resource Status Register */
-+#define PCIE_VC0_RSR0(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x158)
-+#define PCIE_VC0_RSR0_PORT_ARB_TAB_STATUS    0x00010000  /* Port Arbitration Table Status,not used */
-+#define PCIE_VC0_RSR0_VC_NEG_PENDING         0x00020000  /* VC Negotiation Pending */
-+
-+/* Ack Latency Timer and Replay Timer Register */
-+#define PCIE_ALTRT(X)                         (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x700)
-+#define PCIE_ALTRT_ROUND_TRIP_LATENCY_LIMIT   0x0000FFFF  /* Round Trip Latency Time Limit */
-+#define PCIE_ALTRT_ROUND_TRIP_LATENCY_LIMIT_S 0
-+#define PCIE_ALTRT_REPLAY_TIME_LIMIT          0xFFFF0000  /* Replay Time Limit */
-+#define PCIE_ALTRT_REPLAY_TIME_LIMIT_S        16
-+
-+/* Other Message Register */
-+#define PCIE_OMR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x704)
-+
-+/* Port Force Link Register */
-+#define PCIE_PFLR(X)                         (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x708)
-+#define PCIE_PFLR_LINK_NUM                   0x000000FF  /* Link Number */
-+#define PCIE_PFLR_LINK_NUM_S                 0
-+#define PCIE_PFLR_FORCE_LINK                 0x00008000  /* Force link */
-+#define PCIE_PFLR_LINK_STATE                 0x003F0000  /* Link State */
-+#define PCIE_PFLR_LINK_STATE_S               16
-+#define PCIE_PFLR_LOW_POWER_ENTRY_CNT        0xFF000000  /* Low Power Entrance Count, only for EP */
-+#define PCIE_PFLR_LOW_POWER_ENTRY_CNT_S      24
-+
-+/* Ack Frequency Register */
-+#define PCIE_AFR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x70C)
-+#define PCIE_AFR_AF                          0x000000FF  /* Ack Frequency */
-+#define PCIE_AFR_AF_S                        0
-+#define PCIE_AFR_FTS_NUM                     0x0000FF00  /* The number of Fast Training Sequence from L0S to L0 */
-+#define PCIE_AFR_FTS_NUM_S                   8
-+#define PCIE_AFR_COM_FTS_NUM                 0x00FF0000  /* N_FTS; when common clock is used*/
-+#define PCIE_AFR_COM_FTS_NUM_S               16
-+#define PCIE_AFR_L0S_ENTRY_LATENCY           0x07000000  /* L0s Entrance Latency */
-+#define PCIE_AFR_L0S_ENTRY_LATENCY_S         24
-+#define PCIE_AFR_L1_ENTRY_LATENCY            0x38000000  /* L1 Entrance Latency */
-+#define PCIE_AFR_L1_ENTRY_LATENCY_S          27
-+#define PCIE_AFR_FTS_NUM_DEFAULT             32
-+#define PCIE_AFR_L0S_ENTRY_LATENCY_DEFAULT   7
-+#define PCIE_AFR_L1_ENTRY_LATENCY_DEFAULT    5
-+
-+/* Port Link Control Register */
-+#define PCIE_PLCR(X)                         (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x710)
-+#define PCIE_PLCR_OTHER_MSG_REQ              0x00000001  /* Other Message Request */
-+#define PCIE_PLCR_SCRAMBLE_DISABLE           0x00000002  /* Scramble Disable */  
-+#define PCIE_PLCR_LOOPBACK_EN                0x00000004  /* Loopback Enable */
-+#define PCIE_PLCR_LTSSM_HOT_RST              0x00000008  /* Force LTSSM to the hot reset */
-+#define PCIE_PLCR_DLL_LINK_EN                0x00000020  /* Enable Link initialization */
-+#define PCIE_PLCR_FAST_LINK_SIM_EN           0x00000080  /* Sets all internal timers to fast mode for simulation purposes */
-+#define PCIE_PLCR_LINK_MODE                  0x003F0000  /* Link Mode Enable Mask */
-+#define PCIE_PLCR_LINK_MODE_S                16
-+#define PCIE_PLCR_CORRUPTED_CRC_EN           0x02000000  /* Enabled Corrupt CRC */
-+
-+/* Lane Skew Register */
-+#define PCIE_LSR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x714)
-+#define PCIE_LSR_LANE_SKEW_NUM               0x00FFFFFF  /* Insert Lane Skew for Transmit, not applicable */
-+#define PCIE_LSR_LANE_SKEW_NUM_S             0
-+#define PCIE_LSR_FC_DISABLE                  0x01000000  /* Disable of Flow Control */
-+#define PCIE_LSR_ACKNAK_DISABLE              0x02000000  /* Disable of Ack/Nak */
-+#define PCIE_LSR_LANE_DESKEW_DISABLE         0x80000000  /* Disable of Lane-to-Lane Skew */
-+
-+/* Symbol Number Register */
-+#define PCIE_SNR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x718)
-+#define PCIE_SNR_TS                          0x0000000F  /* Number of TS Symbol */
-+#define PCIE_SNR_TS_S                        0
-+#define PCIE_SNR_SKP                         0x00000700  /* Number of SKP Symbol */
-+#define PCIE_SNR_SKP_S                       8
-+#define PCIE_SNR_REPLAY_TIMER                0x0007C000  /* Timer Modifier for Replay Timer */
-+#define PCIE_SNR_REPLAY_TIMER_S              14
-+#define PCIE_SNR_ACKNAK_LATENCY_TIMER        0x00F80000  /* Timer Modifier for Ack/Nak Latency Timer */
-+#define PCIE_SNR_ACKNAK_LATENCY_TIMER_S      19
-+#define PCIE_SNR_FC_TIMER                    0x1F000000  /* Timer Modifier for Flow Control Watchdog Timer */
-+#define PCIE_SNR_FC_TIMER_S                  28
-+
-+/* Symbol Timer Register and Filter Mask Register 1 */
-+#define PCIE_STRFMR(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x71C)
-+#define PCIE_STRFMR_SKP_INTERVAL            0x000007FF  /* SKP lnterval Value */
-+#define PCIE_STRFMR_SKP_INTERVAL_S          0
-+#define PCIE_STRFMR_FC_WDT_DISABLE          0x00008000  /* Disable of FC Watchdog Timer */
-+#define PCIE_STRFMR_TLP_FUNC_MISMATCH_OK    0x00010000  /* Mask Function Mismatch Filtering for Incoming Requests */
-+#define PCIE_STRFMR_POISONED_TLP_OK         0x00020000  /* Mask Poisoned TLP Filtering */
-+#define PCIE_STRFMR_BAR_MATCH_OK            0x00040000  /* Mask BAR Match Filtering */
-+#define PCIE_STRFMR_TYPE1_CFG_REQ_OK        0x00080000  /* Mask Type 1 Configuration Request Filtering */
-+#define PCIE_STRFMR_LOCKED_REQ_OK           0x00100000  /* Mask Locked Request Filtering */
-+#define PCIE_STRFMR_CPL_TAG_ERR_RULES_OK    0x00200000  /* Mask Tag Error Rules for Received Completions */
-+#define PCIE_STRFMR_CPL_REQUESTOR_ID_MISMATCH_OK 0x00400000  /* Mask Requester ID Mismatch Error for Received Completions */
-+#define PCIE_STRFMR_CPL_FUNC_MISMATCH_OK         0x00800000  /* Mask Function Mismatch Error for Received Completions */
-+#define PCIE_STRFMR_CPL_TC_MISMATCH_OK           0x01000000  /* Mask Traffic Class Mismatch Error for Received Completions */
-+#define PCIE_STRFMR_CPL_ATTR_MISMATCH_OK         0x02000000  /* Mask Attribute Mismatch Error for Received Completions */
-+#define PCIE_STRFMR_CPL_LENGTH_MISMATCH_OK       0x04000000  /* Mask Length Mismatch Error for Received Completions */
-+#define PCIE_STRFMR_TLP_ECRC_ERR_OK              0x08000000  /* Mask ECRC Error Filtering */
-+#define PCIE_STRFMR_CPL_TLP_ECRC_OK              0x10000000  /* Mask ECRC Error Filtering for Completions */
-+#define PCIE_STRFMR_RX_TLP_MSG_NO_DROP           0x20000000  /* Send Message TLPs */
-+#define PCIE_STRFMR_RX_IO_TRANS_ENABLE           0x40000000  /* Mask Filtering of received I/O Requests */
-+#define PCIE_STRFMR_RX_CFG_TRANS_ENABLE          0x80000000  /* Mask Filtering of Received Configuration Requests */
-+
-+#define PCIE_DEF_SKP_INTERVAL    700             /* 1180 ~1538 , 125MHz * 2, 250MHz * 1 */
-+
-+/* Filter Masker Register 2 */
-+#define PCIE_FMR2(X)                             (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x720)
-+#define PCIE_FMR2_VENDOR_MSG0_PASSED_TO_TRGT1    0x00000001  /* Mask RADM Filtering and Error Handling Rules */
-+#define PCIE_FMR2_VENDOR_MSG1_PASSED_TO_TRGT1    0x00000002  /* Mask RADM Filtering and Error Handling Rules */
-+
-+/* Debug Register 0 */
-+#define PCIE_DBR0(X)                              (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x728)
-+
-+/* Debug Register 1 */
-+#define PCIE_DBR1(X)                              (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x72C)
-+
-+/* Transmit Posted FC Credit Status Register */
-+#define PCIE_TPFCS(X)                             (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x730)
-+#define PCIE_TPFCS_TX_P_DATA_FC_CREDITS           0x00000FFF /* Transmit Posted Data FC Credits */
-+#define PCIE_TPFCS_TX_P_DATA_FC_CREDITS_S         0
-+#define PCIE_TPFCS_TX_P_HDR_FC_CREDITS            0x000FF000 /* Transmit Posted Header FC Credits */
-+#define PCIE_TPFCS_TX_P_HDR_FC_CREDITS_S          12
-+
-+/* Transmit Non-Posted FC Credit Status */
-+#define PCIE_TNPFCS(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x734)
-+#define PCIE_TNPFCS_TX_NP_DATA_FC_CREDITS         0x00000FFF /* Transmit Non-Posted Data FC Credits */
-+#define PCIE_TNPFCS_TX_NP_DATA_FC_CREDITS_S       0
-+#define PCIE_TNPFCS_TX_NP_HDR_FC_CREDITS          0x000FF000 /* Transmit Non-Posted Header FC Credits */
-+#define PCIE_TNPFCS_TX_NP_HDR_FC_CREDITS_S        12
-+
-+/* Transmit Complete FC Credit Status Register */
-+#define PCIE_TCFCS(X)                             (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x738)
-+#define PCIE_TCFCS_TX_CPL_DATA_FC_CREDITS         0x00000FFF /* Transmit Completion Data FC Credits */
-+#define PCIE_TCFCS_TX_CPL_DATA_FC_CREDITS_S       0
-+#define PCIE_TCFCS_TX_CPL_HDR_FC_CREDITS          0x000FF000 /* Transmit Completion Header FC Credits */
-+#define PCIE_TCFCS_TX_CPL_HDR_FC_CREDITS_S        12
-+
-+/* Queue Status Register */
-+#define PCIE_QSR(X)                              (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x73C)
-+#define PCIE_QSR_WAIT_UPDATE_FC_DLL               0x00000001 /* Received TLP FC Credits Not Returned */
-+#define PCIE_QSR_TX_RETRY_BUF_NOT_EMPTY           0x00000002 /* Transmit Retry Buffer Not Empty */
-+#define PCIE_QSR_RX_QUEUE_NOT_EMPTY               0x00000004 /* Received Queue Not Empty */
-+
-+/* VC Transmit Arbitration Register 1 */
-+#define PCIE_VCTAR1(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x740)
-+#define PCIE_VCTAR1_WRR_WEIGHT_VC0               0x000000FF /* WRR Weight for VC0 */
-+#define PCIE_VCTAR1_WRR_WEIGHT_VC1               0x0000FF00 /* WRR Weight for VC1 */
-+#define PCIE_VCTAR1_WRR_WEIGHT_VC2               0x00FF0000 /* WRR Weight for VC2 */
-+#define PCIE_VCTAR1_WRR_WEIGHT_VC3               0xFF000000 /* WRR Weight for VC3 */
-+
-+/* VC Transmit Arbitration Register 2 */
-+#define PCIE_VCTAR2(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x744)
-+#define PCIE_VCTAR2_WRR_WEIGHT_VC4               0x000000FF /* WRR Weight for VC4 */
-+#define PCIE_VCTAR2_WRR_WEIGHT_VC5               0x0000FF00 /* WRR Weight for VC5 */
-+#define PCIE_VCTAR2_WRR_WEIGHT_VC6               0x00FF0000 /* WRR Weight for VC6 */
-+#define PCIE_VCTAR2_WRR_WEIGHT_VC7               0xFF000000 /* WRR Weight for VC7 */
-+
-+/* VC0 Posted Receive Queue Control Register */
-+#define PCIE_VC0_PRQCR(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x748)
-+#define PCIE_VC0_PRQCR_P_DATA_CREDITS            0x00000FFF /* VC0 Posted Data Credits */
-+#define PCIE_VC0_PRQCR_P_DATA_CREDITS_S          0
-+#define PCIE_VC0_PRQCR_P_HDR_CREDITS             0x000FF000 /* VC0 Posted Header Credits */
-+#define PCIE_VC0_PRQCR_P_HDR_CREDITS_S           12
-+#define PCIE_VC0_PRQCR_P_TLP_QUEUE_MODE          0x00E00000 /* VC0 Posted TLP Queue Mode */
-+#define PCIE_VC0_PRQCR_P_TLP_QUEUE_MODE_S        20
-+#define PCIE_VC0_PRQCR_TLP_RELAX_ORDER           0x40000000 /* TLP Type Ordering for VC0 */    
-+#define PCIE_VC0_PRQCR_VC_STRICT_ORDER           0x80000000 /* VC0 Ordering for Receive Queues */
-+
-+/* VC0 Non-Posted Receive Queue Control */
-+#define PCIE_VC0_NPRQCR(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x74C)
-+#define PCIE_VC0_NPRQCR_NP_DATA_CREDITS          0x00000FFF /* VC0 Non-Posted Data Credits */
-+#define PCIE_VC0_NPRQCR_NP_DATA_CREDITS_S        0
-+#define PCIE_VC0_NPRQCR_NP_HDR_CREDITS           0x000FF000 /* VC0 Non-Posted Header Credits */
-+#define PCIE_VC0_NPRQCR_NP_HDR_CREDITS_S         12
-+#define PCIE_VC0_NPRQCR_NP_TLP_QUEUE_MODE        0x00E00000 /* VC0 Non-Posted TLP Queue Mode */
-+#define PCIE_VC0_NPRQCR_NP_TLP_QUEUE_MODE_S      20
-+
-+/* VC0 Completion Receive Queue Control */
-+#define PCIE_VC0_CRQCR(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x750)
-+#define PCIE_VC0_CRQCR_CPL_DATA_CREDITS          0x00000FFF /* VC0 Completion TLP Queue Mode */
-+#define PCIE_VC0_CRQCR_CPL_DATA_CREDITS_S        0
-+#define PCIE_VC0_CRQCR_CPL_HDR_CREDITS           0x000FF000 /* VC0 Completion Header Credits */
-+#define PCIE_VC0_CRQCR_CPL_HDR_CREDITS_S         12
-+#define PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE        0x00E00000 /* VC0 Completion Data Credits */
-+#define PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE_S      21
-+
-+/* Applicable to the above three registers */
-+enum {
-+    PCIE_VC0_TLP_QUEUE_MODE_STORE_FORWARD = 1,
-+    PCIE_VC0_TLP_QUEUE_MODE_CUT_THROUGH   = 2,
-+    PCIE_VC0_TLP_QUEUE_MODE_BYPASS        = 4,
-+};
-+
-+/* VC0 Posted Buffer Depth Register */
-+#define PCIE_VC0_PBD(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7A8)
-+#define PCIE_VC0_PBD_P_DATA_QUEUE_ENTRIES       0x00003FFF /* VC0 Posted Data Queue Depth */
-+#define PCIE_VC0_PBD_P_DATA_QUEUE_ENTRIES_S     0
-+#define PCIE_VC0_PBD_P_HDR_QUEUE_ENTRIES        0x03FF0000 /* VC0 Posted Header Queue Depth */
-+#define PCIE_VC0_PBD_P_HDR_QUEUE_ENTRIES_S      16
-+
-+/* VC0 Non-Posted Buffer Depth Register */
-+#define PCIE_VC0_NPBD(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7AC)
-+#define PCIE_VC0_NPBD_NP_DATA_QUEUE_ENTRIES     0x00003FFF /* VC0 Non-Posted Data Queue Depth */
-+#define PCIE_VC0_NPBD_NP_DATA_QUEUE_ENTRIES_S   0
-+#define PCIE_VC0_NPBD_NP_HDR_QUEUE_ENTRIES      0x03FF0000 /* VC0 Non-Posted Header Queue Depth */
-+#define PCIE_VC0_NPBD_NP_HDR_QUEUE_ENTRIES_S    16
-+
-+/* VC0 Completion Buffer Depth Register */
-+#define PCIE_VC0_CBD(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7B0)
-+#define PCIE_VC0_CBD_CPL_DATA_QUEUE_ENTRIES     0x00003FFF /* C0 Completion Data Queue Depth */
-+#define PCIE_VC0_CBD_CPL_DATA_QUEUE_ENTRIES_S   0
-+#define PCIE_VC0_CBD_CPL_HDR_QUEUE_ENTRIES      0x03FF0000 /* VC0 Completion Header Queue Depth */
-+#define PCIE_VC0_CBD_CPL_HDR_QUEUE_ENTRIES_S    16
-+
-+/* PHY Status Register, all zeros in VR9 */
-+#define PCIE_PHYSR(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x810)
-+
-+/* PHY Control Register, all zeros in VR9 */
-+#define PCIE_PHYCR(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x814)
-+
-+/* 
-+ * PCIe PDI PHY register definition, suppose all the following 
-+ * stuff is confidential. 
-+ * XXX, detailed bit definition
-+ */
-+#define	PCIE_PHY_PLL_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x22 << 1))
-+#define	PCIE_PHY_PLL_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x23 << 1))
-+#define	PCIE_PHY_PLL_CTRL3(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x24 << 1))
-+#define	PCIE_PHY_PLL_CTRL4(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x25 << 1))
-+#define	PCIE_PHY_PLL_CTRL5(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x26 << 1))
-+#define	PCIE_PHY_PLL_CTRL6(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x27 << 1))
-+#define	PCIE_PHY_PLL_CTRL7(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x28 << 1))
-+#define	PCIE_PHY_PLL_A_CTRL1(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x29 << 1))
-+#define	PCIE_PHY_PLL_A_CTRL2(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x2A << 1))
-+#define	PCIE_PHY_PLL_A_CTRL3(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x2B << 1))
-+#define	PCIE_PHY_PLL_STATUS(X)      (PCIE_PHY_PORT_TO_BASE(X) + (0x2C << 1))
-+ 
-+#define PCIE_PHY_TX1_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x30 << 1))
-+#define PCIE_PHY_TX1_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x31 << 1))
-+#define PCIE_PHY_TX1_CTRL3(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x32 << 1))
-+#define PCIE_PHY_TX1_A_CTRL1(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x33 << 1))
-+#define PCIE_PHY_TX1_A_CTRL2(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x34 << 1))
-+#define PCIE_PHY_TX1_MOD1(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x35 << 1))
-+#define PCIE_PHY_TX1_MOD2(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x36 << 1))
-+#define PCIE_PHY_TX1_MOD3(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x37 << 1))
-+
-+#define PCIE_PHY_TX2_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x38 << 1))
-+#define PCIE_PHY_TX2_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x39 << 1))
-+#define PCIE_PHY_TX2_A_CTRL1(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x3B << 1))
-+#define PCIE_PHY_TX2_A_CTRL2(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x3C << 1))
-+#define PCIE_PHY_TX2_MOD1(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x3D << 1))
-+#define PCIE_PHY_TX2_MOD2(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x3E << 1))
-+#define PCIE_PHY_TX2_MOD3(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x3F << 1))
-+
-+#define PCIE_PHY_RX1_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x50 << 1))
-+#define PCIE_PHY_RX1_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x51 << 1))
-+#define PCIE_PHY_RX1_CDR(X)         (PCIE_PHY_PORT_TO_BASE(X) + (0x52 << 1))
-+#define PCIE_PHY_RX1_EI(X)          (PCIE_PHY_PORT_TO_BASE(X) + (0x53 << 1))
-+#define PCIE_PHY_RX1_A_CTRL(X)      (PCIE_PHY_PORT_TO_BASE(X) + (0x55 << 1))
-+
-+/* Interrupt related stuff */
-+#define PCIE_LEGACY_DISABLE 0
-+#define PCIE_LEGACY_INTA  1
-+#define PCIE_LEGACY_INTB  2
-+#define PCIE_LEGACY_INTC  3
-+#define PCIE_LEGACY_INTD  4
-+#define PCIE_LEGACY_INT_MAX PCIE_LEGACY_INTD
-+
-+#endif /* IFXMIPS_PCIE_REG_H */
-+
---- /dev/null
-+++ b/arch/mips/pci/ifxmips_pcie_vr9.h
-@@ -0,0 +1,269 @@
-+/****************************************************************************
-+                              Copyright (c) 2010
-+                            Lantiq Deutschland GmbH
-+                     Am Campeon 3; 85579 Neubiberg, Germany
-+
-+  For licensing information, see the file 'LICENSE' in the root folder of
-+  this software module.
-+
-+ *****************************************************************************/
-+/*!
-+  \file ifxmips_pcie_vr9.h
-+  \ingroup IFX_PCIE
-+  \brief PCIe RC driver vr9 specific file
-+*/
-+
-+#ifndef IFXMIPS_PCIE_VR9_H
-+#define IFXMIPS_PCIE_VR9_H
-+
-+#include <linux/types.h>
-+#include <linux/delay.h>
-+
-+#include <linux/gpio.h>
-+#include <lantiq_soc.h>
-+
-+#define IFX_PCIE_GPIO_RESET  494
-+
-+#define IFX_REG_R32    ltq_r32
-+#define IFX_REG_W32    ltq_w32
-+#define CONFIG_IFX_PCIE_HW_SWAP
-+#define IFX_RCU_AHB_ENDIAN                      ((volatile u32*)(IFX_RCU + 0x004C))
-+#define IFX_RCU_RST_REQ                         ((volatile u32*)(IFX_RCU + 0x0010))
-+#define IFX_RCU_AHB_BE_PCIE_PDI                  0x00000080  /* Configure PCIE PDI module in big endian*/
-+
-+#define IFX_RCU                                 (KSEG1 | 0x1F203000)
-+#define IFX_RCU_AHB_BE_PCIE_M                    0x00000001  /* Configure AHB master port that connects to PCIe RC in big endian */
-+#define IFX_RCU_AHB_BE_PCIE_S                    0x00000010  /* Configure AHB slave port that connects to PCIe RC in little endian */
-+#define IFX_RCU_AHB_BE_XBAR_M                    0x00000002  /* Configure AHB master port that connects to XBAR in big endian */
-+#define CONFIG_IFX_PCIE_PHY_36MHZ_MODE
-+
-+#define IFX_PMU1_MODULE_PCIE_PHY   (0)
-+#define IFX_PMU1_MODULE_PCIE_CTRL  (1)
-+#define IFX_PMU1_MODULE_PDI        (4)
-+#define IFX_PMU1_MODULE_MSI        (5)
-+
-+#define IFX_PMU_MODULE_PCIE_L0_CLK (31)
-+
-+
-+#define IFX_GPIO				(KSEG1 | 0x1E100B00)
-+#define ALT0			((volatile u32*)(IFX_GPIO + 0x007c))
-+#define ALT1			((volatile u32*)(IFX_GPIO + 0x0080))
-+#define OD			((volatile u32*)(IFX_GPIO + 0x0084))
-+#define DIR			((volatile u32*)(IFX_GPIO + 0x0078))
-+#define OUT			((volatile u32*)(IFX_GPIO + 0x0070))
-+
-+
-+static inline void pcie_ep_gpio_rst_init(int pcie_port)
-+{
-+
-+	gpio_request(IFX_PCIE_GPIO_RESET, "pcie-reset");
-+	gpio_direction_output(IFX_PCIE_GPIO_RESET, 1);
-+	gpio_set_value(IFX_PCIE_GPIO_RESET, 1);
-+
-+/*    ifx_gpio_pin_reserve(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-+    ifx_gpio_output_set(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-+    ifx_gpio_dir_out_set(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-+    ifx_gpio_altsel0_clear(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-+    ifx_gpio_altsel1_clear(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-+    ifx_gpio_open_drain_set(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);*/
-+}
-+
-+static inline void pcie_ahb_pmu_setup(void) 
-+{
-+	/* Enable AHB bus master/slave */
-+	struct clk *clk;
-+	clk = clk_get_sys("1d900000.pcie", "ahb");
-+	clk_enable(clk);
-+
-+    //AHBM_PMU_SETUP(IFX_PMU_ENABLE);
-+    //AHBS_PMU_SETUP(IFX_PMU_ENABLE);
-+}
-+
-+static inline void pcie_rcu_endian_setup(int pcie_port)
-+{
-+    u32 reg;
-+
-+    reg = IFX_REG_R32(IFX_RCU_AHB_ENDIAN);
-+#ifdef CONFIG_IFX_PCIE_HW_SWAP
-+    reg |= IFX_RCU_AHB_BE_PCIE_M;
-+    reg |= IFX_RCU_AHB_BE_PCIE_S;
-+    reg &= ~IFX_RCU_AHB_BE_XBAR_M;
-+#else 
-+    reg |= IFX_RCU_AHB_BE_PCIE_M;
-+    reg &= ~IFX_RCU_AHB_BE_PCIE_S;
-+    reg &= ~IFX_RCU_AHB_BE_XBAR_M;
-+#endif /* CONFIG_IFX_PCIE_HW_SWAP */
-+    IFX_REG_W32(reg, IFX_RCU_AHB_ENDIAN);
-+    IFX_PCIE_PRINT(PCIE_MSG_REG, "%s IFX_RCU_AHB_ENDIAN: 0x%08x\n", __func__, IFX_REG_R32(IFX_RCU_AHB_ENDIAN));
-+}
-+
-+static inline void pcie_phy_pmu_enable(int pcie_port)
-+{
-+	struct clk *clk;
-+	clk = clk_get_sys("1d900000.pcie", "phy");
-+	clk_enable(clk);
-+
-+	//PCIE_PHY_PMU_SETUP(IFX_PMU_ENABLE);
-+}
-+
-+static inline void pcie_phy_pmu_disable(int pcie_port)
-+{
-+	struct clk *clk;
-+	clk = clk_get_sys("1d900000.pcie", "phy");
-+	clk_disable(clk);
-+
-+//    PCIE_PHY_PMU_SETUP(IFX_PMU_DISABLE);
-+}
-+
-+static inline void pcie_pdi_big_endian(int pcie_port)
-+{
-+    u32 reg;
-+
-+    /* SRAM2PDI endianness control. */
-+    reg = IFX_REG_R32(IFX_RCU_AHB_ENDIAN);
-+    /* Config AHB->PCIe and PDI endianness */
-+    reg |= IFX_RCU_AHB_BE_PCIE_PDI;
-+    IFX_REG_W32(reg, IFX_RCU_AHB_ENDIAN);
-+}
-+
-+static inline void pcie_pdi_pmu_enable(int pcie_port)
-+{
-+    /* Enable PDI to access PCIe PHY register */
-+	struct clk *clk;
-+	clk = clk_get_sys("1d900000.pcie", "pdi");
-+	clk_enable(clk);
-+    //PDI_PMU_SETUP(IFX_PMU_ENABLE);
-+}
-+
-+static inline void pcie_core_rst_assert(int pcie_port)
-+{
-+    u32 reg;
-+
-+    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-+
-+    /* Reset PCIe PHY & Core, bit 22, bit 26 may be affected if write it directly  */
-+    reg |= 0x00400000;
-+    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-+}
-+
-+static inline void pcie_core_rst_deassert(int pcie_port)
-+{
-+    u32 reg;
-+
-+    /* Make sure one micro-second delay */
-+    udelay(1);
-+
-+    /* Reset PCIe PHY & Core, bit 22 */
-+    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-+    reg &= ~0x00400000;
-+    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-+}
-+
-+static inline void pcie_phy_rst_assert(int pcie_port)
-+{
-+    u32 reg;
-+
-+    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-+    reg |= 0x00001000; /* Bit 12 */
-+    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-+}
-+
-+static inline void pcie_phy_rst_deassert(int pcie_port)
-+{
-+    u32 reg;
-+
-+    /* Make sure one micro-second delay */
-+    udelay(1);
-+
-+    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-+    reg &= ~0x00001000; /* Bit 12 */
-+    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-+}
-+
-+static inline void pcie_device_rst_assert(int pcie_port)
-+{
-+	gpio_set_value(IFX_PCIE_GPIO_RESET, 0);
-+//    ifx_gpio_output_clear(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-+}
-+
-+static inline void pcie_device_rst_deassert(int pcie_port)
-+{
-+    mdelay(100);
-+	gpio_direction_output(IFX_PCIE_GPIO_RESET, 1);
-+//    gpio_set_value(IFX_PCIE_GPIO_RESET, 1);
-+    //ifx_gpio_output_set(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-+}
-+
-+static inline void pcie_core_pmu_setup(int pcie_port)
-+{
-+	struct clk *clk;
-+	clk = clk_get_sys("1d900000.pcie", "ctl");
-+	clk_enable(clk);
-+	clk = clk_get_sys("1d900000.pcie", "bus");
-+	clk_enable(clk);
-+
-+    /* PCIe Core controller enabled */
-+//    PCIE_CTRL_PMU_SETUP(IFX_PMU_ENABLE);
-+
-+    /* Enable PCIe L0 Clock */
-+//  PCIE_L0_CLK_PMU_SETUP(IFX_PMU_ENABLE);
-+}
-+
-+static inline void pcie_msi_init(int pcie_port)
-+{
-+	struct clk *clk;
-+	pcie_msi_pic_init(pcie_port);
-+	clk = clk_get_sys("ltq_pcie", "msi");
-+	clk_enable(clk);
-+//    MSI_PMU_SETUP(IFX_PMU_ENABLE);
-+}
-+
-+static inline u32
-+ifx_pcie_bus_nr_deduct(u32 bus_number, int pcie_port)
-+{
-+    u32 tbus_number = bus_number;
-+
-+#ifdef CONFIG_PCI_LANTIQ
-+    if (pcibios_host_nr() > 1) {
-+        tbus_number -= pcibios_1st_host_bus_nr();
-+    }
-+#endif /* CONFIG_PCI_LANTIQ */
-+    return tbus_number;
-+}
-+
-+static inline u32
-+ifx_pcie_bus_enum_hack(struct pci_bus *bus, u32 devfn, int where, u32 value, int pcie_port, int read)
-+{
-+    struct pci_dev *pdev;
-+    u32 tvalue = value;
-+
-+    /* Sanity check */
-+    pdev = pci_get_slot(bus, devfn);
-+    if (pdev == NULL) {
-+        return tvalue;
-+    }
-+
-+    /* Only care about PCI bridge */
-+    if (pdev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {
-+        return tvalue;
-+    }
-+
-+    if (read) { /* Read hack */
-+    #ifdef CONFIG_PCI_LANTIQ
-+        if (pcibios_host_nr() > 1) {
-+            tvalue = ifx_pcie_bus_enum_read_hack(where, tvalue);
-+        }
-+    #endif /* CONFIG_PCI_LANTIQ */
-+    }
-+    else { /* Write hack */
-+    #ifdef CONFIG_PCI_LANTIQ
-+        if (pcibios_host_nr() > 1) {
-+            tvalue = ifx_pcie_bus_enum_write_hack(where, tvalue);
-+        }
-+    #endif
-+    }
-+    return tvalue;
-+}
-+
-+#endif /* IFXMIPS_PCIE_VR9_H */
-+
---- a/arch/mips/pci/pci.c
-+++ b/arch/mips/pci/pci.c
-@@ -251,6 +251,31 @@ static int __init pcibios_init(void)
- 
- subsys_initcall(pcibios_init);
- 
-+int pcibios_host_nr(void)
-+{
-+    int count;
-+    struct pci_controller *hose;
-+    for (count = 0, hose = hose_head; hose; hose = hose->next, count++) {
-+        ;
-+    }
-+    return count;
-+}
-+EXPORT_SYMBOL(pcibios_host_nr);
-+
-+int pcibios_1st_host_bus_nr(void)
-+{
-+    int bus_nr = 0;
-+    struct pci_controller *hose = hose_head;
-+
-+    if (hose != NULL) {
-+        if (hose->bus != NULL) {
-+            bus_nr = hose->bus->number + 1;
-+        }
-+    }
-+    return bus_nr;
-+}
-+EXPORT_SYMBOL(pcibios_1st_host_bus_nr);
-+
- static int pcibios_enable_resources(struct pci_dev *dev, int mask)
- {
- 	u16 cmd, old_cmd;
---- /dev/null
-+++ b/arch/mips/pci/pcie-lantiq.h
-@@ -0,0 +1,1305 @@
-+/******************************************************************************
-+**
-+** FILE NAME    : ifxmips_pcie_reg.h
-+** PROJECT      : IFX UEIP for VRX200
-+** MODULES      : PCIe module
-+**
-+** DATE         : 02 Mar 2009
-+** AUTHOR       : Lei Chuanhua
-+** DESCRIPTION  : PCIe Root Complex Driver
-+** COPYRIGHT    :       Copyright (c) 2009
-+**                      Infineon Technologies AG
-+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-+**
-+**    This program is free software; you can redistribute it and/or modify
-+**    it under the terms of the GNU General Public License as published by
-+**    the Free Software Foundation; either version 2 of the License, or
-+**    (at your option) any later version.
-+** HISTORY
-+** $Version $Date        $Author         $Comment
-+** 0.0.1    17 Mar,2009  Lei Chuanhua    Initial version
-+*******************************************************************************/
-+#ifndef IFXMIPS_PCIE_REG_H
-+#define IFXMIPS_PCIE_REG_H
-+#include <linux/version.h>
-+#include <linux/types.h>
-+#include <linux/pci.h>
-+#include <linux/interrupt.h>
-+/*!
-+ \file ifxmips_pcie_reg.h
-+ \ingroup IFX_PCIE  
-+ \brief header file for PCIe module register definition
-+*/
-+/* PCIe Address Mapping Base */
-+#define PCIE_CFG_PHY_BASE        0x1D000000UL
-+#define PCIE_CFG_BASE           (KSEG1 + PCIE_CFG_PHY_BASE)
-+#define PCIE_CFG_SIZE           (8 * 1024 * 1024)
-+
-+#define PCIE_MEM_PHY_BASE        0x1C000000UL
-+#define PCIE_MEM_BASE           (KSEG1 + PCIE_MEM_PHY_BASE)
-+#define PCIE_MEM_SIZE           (16 * 1024 * 1024)
-+#define PCIE_MEM_PHY_END        (PCIE_MEM_PHY_BASE + PCIE_MEM_SIZE - 1)
-+
-+#define PCIE_IO_PHY_BASE         0x1D800000UL
-+#define PCIE_IO_BASE            (KSEG1 + PCIE_IO_PHY_BASE)
-+#define PCIE_IO_SIZE            (1 * 1024 * 1024)
-+#define PCIE_IO_PHY_END         (PCIE_IO_PHY_BASE + PCIE_IO_SIZE - 1)
-+
-+#define PCIE_RC_CFG_BASE        (KSEG1 + 0x1D900000)
-+#define PCIE_APP_LOGIC_REG      (KSEG1 + 0x1E100900)
-+#define PCIE_MSI_PHY_BASE        0x1F600000UL
-+
-+#define PCIE_PDI_PHY_BASE        0x1F106800UL
-+#define PCIE_PDI_BASE           (KSEG1 + PCIE_PDI_PHY_BASE)
-+#define PCIE_PDI_SIZE            0x400
-+
-+#define PCIE1_CFG_PHY_BASE        0x19000000UL
-+#define PCIE1_CFG_BASE           (KSEG1 + PCIE1_CFG_PHY_BASE)
-+#define PCIE1_CFG_SIZE           (8 * 1024 * 1024)
-+
-+#define PCIE1_MEM_PHY_BASE        0x18000000UL
-+#define PCIE1_MEM_BASE           (KSEG1 + PCIE1_MEM_PHY_BASE)
-+#define PCIE1_MEM_SIZE           (16 * 1024 * 1024)
-+#define PCIE1_MEM_PHY_END        (PCIE1_MEM_PHY_BASE + PCIE1_MEM_SIZE - 1)
-+
-+#define PCIE1_IO_PHY_BASE         0x19800000UL
-+#define PCIE1_IO_BASE            (KSEG1 + PCIE1_IO_PHY_BASE)
-+#define PCIE1_IO_SIZE            (1 * 1024 * 1024)
-+#define PCIE1_IO_PHY_END         (PCIE1_IO_PHY_BASE + PCIE1_IO_SIZE - 1)
-+
-+#define PCIE1_RC_CFG_BASE        (KSEG1 + 0x19900000)
-+#define PCIE1_APP_LOGIC_REG      (KSEG1 + 0x1E100700)
-+#define PCIE1_MSI_PHY_BASE        0x1F400000UL
-+
-+#define PCIE1_PDI_PHY_BASE        0x1F700400UL
-+#define PCIE1_PDI_BASE           (KSEG1 + PCIE1_PDI_PHY_BASE)
-+#define PCIE1_PDI_SIZE            0x400
-+
-+#define PCIE_CFG_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_CFG_BASE) : (PCIE_CFG_BASE))
-+#define PCIE_MEM_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_MEM_BASE) : (PCIE_MEM_BASE))
-+#define PCIE_IO_PORT_TO_BASE(X)      ((X) > 0 ? (PCIE1_IO_BASE) : (PCIE_IO_BASE))
-+#define PCIE_MEM_PHY_PORT_TO_BASE(X) ((X) > 0 ? (PCIE1_MEM_PHY_BASE) : (PCIE_MEM_PHY_BASE))
-+#define PCIE_MEM_PHY_PORT_TO_END(X)  ((X) > 0 ? (PCIE1_MEM_PHY_END) : (PCIE_MEM_PHY_END))
-+#define PCIE_IO_PHY_PORT_TO_BASE(X)  ((X) > 0 ? (PCIE1_IO_PHY_BASE) : (PCIE_IO_PHY_BASE))
-+#define PCIE_IO_PHY_PORT_TO_END(X)   ((X) > 0 ? (PCIE1_IO_PHY_END) : (PCIE_IO_PHY_END))
-+#define PCIE_APP_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_APP_LOGIC_REG) : (PCIE_APP_LOGIC_REG))
-+#define PCIE_RC_PORT_TO_BASE(X)      ((X) > 0 ? (PCIE1_RC_CFG_BASE) : (PCIE_RC_CFG_BASE))
-+#define PCIE_PHY_PORT_TO_BASE(X)     ((X) > 0 ? (PCIE1_PDI_BASE) : (PCIE_PDI_BASE))
-+
-+/* PCIe Application Logic Register */
-+/* RC Core Control Register */
-+#define PCIE_RC_CCR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x10)
-+/* This should be enabled after initializing configuratin registers
-+ * Also should check link status retraining bit
-+ */
-+#define PCIE_RC_CCR_LTSSM_ENABLE             0x00000001    /* Enable LTSSM to continue link establishment */
-+
-+/* RC Core Debug Register */
-+#define PCIE_RC_DR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x14)
-+#define PCIE_RC_DR_DLL_UP                    0x00000001  /* Data Link Layer Up */
-+#define PCIE_RC_DR_CURRENT_POWER_STATE       0x0000000E  /* Current Power State */
-+#define PCIE_RC_DR_CURRENT_POWER_STATE_S     1
-+#define PCIE_RC_DR_CURRENT_LTSSM_STATE       0x000001F0  /* Current LTSSM State */
-+#define PCIE_RC_DR_CURRENT_LTSSM_STATE_S     4
-+
-+#define PCIE_RC_DR_PM_DEV_STATE              0x00000E00  /* Power Management D-State */
-+#define PCIE_RC_DR_PM_DEV_STATE_S            9
-+
-+#define PCIE_RC_DR_PM_ENABLED                0x00001000  /* Power Management State from PMU */
-+#define PCIE_RC_DR_PME_EVENT_ENABLED         0x00002000  /* Power Management Event Enable State */
-+#define PCIE_RC_DR_AUX_POWER_ENABLED         0x00004000  /* Auxiliary Power Enable */
-+
-+/* Current Power State Definition */
-+enum {
-+    PCIE_RC_DR_D0 = 0,
-+    PCIE_RC_DR_D1,   /* Not supported */
-+    PCIE_RC_DR_D2,   /* Not supported */
-+    PCIE_RC_DR_D3,
-+    PCIE_RC_DR_UN,
-+};
-+
-+/* PHY Link Status Register */
-+#define PCIE_PHY_SR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x18)
-+#define PCIE_PHY_SR_PHY_LINK_UP              0x00000001   /* PHY Link Up/Down Indicator */
-+
-+/* Electromechanical Control Register */
-+#define PCIE_EM_CR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x1C)
-+#define PCIE_EM_CR_CARD_IS_PRESENT           0x00000001  /* Card Presence Detect State */
-+#define PCIE_EM_CR_MRL_OPEN                  0x00000002  /* MRL Sensor State */
-+#define PCIE_EM_CR_POWER_FAULT_SET           0x00000004  /* Power Fault Detected */
-+#define PCIE_EM_CR_MRL_SENSOR_SET            0x00000008  /* MRL Sensor Changed */
-+#define PCIE_EM_CR_PRESENT_DETECT_SET        0x00000010  /* Card Presense Detect Changed */
-+#define PCIE_EM_CR_CMD_CPL_INT_SET           0x00000020  /* Command Complete Interrupt */
-+#define PCIE_EM_CR_SYS_INTERLOCK_SET         0x00000040  /* System Electromechanical IterLock Engaged */
-+#define PCIE_EM_CR_ATTENTION_BUTTON_SET      0x00000080  /* Attention Button Pressed */
-+
-+/* Interrupt Status Register */
-+#define PCIE_IR_SR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x20)
-+#define PCIE_IR_SR_PME_CAUSE_MSI             0x00000002  /* MSI caused by PME */
-+#define PCIE_IR_SR_HP_PME_WAKE_GEN           0x00000004  /* Hotplug PME Wake Generation */
-+#define PCIE_IR_SR_HP_MSI                    0x00000008  /* Hotplug MSI */
-+#define PCIE_IR_SR_AHB_LU_ERR                0x00000030  /* AHB Bridge Lookup Error Signals */
-+#define PCIE_IR_SR_AHB_LU_ERR_S              4
-+#define PCIE_IR_SR_INT_MSG_NUM               0x00003E00  /* Interrupt Message Number */
-+#define PCIE_IR_SR_INT_MSG_NUM_S             9
-+#define PCIE_IR_SR_AER_INT_MSG_NUM           0xF8000000  /* Advanced Error Interrupt Message Number */
-+#define PCIE_IR_SR_AER_INT_MSG_NUM_S         27
-+
-+/* Message Control Register */
-+#define PCIE_MSG_CR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x30)
-+#define PCIE_MSG_CR_GEN_PME_TURN_OFF_MSG     0x00000001  /* Generate PME Turn Off Message */
-+#define PCIE_MSG_CR_GEN_UNLOCK_MSG           0x00000002  /* Generate Unlock Message */
-+
-+#define PCIE_VDM_DR(X)                      (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x34)
-+
-+/* Vendor-Defined Message Requester ID Register */
-+#define PCIE_VDM_RID(X)                     (PCIE_APP_PORT_TO_BASE (X) + 0x38)
-+#define PCIE_VDM_RID_VENROR_MSG_REQ_ID       0x0000FFFF
-+#define PCIE_VDM_RID_VDMRID_S                0
-+
-+/* ASPM Control Register */
-+#define PCIE_ASPM_CR(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x40)
-+#define PCIE_ASPM_CR_HOT_RST                 0x00000001  /* Hot Reset Request to the downstream device */
-+#define PCIE_ASPM_CR_REQ_EXIT_L1             0x00000002  /* Request to Exit L1 */
-+#define PCIE_ASPM_CR_REQ_ENTER_L1            0x00000004  /* Request to Enter L1 */
-+
-+/* Vendor Message DW0 Register */
-+#define PCIE_VM_MSG_DW0(X)                  (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x50)
-+#define PCIE_VM_MSG_DW0_TYPE                 0x0000001F  /* Message type */
-+#define PCIE_VM_MSG_DW0_TYPE_S               0
-+#define PCIE_VM_MSG_DW0_FORMAT               0x00000060  /* Format */
-+#define PCIE_VM_MSG_DW0_FORMAT_S             5
-+#define PCIE_VM_MSG_DW0_TC                   0x00007000  /* Traffic Class */
-+#define PCIE_VM_MSG_DW0_TC_S                 12
-+#define PCIE_VM_MSG_DW0_ATTR                 0x000C0000  /* Atrributes */
-+#define PCIE_VM_MSG_DW0_ATTR_S               18
-+#define PCIE_VM_MSG_DW0_EP_TLP               0x00100000  /* Poisoned TLP */
-+#define PCIE_VM_MSG_DW0_TD                   0x00200000  /* TLP Digest */
-+#define PCIE_VM_MSG_DW0_LEN                  0xFFC00000  /* Length */
-+#define PCIE_VM_MSG_DW0_LEN_S                22
-+
-+/* Format Definition */
-+enum {
-+    PCIE_VM_MSG_FORMAT_00 = 0,  /* 3DW Hdr, no data*/
-+    PCIE_VM_MSG_FORMAT_01,      /* 4DW Hdr, no data */
-+    PCIE_VM_MSG_FORMAT_10,      /* 3DW Hdr, with data */
-+    PCIE_VM_MSG_FORMAT_11,      /* 4DW Hdr, with data */
-+};
-+
-+/* Traffic Class Definition */
-+enum {
-+    PCIE_VM_MSG_TC0 = 0,
-+    PCIE_VM_MSG_TC1,
-+    PCIE_VM_MSG_TC2,
-+    PCIE_VM_MSG_TC3,
-+    PCIE_VM_MSG_TC4,
-+    PCIE_VM_MSG_TC5,
-+    PCIE_VM_MSG_TC6,
-+    PCIE_VM_MSG_TC7,
-+};
-+
-+/* Attributes Definition */
-+enum {
-+    PCIE_VM_MSG_ATTR_00 = 0,   /* RO and No Snoop cleared */
-+    PCIE_VM_MSG_ATTR_01,       /* RO cleared , No Snoop set */
-+    PCIE_VM_MSG_ATTR_10,       /* RO set, No Snoop cleared*/
-+    PCIE_VM_MSG_ATTR_11,       /* RO and No Snoop set */
-+};
-+
-+/* Payload Size Definition */
-+#define PCIE_VM_MSG_LEN_MIN  0
-+#define PCIE_VM_MSG_LEN_MAX  1024
-+
-+/* Vendor Message DW1 Register */
-+#define PCIE_VM_MSG_DW1(X)                 (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x54)
-+#define PCIE_VM_MSG_DW1_FUNC_NUM            0x00000070  /* Function Number */
-+#define PCIE_VM_MSG_DW1_FUNC_NUM_S          8
-+#define PCIE_VM_MSG_DW1_CODE                0x00FF0000  /* Message Code */
-+#define PCIE_VM_MSG_DW1_CODE_S              16
-+#define PCIE_VM_MSG_DW1_TAG                 0xFF000000  /* Tag */
-+#define PCIE_VM_MSG_DW1_TAG_S               24
-+
-+#define PCIE_VM_MSG_DW2(X)                  (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x58)
-+#define PCIE_VM_MSG_DW3(X)                  (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x5C)
-+
-+/* Vendor Message Request Register */
-+#define PCIE_VM_MSG_REQR(X)                 (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x60)
-+#define PCIE_VM_MSG_REQR_REQ                 0x00000001  /* Vendor Message Request */
-+
-+
-+/* AHB Slave Side Band Control Register */
-+#define PCIE_AHB_SSB(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x70)
-+#define PCIE_AHB_SSB_REQ_BCM                0x00000001 /* Slave Reques BCM filed */
-+#define PCIE_AHB_SSB_REQ_EP                 0x00000002 /* Slave Reques EP filed */
-+#define PCIE_AHB_SSB_REQ_TD                 0x00000004 /* Slave Reques TD filed */
-+#define PCIE_AHB_SSB_REQ_ATTR               0x00000018 /* Slave Reques Attribute number */
-+#define PCIE_AHB_SSB_REQ_ATTR_S             3
-+#define PCIE_AHB_SSB_REQ_TC                 0x000000E0 /* Slave Request TC Field */
-+#define PCIE_AHB_SSB_REQ_TC_S               5
-+
-+/* AHB Master SideBand Ctrl Register */
-+#define PCIE_AHB_MSB(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x74)
-+#define PCIE_AHB_MSB_RESP_ATTR               0x00000003 /* Master Response Attribute number */
-+#define PCIE_AHB_MSB_RESP_ATTR_S             0
-+#define PCIE_AHB_MSB_RESP_BAD_EOT            0x00000004 /* Master Response Badeot filed */
-+#define PCIE_AHB_MSB_RESP_BCM                0x00000008 /* Master Response BCM filed */
-+#define PCIE_AHB_MSB_RESP_EP                 0x00000010 /* Master Response EP filed */
-+#define PCIE_AHB_MSB_RESP_TD                 0x00000020 /* Master Response TD filed */
-+#define PCIE_AHB_MSB_RESP_FUN_NUM            0x000003C0 /* Master Response Function number */
-+#define PCIE_AHB_MSB_RESP_FUN_NUM_S          6
-+
-+/* AHB Control Register, fixed bus enumeration exception */
-+#define PCIE_AHB_CTRL(X)                     (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0x78)
-+#define PCIE_AHB_CTRL_BUS_ERROR_SUPPRESS     0x00000001 
-+
-+/* Interrupt Enalbe Register */
-+#define PCIE_IRNEN(X)                        (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0xF4)
-+#define PCIE_IRNCR(X)                        (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0xF8)
-+#define PCIE_IRNICR(X)                       (volatile u32*)(PCIE_APP_PORT_TO_BASE(X) + 0xFC)
-+
-+/* PCIe interrupt enable/control/capture register definition */
-+#define PCIE_IRN_AER_REPORT                 0x00000001  /* AER Interrupt */
-+#define PCIE_IRN_AER_MSIX                   0x00000002  /* Advanced Error MSI-X Interrupt */
-+#define PCIE_IRN_PME                        0x00000004  /* PME Interrupt */
-+#define PCIE_IRN_HOTPLUG                    0x00000008  /* Hotplug Interrupt */
-+#define PCIE_IRN_RX_VDM_MSG                 0x00000010  /* Vendor-Defined Message Interrupt */
-+#define PCIE_IRN_RX_CORRECTABLE_ERR_MSG     0x00000020  /* Correctable Error Message Interrupt */
-+#define PCIE_IRN_RX_NON_FATAL_ERR_MSG       0x00000040  /* Non-fatal Error Message */
-+#define PCIE_IRN_RX_FATAL_ERR_MSG           0x00000080  /* Fatal Error Message */
-+#define PCIE_IRN_RX_PME_MSG                 0x00000100  /* PME Message Interrupt */
-+#define PCIE_IRN_RX_PME_TURNOFF_ACK         0x00000200  /* PME Turnoff Ack Message Interrupt */
-+#define PCIE_IRN_AHB_BR_FATAL_ERR           0x00000400  /* AHB Fatal Error Interrupt */
-+#define PCIE_IRN_LINK_AUTO_BW_STATUS        0x00000800  /* Link Auto Bandwidth Status Interrupt */
-+#define PCIE_IRN_BW_MGT                     0x00001000  /* Bandwidth Managment Interrupt */
-+#define PCIE_IRN_INTA                       0x00002000  /* INTA */
-+#define PCIE_IRN_INTB                       0x00004000  /* INTB */
-+#define PCIE_IRN_INTC                       0x00008000  /* INTC */
-+#define PCIE_IRN_INTD                       0x00010000  /* INTD */
-+#define PCIE_IRN_WAKEUP                     0x00020000  /* Wake up Interrupt */
-+
-+#define PCIE_RC_CORE_COMBINED_INT    (PCIE_IRN_AER_REPORT |  PCIE_IRN_AER_MSIX | PCIE_IRN_PME | \
-+                                      PCIE_IRN_HOTPLUG | PCIE_IRN_RX_VDM_MSG | PCIE_IRN_RX_CORRECTABLE_ERR_MSG |\
-+                                      PCIE_IRN_RX_NON_FATAL_ERR_MSG | PCIE_IRN_RX_FATAL_ERR_MSG | \
-+                                      PCIE_IRN_RX_PME_MSG | PCIE_IRN_RX_PME_TURNOFF_ACK | PCIE_IRN_AHB_BR_FATAL_ERR | \
-+                                      PCIE_IRN_LINK_AUTO_BW_STATUS | PCIE_IRN_BW_MGT)
-+/* PCIe RC Configuration Register */
-+#define PCIE_VDID(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x00)
-+
-+/* Bit definition from pci_reg.h */
-+#define PCIE_PCICMDSTS(X)           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x04)
-+#define PCIE_CCRID(X)               (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x08)
-+#define PCIE_CLSLTHTBR(X)           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x0C) /* EP only */
-+/* BAR0, BAR1,Only necessary if the bridges implements a device-specific register set or memory buffer */
-+#define PCIE_BAR0(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x10) /* Not used*/
-+#define PCIE_BAR1(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x14) /* Not used */
-+
-+#define PCIE_BNR(X)                 (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x18) /* Mandatory */
-+/* Bus Number Register bits */
-+#define PCIE_BNR_PRIMARY_BUS_NUM             0x000000FF
-+#define PCIE_BNR_PRIMARY_BUS_NUM_S           0
-+#define PCIE_PNR_SECONDARY_BUS_NUM           0x0000FF00
-+#define PCIE_PNR_SECONDARY_BUS_NUM_S         8
-+#define PCIE_PNR_SUB_BUS_NUM                 0x00FF0000
-+#define PCIE_PNR_SUB_BUS_NUM_S               16
-+
-+/* IO Base/Limit Register bits */
-+#define PCIE_IOBLSECS(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x1C)  /* RC only */
-+#define PCIE_IOBLSECS_32BIT_IO_ADDR             0x00000001
-+#define PCIE_IOBLSECS_IO_BASE_ADDR              0x000000F0
-+#define PCIE_IOBLSECS_IO_BASE_ADDR_S            4
-+#define PCIE_IOBLSECS_32BIT_IOLIMT              0x00000100
-+#define PCIE_IOBLSECS_IO_LIMIT_ADDR             0x0000F000
-+#define PCIE_IOBLSECS_IO_LIMIT_ADDR_S           12
-+
-+/* Non-prefetchable Memory Base/Limit Register bit */
-+#define PCIE_MBML(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x20)  /* RC only */
-+#define PCIE_MBML_MEM_BASE_ADDR                 0x0000FFF0
-+#define PCIE_MBML_MEM_BASE_ADDR_S               4
-+#define PCIE_MBML_MEM_LIMIT_ADDR                0xFFF00000
-+#define PCIE_MBML_MEM_LIMIT_ADDR_S              20
-+
-+/* Prefetchable Memory Base/Limit Register bit */
-+#define PCIE_PMBL(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x24)  /* RC only */
-+#define PCIE_PMBL_64BIT_ADDR                    0x00000001
-+#define PCIE_PMBL_UPPER_12BIT                   0x0000FFF0
-+#define PCIE_PMBL_UPPER_12BIT_S                 4
-+#define PCIE_PMBL_E64MA                         0x00010000
-+#define PCIE_PMBL_END_ADDR                      0xFFF00000
-+#define PCIE_PMBL_END_ADDR_S                    20
-+#define PCIE_PMBU32(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x28)  /* RC only */
-+#define PCIE_PMLU32(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x2C)  /* RC only */
-+
-+/* I/O Base/Limit Upper 16 bits register */
-+#define PCIE_IO_BANDL(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x30)  /* RC only */
-+#define PCIE_IO_BANDL_UPPER_16BIT_IO_BASE        0x0000FFFF
-+#define PCIE_IO_BANDL_UPPER_16BIT_IO_BASE_S      0
-+#define PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT       0xFFFF0000
-+#define PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT_S     16
-+
-+#define PCIE_CPR(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x34)
-+#define PCIE_EBBAR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x38)
-+
-+/* Interrupt and Secondary Bridge Control Register */
-+#define PCIE_INTRBCTRL(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x3C)
-+
-+#define PCIE_INTRBCTRL_INT_LINE                 0x000000FF
-+#define PCIE_INTRBCTRL_INT_LINE_S               0
-+#define PCIE_INTRBCTRL_INT_PIN                  0x0000FF00
-+#define PCIE_INTRBCTRL_INT_PIN_S                8
-+#define PCIE_INTRBCTRL_PARITY_ERR_RESP_ENABLE   0x00010000    /* #PERR */
-+#define PCIE_INTRBCTRL_SERR_ENABLE              0x00020000    /* #SERR */
-+#define PCIE_INTRBCTRL_ISA_ENABLE               0x00040000    /* ISA enable, IO 64KB only */
-+#define PCIE_INTRBCTRL_VGA_ENABLE               0x00080000    /* VGA enable */
-+#define PCIE_INTRBCTRL_VGA_16BIT_DECODE         0x00100000    /* VGA 16bit decode */
-+#define PCIE_INTRBCTRL_RST_SECONDARY_BUS        0x00400000    /* Secondary bus rest, hot rest, 1ms */
-+/* Others are read only */
-+enum {
-+    PCIE_INTRBCTRL_INT_NON = 0,
-+    PCIE_INTRBCTRL_INTA,
-+    PCIE_INTRBCTRL_INTB,
-+    PCIE_INTRBCTRL_INTC,
-+    PCIE_INTRBCTRL_INTD,
-+};
-+
-+#define PCIE_PM_CAPR(X)                  (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x40)
-+
-+/* Power Management Control and Status Register */
-+#define PCIE_PM_CSR(X)                   (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x44)
-+
-+#define PCIE_PM_CSR_POWER_STATE           0x00000003   /* Power State */
-+#define PCIE_PM_CSR_POWER_STATE_S         0
-+#define PCIE_PM_CSR_SW_RST                0x00000008   /* Soft Reset Enabled */
-+#define PCIE_PM_CSR_PME_ENABLE            0x00000100   /* PME Enable */
-+#define PCIE_PM_CSR_PME_STATUS            0x00008000   /* PME status */
-+
-+/* MSI Capability Register for EP */
-+#define PCIE_MCAPR(X)                    (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x50)
-+
-+#define PCIE_MCAPR_MSI_CAP_ID             0x000000FF  /* MSI Capability ID */
-+#define PCIE_MCAPR_MSI_CAP_ID_S           0
-+#define PCIE_MCAPR_MSI_NEXT_CAP_PTR       0x0000FF00  /* Next Capability Pointer */
-+#define PCIE_MCAPR_MSI_NEXT_CAP_PTR_S     8
-+#define PCIE_MCAPR_MSI_ENABLE             0x00010000  /* MSI Enable */
-+#define PCIE_MCAPR_MULTI_MSG_CAP          0x000E0000  /* Multiple Message Capable */
-+#define PCIE_MCAPR_MULTI_MSG_CAP_S        17
-+#define PCIE_MCAPR_MULTI_MSG_ENABLE       0x00700000  /* Multiple Message Enable */
-+#define PCIE_MCAPR_MULTI_MSG_ENABLE_S     20
-+#define PCIE_MCAPR_ADDR64_CAP             0X00800000  /* 64-bit Address Capable */
-+
-+/* MSI Message Address Register */
-+#define PCIE_MA(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x54)
-+
-+#define PCIE_MA_ADDR_MASK                 0xFFFFFFFC  /* Message Address */
-+
-+/* MSI Message Upper Address Register */
-+#define PCIE_MUA(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x58)
-+
-+/* MSI Message Data Register */
-+#define PCIE_MD(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x5C)
-+
-+#define PCIE_MD_DATA                      0x0000FFFF  /* Message Data */
-+#define PCIE_MD_DATA_S                    0
-+
-+/* PCI Express Capability Register */
-+#define PCIE_XCAP(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x70)
-+
-+#define PCIE_XCAP_ID                      0x000000FF  /* PCI Express Capability ID */
-+#define PCIE_XCAP_ID_S                    0
-+#define PCIE_XCAP_NEXT_CAP                0x0000FF00  /* Next Capability Pointer */
-+#define PCIE_XCAP_NEXT_CAP_S              8
-+#define PCIE_XCAP_VER                     0x000F0000  /* PCI Express Capability Version */
-+#define PCIE_XCAP_VER_S                   16
-+#define PCIE_XCAP_DEV_PORT_TYPE           0x00F00000  /* Device Port Type */
-+#define PCIE_XCAP_DEV_PORT_TYPE_S         20
-+#define PCIE_XCAP_SLOT_IMPLEMENTED        0x01000000  /* Slot Implemented */
-+#define PCIE_XCAP_MSG_INT_NUM             0x3E000000  /* Interrupt Message Number */
-+#define PCIE_XCAP_MSG_INT_NUM_S           25
-+
-+/* Device Capability Register */
-+#define PCIE_DCAP(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x74)
-+
-+#define PCIE_DCAP_MAX_PAYLOAD_SIZE        0x00000007   /* Max Payload size */
-+#define PCIE_DCAP_MAX_PAYLOAD_SIZE_S      0
-+#define PCIE_DCAP_PHANTOM_FUNC            0x00000018   /* Phanton Function, not supported */
-+#define PCIE_DCAP_PHANTOM_FUNC_S          3
-+#define PCIE_DCAP_EXT_TAG                 0x00000020   /* Extended Tag Field */
-+#define PCIE_DCAP_EP_L0S_LATENCY          0x000001C0   /* EP L0s latency only */
-+#define PCIE_DCAP_EP_L0S_LATENCY_S        6
-+#define PCIE_DCAP_EP_L1_LATENCY           0x00000E00   /* EP L1 latency only */
-+#define PCIE_DCAP_EP_L1_LATENCY_S         9
-+#define PCIE_DCAP_ROLE_BASE_ERR_REPORT    0x00008000   /* Role Based ERR */
-+
-+/* Maximum payload size supported */
-+enum {
-+    PCIE_MAX_PAYLOAD_128 = 0,
-+    PCIE_MAX_PAYLOAD_256,
-+    PCIE_MAX_PAYLOAD_512,
-+    PCIE_MAX_PAYLOAD_1024,
-+    PCIE_MAX_PAYLOAD_2048,
-+    PCIE_MAX_PAYLOAD_4096,
-+};
-+
-+/* Device Control and Status Register */
-+#define PCIE_DCTLSTS(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x78)
-+
-+#define PCIE_DCTLSTS_CORRECTABLE_ERR_EN        0x00000001   /* COR-ERR */
-+#define PCIE_DCTLSTS_NONFATAL_ERR_EN           0x00000002   /* Non-fatal ERR */
-+#define PCIE_DCTLSTS_FATAL_ERR_EN              0x00000004   /* Fatal ERR */
-+#define PCIE_DCTLSYS_UR_REQ_EN                 0x00000008   /* UR ERR */
-+#define PCIE_DCTLSTS_RELAXED_ORDERING_EN       0x00000010   /* Enable relaxing ordering */
-+#define PCIE_DCTLSTS_MAX_PAYLOAD_SIZE          0x000000E0   /* Max payload mask */
-+#define PCIE_DCTLSTS_MAX_PAYLOAD_SIZE_S        5
-+#define PCIE_DCTLSTS_EXT_TAG_EN                0x00000100   /* Extended tag field */
-+#define PCIE_DCTLSTS_PHANTOM_FUNC_EN           0x00000200   /* Phantom Function Enable */
-+#define PCIE_DCTLSTS_AUX_PM_EN                 0x00000400   /* AUX Power PM Enable */
-+#define PCIE_DCTLSTS_NO_SNOOP_EN               0x00000800   /* Enable no snoop, except root port*/
-+#define PCIE_DCTLSTS_MAX_READ_SIZE             0x00007000   /* Max Read Request size*/
-+#define PCIE_DCTLSTS_MAX_READ_SIZE_S           12
-+#define PCIE_DCTLSTS_CORRECTABLE_ERR           0x00010000   /* COR-ERR Detected */
-+#define PCIE_DCTLSTS_NONFATAL_ERR              0x00020000   /* Non-Fatal ERR Detected */
-+#define PCIE_DCTLSTS_FATAL_ER                  0x00040000   /* Fatal ERR Detected */
-+#define PCIE_DCTLSTS_UNSUPPORTED_REQ           0x00080000   /* UR Detected */
-+#define PCIE_DCTLSTS_AUX_POWER                 0x00100000   /* Aux Power Detected */
-+#define PCIE_DCTLSTS_TRANSACT_PENDING          0x00200000   /* Transaction pending */
-+
-+#define PCIE_DCTLSTS_ERR_EN      (PCIE_DCTLSTS_CORRECTABLE_ERR_EN | \
-+                                  PCIE_DCTLSTS_NONFATAL_ERR_EN | PCIE_DCTLSTS_FATAL_ERR_EN | \
-+                                  PCIE_DCTLSYS_UR_REQ_EN)
-+
-+/* Link Capability Register */
-+#define PCIE_LCAP(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7C)
-+#define PCIE_LCAP_MAX_LINK_SPEED               0x0000000F  /* Max link speed, 0x1 by default */
-+#define PCIE_LCAP_MAX_LINK_SPEED_S             0
-+#define PCIE_LCAP_MAX_LENGTH_WIDTH             0x000003F0  /* Maxium Length Width */
-+#define PCIE_LCAP_MAX_LENGTH_WIDTH_S           4
-+#define PCIE_LCAP_ASPM_LEVEL                   0x00000C00  /* Active State Link PM Support */
-+#define PCIE_LCAP_ASPM_LEVEL_S                 10
-+#define PCIE_LCAP_L0S_EIXT_LATENCY             0x00007000  /* L0s Exit Latency */
-+#define PCIE_LCAP_L0S_EIXT_LATENCY_S           12
-+#define PCIE_LCAP_L1_EXIT_LATENCY              0x00038000  /* L1 Exit Latency */
-+#define PCIE_LCAP_L1_EXIT_LATENCY_S            15
-+#define PCIE_LCAP_CLK_PM                       0x00040000  /* Clock Power Management */
-+#define PCIE_LCAP_SDER                         0x00080000  /* Surprise Down Error Reporting */
-+#define PCIE_LCAP_DLL_ACTIVE_REPROT            0x00100000  /* Data Link Layer Active Reporting Capable */
-+#define PCIE_LCAP_PORT_NUM                     0xFF0000000  /* Port number */
-+#define PCIE_LCAP_PORT_NUM_S                   24
-+
-+/* Maximum Length width definition */
-+#define PCIE_MAX_LENGTH_WIDTH_RES  0x00
-+#define PCIE_MAX_LENGTH_WIDTH_X1   0x01  /* Default */
-+#define PCIE_MAX_LENGTH_WIDTH_X2   0x02
-+#define PCIE_MAX_LENGTH_WIDTH_X4   0x04
-+#define PCIE_MAX_LENGTH_WIDTH_X8   0x08
-+#define PCIE_MAX_LENGTH_WIDTH_X12  0x0C
-+#define PCIE_MAX_LENGTH_WIDTH_X16  0x10
-+#define PCIE_MAX_LENGTH_WIDTH_X32  0x20
-+
-+/* Active State Link PM definition */
-+enum {
-+    PCIE_ASPM_RES0                = 0,
-+    PCIE_ASPM_L0S_ENTRY_SUPPORT,        /* L0s */
-+    PCIE_ASPM_RES1,
-+    PCIE_ASPM_L0S_L1_ENTRY_SUPPORT,     /* L0s and L1, default */
-+};
-+
-+/* L0s Exit Latency definition */
-+enum {
-+    PCIE_L0S_EIXT_LATENCY_L64NS    = 0, /* < 64 ns */
-+    PCIE_L0S_EIXT_LATENCY_B64A128,      /* > 64 ns < 128 ns */
-+    PCIE_L0S_EIXT_LATENCY_B128A256,     /* > 128 ns < 256 ns */
-+    PCIE_L0S_EIXT_LATENCY_B256A512,     /* > 256 ns < 512 ns */
-+    PCIE_L0S_EIXT_LATENCY_B512TO1U,     /* > 512 ns < 1 us */
-+    PCIE_L0S_EIXT_LATENCY_B1A2U,        /* > 1 us < 2 us */
-+    PCIE_L0S_EIXT_LATENCY_B2A4U,        /* > 2 us < 4 us */
-+    PCIE_L0S_EIXT_LATENCY_M4US,         /* > 4 us  */
-+};
-+
-+/* L1 Exit Latency definition */
-+enum {
-+    PCIE_L1_EXIT_LATENCY_L1US  = 0,  /* < 1 us */
-+    PCIE_L1_EXIT_LATENCY_B1A2,       /* > 1 us < 2 us */
-+    PCIE_L1_EXIT_LATENCY_B2A4,       /* > 2 us < 4 us */
-+    PCIE_L1_EXIT_LATENCY_B4A8,       /* > 4 us < 8 us */
-+    PCIE_L1_EXIT_LATENCY_B8A16,      /* > 8 us < 16 us */
-+    PCIE_L1_EXIT_LATENCY_B16A32,     /* > 16 us < 32 us */
-+    PCIE_L1_EXIT_LATENCY_B32A64,     /* > 32 us < 64 us */
-+    PCIE_L1_EXIT_LATENCY_M64US,      /* > 64 us */
-+};
-+
-+/* Link Control and Status Register */
-+#define PCIE_LCTLSTS(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x80)
-+#define PCIE_LCTLSTS_ASPM_ENABLE            0x00000003  /* Active State Link PM Control */
-+#define PCIE_LCTLSTS_ASPM_ENABLE_S          0
-+#define PCIE_LCTLSTS_RCB128                 0x00000008  /* Read Completion Boundary 128*/
-+#define PCIE_LCTLSTS_LINK_DISABLE           0x00000010  /* Link Disable */
-+#define PCIE_LCTLSTS_RETRIAN_LINK           0x00000020  /* Retrain Link */
-+#define PCIE_LCTLSTS_COM_CLK_CFG            0x00000040  /* Common Clock Configuration */
-+#define PCIE_LCTLSTS_EXT_SYNC               0x00000080  /* Extended Synch */
-+#define PCIE_LCTLSTS_CLK_PM_EN              0x00000100  /* Enable Clock Powerm Management */
-+#define PCIE_LCTLSTS_LINK_SPEED             0x000F0000  /* Link Speed */
-+#define PCIE_LCTLSTS_LINK_SPEED_S           16
-+#define PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH  0x03F00000  /* Negotiated Link Width */
-+#define PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH_S 20
-+#define PCIE_LCTLSTS_RETRAIN_PENDING        0x08000000  /* Link training is ongoing */
-+#define PCIE_LCTLSTS_SLOT_CLK_CFG           0x10000000  /* Slot Clock Configuration */
-+#define PCIE_LCTLSTS_DLL_ACTIVE             0x20000000  /* Data Link Layer Active */
-+
-+/* Slot Capabilities Register */
-+#define PCIE_SLCAP(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x84)
-+
-+/* Slot Capabilities */
-+#define PCIE_SLCTLSTS(X)                    (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x88)
-+
-+/* Root Control and Capability Register */
-+#define PCIE_RCTLCAP(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x8C)
-+#define PCIE_RCTLCAP_SERR_ON_CORRECTABLE_ERR  0x00000001   /* #SERR on COR-ERR */
-+#define PCIE_RCTLCAP_SERR_ON_NONFATAL_ERR     0x00000002   /* #SERR on Non-Fatal ERR */
-+#define PCIE_RCTLCAP_SERR_ON_FATAL_ERR        0x00000004   /* #SERR on Fatal ERR */
-+#define PCIE_RCTLCAP_PME_INT_EN               0x00000008   /* PME Interrupt Enable */
-+#define PCIE_RCTLCAP_SERR_ENABLE    (PCIE_RCTLCAP_SERR_ON_CORRECTABLE_ERR | \
-+                                     PCIE_RCTLCAP_SERR_ON_NONFATAL_ERR | PCIE_RCTLCAP_SERR_ON_FATAL_ERR)
-+/* Root Status Register */
-+#define PCIE_RSTS(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x90)
-+#define PCIE_RSTS_PME_REQ_ID                   0x0000FFFF   /* PME Request ID */
-+#define PCIE_RSTS_PME_REQ_ID_S                 0
-+#define PCIE_RSTS_PME_STATUS                   0x00010000   /* PME Status */
-+#define PCIE_RSTS_PME_PENDING                  0x00020000   /* PME Pending */
-+
-+/* PCI Express Enhanced Capability Header */
-+#define PCIE_ENHANCED_CAP(X)                (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x100)
-+#define PCIE_ENHANCED_CAP_ID                 0x0000FFFF  /* PCI Express Extended Capability ID */
-+#define PCIE_ENHANCED_CAP_ID_S               0
-+#define PCIE_ENHANCED_CAP_VER                0x000F0000  /* Capability Version */
-+#define PCIE_ENHANCED_CAP_VER_S              16
-+#define PCIE_ENHANCED_CAP_NEXT_OFFSET        0xFFF00000  /* Next Capability Offset */
-+#define PCIE_ENHANCED_CAP_NEXT_OFFSET_S      20
-+
-+/* Uncorrectable Error Status Register */
-+#define PCIE_UES_R(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x104)
-+#define PCIE_DATA_LINK_PROTOCOL_ERR          0x00000010  /* Data Link Protocol Error Status */
-+#define PCIE_SURPRISE_DOWN_ERROR             0x00000020  /* Surprise Down Error Status */
-+#define PCIE_POISONED_TLP                    0x00001000  /* Poisoned TLP Status */
-+#define PCIE_FC_PROTOCOL_ERR                 0x00002000  /* Flow Control Protocol Error Status */
-+#define PCIE_COMPLETION_TIMEOUT              0x00004000  /* Completion Timeout Status */
-+#define PCIE_COMPLETOR_ABORT                 0x00008000  /* Completer Abort Error */
-+#define PCIE_UNEXPECTED_COMPLETION           0x00010000  /* Unexpected Completion Status */
-+#define PCIE_RECEIVER_OVERFLOW               0x00020000  /* Receive Overflow Status */
-+#define PCIE_MALFORNED_TLP                   0x00040000  /* Malformed TLP Stauts */
-+#define PCIE_ECRC_ERR                        0x00080000  /* ECRC Error Stauts */
-+#define PCIE_UR_REQ                          0x00100000  /* Unsupported Request Error Status */
-+#define PCIE_ALL_UNCORRECTABLE_ERR    (PCIE_DATA_LINK_PROTOCOL_ERR | PCIE_SURPRISE_DOWN_ERROR | \
-+                         PCIE_POISONED_TLP | PCIE_FC_PROTOCOL_ERR | PCIE_COMPLETION_TIMEOUT |   \
-+                         PCIE_COMPLETOR_ABORT | PCIE_UNEXPECTED_COMPLETION | PCIE_RECEIVER_OVERFLOW |\
-+                         PCIE_MALFORNED_TLP | PCIE_ECRC_ERR | PCIE_UR_REQ)
-+
-+/* Uncorrectable Error Mask Register, Mask means no report */
-+#define PCIE_UEMR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x108)
-+
-+/* Uncorrectable Error Severity Register */
-+#define PCIE_UESR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x10C)
-+
-+/* Correctable Error Status Register */
-+#define PCIE_CESR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x110)
-+#define PCIE_RX_ERR                          0x00000001  /* Receive Error Status */
-+#define PCIE_BAD_TLP                         0x00000040  /* Bad TLP Status */
-+#define PCIE_BAD_DLLP                        0x00000080  /* Bad DLLP Status */
-+#define PCIE_REPLAY_NUM_ROLLOVER             0x00000100  /* Replay Number Rollover Status */
-+#define PCIE_REPLAY_TIMER_TIMEOUT_ERR        0x00001000  /* Reply Timer Timeout Status */
-+#define PCIE_ADVISORY_NONFTAL_ERR            0x00002000  /* Advisory Non-Fatal Error Status */
-+#define PCIE_CORRECTABLE_ERR        (PCIE_RX_ERR | PCIE_BAD_TLP | PCIE_BAD_DLLP | PCIE_REPLAY_NUM_ROLLOVER |\
-+                                     PCIE_REPLAY_TIMER_TIMEOUT_ERR | PCIE_ADVISORY_NONFTAL_ERR)
-+
-+/* Correctable Error Mask Register */
-+#define PCIE_CEMR(X)                        (volatile u32*)(PCIE_RC_CFG_BASE + 0x114)
-+
-+/* Advanced Error Capabilities and Control Register */
-+#define PCIE_AECCR(X)                       (volatile u32*)(PCIE_RC_CFG_BASE + 0x118)
-+#define PCIE_AECCR_FIRST_ERR_PTR            0x0000001F  /* First Error Pointer */
-+#define PCIE_AECCR_FIRST_ERR_PTR_S          0
-+#define PCIE_AECCR_ECRC_GEN_CAP             0x00000020  /* ECRC Generation Capable */
-+#define PCIE_AECCR_ECRC_GEN_EN              0x00000040  /* ECRC Generation Enable */
-+#define PCIE_AECCR_ECRC_CHECK_CAP           0x00000080  /* ECRC Check Capable */
-+#define PCIE_AECCR_ECRC_CHECK_EN            0x00000100  /* ECRC Check Enable */
-+
-+/* Header Log Register 1 */
-+#define PCIE_HLR1(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x11C)
-+
-+/* Header Log Register 2 */
-+#define PCIE_HLR2(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x120)
-+
-+/* Header Log Register 3 */
-+#define PCIE_HLR3(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x124)
-+
-+/* Header Log Register 4 */
-+#define PCIE_HLR4(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x128)
-+
-+/* Root Error Command Register */
-+#define PCIE_RECR(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x12C)
-+#define PCIE_RECR_CORRECTABLE_ERR_REPORT_EN  0x00000001 /* COR-ERR */
-+#define PCIE_RECR_NONFATAL_ERR_REPORT_EN     0x00000002 /* Non-Fatal ERR */
-+#define PCIE_RECR_FATAL_ERR_REPORT_EN        0x00000004 /* Fatal ERR */
-+#define PCIE_RECR_ERR_REPORT_EN  (PCIE_RECR_CORRECTABLE_ERR_REPORT_EN | \
-+                PCIE_RECR_NONFATAL_ERR_REPORT_EN | PCIE_RECR_FATAL_ERR_REPORT_EN)
-+
-+/* Root Error Status Register */
-+#define PCIE_RESR(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x130)
-+#define PCIE_RESR_CORRECTABLE_ERR                0x00000001   /* COR-ERR Receveid */
-+#define PCIE_RESR_MULTI_CORRECTABLE_ERR          0x00000002   /* Multiple COR-ERR Received */
-+#define PCIE_RESR_FATAL_NOFATAL_ERR              0x00000004   /* ERR Fatal/Non-Fatal Received */
-+#define PCIE_RESR_MULTI_FATAL_NOFATAL_ERR        0x00000008   /* Multiple ERR Fatal/Non-Fatal Received */
-+#define PCIE_RESR_FIRST_UNCORRECTABLE_FATAL_ERR  0x00000010   /* First UN-COR Fatal */
-+#define PCIR_RESR_NON_FATAL_ERR                  0x00000020   /* Non-Fatal Error Message Received */
-+#define PCIE_RESR_FATAL_ERR                      0x00000040   /* Fatal Message Received */
-+#define PCIE_RESR_AER_INT_MSG_NUM                0xF8000000   /* Advanced Error Interrupt Message Number */
-+#define PCIE_RESR_AER_INT_MSG_NUM_S              27
-+
-+/* Error Source Indentification Register */
-+#define PCIE_ESIR(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x134)
-+#define PCIE_ESIR_CORRECTABLE_ERR_SRC_ID         0x0000FFFF
-+#define PCIE_ESIR_CORRECTABLE_ERR_SRC_ID_S       0
-+#define PCIE_ESIR_FATAL_NON_FATAL_SRC_ID         0xFFFF0000
-+#define PCIE_ESIR_FATAL_NON_FATAL_SRC_ID_S       16
-+
-+/* VC Enhanced Capability Header */
-+#define PCIE_VC_ECH(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x140)
-+
-+/* Port VC Capability Register */
-+#define PCIE_PVC1(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x144)
-+#define PCIE_PVC1_EXT_VC_CNT                    0x00000007  /* Extended VC Count */
-+#define PCIE_PVC1_EXT_VC_CNT_S                  0
-+#define PCIE_PVC1_LOW_PRI_EXT_VC_CNT            0x00000070  /* Low Priority Extended VC Count */
-+#define PCIE_PVC1_LOW_PRI_EXT_VC_CNT_S          4
-+#define PCIE_PVC1_REF_CLK                       0x00000300  /* Reference Clock */
-+#define PCIE_PVC1_REF_CLK_S                     8
-+#define PCIE_PVC1_PORT_ARB_TAB_ENTRY_SIZE       0x00000C00  /* Port Arbitration Table Entry Size */
-+#define PCIE_PVC1_PORT_ARB_TAB_ENTRY_SIZE_S     10
-+
-+/* Extended Virtual Channel Count Defintion */
-+#define PCIE_EXT_VC_CNT_MIN   0
-+#define PCIE_EXT_VC_CNT_MAX   7
-+
-+/* Port Arbitration Table Entry Size Definition */
-+enum {
-+    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S1BIT = 0,
-+    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S2BIT,
-+    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S4BIT,
-+    PCIE_PORT_ARB_TAB_ENTRY_SIZE_S8BIT,
-+};
-+
-+/* Port VC Capability Register 2 */
-+#define PCIE_PVC2(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x148)
-+#define PCIE_PVC2_VC_ARB_16P_FIXED_WRR      0x00000001  /* HW Fixed arbitration, 16 phase WRR */
-+#define PCIE_PVC2_VC_ARB_32P_WRR            0x00000002  /* 32 phase WRR */
-+#define PCIE_PVC2_VC_ARB_64P_WRR            0x00000004  /* 64 phase WRR */
-+#define PCIE_PVC2_VC_ARB_128P_WRR           0x00000008  /* 128 phase WRR */
-+#define PCIE_PVC2_VC_ARB_WRR                0x0000000F
-+#define PCIE_PVC2_VC_ARB_TAB_OFFSET         0xFF000000  /* VC arbitration table offset, not support */
-+#define PCIE_PVC2_VC_ARB_TAB_OFFSET_S       24
-+
-+/* Port VC Control and Status Register */     
-+#define PCIE_PVCCRSR(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x14C)
-+#define PCIE_PVCCRSR_LOAD_VC_ARB_TAB         0x00000001  /* Load VC Arbitration Table */
-+#define PCIE_PVCCRSR_VC_ARB_SEL              0x0000000E  /* VC Arbitration Select */
-+#define PCIE_PVCCRSR_VC_ARB_SEL_S            1
-+#define PCIE_PVCCRSR_VC_ARB_TAB_STATUS       0x00010000  /* Arbitration Status */
-+
-+/* VC0 Resource Capability Register */
-+#define PCIE_VC0_RC(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x150)
-+#define PCIE_VC0_RC_PORT_ARB_HW_FIXED        0x00000001  /* HW Fixed arbitration */
-+#define PCIE_VC0_RC_PORT_ARB_32P_WRR         0x00000002  /* 32 phase WRR */
-+#define PCIE_VC0_RC_PORT_ARB_64P_WRR         0x00000004  /* 64 phase WRR */
-+#define PCIE_VC0_RC_PORT_ARB_128P_WRR        0x00000008  /* 128 phase WRR */
-+#define PCIE_VC0_RC_PORT_ARB_TM_128P_WRR     0x00000010  /* Time-based 128 phase WRR */
-+#define PCIE_VC0_RC_PORT_ARB_TM_256P_WRR     0x00000020  /* Time-based 256 phase WRR */
-+#define PCIE_VC0_RC_PORT_ARB          (PCIE_VC0_RC_PORT_ARB_HW_FIXED | PCIE_VC0_RC_PORT_ARB_32P_WRR |\
-+                        PCIE_VC0_RC_PORT_ARB_64P_WRR | PCIE_VC0_RC_PORT_ARB_128P_WRR | \
-+                        PCIE_VC0_RC_PORT_ARB_TM_128P_WRR | PCIE_VC0_RC_PORT_ARB_TM_256P_WRR)
-+
-+#define PCIE_VC0_RC_REJECT_SNOOP             0x00008000  /* Reject Snoop Transactioin */
-+#define PCIE_VC0_RC_MAX_TIMESLOTS            0x007F0000  /* Maximum time Slots */
-+#define PCIE_VC0_RC_MAX_TIMESLOTS_S          16
-+#define PCIE_VC0_RC_PORT_ARB_TAB_OFFSET      0xFF000000  /* Port Arbitration Table Offset */
-+#define PCIE_VC0_RC_PORT_ARB_TAB_OFFSET_S    24
-+
-+/* VC0 Resource Control Register */
-+#define PCIE_VC0_RC0(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x154)
-+#define PCIE_VC0_RC0_TVM0                    0x00000001  /* TC0 and VC0 */
-+#define PCIE_VC0_RC0_TVM1                    0x00000002  /* TC1 and VC1 */
-+#define PCIE_VC0_RC0_TVM2                    0x00000004  /* TC2 and VC2 */
-+#define PCIE_VC0_RC0_TVM3                    0x00000008  /* TC3 and VC3 */
-+#define PCIE_VC0_RC0_TVM4                    0x00000010  /* TC4 and VC4 */
-+#define PCIE_VC0_RC0_TVM5                    0x00000020  /* TC5 and VC5 */
-+#define PCIE_VC0_RC0_TVM6                    0x00000040  /* TC6 and VC6 */
-+#define PCIE_VC0_RC0_TVM7                    0x00000080  /* TC7 and VC7 */
-+#define PCIE_VC0_RC0_TC_VC                   0x000000FF  /* TC/VC mask */
-+
-+#define PCIE_VC0_RC0_LOAD_PORT_ARB_TAB       0x00010000  /* Load Port Arbitration Table */
-+#define PCIE_VC0_RC0_PORT_ARB_SEL            0x000E0000  /* Port Arbitration Select */
-+#define PCIE_VC0_RC0_PORT_ARB_SEL_S          17
-+#define PCIE_VC0_RC0_VC_ID                   0x07000000  /* VC ID */
-+#define PCIE_VC0_RC0_VC_ID_S                 24
-+#define PCIE_VC0_RC0_VC_EN                   0x80000000  /* VC Enable */
-+
-+/* VC0 Resource Status Register */
-+#define PCIE_VC0_RSR0(X)                     (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x158)
-+#define PCIE_VC0_RSR0_PORT_ARB_TAB_STATUS    0x00010000  /* Port Arbitration Table Status,not used */
-+#define PCIE_VC0_RSR0_VC_NEG_PENDING         0x00020000  /* VC Negotiation Pending */
-+
-+/* Ack Latency Timer and Replay Timer Register */
-+#define PCIE_ALTRT(X)                         (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x700)
-+#define PCIE_ALTRT_ROUND_TRIP_LATENCY_LIMIT   0x0000FFFF  /* Round Trip Latency Time Limit */
-+#define PCIE_ALTRT_ROUND_TRIP_LATENCY_LIMIT_S 0
-+#define PCIE_ALTRT_REPLAY_TIME_LIMIT          0xFFFF0000  /* Replay Time Limit */
-+#define PCIE_ALTRT_REPLAY_TIME_LIMIT_S        16
-+
-+/* Other Message Register */
-+#define PCIE_OMR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x704)
-+
-+/* Port Force Link Register */
-+#define PCIE_PFLR(X)                         (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x708)
-+#define PCIE_PFLR_LINK_NUM                   0x000000FF  /* Link Number */
-+#define PCIE_PFLR_LINK_NUM_S                 0
-+#define PCIE_PFLR_FORCE_LINK                 0x00008000  /* Force link */
-+#define PCIE_PFLR_LINK_STATE                 0x003F0000  /* Link State */
-+#define PCIE_PFLR_LINK_STATE_S               16
-+#define PCIE_PFLR_LOW_POWER_ENTRY_CNT        0xFF000000  /* Low Power Entrance Count, only for EP */
-+#define PCIE_PFLR_LOW_POWER_ENTRY_CNT_S      24
-+
-+/* Ack Frequency Register */
-+#define PCIE_AFR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x70C)
-+#define PCIE_AFR_AF                          0x000000FF  /* Ack Frequency */
-+#define PCIE_AFR_AF_S                        0
-+#define PCIE_AFR_FTS_NUM                     0x0000FF00  /* The number of Fast Training Sequence from L0S to L0 */
-+#define PCIE_AFR_FTS_NUM_S                   8
-+#define PCIE_AFR_COM_FTS_NUM                 0x00FF0000  /* N_FTS; when common clock is used*/
-+#define PCIE_AFR_COM_FTS_NUM_S               16
-+#define PCIE_AFR_L0S_ENTRY_LATENCY           0x07000000  /* L0s Entrance Latency */
-+#define PCIE_AFR_L0S_ENTRY_LATENCY_S         24
-+#define PCIE_AFR_L1_ENTRY_LATENCY            0x38000000  /* L1 Entrance Latency */
-+#define PCIE_AFR_L1_ENTRY_LATENCY_S          27
-+#define PCIE_AFR_FTS_NUM_DEFAULT             32
-+#define PCIE_AFR_L0S_ENTRY_LATENCY_DEFAULT   7
-+#define PCIE_AFR_L1_ENTRY_LATENCY_DEFAULT    5
-+
-+/* Port Link Control Register */
-+#define PCIE_PLCR(X)                         (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x710)
-+#define PCIE_PLCR_OTHER_MSG_REQ              0x00000001  /* Other Message Request */
-+#define PCIE_PLCR_SCRAMBLE_DISABLE           0x00000002  /* Scramble Disable */  
-+#define PCIE_PLCR_LOOPBACK_EN                0x00000004  /* Loopback Enable */
-+#define PCIE_PLCR_LTSSM_HOT_RST              0x00000008  /* Force LTSSM to the hot reset */
-+#define PCIE_PLCR_DLL_LINK_EN                0x00000020  /* Enable Link initialization */
-+#define PCIE_PLCR_FAST_LINK_SIM_EN           0x00000080  /* Sets all internal timers to fast mode for simulation purposes */
-+#define PCIE_PLCR_LINK_MODE                  0x003F0000  /* Link Mode Enable Mask */
-+#define PCIE_PLCR_LINK_MODE_S                16
-+#define PCIE_PLCR_CORRUPTED_CRC_EN           0x02000000  /* Enabled Corrupt CRC */
-+
-+/* Lane Skew Register */
-+#define PCIE_LSR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x714)
-+#define PCIE_LSR_LANE_SKEW_NUM               0x00FFFFFF  /* Insert Lane Skew for Transmit, not applicable */
-+#define PCIE_LSR_LANE_SKEW_NUM_S             0
-+#define PCIE_LSR_FC_DISABLE                  0x01000000  /* Disable of Flow Control */
-+#define PCIE_LSR_ACKNAK_DISABLE              0x02000000  /* Disable of Ack/Nak */
-+#define PCIE_LSR_LANE_DESKEW_DISABLE         0x80000000  /* Disable of Lane-to-Lane Skew */
-+
-+/* Symbol Number Register */
-+#define PCIE_SNR(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x718)
-+#define PCIE_SNR_TS                          0x0000000F  /* Number of TS Symbol */
-+#define PCIE_SNR_TS_S                        0
-+#define PCIE_SNR_SKP                         0x00000700  /* Number of SKP Symbol */
-+#define PCIE_SNR_SKP_S                       8
-+#define PCIE_SNR_REPLAY_TIMER                0x0007C000  /* Timer Modifier for Replay Timer */
-+#define PCIE_SNR_REPLAY_TIMER_S              14
-+#define PCIE_SNR_ACKNAK_LATENCY_TIMER        0x00F80000  /* Timer Modifier for Ack/Nak Latency Timer */
-+#define PCIE_SNR_ACKNAK_LATENCY_TIMER_S      19
-+#define PCIE_SNR_FC_TIMER                    0x1F000000  /* Timer Modifier for Flow Control Watchdog Timer */
-+#define PCIE_SNR_FC_TIMER_S                  28
-+
-+/* Symbol Timer Register and Filter Mask Register 1 */
-+#define PCIE_STRFMR(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x71C)
-+#define PCIE_STRFMR_SKP_INTERVAL            0x000007FF  /* SKP lnterval Value */
-+#define PCIE_STRFMR_SKP_INTERVAL_S          0
-+#define PCIE_STRFMR_FC_WDT_DISABLE          0x00008000  /* Disable of FC Watchdog Timer */
-+#define PCIE_STRFMR_TLP_FUNC_MISMATCH_OK    0x00010000  /* Mask Function Mismatch Filtering for Incoming Requests */
-+#define PCIE_STRFMR_POISONED_TLP_OK         0x00020000  /* Mask Poisoned TLP Filtering */
-+#define PCIE_STRFMR_BAR_MATCH_OK            0x00040000  /* Mask BAR Match Filtering */
-+#define PCIE_STRFMR_TYPE1_CFG_REQ_OK        0x00080000  /* Mask Type 1 Configuration Request Filtering */
-+#define PCIE_STRFMR_LOCKED_REQ_OK           0x00100000  /* Mask Locked Request Filtering */
-+#define PCIE_STRFMR_CPL_TAG_ERR_RULES_OK    0x00200000  /* Mask Tag Error Rules for Received Completions */
-+#define PCIE_STRFMR_CPL_REQUESTOR_ID_MISMATCH_OK 0x00400000  /* Mask Requester ID Mismatch Error for Received Completions */
-+#define PCIE_STRFMR_CPL_FUNC_MISMATCH_OK         0x00800000  /* Mask Function Mismatch Error for Received Completions */
-+#define PCIE_STRFMR_CPL_TC_MISMATCH_OK           0x01000000  /* Mask Traffic Class Mismatch Error for Received Completions */
-+#define PCIE_STRFMR_CPL_ATTR_MISMATCH_OK         0x02000000  /* Mask Attribute Mismatch Error for Received Completions */
-+#define PCIE_STRFMR_CPL_LENGTH_MISMATCH_OK       0x04000000  /* Mask Length Mismatch Error for Received Completions */
-+#define PCIE_STRFMR_TLP_ECRC_ERR_OK              0x08000000  /* Mask ECRC Error Filtering */
-+#define PCIE_STRFMR_CPL_TLP_ECRC_OK              0x10000000  /* Mask ECRC Error Filtering for Completions */
-+#define PCIE_STRFMR_RX_TLP_MSG_NO_DROP           0x20000000  /* Send Message TLPs */
-+#define PCIE_STRFMR_RX_IO_TRANS_ENABLE           0x40000000  /* Mask Filtering of received I/O Requests */
-+#define PCIE_STRFMR_RX_CFG_TRANS_ENABLE          0x80000000  /* Mask Filtering of Received Configuration Requests */
-+
-+#define PCIE_DEF_SKP_INTERVAL    700             /* 1180 ~1538 , 125MHz * 2, 250MHz * 1 */
-+
-+/* Filter Masker Register 2 */
-+#define PCIE_FMR2(X)                             (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x720)
-+#define PCIE_FMR2_VENDOR_MSG0_PASSED_TO_TRGT1    0x00000001  /* Mask RADM Filtering and Error Handling Rules */
-+#define PCIE_FMR2_VENDOR_MSG1_PASSED_TO_TRGT1    0x00000002  /* Mask RADM Filtering and Error Handling Rules */
-+
-+/* Debug Register 0 */
-+#define PCIE_DBR0(X)                              (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x728)
-+
-+/* Debug Register 1 */
-+#define PCIE_DBR1(X)                              (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x72C)
-+
-+/* Transmit Posted FC Credit Status Register */
-+#define PCIE_TPFCS(X)                             (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x730)
-+#define PCIE_TPFCS_TX_P_DATA_FC_CREDITS           0x00000FFF /* Transmit Posted Data FC Credits */
-+#define PCIE_TPFCS_TX_P_DATA_FC_CREDITS_S         0
-+#define PCIE_TPFCS_TX_P_HDR_FC_CREDITS            0x000FF000 /* Transmit Posted Header FC Credits */
-+#define PCIE_TPFCS_TX_P_HDR_FC_CREDITS_S          12
-+
-+/* Transmit Non-Posted FC Credit Status */
-+#define PCIE_TNPFCS(X)                            (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x734)
-+#define PCIE_TNPFCS_TX_NP_DATA_FC_CREDITS         0x00000FFF /* Transmit Non-Posted Data FC Credits */
-+#define PCIE_TNPFCS_TX_NP_DATA_FC_CREDITS_S       0
-+#define PCIE_TNPFCS_TX_NP_HDR_FC_CREDITS          0x000FF000 /* Transmit Non-Posted Header FC Credits */
-+#define PCIE_TNPFCS_TX_NP_HDR_FC_CREDITS_S        12
-+
-+/* Transmit Complete FC Credit Status Register */
-+#define PCIE_TCFCS(X)                             (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x738)
-+#define PCIE_TCFCS_TX_CPL_DATA_FC_CREDITS         0x00000FFF /* Transmit Completion Data FC Credits */
-+#define PCIE_TCFCS_TX_CPL_DATA_FC_CREDITS_S       0
-+#define PCIE_TCFCS_TX_CPL_HDR_FC_CREDITS          0x000FF000 /* Transmit Completion Header FC Credits */
-+#define PCIE_TCFCS_TX_CPL_HDR_FC_CREDITS_S        12
-+
-+/* Queue Status Register */
-+#define PCIE_QSR(X)                              (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x73C)
-+#define PCIE_QSR_WAIT_UPDATE_FC_DLL               0x00000001 /* Received TLP FC Credits Not Returned */
-+#define PCIE_QSR_TX_RETRY_BUF_NOT_EMPTY           0x00000002 /* Transmit Retry Buffer Not Empty */
-+#define PCIE_QSR_RX_QUEUE_NOT_EMPTY               0x00000004 /* Received Queue Not Empty */
-+
-+/* VC Transmit Arbitration Register 1 */
-+#define PCIE_VCTAR1(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x740)
-+#define PCIE_VCTAR1_WRR_WEIGHT_VC0               0x000000FF /* WRR Weight for VC0 */
-+#define PCIE_VCTAR1_WRR_WEIGHT_VC1               0x0000FF00 /* WRR Weight for VC1 */
-+#define PCIE_VCTAR1_WRR_WEIGHT_VC2               0x00FF0000 /* WRR Weight for VC2 */
-+#define PCIE_VCTAR1_WRR_WEIGHT_VC3               0xFF000000 /* WRR Weight for VC3 */
-+
-+/* VC Transmit Arbitration Register 2 */
-+#define PCIE_VCTAR2(X)                          (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x744)
-+#define PCIE_VCTAR2_WRR_WEIGHT_VC4               0x000000FF /* WRR Weight for VC4 */
-+#define PCIE_VCTAR2_WRR_WEIGHT_VC5               0x0000FF00 /* WRR Weight for VC5 */
-+#define PCIE_VCTAR2_WRR_WEIGHT_VC6               0x00FF0000 /* WRR Weight for VC6 */
-+#define PCIE_VCTAR2_WRR_WEIGHT_VC7               0xFF000000 /* WRR Weight for VC7 */
-+
-+/* VC0 Posted Receive Queue Control Register */
-+#define PCIE_VC0_PRQCR(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x748)
-+#define PCIE_VC0_PRQCR_P_DATA_CREDITS            0x00000FFF /* VC0 Posted Data Credits */
-+#define PCIE_VC0_PRQCR_P_DATA_CREDITS_S          0
-+#define PCIE_VC0_PRQCR_P_HDR_CREDITS             0x000FF000 /* VC0 Posted Header Credits */
-+#define PCIE_VC0_PRQCR_P_HDR_CREDITS_S           12
-+#define PCIE_VC0_PRQCR_P_TLP_QUEUE_MODE          0x00E00000 /* VC0 Posted TLP Queue Mode */
-+#define PCIE_VC0_PRQCR_P_TLP_QUEUE_MODE_S        20
-+#define PCIE_VC0_PRQCR_TLP_RELAX_ORDER           0x40000000 /* TLP Type Ordering for VC0 */    
-+#define PCIE_VC0_PRQCR_VC_STRICT_ORDER           0x80000000 /* VC0 Ordering for Receive Queues */
-+
-+/* VC0 Non-Posted Receive Queue Control */
-+#define PCIE_VC0_NPRQCR(X)                      (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x74C)
-+#define PCIE_VC0_NPRQCR_NP_DATA_CREDITS          0x00000FFF /* VC0 Non-Posted Data Credits */
-+#define PCIE_VC0_NPRQCR_NP_DATA_CREDITS_S        0
-+#define PCIE_VC0_NPRQCR_NP_HDR_CREDITS           0x000FF000 /* VC0 Non-Posted Header Credits */
-+#define PCIE_VC0_NPRQCR_NP_HDR_CREDITS_S         12
-+#define PCIE_VC0_NPRQCR_NP_TLP_QUEUE_MODE        0x00E00000 /* VC0 Non-Posted TLP Queue Mode */
-+#define PCIE_VC0_NPRQCR_NP_TLP_QUEUE_MODE_S      20
-+
-+/* VC0 Completion Receive Queue Control */
-+#define PCIE_VC0_CRQCR(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x750)
-+#define PCIE_VC0_CRQCR_CPL_DATA_CREDITS          0x00000FFF /* VC0 Completion TLP Queue Mode */
-+#define PCIE_VC0_CRQCR_CPL_DATA_CREDITS_S        0
-+#define PCIE_VC0_CRQCR_CPL_HDR_CREDITS           0x000FF000 /* VC0 Completion Header Credits */
-+#define PCIE_VC0_CRQCR_CPL_HDR_CREDITS_S         12
-+#define PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE        0x00E00000 /* VC0 Completion Data Credits */
-+#define PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE_S      21
-+
-+/* Applicable to the above three registers */
-+enum {
-+    PCIE_VC0_TLP_QUEUE_MODE_STORE_FORWARD = 1,
-+    PCIE_VC0_TLP_QUEUE_MODE_CUT_THROUGH   = 2,
-+    PCIE_VC0_TLP_QUEUE_MODE_BYPASS        = 4,
-+};
-+
-+/* VC0 Posted Buffer Depth Register */
-+#define PCIE_VC0_PBD(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7A8)
-+#define PCIE_VC0_PBD_P_DATA_QUEUE_ENTRIES       0x00003FFF /* VC0 Posted Data Queue Depth */
-+#define PCIE_VC0_PBD_P_DATA_QUEUE_ENTRIES_S     0
-+#define PCIE_VC0_PBD_P_HDR_QUEUE_ENTRIES        0x03FF0000 /* VC0 Posted Header Queue Depth */
-+#define PCIE_VC0_PBD_P_HDR_QUEUE_ENTRIES_S      16
-+
-+/* VC0 Non-Posted Buffer Depth Register */
-+#define PCIE_VC0_NPBD(X)                       (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7AC)
-+#define PCIE_VC0_NPBD_NP_DATA_QUEUE_ENTRIES     0x00003FFF /* VC0 Non-Posted Data Queue Depth */
-+#define PCIE_VC0_NPBD_NP_DATA_QUEUE_ENTRIES_S   0
-+#define PCIE_VC0_NPBD_NP_HDR_QUEUE_ENTRIES      0x03FF0000 /* VC0 Non-Posted Header Queue Depth */
-+#define PCIE_VC0_NPBD_NP_HDR_QUEUE_ENTRIES_S    16
-+
-+/* VC0 Completion Buffer Depth Register */
-+#define PCIE_VC0_CBD(X)                        (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x7B0)
-+#define PCIE_VC0_CBD_CPL_DATA_QUEUE_ENTRIES     0x00003FFF /* C0 Completion Data Queue Depth */
-+#define PCIE_VC0_CBD_CPL_DATA_QUEUE_ENTRIES_S   0
-+#define PCIE_VC0_CBD_CPL_HDR_QUEUE_ENTRIES      0x03FF0000 /* VC0 Completion Header Queue Depth */
-+#define PCIE_VC0_CBD_CPL_HDR_QUEUE_ENTRIES_S    16
-+
-+/* PHY Status Register, all zeros in VR9 */
-+#define PCIE_PHYSR(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x810)
-+
-+/* PHY Control Register, all zeros in VR9 */
-+#define PCIE_PHYCR(X)                           (volatile u32*)(PCIE_RC_PORT_TO_BASE(X) + 0x814)
-+
-+/* 
-+ * PCIe PDI PHY register definition, suppose all the following 
-+ * stuff is confidential. 
-+ * XXX, detailed bit definition
-+ */
-+#define	PCIE_PHY_PLL_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x22 << 1))
-+#define	PCIE_PHY_PLL_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x23 << 1))
-+#define	PCIE_PHY_PLL_CTRL3(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x24 << 1))
-+#define	PCIE_PHY_PLL_CTRL4(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x25 << 1))
-+#define	PCIE_PHY_PLL_CTRL5(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x26 << 1))
-+#define	PCIE_PHY_PLL_CTRL6(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x27 << 1))
-+#define	PCIE_PHY_PLL_CTRL7(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x28 << 1))
-+#define	PCIE_PHY_PLL_A_CTRL1(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x29 << 1))
-+#define	PCIE_PHY_PLL_A_CTRL2(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x2A << 1))
-+#define	PCIE_PHY_PLL_A_CTRL3(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x2B << 1))
-+#define	PCIE_PHY_PLL_STATUS(X)      (PCIE_PHY_PORT_TO_BASE(X) + (0x2C << 1))
-+ 
-+#define PCIE_PHY_TX1_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x30 << 1))
-+#define PCIE_PHY_TX1_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x31 << 1))
-+#define PCIE_PHY_TX1_CTRL3(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x32 << 1))
-+#define PCIE_PHY_TX1_A_CTRL1(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x33 << 1))
-+#define PCIE_PHY_TX1_A_CTRL2(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x34 << 1))
-+#define PCIE_PHY_TX1_MOD1(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x35 << 1))
-+#define PCIE_PHY_TX1_MOD2(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x36 << 1))
-+#define PCIE_PHY_TX1_MOD3(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x37 << 1))
-+
-+#define PCIE_PHY_TX2_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x38 << 1))
-+#define PCIE_PHY_TX2_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x39 << 1))
-+#define PCIE_PHY_TX2_A_CTRL1(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x3B << 1))
-+#define PCIE_PHY_TX2_A_CTRL2(X)     (PCIE_PHY_PORT_TO_BASE(X) + (0x3C << 1))
-+#define PCIE_PHY_TX2_MOD1(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x3D << 1))
-+#define PCIE_PHY_TX2_MOD2(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x3E << 1))
-+#define PCIE_PHY_TX2_MOD3(X)        (PCIE_PHY_PORT_TO_BASE(X) + (0x3F << 1))
-+
-+#define PCIE_PHY_RX1_CTRL1(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x50 << 1))
-+#define PCIE_PHY_RX1_CTRL2(X)       (PCIE_PHY_PORT_TO_BASE(X) + (0x51 << 1))
-+#define PCIE_PHY_RX1_CDR(X)         (PCIE_PHY_PORT_TO_BASE(X) + (0x52 << 1))
-+#define PCIE_PHY_RX1_EI(X)          (PCIE_PHY_PORT_TO_BASE(X) + (0x53 << 1))
-+#define PCIE_PHY_RX1_A_CTRL(X)      (PCIE_PHY_PORT_TO_BASE(X) + (0x55 << 1))
-+
-+/* Interrupt related stuff */
-+#define PCIE_LEGACY_DISABLE 0
-+#define PCIE_LEGACY_INTA  1
-+#define PCIE_LEGACY_INTB  2
-+#define PCIE_LEGACY_INTC  3
-+#define PCIE_LEGACY_INTD  4
-+#define PCIE_LEGACY_INT_MAX PCIE_LEGACY_INTD
-+
-+#define PCIE_IRQ_LOCK(lock) do {             \
-+    unsigned long flags;                     \
-+    spin_lock_irqsave(&(lock), flags);
-+#define PCIE_IRQ_UNLOCK(lock)                \
-+    spin_unlock_irqrestore(&(lock), flags);  \
-+} while (0)
-+
-+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
-+#define IRQF_SHARED SA_SHIRQ
-+#endif
-+
-+#define PCIE_MSG_MSI        0x00000001
-+#define PCIE_MSG_ISR        0x00000002
-+#define PCIE_MSG_FIXUP      0x00000004
-+#define PCIE_MSG_READ_CFG   0x00000008
-+#define PCIE_MSG_WRITE_CFG  0x00000010
-+#define PCIE_MSG_CFG        (PCIE_MSG_READ_CFG | PCIE_MSG_WRITE_CFG)
-+#define PCIE_MSG_REG        0x00000020
-+#define PCIE_MSG_INIT       0x00000040
-+#define PCIE_MSG_ERR        0x00000080
-+#define PCIE_MSG_PHY        0x00000100
-+#define PCIE_MSG_ANY        0x000001ff
-+
-+#define IFX_PCIE_PORT0      0
-+#define IFX_PCIE_PORT1      1
-+
-+#ifdef CONFIG_IFX_PCIE_2ND_CORE
-+#define IFX_PCIE_CORE_NR    2
-+#else
-+#define IFX_PCIE_CORE_NR    1
-+#endif
-+
-+//#define IFX_PCIE_ERROR_INT
-+
-+//#define IFX_PCIE_DBG
-+
-+#if defined(IFX_PCIE_DBG)
-+#define IFX_PCIE_PRINT(_m, _fmt, args...) do {   \
-+    if (g_pcie_debug_flag & (_m)) {              \
-+        ifx_pcie_debug((_fmt), ##args);          \
-+    }                                            \
-+} while (0)
-+
-+#define INLINE 
-+#else
-+#define IFX_PCIE_PRINT(_m, _fmt, args...)   \
-+    do {} while(0)
-+#define INLINE inline
-+#endif
-+
-+struct ifx_pci_controller {
-+	struct pci_controller   pcic;
-+    
-+	/* RC specific, per host bus information */
-+	u32   port;  /* Port index, 0 -- 1st core, 1 -- 2nd core */
-+};
-+
-+typedef struct ifx_pcie_ir_irq {
-+    const unsigned int irq;
-+    const char name[16];
-+}ifx_pcie_ir_irq_t;
-+
-+typedef struct ifx_pcie_legacy_irq{
-+    const u32 irq_bit;
-+    const int irq;
-+}ifx_pcie_legacy_irq_t;
-+
-+typedef struct ifx_pcie_irq {
-+    ifx_pcie_ir_irq_t ir_irq;
-+    ifx_pcie_legacy_irq_t legacy_irq[PCIE_LEGACY_INT_MAX];
-+}ifx_pcie_irq_t;
-+
-+extern u32 g_pcie_debug_flag;
-+extern void ifx_pcie_debug(const char *fmt, ...);
-+extern void pcie_phy_clock_mode_setup(int pcie_port);
-+extern void pcie_msi_pic_init(int pcie_port);
-+extern u32 ifx_pcie_bus_enum_read_hack(int where, u32 value);
-+extern u32 ifx_pcie_bus_enum_write_hack(int where, u32 value);
-+
-+
-+#include <linux/types.h>
-+#include <linux/delay.h>
-+#include <linux/gpio.h>
-+#include <linux/clk.h>
-+
-+#include <lantiq_soc.h>
-+
-+#define IFX_PCIE_GPIO_RESET  38
-+#define IFX_REG_R32	ltq_r32
-+#define IFX_REG_W32	ltq_w32
-+#define CONFIG_IFX_PCIE_HW_SWAP
-+#define IFX_RCU_AHB_ENDIAN                      ((volatile u32*)(IFX_RCU + 0x004C))
-+#define IFX_RCU_RST_REQ                         ((volatile u32*)(IFX_RCU + 0x0010))
-+#define IFX_RCU_AHB_BE_PCIE_PDI                  0x00000080  /* Configure PCIE PDI module in big endian*/
-+
-+#define IFX_RCU                                 (KSEG1 | 0x1F203000)
-+#define IFX_RCU_AHB_BE_PCIE_M                    0x00000001  /* Configure AHB master port that connects to PCIe RC in big endian */
-+#define IFX_RCU_AHB_BE_PCIE_S                    0x00000010  /* Configure AHB slave port that connects to PCIe RC in little endian */
-+#define IFX_RCU_AHB_BE_XBAR_M                    0x00000002  /* Configure AHB master port that connects to XBAR in big endian */
-+#define CONFIG_IFX_PCIE_PHY_36MHZ_MODE
-+
-+#define IFX_PMU1_MODULE_PCIE_PHY   (0)
-+#define IFX_PMU1_MODULE_PCIE_CTRL  (1)
-+#define IFX_PMU1_MODULE_PDI        (4)
-+#define IFX_PMU1_MODULE_MSI        (5)
-+
-+#define IFX_PMU_MODULE_PCIE_L0_CLK (31)
-+
-+
-+static inline void pcie_ep_gpio_rst_init(int pcie_port)
-+{
-+}
-+
-+static inline void pcie_ahb_pmu_setup(void)
-+{
-+	struct clk *clk;
-+	clk = clk_get_sys("ltq_pcie", "ahb");
-+	clk_enable(clk);
-+	//ltq_pmu_enable(PMU_AHBM | PMU_AHBS);
-+}
-+
-+static inline void pcie_rcu_endian_setup(int pcie_port)
-+{
-+    u32 reg;
-+
-+    reg = IFX_REG_R32(IFX_RCU_AHB_ENDIAN);
-+#ifdef CONFIG_IFX_PCIE_HW_SWAP
-+    reg |= IFX_RCU_AHB_BE_PCIE_M;
-+    reg |= IFX_RCU_AHB_BE_PCIE_S;
-+    reg &= ~IFX_RCU_AHB_BE_XBAR_M;
-+#else 
-+    reg |= IFX_RCU_AHB_BE_PCIE_M;
-+    reg &= ~IFX_RCU_AHB_BE_PCIE_S;
-+    reg &= ~IFX_RCU_AHB_BE_XBAR_M;
-+#endif /* CONFIG_IFX_PCIE_HW_SWAP */
-+    IFX_REG_W32(reg, IFX_RCU_AHB_ENDIAN);
-+    IFX_PCIE_PRINT(PCIE_MSG_REG, "%s IFX_RCU_AHB_ENDIAN: 0x%08x\n", __func__, IFX_REG_R32(IFX_RCU_AHB_ENDIAN));
-+}
-+
-+static inline void pcie_phy_pmu_enable(int pcie_port)
-+{
-+	struct clk *clk;
-+	clk = clk_get_sys("ltq_pcie", "phy");
-+	clk_enable(clk);
-+	//ltq_pmu1_enable(1<<IFX_PMU1_MODULE_PCIE_PHY);
-+}
-+
-+static inline void pcie_phy_pmu_disable(int pcie_port)
-+{
-+	struct clk *clk;
-+	clk = clk_get_sys("ltq_pcie", "phy");
-+	clk_disable(clk);
-+	//ltq_pmu1_disable(1<<IFX_PMU1_MODULE_PCIE_PHY);
-+}
-+
-+static inline void pcie_pdi_big_endian(int pcie_port)
-+{
-+    u32 reg;
-+
-+    /* SRAM2PDI endianness control. */
-+    reg = IFX_REG_R32(IFX_RCU_AHB_ENDIAN);
-+    /* Config AHB->PCIe and PDI endianness */
-+    reg |= IFX_RCU_AHB_BE_PCIE_PDI;
-+    IFX_REG_W32(reg, IFX_RCU_AHB_ENDIAN);
-+}
-+
-+static inline void pcie_pdi_pmu_enable(int pcie_port)
-+{
-+	struct clk *clk;
-+	clk = clk_get_sys("ltq_pcie", "pdi");
-+	clk_enable(clk);
-+	//ltq_pmu1_enable(1<<IFX_PMU1_MODULE_PDI);
-+}
-+
-+static inline void pcie_core_rst_assert(int pcie_port)
-+{
-+    u32 reg;
-+
-+    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-+
-+    /* Reset PCIe PHY & Core, bit 22, bit 26 may be affected if write it directly  */
-+    reg |= 0x00400000;
-+    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-+}
-+
-+static inline void pcie_core_rst_deassert(int pcie_port)
-+{
-+    u32 reg;
-+
-+    /* Make sure one micro-second delay */
-+    udelay(1);
-+
-+    /* Reset PCIe PHY & Core, bit 22 */
-+    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-+    reg &= ~0x00400000;
-+    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-+}
-+
-+static inline void pcie_phy_rst_assert(int pcie_port)
-+{
-+    u32 reg;
-+
-+    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-+    reg |= 0x00001000; /* Bit 12 */
-+    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-+}
-+
-+static inline void pcie_phy_rst_deassert(int pcie_port)
-+{
-+    u32 reg;
-+
-+    /* Make sure one micro-second delay */
-+    udelay(1);
-+
-+    reg = IFX_REG_R32(IFX_RCU_RST_REQ);
-+    reg &= ~0x00001000; /* Bit 12 */
-+    IFX_REG_W32(reg, IFX_RCU_RST_REQ);
-+}
-+
-+static inline void pcie_device_rst_assert(int pcie_port)
-+{
-+	gpio_set_value(IFX_PCIE_GPIO_RESET, 0);
-+  //  ifx_gpio_output_clear(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-+}
-+
-+static inline void pcie_device_rst_deassert(int pcie_port)
-+{
-+    mdelay(100);
-+	gpio_set_value(IFX_PCIE_GPIO_RESET, 1);
-+//    ifx_gpio_output_set(IFX_PCIE_GPIO_RESET, ifx_pcie_gpio_module_id);
-+}
-+
-+static inline void pcie_core_pmu_setup(int pcie_port)
-+{
-+	struct clk *clk;
-+	clk = clk_get_sys("ltq_pcie", "ctl");
-+	clk_enable(clk);
-+	clk = clk_get_sys("ltq_pcie", "bus");
-+	clk_enable(clk);
-+
-+	//ltq_pmu1_enable(1 << IFX_PMU1_MODULE_PCIE_CTRL);
-+	//ltq_pmu_enable(1 << IFX_PMU_MODULE_PCIE_L0_CLK);
-+}
-+
-+static inline void pcie_msi_init(int pcie_port)
-+{
-+	struct clk *clk;
-+    pcie_msi_pic_init(pcie_port);
-+	clk = clk_get_sys("ltq_pcie", "msi");
-+	clk_enable(clk);
-+	//ltq_pmu1_enable(1 << IFX_PMU1_MODULE_MSI);
-+}
-+
-+static inline u32
-+ifx_pcie_bus_nr_deduct(u32 bus_number, int pcie_port)
-+{
-+    u32 tbus_number = bus_number;
-+
-+#ifdef CONFIG_PCI_LANTIQ
-+    if (pcibios_host_nr() > 1) {
-+        tbus_number -= pcibios_1st_host_bus_nr();
-+    }
-+#endif /* CONFIG_PCI_LANTIQ */
-+    return tbus_number;
-+}
-+
-+static inline u32
-+ifx_pcie_bus_enum_hack(struct pci_bus *bus, u32 devfn, int where, u32 value, int pcie_port, int read)
-+{
-+    struct pci_dev *pdev;
-+    u32 tvalue = value;
-+
-+    /* Sanity check */
-+    pdev = pci_get_slot(bus, devfn);
-+    if (pdev == NULL) {
-+        return tvalue;
-+    }
-+
-+    /* Only care about PCI bridge */
-+    if (pdev->hdr_type != PCI_HEADER_TYPE_BRIDGE) {
-+        return tvalue;
-+    }
-+
-+    if (read) { /* Read hack */
-+    #ifdef CONFIG_PCI_LANTIQ
-+        if (pcibios_host_nr() > 1) {
-+            tvalue = ifx_pcie_bus_enum_read_hack(where, tvalue);
-+        }
-+    #endif /* CONFIG_PCI_LANTIQ */
-+    }
-+    else { /* Write hack */
-+    #ifdef CONFIG_PCI_LANTIQ
-+        if (pcibios_host_nr() > 1) {
-+            tvalue = ifx_pcie_bus_enum_write_hack(where, tvalue);
-+        }
-+    #endif
-+    }
-+    return tvalue;
-+}
-+
-+#endif /* IFXMIPS_PCIE_VR9_H */
-+
---- a/drivers/pci/pcie/aer/Kconfig
-+++ b/drivers/pci/pcie/aer/Kconfig
-@@ -19,6 +19,7 @@ config PCIEAER
- config PCIE_ECRC
- 	bool "PCI Express ECRC settings control"
- 	depends on PCIEAER
-+	default n
- 	help
- 	  Used to override firmware/bios settings for PCI Express ECRC
- 	  (transaction layer end-to-end CRC checking).
---- a/include/linux/pci.h
-+++ b/include/linux/pci.h
-@@ -1156,6 +1156,8 @@ void pci_walk_bus(struct pci_bus *top, i
- 		  void *userdata);
- int pci_cfg_space_size(struct pci_dev *dev);
- unsigned char pci_bus_max_busnr(struct pci_bus *bus);
-+int pcibios_host_nr(void);
-+int pcibios_1st_host_bus_nr(void);
- void pci_setup_bridge(struct pci_bus *bus);
- resource_size_t pcibios_window_alignment(struct pci_bus *bus,
- 					 unsigned long type);
---- a/include/linux/pci_ids.h
-+++ b/include/linux/pci_ids.h
-@@ -1050,6 +1050,12 @@
- #define PCI_DEVICE_ID_SGI_LITHIUM	0x1002
- #define PCI_DEVICE_ID_SGI_IOC4		0x100a
- 
-+#define PCI_VENDOR_ID_INFINEON		0x15D1
-+#define PCI_DEVICE_ID_INFINEON_DANUBE	0x000F
-+#define PCI_DEVICE_ID_INFINEON_PCIE	0x0011
-+#define PCI_VENDOR_ID_LANTIQ		0x1BEF
-+#define PCI_DEVICE_ID_LANTIQ_PCIE	0x00
-+
- #define PCI_VENDOR_ID_WINBOND		0x10ad
- #define PCI_DEVICE_ID_WINBOND_82C105	0x0105
- #define PCI_DEVICE_ID_WINBOND_83C553	0x0565
diff --git a/target/linux/lantiq/patches-3.18/0002-MIPS-lantiq-dtb-image-hack.patch b/target/linux/lantiq/patches-3.18/0002-MIPS-lantiq-dtb-image-hack.patch
deleted file mode 100644
index 6919c70a25..0000000000
--- a/target/linux/lantiq/patches-3.18/0002-MIPS-lantiq-dtb-image-hack.patch
+++ /dev/null
@@ -1,31 +0,0 @@
-From 17348293f7f8103c97c8d2a6b0ef36eae06ec371 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Wed, 13 Mar 2013 09:36:16 +0100
-Subject: [PATCH 02/36] MIPS: lantiq: dtb image hack
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- arch/mips/lantiq/Makefile |    2 --
- arch/mips/lantiq/prom.c   |    4 +++-
- 2 files changed, 3 insertions(+), 3 deletions(-)
-
---- a/arch/mips/lantiq/prom.c
-+++ b/arch/mips/lantiq/prom.c
-@@ -58,6 +58,8 @@ static void __init prom_init_cmdline(voi
- 	}
- }
- 
-+extern struct boot_param_header __image_dtb;
-+
- void __init plat_mem_setup(void)
- {
- 	ioport_resource.start = IOPORT_RESOURCE_START;
-@@ -71,7 +73,7 @@ void __init plat_mem_setup(void)
- 	 * Load the builtin devicetree. This causes the chosen node to be
- 	 * parsed resulting in our memory appearing
- 	 */
--	__dt_setup_arch(__dtb_start);
-+	__dt_setup_arch(&__image_dtb);
- }
- 
- void __init device_tree_init(void)
diff --git a/target/linux/lantiq/patches-3.18/0003-MIPS-lantiq-handle-vmmc-memory-reservation.patch b/target/linux/lantiq/patches-3.18/0003-MIPS-lantiq-handle-vmmc-memory-reservation.patch
deleted file mode 100644
index cc281b6f8f..0000000000
--- a/target/linux/lantiq/patches-3.18/0003-MIPS-lantiq-handle-vmmc-memory-reservation.patch
+++ /dev/null
@@ -1,86 +0,0 @@
-From 16e315864132b59749faff739230daf4cee9abbb Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Wed, 13 Mar 2013 10:04:01 +0100
-Subject: [PATCH 03/36] MIPS: lantiq: handle vmmc memory reservation
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- arch/mips/lantiq/xway/Makefile |    2 ++
- arch/mips/lantiq/xway/vmmc.c   |   63 ++++++++++++++++++++++++++++++++++++++++
- 2 files changed, 65 insertions(+)
- create mode 100644 arch/mips/lantiq/xway/vmmc.c
-
---- a/arch/mips/lantiq/xway/Makefile
-+++ b/arch/mips/lantiq/xway/Makefile
-@@ -1,3 +1,5 @@
- obj-y := prom.o sysctrl.o clk.o reset.o dma.o gptu.o dcdc.o
- 
-+obj-y += vmmc.o
-+
- obj-$(CONFIG_XRX200_PHY_FW) += xrx200_phy_fw.o
---- /dev/null
-+++ b/arch/mips/lantiq/xway/vmmc.c
-@@ -0,0 +1,63 @@
-+/*
-+ *  This program is free software; you can redistribute it and/or modify it
-+ *  under the terms of the GNU General Public License version 2 as published
-+ *  by the Free Software Foundation.
-+ *
-+ *  Copyright (C) 2012 John Crispin <blogic@openwrt.org>
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/of_platform.h>
-+#include <linux/of_gpio.h>
-+#include <linux/dma-mapping.h>
-+
-+#include <lantiq_soc.h>
-+
-+static unsigned int *cp1_base = 0;
-+unsigned int* ltq_get_cp1_base(void)
-+{
-+	if (!cp1_base)
-+		panic("no cp1 base was set\n");
-+	return cp1_base;
-+}
-+EXPORT_SYMBOL(ltq_get_cp1_base);
-+
-+static int vmmc_probe(struct platform_device *pdev)
-+{
-+#define CP1_SIZE       (1 << 20)
-+	int gpio_count;
-+	dma_addr_t dma;
-+	cp1_base =
-+		(void*)CPHYSADDR(dma_alloc_coherent(NULL, CP1_SIZE, &dma, GFP_ATOMIC));
-+
-+	gpio_count = of_gpio_count(pdev->dev.of_node);
-+	while (gpio_count > 0) {
-+		enum of_gpio_flags flags;
-+		int gpio = of_get_gpio_flags(pdev->dev.of_node, --gpio_count, &flags);
-+		if (gpio_request(gpio, "vmmc-relay"))
-+			continue;
-+		dev_info(&pdev->dev, "requested GPIO %d\n", gpio);
-+		gpio_direction_output(gpio, (flags & OF_GPIO_ACTIVE_LOW) ? (0) : (1));
-+	}
-+
-+	dev_info(&pdev->dev, "reserved %dMB at 0x%p", CP1_SIZE >> 20, cp1_base);
-+
-+	return 0;
-+}
-+
-+static const struct of_device_id vmmc_match[] = {
-+	{ .compatible = "lantiq,vmmc" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, vmmc_match);
-+
-+static struct platform_driver vmmc_driver = {
-+	.probe = vmmc_probe,
-+	.driver = {
-+		.name = "lantiq,vmmc",
-+		.owner = THIS_MODULE,
-+		.of_match_table = vmmc_match,
-+	},
-+};
-+
-+module_platform_driver(vmmc_driver);
diff --git a/target/linux/lantiq/patches-3.18/0004-MIPS-lantiq-add-atm-hack.patch b/target/linux/lantiq/patches-3.18/0004-MIPS-lantiq-add-atm-hack.patch
deleted file mode 100644
index 39b5e5b7ac..0000000000
--- a/target/linux/lantiq/patches-3.18/0004-MIPS-lantiq-add-atm-hack.patch
+++ /dev/null
@@ -1,500 +0,0 @@
-From 9afadf01b1be371ee88491819aa67364684461f9 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Fri, 3 Aug 2012 10:27:25 +0200
-Subject: [PATCH 04/36] MIPS: lantiq: add atm hack
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- arch/mips/include/asm/mach-lantiq/lantiq_atm.h |  196 +++++++++++++++++++++++
- arch/mips/include/asm/mach-lantiq/lantiq_ptm.h |  203 ++++++++++++++++++++++++
- arch/mips/lantiq/irq.c                         |    2 +
- arch/mips/mm/cache.c                           |    2 +
- include/uapi/linux/atm.h                       |    6 +
- net/atm/common.c                               |    6 +
- net/atm/proc.c                                 |    2 +-
- 7 files changed, 416 insertions(+), 1 deletion(-)
- create mode 100644 arch/mips/include/asm/mach-lantiq/lantiq_atm.h
- create mode 100644 arch/mips/include/asm/mach-lantiq/lantiq_ptm.h
-
---- /dev/null
-+++ b/arch/mips/include/asm/mach-lantiq/lantiq_atm.h
-@@ -0,0 +1,196 @@
-+/******************************************************************************
-+**
-+** FILE NAME    : ifx_atm.h
-+** PROJECT      : UEIP
-+** MODULES      : ATM
-+**
-+** DATE         : 17 Jun 2009
-+** AUTHOR       : Xu Liang
-+** DESCRIPTION  : Global ATM driver header file
-+** COPYRIGHT    :       Copyright (c) 2006
-+**                      Infineon Technologies AG
-+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-+**
-+**    This program is free software; you can redistribute it and/or modify
-+**    it under the terms of the GNU General Public License as published by
-+**    the Free Software Foundation; either version 2 of the License, or
-+**    (at your option) any later version.
-+**
-+** HISTORY
-+** $Date        $Author         $Comment
-+** 07 JUL 2009  Xu Liang        Init Version
-+*******************************************************************************/
-+
-+#ifndef IFX_ATM_H
-+#define IFX_ATM_H
-+
-+
-+
-+/*!
-+  \defgroup IFX_ATM UEIP Project - ATM driver module
-+  \brief UEIP Project - ATM driver module, support Danube, Amazon-SE, AR9, VR9.
-+ */
-+
-+/*!
-+  \defgroup IFX_ATM_IOCTL IOCTL Commands
-+  \ingroup IFX_ATM
-+  \brief IOCTL Commands used by user application.
-+ */
-+
-+/*!
-+  \defgroup IFX_ATM_STRUCT Structures
-+  \ingroup IFX_ATM
-+  \brief Structures used by user application.
-+ */
-+
-+/*!
-+  \file ifx_atm.h
-+  \ingroup IFX_ATM
-+  \brief ATM driver header file
-+ */
-+
-+
-+
-+/*
-+ * ####################################
-+ *              Definition
-+ * ####################################
-+ */
-+
-+/*!
-+  \addtogroup IFX_ATM_STRUCT
-+ */
-+/*@{*/
-+
-+/*
-+ *  ATM MIB
-+ */
-+
-+/*!
-+  \struct atm_cell_ifEntry_t
-+  \brief Structure used for Cell Level MIB Counters.
-+
-+  User application use this structure to call IOCTL command "PPE_ATM_MIB_CELL".
-+ */
-+typedef struct {
-+	__u32	ifHCInOctets_h;     /*!< byte counter of ingress cells (upper 32 bits, total 64 bits)   */
-+	__u32	ifHCInOctets_l;     /*!< byte counter of ingress cells (lower 32 bits, total 64 bits)   */
-+	__u32	ifHCOutOctets_h;    /*!< byte counter of egress cells (upper 32 bits, total 64 bits)    */
-+	__u32	ifHCOutOctets_l;    /*!< byte counter of egress cells (lower 32 bits, total 64 bits)    */
-+	__u32	ifInErrors;         /*!< counter of error ingress cells     */
-+	__u32	ifInUnknownProtos;  /*!< counter of unknown ingress cells   */
-+	__u32	ifOutErrors;        /*!< counter of error egress cells      */
-+} atm_cell_ifEntry_t;
-+
-+/*!
-+  \struct atm_aal5_ifEntry_t
-+  \brief Structure used for AAL5 Frame Level MIB Counters.
-+
-+  User application use this structure to call IOCTL command "PPE_ATM_MIB_AAL5".
-+ */
-+typedef struct {
-+	__u32	ifHCInOctets_h;     /*!< byte counter of ingress packets (upper 32 bits, total 64 bits) */
-+	__u32	ifHCInOctets_l;     /*!< byte counter of ingress packets (lower 32 bits, total 64 bits) */
-+	__u32	ifHCOutOctets_h;    /*!< byte counter of egress packets (upper 32 bits, total 64 bits)  */
-+	__u32	ifHCOutOctets_l;    /*!< byte counter of egress packets (lower 32 bits, total 64 bits)  */
-+	__u32	ifInUcastPkts;      /*!< counter of ingress packets         */
-+	__u32	ifOutUcastPkts;     /*!< counter of egress packets          */
-+	__u32	ifInErrors;         /*!< counter of error ingress packets   */
-+	__u32	ifInDiscards;       /*!< counter of dropped ingress packets */
-+	__u32	ifOutErros;         /*!< counter of error egress packets    */
-+	__u32	ifOutDiscards;      /*!< counter of dropped egress packets  */
-+} atm_aal5_ifEntry_t;
-+
-+/*!
-+  \struct atm_aal5_vcc_t
-+  \brief Structure used for per PVC AAL5 Frame Level MIB Counters.
-+
-+  This structure is a part of structure "atm_aal5_vcc_x_t".
-+ */
-+typedef struct {
-+	__u32	aal5VccCrcErrors;       /*!< counter of ingress packets with CRC error  */
-+	__u32	aal5VccSarTimeOuts;     /*!< counter of ingress packets with Re-assemble timeout    */  //no timer support yet
-+	__u32	aal5VccOverSizedSDUs;   /*!< counter of oversized ingress packets       */
-+} atm_aal5_vcc_t;
-+
-+/*!
-+  \struct atm_aal5_vcc_x_t
-+  \brief Structure used for per PVC AAL5 Frame Level MIB Counters.
-+
-+  User application use this structure to call IOCTL command "PPE_ATM_MIB_VCC".
-+ */
-+typedef struct {
-+	int             vpi;        /*!< VPI of the VCC to get MIB counters */
-+	int             vci;        /*!< VCI of the VCC to get MIB counters */
-+	atm_aal5_vcc_t  mib_vcc;    /*!< structure to get MIB counters      */
-+} atm_aal5_vcc_x_t;
-+
-+/*@}*/
-+
-+
-+
-+/*
-+ * ####################################
-+ *                IOCTL
-+ * ####################################
-+ */
-+
-+/*!
-+  \addtogroup IFX_ATM_IOCTL
-+ */
-+/*@{*/
-+
-+/*
-+ *  ioctl Command
-+ */
-+/*!
-+  \brief ATM IOCTL Magic Number
-+ */
-+#define PPE_ATM_IOC_MAGIC       'o'
-+/*!
-+  \brief ATM IOCTL Command - Get Cell Level MIB Counters
-+
-+   This command is obsolete. User can get cell level MIB from DSL API.
-+   This command uses structure "atm_cell_ifEntry_t" as parameter for output of MIB counters.
-+ */
-+#define PPE_ATM_MIB_CELL        _IOW(PPE_ATM_IOC_MAGIC,  0, atm_cell_ifEntry_t)
-+/*!
-+  \brief ATM IOCTL Command - Get AAL5 Level MIB Counters
-+
-+   Get AAL5 packet counters.
-+   This command uses structure "atm_aal5_ifEntry_t" as parameter for output of MIB counters.
-+ */
-+#define PPE_ATM_MIB_AAL5        _IOW(PPE_ATM_IOC_MAGIC,  1, atm_aal5_ifEntry_t)
-+/*!
-+  \brief ATM IOCTL Command - Get Per PVC MIB Counters
-+
-+   Get AAL5 packet counters for each PVC.
-+   This command uses structure "atm_aal5_vcc_x_t" as parameter for input of VPI/VCI information and output of MIB counters.
-+ */
-+#define PPE_ATM_MIB_VCC         _IOWR(PPE_ATM_IOC_MAGIC, 2, atm_aal5_vcc_x_t)
-+/*!
-+  \brief Total Number of ATM IOCTL Commands
-+ */
-+#define PPE_ATM_IOC_MAXNR       3
-+
-+/*@}*/
-+
-+
-+
-+/*
-+ * ####################################
-+ *                 API
-+ * ####################################
-+ */
-+
-+#ifdef __KERNEL__
-+struct port_cell_info {
-+    unsigned int    port_num;
-+    unsigned int    tx_link_rate[2];
-+};
-+#endif
-+
-+
-+
-+#endif  //  IFX_ATM_H
-+
---- /dev/null
-+++ b/arch/mips/include/asm/mach-lantiq/lantiq_ptm.h
-@@ -0,0 +1,203 @@
-+/******************************************************************************
-+**
-+** FILE NAME    : ifx_ptm.h
-+** PROJECT      : UEIP
-+** MODULES      : PTM
-+**
-+** DATE         : 17 Jun 2009
-+** AUTHOR       : Xu Liang
-+** DESCRIPTION  : Global PTM driver header file
-+** COPYRIGHT    :       Copyright (c) 2006
-+**                      Infineon Technologies AG
-+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
-+**
-+**    This program is free software; you can redistribute it and/or modify
-+**    it under the terms of the GNU General Public License as published by
-+**    the Free Software Foundation; either version 2 of the License, or
-+**    (at your option) any later version.
-+**
-+** HISTORY
-+** $Date        $Author         $Comment
-+** 07 JUL 2009  Xu Liang        Init Version
-+*******************************************************************************/
-+
-+#ifndef IFX_PTM_H
-+#define IFX_PTM_H
-+
-+
-+
-+/*!
-+  \defgroup IFX_PTM UEIP Project - PTM driver module
-+  \brief UEIP Project - PTM driver module, support Danube, Amazon-SE, AR9, VR9.
-+ */
-+
-+/*!
-+  \defgroup IFX_PTM_IOCTL IOCTL Commands
-+  \ingroup IFX_PTM
-+  \brief IOCTL Commands used by user application.
-+ */
-+
-+/*!
-+  \defgroup IFX_PTM_STRUCT Structures
-+  \ingroup IFX_PTM
-+  \brief Structures used by user application.
-+ */
-+
-+/*!
-+  \file ifx_ptm.h
-+  \ingroup IFX_PTM
-+  \brief PTM driver header file
-+ */
-+
-+
-+
-+/*
-+ * ####################################
-+ *              Definition
-+ * ####################################
-+ */
-+
-+
-+
-+/*
-+ * ####################################
-+ *                IOCTL
-+ * ####################################
-+ */
-+
-+/*!
-+  \addtogroup IFX_PTM_IOCTL
-+ */
-+/*@{*/
-+
-+/*
-+ *  ioctl Command
-+ */
-+/*!
-+  \brief PTM IOCTL Command - Get codeword MIB counters.
-+
-+  This command uses structure "PTM_CW_IF_ENTRY_T" to get codeword level MIB counters.
-+ */
-+#define IFX_PTM_MIB_CW_GET              SIOCDEVPRIVATE + 1
-+/*!
-+  \brief PTM IOCTL Command - Get packet MIB counters.
-+
-+  This command uses structure "PTM_FRAME_MIB_T" to get packet level MIB counters.
-+ */
-+#define IFX_PTM_MIB_FRAME_GET           SIOCDEVPRIVATE + 2
-+/*!
-+  \brief PTM IOCTL Command - Get firmware configuration (CRC).
-+
-+  This command uses structure "IFX_PTM_CFG_T" to get firmware configuration (CRC).
-+ */
-+#define IFX_PTM_CFG_GET                 SIOCDEVPRIVATE + 3
-+/*!
-+  \brief PTM IOCTL Command - Set firmware configuration (CRC).
-+
-+  This command uses structure "IFX_PTM_CFG_T" to set firmware configuration (CRC).
-+ */
-+#define IFX_PTM_CFG_SET                 SIOCDEVPRIVATE + 4
-+/*!
-+  \brief PTM IOCTL Command - Program priority value to TX queue mapping.
-+
-+  This command uses structure "IFX_PTM_PRIO_Q_MAP_T" to program priority value to TX queue mapping.
-+ */
-+#define IFX_PTM_MAP_PKT_PRIO_TO_Q       SIOCDEVPRIVATE + 14
-+
-+/*@}*/
-+
-+
-+/*!
-+  \addtogroup IFX_PTM_STRUCT
-+ */
-+/*@{*/
-+
-+/*
-+ *  ioctl Data Type
-+ */
-+
-+/*!
-+  \typedef PTM_CW_IF_ENTRY_T
-+  \brief Wrapping of structure "ptm_cw_ifEntry_t".
-+ */
-+/*!
-+  \struct ptm_cw_ifEntry_t
-+  \brief Structure used for CodeWord level MIB counters.
-+ */
-+typedef struct ptm_cw_ifEntry_t {
-+    uint32_t    ifRxNoIdleCodewords;    /*!< output, number of ingress user codeword */
-+    uint32_t    ifRxIdleCodewords;      /*!< output, number of ingress idle codeword */
-+    uint32_t    ifRxCodingViolation;    /*!< output, number of error ingress codeword */
-+    uint32_t    ifTxNoIdleCodewords;    /*!< output, number of egress user codeword */
-+    uint32_t    ifTxIdleCodewords;      /*!< output, number of egress idle codeword */
-+} PTM_CW_IF_ENTRY_T;
-+
-+/*!
-+  \typedef PTM_FRAME_MIB_T
-+  \brief Wrapping of structure "ptm_frame_mib_t".
-+ */
-+/*!
-+  \struct ptm_frame_mib_t
-+  \brief Structure used for packet level MIB counters.
-+ */
-+typedef struct ptm_frame_mib_t {
-+    uint32_t    RxCorrect;      /*!< output, number of ingress packet */
-+    uint32_t    TC_CrcError;    /*!< output, number of egress packet with CRC error */
-+    uint32_t    RxDropped;      /*!< output, number of dropped ingress packet */
-+    uint32_t    TxSend;         /*!< output, number of egress packet */
-+} PTM_FRAME_MIB_T;
-+
-+/*!
-+  \typedef IFX_PTM_CFG_T
-+  \brief Wrapping of structure "ptm_cfg_t".
-+ */
-+/*!
-+  \struct ptm_cfg_t
-+  \brief Structure used for ETH/TC CRC configuration.
-+ */
-+typedef struct ptm_cfg_t {
-+    uint32_t    RxEthCrcPresent;    /*!< input/output, ingress packet has ETH CRC */
-+    uint32_t    RxEthCrcCheck;      /*!< input/output, check ETH CRC of ingress packet */
-+    uint32_t    RxTcCrcCheck;       /*!< input/output, check TC CRC of ingress codeword */
-+    uint32_t    RxTcCrcLen;         /*!< input/output, length of TC CRC of ingress codeword */
-+    uint32_t    TxEthCrcGen;        /*!< input/output, generate ETH CRC for egress packet */
-+    uint32_t    TxTcCrcGen;         /*!< input/output, generate TC CRC for egress codeword */
-+    uint32_t    TxTcCrcLen;         /*!< input/output, length of TC CRC of egress codeword */
-+} IFX_PTM_CFG_T;
-+
-+/*!
-+  \typedef IFX_PTM_PRIO_Q_MAP_T
-+  \brief Wrapping of structure "ppe_prio_q_map".
-+ */
-+/*!
-+  \struct ppe_prio_q_map
-+  \brief Structure used for Priority Value to TX Queue mapping.
-+ */
-+typedef struct ppe_prio_q_map {
-+    int             pkt_prio;
-+    int             qid;
-+    int             vpi;    //  ignored in eth interface
-+    int             vci;    //  ignored in eth interface
-+} IFX_PTM_PRIO_Q_MAP_T;
-+
-+/*@}*/
-+
-+
-+
-+/*
-+ * ####################################
-+ *                 API
-+ * ####################################
-+ */
-+
-+#ifdef __KERNEL__
-+struct port_cell_info {
-+    unsigned int    port_num;
-+    unsigned int    tx_link_rate[2];
-+};
-+#endif
-+
-+
-+
-+#endif  //  IFX_PTM_H
-+
---- a/arch/mips/lantiq/irq.c
-+++ b/arch/mips/lantiq/irq.c
-@@ -14,6 +14,7 @@
- #include <linux/of_platform.h>
- #include <linux/of_address.h>
- #include <linux/of_irq.h>
-+#include <linux/module.h>
- 
- #include <asm/bootinfo.h>
- #include <asm/irq_cpu.h>
-@@ -99,6 +100,7 @@ void ltq_mask_and_ack_irq(struct irq_dat
- 	ltq_icu_w32(im, ltq_icu_r32(im, ier) & ~BIT(offset), ier);
- 	ltq_icu_w32(im, BIT(offset), isr);
- }
-+EXPORT_SYMBOL(ltq_mask_and_ack_irq);
- 
- static void ltq_ack_irq(struct irq_data *d)
- {
---- a/arch/mips/mm/cache.c
-+++ b/arch/mips/mm/cache.c
-@@ -59,6 +59,8 @@ void (*_dma_cache_wback)(unsigned long s
- void (*_dma_cache_inv)(unsigned long start, unsigned long size);
- 
- EXPORT_SYMBOL(_dma_cache_wback_inv);
-+EXPORT_SYMBOL(_dma_cache_wback);
-+EXPORT_SYMBOL(_dma_cache_inv);
- 
- #endif /* CONFIG_DMA_NONCOHERENT || CONFIG_DMA_MAYBE_COHERENT */
- 
---- a/include/uapi/linux/atm.h
-+++ b/include/uapi/linux/atm.h
-@@ -130,8 +130,14 @@
- #define ATM_ABR		4
- #define ATM_ANYCLASS	5		/* compatible with everything */
- 
-+#define ATM_VBR_NRT     ATM_VBR
-+#define ATM_VBR_RT      6
-+#define ATM_UBR_PLUS    7
-+#define ATM_GFR         8
-+
- #define ATM_MAX_PCR	-1		/* maximum available PCR */
- 
-+
- struct atm_trafprm {
- 	unsigned char	traffic_class;	/* traffic class (ATM_UBR, ...) */
- 	int		max_pcr;	/* maximum PCR in cells per second */
---- a/net/atm/common.c
-+++ b/net/atm/common.c
-@@ -62,11 +62,17 @@ static void vcc_remove_socket(struct soc
- 	write_unlock_irq(&vcc_sklist_lock);
- }
- 
-+struct sk_buff* (*ifx_atm_alloc_tx)(struct atm_vcc *, unsigned int) = NULL;
-+EXPORT_SYMBOL(ifx_atm_alloc_tx);
-+
- static struct sk_buff *alloc_tx(struct atm_vcc *vcc, unsigned int size)
- {
- 	struct sk_buff *skb;
- 	struct sock *sk = sk_atm(vcc);
- 
-+	if (ifx_atm_alloc_tx != NULL)
-+		return ifx_atm_alloc_tx(vcc, size);
-+
- 	if (sk_wmem_alloc_get(sk) && !atm_may_send(vcc, size)) {
- 		pr_debug("Sorry: wmem_alloc = %d, size = %d, sndbuf = %d\n",
- 			 sk_wmem_alloc_get(sk), size, sk->sk_sndbuf);
---- a/net/atm/proc.c
-+++ b/net/atm/proc.c
-@@ -154,7 +154,7 @@ static void *vcc_seq_next(struct seq_fil
- static void pvc_info(struct seq_file *seq, struct atm_vcc *vcc)
- {
- 	static const char *const class_name[] = {
--		"off", "UBR", "CBR", "VBR", "ABR"};
-+		"off","UBR","CBR","NTR-VBR","ABR","ANY","RT-VBR","UBR+","GFR"};
- 	static const char *const aal_name[] = {
- 		"---",	"1",	"2",	"3/4",	/*  0- 3 */
- 		"???",	"5",	"???",	"???",	/*  4- 7 */
diff --git a/target/linux/lantiq/patches-3.18/0005-MIPS-lantiq-add-reset-controller-api-support.patch b/target/linux/lantiq/patches-3.18/0005-MIPS-lantiq-add-reset-controller-api-support.patch
deleted file mode 100644
index 31290195b8..0000000000
--- a/target/linux/lantiq/patches-3.18/0005-MIPS-lantiq-add-reset-controller-api-support.patch
+++ /dev/null
@@ -1,90 +0,0 @@
-From 223f1c46e109a8420765aee099a5d1dc4ab7ee98 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Tue, 3 Sep 2013 13:18:12 +0200
-Subject: [PATCH 05/36] MIPS: lantiq: add reset-controller api support
-
-Add a reset-controller binding for the reset registers found on the lantiq
-SoC.
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- arch/mips/lantiq/xway/reset.c |   61 +++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 61 insertions(+)
-
---- a/arch/mips/lantiq/xway/reset.c
-+++ b/arch/mips/lantiq/xway/reset.c
-@@ -14,6 +14,7 @@
- #include <linux/delay.h>
- #include <linux/of_address.h>
- #include <linux/of_platform.h>
-+#include <linux/reset-controller.h>
- 
- #include <asm/reboot.h>
- 
-@@ -113,6 +114,66 @@ void ltq_reset_once(unsigned int module,
- 	ltq_rcu_w32(ltq_rcu_r32(RCU_RST_REQ) & ~module, RCU_RST_REQ);
- }
- 
-+static int ltq_assert_device(struct reset_controller_dev *rcdev,
-+				unsigned long id)
-+{
-+	u32 val;
-+
-+	if (id < 8)
-+		return -1;
-+
-+	val = ltq_rcu_r32(RCU_RST_REQ);
-+	val |= BIT(id);
-+	ltq_rcu_w32(val, RCU_RST_REQ);
-+
-+	return 0;
-+}
-+
-+static int ltq_deassert_device(struct reset_controller_dev *rcdev,
-+				  unsigned long id)
-+{
-+	u32 val;
-+
-+	if (id < 8)
-+		return -1;
-+
-+	val = ltq_rcu_r32(RCU_RST_REQ);
-+	val &= ~BIT(id);
-+	ltq_rcu_w32(val, RCU_RST_REQ);
-+
-+	return 0;
-+}
-+
-+static int ltq_reset_device(struct reset_controller_dev *rcdev,
-+			       unsigned long id)
-+{
-+	ltq_assert_device(rcdev, id);
-+	return ltq_deassert_device(rcdev, id);
-+}
-+
-+static struct reset_control_ops reset_ops = {
-+	.reset = ltq_reset_device,
-+	.assert = ltq_assert_device,
-+	.deassert = ltq_deassert_device,
-+};
-+
-+static struct reset_controller_dev reset_dev = {
-+	.ops			= &reset_ops,
-+	.owner			= THIS_MODULE,
-+	.nr_resets		= 32,
-+	.of_reset_n_cells	= 1,
-+};
-+
-+void ltq_rst_init(void)
-+{
-+	reset_dev.of_node = of_find_compatible_node(NULL, NULL,
-+						"lantiq,xway-reset");
-+	if (!reset_dev.of_node)
-+		pr_err("Failed to find reset controller node");
-+	else
-+		reset_controller_register(&reset_dev);
-+}
-+
- static void ltq_machine_restart(char *command)
- {
- 	local_irq_disable();
diff --git a/target/linux/lantiq/patches-3.18/0006-MIPS-lantiq-reboot-gphy-on-restart.patch b/target/linux/lantiq/patches-3.18/0006-MIPS-lantiq-reboot-gphy-on-restart.patch
deleted file mode 100644
index 1af4fa7b22..0000000000
--- a/target/linux/lantiq/patches-3.18/0006-MIPS-lantiq-reboot-gphy-on-restart.patch
+++ /dev/null
@@ -1,29 +0,0 @@
-From f81979f4b297693ac70616feaa4a79bdcb11db35 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Thu, 7 Aug 2014 18:55:57 +0200
-Subject: [PATCH 06/36] MIPS: lantiq: reboot gphy on restart
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- arch/mips/lantiq/xway/reset.c |    9 ++++++++-
- 1 file changed, 8 insertions(+), 1 deletion(-)
-
---- a/arch/mips/lantiq/xway/reset.c
-+++ b/arch/mips/lantiq/xway/reset.c
-@@ -176,8 +176,15 @@ void ltq_rst_init(void)
- 
- static void ltq_machine_restart(char *command)
- {
-+	u32 val = ltq_rcu_r32(RCU_RST_REQ);
-+
-+	if (of_device_is_compatible(ltq_rcu_np, "lantiq,rcu-xrx200"))
-+		val |= RCU_RD_GPHY1_XRX200 | RCU_RD_GPHY0_XRX200;
-+
-+	val |= RCU_RD_SRST;
-+
- 	local_irq_disable();
--	ltq_rcu_w32(ltq_rcu_r32(RCU_RST_REQ) | RCU_RD_SRST, RCU_RST_REQ);
-+	ltq_rcu_w32(val, RCU_RST_REQ);
- 	unreachable();
- }
- 
diff --git a/target/linux/lantiq/patches-3.18/0007-MIPS-lantiq-add-basic-tffs-driver.patch b/target/linux/lantiq/patches-3.18/0007-MIPS-lantiq-add-basic-tffs-driver.patch
deleted file mode 100644
index 70813738cc..0000000000
--- a/target/linux/lantiq/patches-3.18/0007-MIPS-lantiq-add-basic-tffs-driver.patch
+++ /dev/null
@@ -1,111 +0,0 @@
-From d27ec8bb97db0f60d81ab255d51ac4e967362067 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Thu, 7 Aug 2014 18:34:19 +0200
-Subject: [PATCH 07/36] MIPS: lantiq: add basic tffs driver
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- arch/mips/lantiq/xway/Makefile |    2 +-
- arch/mips/lantiq/xway/tffs.c   |   87 ++++++++++++++++++++++++++++++++++++++++
- 2 files changed, 88 insertions(+), 1 deletion(-)
- create mode 100644 arch/mips/lantiq/xway/tffs.c
-
---- a/arch/mips/lantiq/xway/Makefile
-+++ b/arch/mips/lantiq/xway/Makefile
-@@ -1,5 +1,5 @@
- obj-y := prom.o sysctrl.o clk.o reset.o dma.o gptu.o dcdc.o
- 
--obj-y += vmmc.o
-+obj-y += vmmc.o tffs.o
- 
- obj-$(CONFIG_XRX200_PHY_FW) += xrx200_phy_fw.o
---- /dev/null
-+++ b/arch/mips/lantiq/xway/tffs.c
-@@ -0,0 +1,87 @@
-+#include <linux/module.h>
-+#include <linux/mtd/mtd.h>
-+#include <linux/errno.h>
-+#include <linux/slab.h>
-+
-+struct tffs_entry {
-+    uint16_t id;
-+    uint16_t len;
-+};
-+
-+static struct tffs_id {
-+	uint32_t id;
-+	char *name;
-+	unsigned char *val;
-+	uint32_t offset;
-+	uint32_t len;
-+} ids[] = {
-+	{ 0x01A9, "annex" },
-+	{ 0x0188, "maca" },
-+	{ 0x0189, "macb" },
-+	{ 0x018a, "macwlan" },
-+	{ 0x0195, "macwlan2" },
-+	{ 0x018b, "macdsl" },
-+	{ 0x01C2, "webgui_pass" },
-+	{ 0x01AB, "wlan_key" },
-+};
-+
-+static struct mtd_info *tffs1, *tffs2;
-+
-+static struct tffs_id* tffs_find_id(int id)
-+{
-+	int i;
-+
-+	for (i = 0; i < ARRAY_SIZE(ids); i++)
-+		if (id == ids[i].id)
-+			return &ids[i];
-+
-+	return NULL;
-+}
-+
-+static void tffs_index(void)
-+{
-+	struct tffs_entry *E = NULL;
-+	struct tffs_entry entry;
-+	int ret, retlen;
-+
-+	while ((unsigned int) E + sizeof(struct tffs_entry) < tffs2->size) {
-+		struct tffs_id *id;
-+		int len;
-+
-+		ret = mtd_read(tffs2, (unsigned int) E, sizeof(struct tffs_entry), &retlen, (unsigned char *)&entry);
-+		if (ret)
-+			return;
-+
-+		if (entry.id == 0xffff)
-+			return;
-+
-+		id = tffs_find_id(entry.id);
-+		if (id) {
-+			id->offset = (uint32_t) E;
-+			id->len = entry.len;
-+			id->val = kzalloc(entry.len + 1, GFP_KERNEL);
-+			mtd_read(tffs2, ((unsigned int) E) + sizeof(struct tffs_entry), entry.len, &retlen, id->val);
-+
-+		}
-+		//printk(KERN_INFO "found entry at 0x%08X-> [<0x%x> %u bytes]\n", (uint32_t) E, entry.id, entry.len);
-+		if (id && id->name)
-+			printk(KERN_INFO "found entry name -> %s=%s\n", id->name, id->val);
-+
-+		len = (entry.len + 3) & ~0x03;
-+		E = (struct tffs_entry *)(((unsigned int)E) + sizeof(struct tffs_entry) + len);
-+	}
-+}
-+
-+static int __init tffs_init(void)
-+{
-+	tffs1 = get_mtd_device_nm("tffs (1)");
-+	tffs2 = get_mtd_device_nm("tffs (2)");
-+	if (IS_ERR(tffs1) || IS_ERR(tffs2))
-+		return -1;
-+
-+	tffs_index();
-+
-+	return 0;
-+}
-+late_initcall(tffs_init);
-+
diff --git a/target/linux/lantiq/patches-3.18/0008-MIPS-lantiq-backport-old-timer-code.patch b/target/linux/lantiq/patches-3.18/0008-MIPS-lantiq-backport-old-timer-code.patch
deleted file mode 100644
index 55255037fa..0000000000
--- a/target/linux/lantiq/patches-3.18/0008-MIPS-lantiq-backport-old-timer-code.patch
+++ /dev/null
@@ -1,1028 +0,0 @@
-From 94800350cb8d2f29dda2206b5e9a3772024ee168 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Thu, 7 Aug 2014 18:30:56 +0200
-Subject: [PATCH 08/36] MIPS: lantiq: backport old timer code
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- arch/mips/include/asm/mach-lantiq/lantiq_timer.h |  155 ++++
- arch/mips/lantiq/xway/Makefile                   |    2 +-
- arch/mips/lantiq/xway/timer.c                    |  845 ++++++++++++++++++++++
- 3 files changed, 1001 insertions(+), 1 deletion(-)
- create mode 100644 arch/mips/include/asm/mach-lantiq/lantiq_timer.h
- create mode 100644 arch/mips/lantiq/xway/timer.c
-
---- /dev/null
-+++ b/arch/mips/include/asm/mach-lantiq/lantiq_timer.h
-@@ -0,0 +1,155 @@
-+#ifndef __DANUBE_GPTU_DEV_H__2005_07_26__10_19__
-+#define __DANUBE_GPTU_DEV_H__2005_07_26__10_19__
-+
-+
-+/******************************************************************************
-+       Copyright (c) 2002, Infineon Technologies.  All rights reserved.
-+
-+                               No Warranty
-+   Because the program is licensed free of charge, there is no warranty for
-+   the program, to the extent permitted by applicable law.  Except when
-+   otherwise stated in writing the copyright holders and/or other parties
-+   provide the program "as is" without warranty of any kind, either
-+   expressed or implied, including, but not limited to, the implied
-+   warranties of merchantability and fitness for a particular purpose. The
-+   entire risk as to the quality and performance of the program is with
-+   you.  should the program prove defective, you assume the cost of all
-+   necessary servicing, repair or correction.
-+
-+   In no event unless required by applicable law or agreed to in writing
-+   will any copyright holder, or any other party who may modify and/or
-+   redistribute the program as permitted above, be liable to you for
-+   damages, including any general, special, incidental or consequential
-+   damages arising out of the use or inability to use the program
-+   (including but not limited to loss of data or data being rendered
-+   inaccurate or losses sustained by you or third parties or a failure of
-+   the program to operate with any other programs), even if such holder or
-+   other party has been advised of the possibility of such damages.
-+******************************************************************************/
-+
-+
-+/*
-+ * ####################################
-+ *              Definition
-+ * ####################################
-+ */
-+
-+/*
-+ *  Available Timer/Counter Index
-+ */
-+#define TIMER(n, X)                     (n * 2 + (X ? 1 : 0))
-+#define TIMER_ANY                       0x00
-+#define TIMER1A                         TIMER(1, 0)
-+#define TIMER1B                         TIMER(1, 1)
-+#define TIMER2A                         TIMER(2, 0)
-+#define TIMER2B                         TIMER(2, 1)
-+#define TIMER3A                         TIMER(3, 0)
-+#define TIMER3B                         TIMER(3, 1)
-+
-+/*
-+ *  Flag of Timer/Counter
-+ *  These flags specify the way in which timer is configured.
-+ */
-+/*  Bit size of timer/counter.                      */
-+#define TIMER_FLAG_16BIT                0x0000
-+#define TIMER_FLAG_32BIT                0x0001
-+/*  Switch between timer and counter.               */
-+#define TIMER_FLAG_TIMER                0x0000
-+#define TIMER_FLAG_COUNTER              0x0002
-+/*  Stop or continue when overflowing/underflowing. */
-+#define TIMER_FLAG_ONCE                 0x0000
-+#define TIMER_FLAG_CYCLIC               0x0004
-+/*  Count up or counter down.                       */
-+#define TIMER_FLAG_UP                   0x0000
-+#define TIMER_FLAG_DOWN                 0x0008
-+/*  Count on specific level or edge.                */
-+#define TIMER_FLAG_HIGH_LEVEL_SENSITIVE 0x0000
-+#define TIMER_FLAG_LOW_LEVEL_SENSITIVE  0x0040
-+#define TIMER_FLAG_RISE_EDGE            0x0010
-+#define TIMER_FLAG_FALL_EDGE            0x0020
-+#define TIMER_FLAG_ANY_EDGE             0x0030
-+/*  Signal is syncronous to module clock or not.    */
-+#define TIMER_FLAG_UNSYNC               0x0000
-+#define TIMER_FLAG_SYNC                 0x0080
-+/*  Different interrupt handle type.                */
-+#define TIMER_FLAG_NO_HANDLE            0x0000
-+#if defined(__KERNEL__)
-+    #define TIMER_FLAG_CALLBACK_IN_IRQ  0x0100
-+#endif  //  defined(__KERNEL__)
-+#define TIMER_FLAG_SIGNAL               0x0300
-+/*  Internal clock source or external clock source  */
-+#define TIMER_FLAG_INT_SRC              0x0000
-+#define TIMER_FLAG_EXT_SRC              0x1000
-+
-+
-+/*
-+ *  ioctl Command
-+ */
-+#define GPTU_REQUEST_TIMER              0x01    /*  General method to setup timer/counter.  */
-+#define GPTU_FREE_TIMER                 0x02    /*  Free timer/counter.                     */
-+#define GPTU_START_TIMER                0x03    /*  Start or resume timer/counter.          */
-+#define GPTU_STOP_TIMER                 0x04    /*  Suspend timer/counter.                  */
-+#define GPTU_GET_COUNT_VALUE            0x05    /*  Get current count value.                */
-+#define GPTU_CALCULATE_DIVIDER          0x06    /*  Calculate timer divider from given freq.*/
-+#define GPTU_SET_TIMER                  0x07    /*  Simplified method to setup timer.       */
-+#define GPTU_SET_COUNTER                0x08    /*  Simplified method to setup counter.     */
-+
-+/*
-+ *  Data Type Used to Call ioctl
-+ */
-+struct gptu_ioctl_param {
-+    unsigned int                        timer;  /*  In command GPTU_REQUEST_TIMER, GPTU_SET_TIMER, and  *
-+                                                 *  GPTU_SET_COUNTER, this field is ID of expected      *
-+                                                 *  timer/counter. If it's zero, a timer/counter would  *
-+                                                 *  be dynamically allocated and ID would be stored in  *
-+                                                 *  this field.                                         *
-+                                                 *  In command GPTU_GET_COUNT_VALUE, this field is      *
-+                                                 *  ignored.                                            *
-+                                                 *  In other command, this field is ID of timer/counter *
-+                                                 *  allocated.                                          */
-+    unsigned int                        flag;   /*  In command GPTU_REQUEST_TIMER, GPTU_SET_TIMER, and  *
-+                                                 *  GPTU_SET_COUNTER, this field contains flags to      *
-+                                                 *  specify how to configure timer/counter.             *
-+                                                 *  In command GPTU_START_TIMER, zero indicate start    *
-+                                                 *  and non-zero indicate resume timer/counter.         *
-+                                                 *  In other command, this field is ignored.            */
-+    unsigned long                       value;  /*  In command GPTU_REQUEST_TIMER, this field contains  *
-+                                                 *  init/reload value.                                  *
-+                                                 *  In command GPTU_SET_TIMER, this field contains      *
-+                                                 *  frequency (0.001Hz) of timer.                       *
-+                                                 *  In command GPTU_GET_COUNT_VALUE, current count      *
-+                                                 *  value would be stored in this field.                *
-+                                                 *  In command GPTU_CALCULATE_DIVIDER, this field       *
-+                                                 *  contains frequency wanted, and after calculation,   *
-+                                                 *  divider would be stored in this field to overwrite  *
-+                                                 *  the frequency.                                      *
-+                                                 *  In other command, this field is ignored.            */
-+    int                                 pid;    /*  In command GPTU_REQUEST_TIMER and GPTU_SET_TIMER,   *
-+                                                 *  if signal is required, this field contains process  *
-+                                                 *  ID to which signal would be sent.                   *
-+                                                 *  In other command, this field is ignored.            */
-+    int                                 sig;    /*  In command GPTU_REQUEST_TIMER and GPTU_SET_TIMER,   *
-+                                                 *  if signal is required, this field contains signal   *
-+                                                 *  number which would be sent.                         *
-+                                                 *  In other command, this field is ignored.            */
-+};
-+
-+/*
-+ * ####################################
-+ *              Data Type
-+ * ####################################
-+ */
-+typedef void (*timer_callback)(unsigned long arg);
-+
-+extern int lq_request_timer(unsigned int, unsigned int, unsigned long, unsigned long, unsigned long);
-+extern int lq_free_timer(unsigned int);
-+extern int lq_start_timer(unsigned int, int);
-+extern int lq_stop_timer(unsigned int);
-+extern int lq_reset_counter_flags(u32 timer, u32 flags);
-+extern int lq_get_count_value(unsigned int, unsigned long *);
-+extern u32 lq_cal_divider(unsigned long);
-+extern int lq_set_timer(unsigned int, unsigned int, int, int, unsigned int, unsigned long, unsigned long);
-+extern int lq_set_counter(unsigned int timer, unsigned int flag,
-+	u32 reload, unsigned long arg1, unsigned long arg2);
-+
-+#endif /* __DANUBE_GPTU_DEV_H__2005_07_26__10_19__ */
---- a/arch/mips/lantiq/xway/Makefile
-+++ b/arch/mips/lantiq/xway/Makefile
-@@ -1,4 +1,4 @@
--obj-y := prom.o sysctrl.o clk.o reset.o dma.o gptu.o dcdc.o
-+obj-y := prom.o sysctrl.o clk.o reset.o dma.o timer.o dcdc.o
- 
- obj-y += vmmc.o tffs.o
- 
---- /dev/null
-+++ b/arch/mips/lantiq/xway/timer.c
-@@ -0,0 +1,845 @@
-+#ifndef CONFIG_SOC_AMAZON_SE
-+
-+#include <linux/kernel.h>
-+#include <linux/module.h>
-+#include <linux/version.h>
-+#include <linux/types.h>
-+#include <linux/fs.h>
-+#include <linux/miscdevice.h>
-+#include <linux/init.h>
-+#include <linux/uaccess.h>
-+#include <linux/unistd.h>
-+#include <linux/errno.h>
-+#include <linux/interrupt.h>
-+#include <linux/sched.h>
-+
-+#include <asm/irq.h>
-+#include <asm/div64.h>
-+#include "../clk.h"
-+
-+#include <lantiq_soc.h>
-+#include <lantiq_irq.h>
-+#include <lantiq_timer.h>
-+
-+#define MAX_NUM_OF_32BIT_TIMER_BLOCKS	6
-+
-+#ifdef TIMER1A
-+#define FIRST_TIMER			TIMER1A
-+#else
-+#define FIRST_TIMER			2
-+#endif
-+
-+/*
-+ *  GPTC divider is set or not.
-+ */
-+#define GPTU_CLC_RMC_IS_SET		0
-+
-+/*
-+ *  Timer Interrupt (IRQ)
-+ */
-+/*  Must be adjusted when ICU driver is available */
-+#define TIMER_INTERRUPT			(INT_NUM_IM3_IRL0 + 22)
-+
-+/*
-+ *  Bits Operation
-+ */
-+#define GET_BITS(x, msb, lsb)		\
-+	(((x) & ((1 << ((msb) + 1)) - 1)) >> (lsb))
-+#define SET_BITS(x, msb, lsb, value)	\
-+	(((x) & ~(((1 << ((msb) + 1)) - 1) ^ ((1 << (lsb)) - 1))) | \
-+	(((value) & ((1 << (1 + (msb) - (lsb))) - 1)) << (lsb)))
-+
-+/*
-+ *  GPTU Register Mapping
-+ */
-+#define LQ_GPTU			(KSEG1 + 0x1E100A00)
-+#define LQ_GPTU_CLC		((volatile u32 *)(LQ_GPTU + 0x0000))
-+#define LQ_GPTU_ID			((volatile u32 *)(LQ_GPTU + 0x0008))
-+#define LQ_GPTU_CON(n, X)		((volatile u32 *)(LQ_GPTU + 0x0010 + ((X) * 4) + ((n) - 1) * 0x0020))	/* X must be either A or B */
-+#define LQ_GPTU_RUN(n, X)		((volatile u32 *)(LQ_GPTU + 0x0018 + ((X) * 4) + ((n) - 1) * 0x0020))	/* X must be either A or B */
-+#define LQ_GPTU_RELOAD(n, X)	((volatile u32 *)(LQ_GPTU + 0x0020 + ((X) * 4) + ((n) - 1) * 0x0020))	/* X must be either A or B */
-+#define LQ_GPTU_COUNT(n, X)	((volatile u32 *)(LQ_GPTU + 0x0028 + ((X) * 4) + ((n) - 1) * 0x0020))	/* X must be either A or B */
-+#define LQ_GPTU_IRNEN		((volatile u32 *)(LQ_GPTU + 0x00F4))
-+#define LQ_GPTU_IRNICR		((volatile u32 *)(LQ_GPTU + 0x00F8))
-+#define LQ_GPTU_IRNCR		((volatile u32 *)(LQ_GPTU + 0x00FC))
-+
-+/*
-+ *  Clock Control Register
-+ */
-+#define GPTU_CLC_SMC			GET_BITS(*LQ_GPTU_CLC, 23, 16)
-+#define GPTU_CLC_RMC			GET_BITS(*LQ_GPTU_CLC, 15, 8)
-+#define GPTU_CLC_FSOE			(*LQ_GPTU_CLC & (1 << 5))
-+#define GPTU_CLC_EDIS			(*LQ_GPTU_CLC & (1 << 3))
-+#define GPTU_CLC_SPEN			(*LQ_GPTU_CLC & (1 << 2))
-+#define GPTU_CLC_DISS			(*LQ_GPTU_CLC & (1 << 1))
-+#define GPTU_CLC_DISR			(*LQ_GPTU_CLC & (1 << 0))
-+
-+#define GPTU_CLC_SMC_SET(value)		SET_BITS(0, 23, 16, (value))
-+#define GPTU_CLC_RMC_SET(value)		SET_BITS(0, 15, 8, (value))
-+#define GPTU_CLC_FSOE_SET(value)	((value) ? (1 << 5) : 0)
-+#define GPTU_CLC_SBWE_SET(value)	((value) ? (1 << 4) : 0)
-+#define GPTU_CLC_EDIS_SET(value)	((value) ? (1 << 3) : 0)
-+#define GPTU_CLC_SPEN_SET(value)	((value) ? (1 << 2) : 0)
-+#define GPTU_CLC_DISR_SET(value)	((value) ? (1 << 0) : 0)
-+
-+/*
-+ *  ID Register
-+ */
-+#define GPTU_ID_ID			GET_BITS(*LQ_GPTU_ID, 15, 8)
-+#define GPTU_ID_CFG			GET_BITS(*LQ_GPTU_ID, 7, 5)
-+#define GPTU_ID_REV			GET_BITS(*LQ_GPTU_ID, 4, 0)
-+
-+/*
-+ *  Control Register of Timer/Counter nX
-+ *    n is the index of block (1 based index)
-+ *    X is either A or B
-+ */
-+#define GPTU_CON_SRC_EG(n, X)		(*LQ_GPTU_CON(n, X) & (1 << 10))
-+#define GPTU_CON_SRC_EXT(n, X)		(*LQ_GPTU_CON(n, X) & (1 << 9))
-+#define GPTU_CON_SYNC(n, X)		(*LQ_GPTU_CON(n, X) & (1 << 8))
-+#define GPTU_CON_EDGE(n, X)		GET_BITS(*LQ_GPTU_CON(n, X), 7, 6)
-+#define GPTU_CON_INV(n, X)		(*LQ_GPTU_CON(n, X) & (1 << 5))
-+#define GPTU_CON_EXT(n, X)		(*LQ_GPTU_CON(n, A) & (1 << 4))	/* Timer/Counter B does not have this bit */
-+#define GPTU_CON_STP(n, X)		(*LQ_GPTU_CON(n, X) & (1 << 3))
-+#define GPTU_CON_CNT(n, X)		(*LQ_GPTU_CON(n, X) & (1 << 2))
-+#define GPTU_CON_DIR(n, X)		(*LQ_GPTU_CON(n, X) & (1 << 1))
-+#define GPTU_CON_EN(n, X)		(*LQ_GPTU_CON(n, X) & (1 << 0))
-+
-+#define GPTU_CON_SRC_EG_SET(value)	((value) ? 0 : (1 << 10))
-+#define GPTU_CON_SRC_EXT_SET(value)	((value) ? (1 << 9) : 0)
-+#define GPTU_CON_SYNC_SET(value)	((value) ? (1 << 8) : 0)
-+#define GPTU_CON_EDGE_SET(value)	SET_BITS(0, 7, 6, (value))
-+#define GPTU_CON_INV_SET(value)		((value) ? (1 << 5) : 0)
-+#define GPTU_CON_EXT_SET(value)		((value) ? (1 << 4) : 0)
-+#define GPTU_CON_STP_SET(value)		((value) ? (1 << 3) : 0)
-+#define GPTU_CON_CNT_SET(value)		((value) ? (1 << 2) : 0)
-+#define GPTU_CON_DIR_SET(value)		((value) ? (1 << 1) : 0)
-+
-+#define GPTU_RUN_RL_SET(value)		((value) ? (1 << 2) : 0)
-+#define GPTU_RUN_CEN_SET(value)		((value) ? (1 << 1) : 0)
-+#define GPTU_RUN_SEN_SET(value)		((value) ? (1 << 0) : 0)
-+
-+#define GPTU_IRNEN_TC_SET(n, X, value)	((value) ? (1 << (((n) - 1) * 2 + (X))) : 0)
-+#define GPTU_IRNCR_TC_SET(n, X, value)	((value) ? (1 << (((n) - 1) * 2 + (X))) : 0)
-+
-+#define TIMER_FLAG_MASK_SIZE(x)		(x & 0x0001)
-+#define TIMER_FLAG_MASK_TYPE(x)		(x & 0x0002)
-+#define TIMER_FLAG_MASK_STOP(x)		(x & 0x0004)
-+#define TIMER_FLAG_MASK_DIR(x)		(x & 0x0008)
-+#define TIMER_FLAG_NONE_EDGE		0x0000
-+#define TIMER_FLAG_MASK_EDGE(x)		(x & 0x0030)
-+#define TIMER_FLAG_REAL			0x0000
-+#define TIMER_FLAG_INVERT		0x0040
-+#define TIMER_FLAG_MASK_INVERT(x)	(x & 0x0040)
-+#define TIMER_FLAG_MASK_TRIGGER(x)	(x & 0x0070)
-+#define TIMER_FLAG_MASK_SYNC(x)		(x & 0x0080)
-+#define TIMER_FLAG_CALLBACK_IN_HB	0x0200
-+#define TIMER_FLAG_MASK_HANDLE(x)	(x & 0x0300)
-+#define TIMER_FLAG_MASK_SRC(x)		(x & 0x1000)
-+
-+struct timer_dev_timer {
-+	unsigned int f_irq_on;
-+	unsigned int irq;
-+	unsigned int flag;
-+	unsigned long arg1;
-+	unsigned long arg2;
-+};
-+
-+struct timer_dev {
-+	struct mutex gptu_mutex;
-+	unsigned int number_of_timers;
-+	unsigned int occupation;
-+	unsigned int f_gptu_on;
-+	struct timer_dev_timer timer[MAX_NUM_OF_32BIT_TIMER_BLOCKS * 2];
-+};
-+
-+
-+unsigned int ltq_get_fpi_bus_clock(int fpi) {
-+	struct clk *clk = clk_get_fpi();
-+	return clk_get_rate(clk);
-+}
-+
-+
-+static long gptu_ioctl(struct file *, unsigned int, unsigned long);
-+static int gptu_open(struct inode *, struct file *);
-+static int gptu_release(struct inode *, struct file *);
-+
-+static struct file_operations gptu_fops = {
-+	.owner = THIS_MODULE,
-+	.unlocked_ioctl = gptu_ioctl,
-+	.open = gptu_open,
-+	.release = gptu_release
-+};
-+
-+static struct miscdevice gptu_miscdev = {
-+	.minor = MISC_DYNAMIC_MINOR,
-+	.name = "gptu",
-+	.fops = &gptu_fops,
-+};
-+
-+static struct timer_dev timer_dev;
-+
-+static irqreturn_t timer_irq_handler(int irq, void *p)
-+{
-+	unsigned int timer;
-+	unsigned int flag;
-+	struct timer_dev_timer *dev_timer = (struct timer_dev_timer *)p;
-+
-+	timer = irq - TIMER_INTERRUPT;
-+	if (timer < timer_dev.number_of_timers
-+		&& dev_timer == &timer_dev.timer[timer]) {
-+		/*  Clear interrupt.    */
-+		ltq_w32(1 << timer, LQ_GPTU_IRNCR);
-+
-+		/*  Call user hanler or signal. */
-+		flag = dev_timer->flag;
-+		if (!(timer & 0x01)
-+			|| TIMER_FLAG_MASK_SIZE(flag) == TIMER_FLAG_16BIT) {
-+			/* 16-bit timer or timer A of 32-bit timer  */
-+			switch (TIMER_FLAG_MASK_HANDLE(flag)) {
-+			case TIMER_FLAG_CALLBACK_IN_IRQ:
-+			case TIMER_FLAG_CALLBACK_IN_HB:
-+				if (dev_timer->arg1)
-+					(*(timer_callback)dev_timer->arg1)(dev_timer->arg2);
-+				break;
-+			case TIMER_FLAG_SIGNAL:
-+				send_sig((int)dev_timer->arg2, (struct task_struct *)dev_timer->arg1, 0);
-+				break;
-+			}
-+		}
-+	}
-+	return IRQ_HANDLED;
-+}
-+
-+static inline void lq_enable_gptu(void)
-+{
-+	struct clk *clk = clk_get_sys("1e100a00.gptu", NULL);
-+	clk_enable(clk);
-+
-+	//ltq_pmu_enable(PMU_GPT);
-+
-+	/*  Set divider as 1, disable write protection for SPEN, enable module. */
-+	*LQ_GPTU_CLC =
-+		GPTU_CLC_SMC_SET(0x00) |
-+		GPTU_CLC_RMC_SET(0x01) |
-+		GPTU_CLC_FSOE_SET(0) |
-+		GPTU_CLC_SBWE_SET(1) |
-+		GPTU_CLC_EDIS_SET(0) |
-+		GPTU_CLC_SPEN_SET(0) |
-+		GPTU_CLC_DISR_SET(0);
-+}
-+
-+static inline void lq_disable_gptu(void)
-+{
-+	struct clk *clk = clk_get_sys("1e100a00.gptu", NULL);
-+	ltq_w32(0x00, LQ_GPTU_IRNEN);
-+	ltq_w32(0xfff, LQ_GPTU_IRNCR);
-+
-+	/*  Set divider as 0, enable write protection for SPEN, disable module. */
-+	*LQ_GPTU_CLC =
-+		GPTU_CLC_SMC_SET(0x00) |
-+		GPTU_CLC_RMC_SET(0x00) |
-+		GPTU_CLC_FSOE_SET(0) |
-+		GPTU_CLC_SBWE_SET(0) |
-+		GPTU_CLC_EDIS_SET(0) |
-+		GPTU_CLC_SPEN_SET(0) |
-+		GPTU_CLC_DISR_SET(1);
-+
-+	clk_enable(clk);
-+}
-+
-+int lq_request_timer(unsigned int timer, unsigned int flag,
-+	unsigned long value, unsigned long arg1, unsigned long arg2)
-+{
-+	int ret = 0;
-+	unsigned int con_reg, irnen_reg;
-+	int n, X;
-+
-+	if (timer >= FIRST_TIMER + timer_dev.number_of_timers)
-+		return -EINVAL;
-+
-+	printk(KERN_INFO "request_timer(%d, 0x%08X, %lu)...",
-+		timer, flag, value);
-+
-+	if (TIMER_FLAG_MASK_SIZE(flag) == TIMER_FLAG_16BIT)
-+		value &= 0xFFFF;
-+	else
-+		timer &= ~0x01;
-+
-+	mutex_lock(&timer_dev.gptu_mutex);
-+
-+	/*
-+	 *  Allocate timer.
-+	 */
-+	if (timer < FIRST_TIMER) {
-+		unsigned int mask;
-+		unsigned int shift;
-+		/* This takes care of TIMER1B which is the only choice for Voice TAPI system */
-+		unsigned int offset = TIMER2A;
-+
-+		/*
-+		 *  Pick up a free timer.
-+		 */
-+		if (TIMER_FLAG_MASK_SIZE(flag) == TIMER_FLAG_16BIT) {
-+			mask = 1 << offset;
-+			shift = 1;
-+		} else {
-+			mask = 3 << offset;
-+			shift = 2;
-+		}
-+		for (timer = offset;
-+		     timer < offset + timer_dev.number_of_timers;
-+		     timer += shift, mask <<= shift)
-+			if (!(timer_dev.occupation & mask)) {
-+				timer_dev.occupation |= mask;
-+				break;
-+			}
-+		if (timer >= offset + timer_dev.number_of_timers) {
-+			printk("failed![%d]\n", __LINE__);
-+			mutex_unlock(&timer_dev.gptu_mutex);
-+			return -EINVAL;
-+		} else
-+			ret = timer;
-+	} else {
-+		register unsigned int mask;
-+
-+		/*
-+		 *  Check if the requested timer is free.
-+		 */
-+		mask = (TIMER_FLAG_MASK_SIZE(flag) == TIMER_FLAG_16BIT ? 1 : 3) << timer;
-+		if ((timer_dev.occupation & mask)) {
-+			printk("failed![%d] mask %#x, timer_dev.occupation %#x\n",
-+				__LINE__, mask, timer_dev.occupation);
-+			mutex_unlock(&timer_dev.gptu_mutex);
-+			return -EBUSY;
-+		} else {
-+			timer_dev.occupation |= mask;
-+			ret = 0;
-+		}
-+	}
-+
-+	/*
-+	 *  Prepare control register value.
-+	 */
-+	switch (TIMER_FLAG_MASK_EDGE(flag)) {
-+	default:
-+	case TIMER_FLAG_NONE_EDGE:
-+		con_reg = GPTU_CON_EDGE_SET(0x00);
-+		break;
-+	case TIMER_FLAG_RISE_EDGE:
-+		con_reg = GPTU_CON_EDGE_SET(0x01);
-+		break;
-+	case TIMER_FLAG_FALL_EDGE:
-+		con_reg = GPTU_CON_EDGE_SET(0x02);
-+		break;
-+	case TIMER_FLAG_ANY_EDGE:
-+		con_reg = GPTU_CON_EDGE_SET(0x03);
-+		break;
-+	}
-+	if (TIMER_FLAG_MASK_TYPE(flag) == TIMER_FLAG_TIMER)
-+		con_reg |=
-+			TIMER_FLAG_MASK_SRC(flag) ==
-+			TIMER_FLAG_EXT_SRC ? GPTU_CON_SRC_EXT_SET(1) :
-+			GPTU_CON_SRC_EXT_SET(0);
-+	else
-+		con_reg |=
-+			TIMER_FLAG_MASK_SRC(flag) ==
-+			TIMER_FLAG_EXT_SRC ? GPTU_CON_SRC_EG_SET(1) :
-+			GPTU_CON_SRC_EG_SET(0);
-+	con_reg |=
-+		TIMER_FLAG_MASK_SYNC(flag) ==
-+		TIMER_FLAG_UNSYNC ? GPTU_CON_SYNC_SET(0) :
-+		GPTU_CON_SYNC_SET(1);
-+	con_reg |=
-+		TIMER_FLAG_MASK_INVERT(flag) ==
-+		TIMER_FLAG_REAL ? GPTU_CON_INV_SET(0) : GPTU_CON_INV_SET(1);
-+	con_reg |=
-+		TIMER_FLAG_MASK_SIZE(flag) ==
-+		TIMER_FLAG_16BIT ? GPTU_CON_EXT_SET(0) :
-+		GPTU_CON_EXT_SET(1);
-+	con_reg |=
-+		TIMER_FLAG_MASK_STOP(flag) ==
-+		TIMER_FLAG_ONCE ? GPTU_CON_STP_SET(1) : GPTU_CON_STP_SET(0);
-+	con_reg |=
-+		TIMER_FLAG_MASK_TYPE(flag) ==
-+		TIMER_FLAG_TIMER ? GPTU_CON_CNT_SET(0) :
-+		GPTU_CON_CNT_SET(1);
-+	con_reg |=
-+		TIMER_FLAG_MASK_DIR(flag) ==
-+		TIMER_FLAG_UP ? GPTU_CON_DIR_SET(1) : GPTU_CON_DIR_SET(0);
-+
-+	/*
-+	 *  Fill up running data.
-+	 */
-+	timer_dev.timer[timer - FIRST_TIMER].flag = flag;
-+	timer_dev.timer[timer - FIRST_TIMER].arg1 = arg1;
-+	timer_dev.timer[timer - FIRST_TIMER].arg2 = arg2;
-+	if (TIMER_FLAG_MASK_SIZE(flag) != TIMER_FLAG_16BIT)
-+		timer_dev.timer[timer - FIRST_TIMER + 1].flag = flag;
-+
-+	/*
-+	 *  Enable GPTU module.
-+	 */
-+	if (!timer_dev.f_gptu_on) {
-+		lq_enable_gptu();
-+		timer_dev.f_gptu_on = 1;
-+	}
-+
-+	/*
-+	 *  Enable IRQ.
-+	 */
-+	if (TIMER_FLAG_MASK_HANDLE(flag) != TIMER_FLAG_NO_HANDLE) {
-+		if (TIMER_FLAG_MASK_HANDLE(flag) == TIMER_FLAG_SIGNAL)
-+			timer_dev.timer[timer - FIRST_TIMER].arg1 =
-+				(unsigned long) find_task_by_vpid((int) arg1);
-+
-+		irnen_reg = 1 << (timer - FIRST_TIMER);
-+
-+		if (TIMER_FLAG_MASK_HANDLE(flag) == TIMER_FLAG_SIGNAL
-+		    || (TIMER_FLAG_MASK_HANDLE(flag) ==
-+			TIMER_FLAG_CALLBACK_IN_IRQ
-+			&& timer_dev.timer[timer - FIRST_TIMER].arg1)) {
-+			enable_irq(timer_dev.timer[timer - FIRST_TIMER].irq);
-+			timer_dev.timer[timer - FIRST_TIMER].f_irq_on = 1;
-+		}
-+	} else
-+		irnen_reg = 0;
-+
-+	/*
-+	 *  Write config register, reload value and enable interrupt.
-+	 */
-+	n = timer >> 1;
-+	X = timer & 0x01;
-+	*LQ_GPTU_CON(n, X) = con_reg;
-+	*LQ_GPTU_RELOAD(n, X) = value;
-+	/* printk("reload value = %d\n", (u32)value); */
-+	*LQ_GPTU_IRNEN |= irnen_reg;
-+
-+	mutex_unlock(&timer_dev.gptu_mutex);
-+	printk("successful!\n");
-+	return ret;
-+}
-+EXPORT_SYMBOL(lq_request_timer);
-+
-+int lq_free_timer(unsigned int timer)
-+{
-+	unsigned int flag;
-+	unsigned int mask;
-+	int n, X;
-+
-+	if (!timer_dev.f_gptu_on)
-+		return -EINVAL;
-+
-+	if (timer < FIRST_TIMER || timer >= FIRST_TIMER + timer_dev.number_of_timers)
-+		return -EINVAL;
-+
-+	mutex_lock(&timer_dev.gptu_mutex);
-+
-+	flag = timer_dev.timer[timer - FIRST_TIMER].flag;
-+	if (TIMER_FLAG_MASK_SIZE(flag) != TIMER_FLAG_16BIT)
-+		timer &= ~0x01;
-+
-+	mask = (TIMER_FLAG_MASK_SIZE(flag) == TIMER_FLAG_16BIT ? 1 : 3) << timer;
-+	if (((timer_dev.occupation & mask) ^ mask)) {
-+		mutex_unlock(&timer_dev.gptu_mutex);
-+		return -EINVAL;
-+	}
-+
-+	n = timer >> 1;
-+	X = timer & 0x01;
-+
-+	if (GPTU_CON_EN(n, X))
-+		*LQ_GPTU_RUN(n, X) = GPTU_RUN_CEN_SET(1);
-+
-+	*LQ_GPTU_IRNEN &= ~GPTU_IRNEN_TC_SET(n, X, 1);
-+	*LQ_GPTU_IRNCR |= GPTU_IRNCR_TC_SET(n, X, 1);
-+
-+	if (timer_dev.timer[timer - FIRST_TIMER].f_irq_on) {
-+		disable_irq(timer_dev.timer[timer - FIRST_TIMER].irq);
-+		timer_dev.timer[timer - FIRST_TIMER].f_irq_on = 0;
-+	}
-+
-+	timer_dev.occupation &= ~mask;
-+	if (!timer_dev.occupation && timer_dev.f_gptu_on) {
-+		lq_disable_gptu();
-+		timer_dev.f_gptu_on = 0;
-+	}
-+
-+	mutex_unlock(&timer_dev.gptu_mutex);
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL(lq_free_timer);
-+
-+int lq_start_timer(unsigned int timer, int is_resume)
-+{
-+	unsigned int flag;
-+	unsigned int mask;
-+	int n, X;
-+
-+	if (!timer_dev.f_gptu_on)
-+		return -EINVAL;
-+
-+	if (timer < FIRST_TIMER || timer >= FIRST_TIMER + timer_dev.number_of_timers)
-+		return -EINVAL;
-+
-+	mutex_lock(&timer_dev.gptu_mutex);
-+
-+	flag = timer_dev.timer[timer - FIRST_TIMER].flag;
-+	if (TIMER_FLAG_MASK_SIZE(flag) != TIMER_FLAG_16BIT)
-+		timer &= ~0x01;
-+
-+	mask = (TIMER_FLAG_MASK_SIZE(flag) ==
-+	TIMER_FLAG_16BIT ? 1 : 3) << timer;
-+	if (((timer_dev.occupation & mask) ^ mask)) {
-+		mutex_unlock(&timer_dev.gptu_mutex);
-+		return -EINVAL;
-+	}
-+
-+	n = timer >> 1;
-+	X = timer & 0x01;
-+
-+	*LQ_GPTU_RUN(n, X) = GPTU_RUN_RL_SET(!is_resume) | GPTU_RUN_SEN_SET(1);
-+
-+
-+	mutex_unlock(&timer_dev.gptu_mutex);
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL(lq_start_timer);
-+
-+int lq_stop_timer(unsigned int timer)
-+{
-+	unsigned int flag;
-+	unsigned int mask;
-+	int n, X;
-+
-+	if (!timer_dev.f_gptu_on)
-+		return -EINVAL;
-+
-+	if (timer < FIRST_TIMER
-+	    || timer >= FIRST_TIMER + timer_dev.number_of_timers)
-+		return -EINVAL;
-+
-+	mutex_lock(&timer_dev.gptu_mutex);
-+
-+	flag = timer_dev.timer[timer - FIRST_TIMER].flag;
-+	if (TIMER_FLAG_MASK_SIZE(flag) != TIMER_FLAG_16BIT)
-+		timer &= ~0x01;
-+
-+	mask = (TIMER_FLAG_MASK_SIZE(flag) == TIMER_FLAG_16BIT ? 1 : 3) << timer;
-+	if (((timer_dev.occupation & mask) ^ mask)) {
-+		mutex_unlock(&timer_dev.gptu_mutex);
-+		return -EINVAL;
-+	}
-+
-+	n = timer >> 1;
-+	X = timer & 0x01;
-+
-+	*LQ_GPTU_RUN(n, X) = GPTU_RUN_CEN_SET(1);
-+
-+	mutex_unlock(&timer_dev.gptu_mutex);
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL(lq_stop_timer);
-+
-+int lq_reset_counter_flags(u32 timer, u32 flags)
-+{
-+	unsigned int oflag;
-+	unsigned int mask, con_reg;
-+	int n, X;
-+
-+	if (!timer_dev.f_gptu_on)
-+		return -EINVAL;
-+
-+	if (timer < FIRST_TIMER || timer >= FIRST_TIMER + timer_dev.number_of_timers)
-+		return -EINVAL;
-+
-+	mutex_lock(&timer_dev.gptu_mutex);
-+
-+	oflag = timer_dev.timer[timer - FIRST_TIMER].flag;
-+	if (TIMER_FLAG_MASK_SIZE(oflag) != TIMER_FLAG_16BIT)
-+		timer &= ~0x01;
-+
-+	mask = (TIMER_FLAG_MASK_SIZE(oflag) == TIMER_FLAG_16BIT ? 1 : 3) << timer;
-+	if (((timer_dev.occupation & mask) ^ mask)) {
-+		mutex_unlock(&timer_dev.gptu_mutex);
-+		return -EINVAL;
-+	}
-+
-+	switch (TIMER_FLAG_MASK_EDGE(flags)) {
-+	default:
-+	case TIMER_FLAG_NONE_EDGE:
-+		con_reg = GPTU_CON_EDGE_SET(0x00);
-+		break;
-+	case TIMER_FLAG_RISE_EDGE:
-+		con_reg = GPTU_CON_EDGE_SET(0x01);
-+		break;
-+	case TIMER_FLAG_FALL_EDGE:
-+		con_reg = GPTU_CON_EDGE_SET(0x02);
-+		break;
-+	case TIMER_FLAG_ANY_EDGE:
-+		con_reg = GPTU_CON_EDGE_SET(0x03);
-+		break;
-+	}
-+	if (TIMER_FLAG_MASK_TYPE(flags) == TIMER_FLAG_TIMER)
-+		con_reg |= TIMER_FLAG_MASK_SRC(flags) == TIMER_FLAG_EXT_SRC ? GPTU_CON_SRC_EXT_SET(1) : GPTU_CON_SRC_EXT_SET(0);
-+	else
-+		con_reg |= TIMER_FLAG_MASK_SRC(flags) == TIMER_FLAG_EXT_SRC ? GPTU_CON_SRC_EG_SET(1) : GPTU_CON_SRC_EG_SET(0);
-+	con_reg |= TIMER_FLAG_MASK_SYNC(flags) == TIMER_FLAG_UNSYNC ? GPTU_CON_SYNC_SET(0) : GPTU_CON_SYNC_SET(1);
-+	con_reg |= TIMER_FLAG_MASK_INVERT(flags) == TIMER_FLAG_REAL ? GPTU_CON_INV_SET(0) : GPTU_CON_INV_SET(1);
-+	con_reg |= TIMER_FLAG_MASK_SIZE(flags) == TIMER_FLAG_16BIT ? GPTU_CON_EXT_SET(0) : GPTU_CON_EXT_SET(1);
-+	con_reg |= TIMER_FLAG_MASK_STOP(flags) == TIMER_FLAG_ONCE ? GPTU_CON_STP_SET(1) : GPTU_CON_STP_SET(0);
-+	con_reg |= TIMER_FLAG_MASK_TYPE(flags) == TIMER_FLAG_TIMER ? GPTU_CON_CNT_SET(0) : GPTU_CON_CNT_SET(1);
-+	con_reg |= TIMER_FLAG_MASK_DIR(flags) == TIMER_FLAG_UP ? GPTU_CON_DIR_SET(1) : GPTU_CON_DIR_SET(0);
-+
-+	timer_dev.timer[timer - FIRST_TIMER].flag = flags;
-+	if (TIMER_FLAG_MASK_SIZE(flags) != TIMER_FLAG_16BIT)
-+		timer_dev.timer[timer - FIRST_TIMER + 1].flag = flags;
-+
-+	n = timer >> 1;
-+	X = timer & 0x01;
-+
-+	*LQ_GPTU_CON(n, X) = con_reg;
-+	smp_wmb();
-+	mutex_unlock(&timer_dev.gptu_mutex);
-+	return 0;
-+}
-+EXPORT_SYMBOL(lq_reset_counter_flags);
-+
-+int lq_get_count_value(unsigned int timer, unsigned long *value)
-+{
-+	unsigned int flag;
-+	unsigned int mask;
-+	int n, X;
-+
-+	if (!timer_dev.f_gptu_on)
-+		return -EINVAL;
-+
-+	if (timer < FIRST_TIMER
-+	    || timer >= FIRST_TIMER + timer_dev.number_of_timers)
-+		return -EINVAL;
-+
-+	mutex_lock(&timer_dev.gptu_mutex);
-+
-+	flag = timer_dev.timer[timer - FIRST_TIMER].flag;
-+	if (TIMER_FLAG_MASK_SIZE(flag) != TIMER_FLAG_16BIT)
-+		timer &= ~0x01;
-+
-+	mask = (TIMER_FLAG_MASK_SIZE(flag) == TIMER_FLAG_16BIT ? 1 : 3) << timer;
-+	if (((timer_dev.occupation & mask) ^ mask)) {
-+		mutex_unlock(&timer_dev.gptu_mutex);
-+		return -EINVAL;
-+	}
-+
-+	n = timer >> 1;
-+	X = timer & 0x01;
-+
-+	*value = *LQ_GPTU_COUNT(n, X);
-+
-+
-+	mutex_unlock(&timer_dev.gptu_mutex);
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL(lq_get_count_value);
-+
-+u32 lq_cal_divider(unsigned long freq)
-+{
-+	u64 module_freq, fpi = ltq_get_fpi_bus_clock(2);
-+	u32 clock_divider = 1;
-+	module_freq = fpi * 1000;
-+	do_div(module_freq, clock_divider * freq);
-+	return module_freq;
-+}
-+EXPORT_SYMBOL(lq_cal_divider);
-+
-+int lq_set_timer(unsigned int timer, unsigned int freq, int is_cyclic,
-+	int is_ext_src, unsigned int handle_flag, unsigned long arg1,
-+	unsigned long arg2)
-+{
-+	unsigned long divider;
-+	unsigned int flag;
-+
-+	divider = lq_cal_divider(freq);
-+	if (divider == 0)
-+		return -EINVAL;
-+	flag = ((divider & ~0xFFFF) ? TIMER_FLAG_32BIT : TIMER_FLAG_16BIT)
-+		| (is_cyclic ? TIMER_FLAG_CYCLIC : TIMER_FLAG_ONCE)
-+		| (is_ext_src ? TIMER_FLAG_EXT_SRC : TIMER_FLAG_INT_SRC)
-+		| TIMER_FLAG_TIMER | TIMER_FLAG_DOWN
-+		| TIMER_FLAG_MASK_HANDLE(handle_flag);
-+
-+	printk(KERN_INFO "lq_set_timer(%d, %d), divider = %lu\n",
-+		timer, freq, divider);
-+	return lq_request_timer(timer, flag, divider, arg1, arg2);
-+}
-+EXPORT_SYMBOL(lq_set_timer);
-+
-+int lq_set_counter(unsigned int timer, unsigned int flag, u32 reload,
-+	unsigned long arg1, unsigned long arg2)
-+{
-+	printk(KERN_INFO "lq_set_counter(%d, %#x, %d)\n", timer, flag, reload);
-+	return lq_request_timer(timer, flag, reload, arg1, arg2);
-+}
-+EXPORT_SYMBOL(lq_set_counter);
-+
-+static long gptu_ioctl(struct file *file, unsigned int cmd,
-+	unsigned long arg)
-+{
-+	int ret;
-+	struct gptu_ioctl_param param;
-+
-+	if (!access_ok(VERIFY_READ, arg, sizeof(struct gptu_ioctl_param)))
-+		return -EFAULT;
-+	copy_from_user(&param, (void *) arg, sizeof(param));
-+
-+	if ((((cmd == GPTU_REQUEST_TIMER || cmd == GPTU_SET_TIMER
-+	       || GPTU_SET_COUNTER) && param.timer < 2)
-+	     || cmd == GPTU_GET_COUNT_VALUE || cmd == GPTU_CALCULATE_DIVIDER)
-+	    && !access_ok(VERIFY_WRITE, arg,
-+			   sizeof(struct gptu_ioctl_param)))
-+		return -EFAULT;
-+
-+	switch (cmd) {
-+	case GPTU_REQUEST_TIMER:
-+		ret = lq_request_timer(param.timer, param.flag, param.value,
-+				     (unsigned long) param.pid,
-+				     (unsigned long) param.sig);
-+		if (ret > 0) {
-+			copy_to_user(&((struct gptu_ioctl_param *) arg)->
-+				      timer, &ret, sizeof(&ret));
-+			ret = 0;
-+		}
-+		break;
-+	case GPTU_FREE_TIMER:
-+		ret = lq_free_timer(param.timer);
-+		break;
-+	case GPTU_START_TIMER:
-+		ret = lq_start_timer(param.timer, param.flag);
-+		break;
-+	case GPTU_STOP_TIMER:
-+		ret = lq_stop_timer(param.timer);
-+		break;
-+	case GPTU_GET_COUNT_VALUE:
-+		ret = lq_get_count_value(param.timer, &param.value);
-+		if (!ret)
-+			copy_to_user(&((struct gptu_ioctl_param *) arg)->
-+				      value, &param.value,
-+				      sizeof(param.value));
-+		break;
-+	case GPTU_CALCULATE_DIVIDER:
-+		param.value = lq_cal_divider(param.value);
-+		if (param.value == 0)
-+			ret = -EINVAL;
-+		else {
-+			copy_to_user(&((struct gptu_ioctl_param *) arg)->
-+				      value, &param.value,
-+				      sizeof(param.value));
-+			ret = 0;
-+		}
-+		break;
-+	case GPTU_SET_TIMER:
-+		ret = lq_set_timer(param.timer, param.value,
-+				 TIMER_FLAG_MASK_STOP(param.flag) !=
-+				 TIMER_FLAG_ONCE ? 1 : 0,
-+				 TIMER_FLAG_MASK_SRC(param.flag) ==
-+				 TIMER_FLAG_EXT_SRC ? 1 : 0,
-+				 TIMER_FLAG_MASK_HANDLE(param.flag) ==
-+				 TIMER_FLAG_SIGNAL ? TIMER_FLAG_SIGNAL :
-+				 TIMER_FLAG_NO_HANDLE,
-+				 (unsigned long) param.pid,
-+				 (unsigned long) param.sig);
-+		if (ret > 0) {
-+			copy_to_user(&((struct gptu_ioctl_param *) arg)->
-+				      timer, &ret, sizeof(&ret));
-+			ret = 0;
-+		}
-+		break;
-+	case GPTU_SET_COUNTER:
-+		lq_set_counter(param.timer, param.flag, param.value, 0, 0);
-+		if (ret > 0) {
-+			copy_to_user(&((struct gptu_ioctl_param *) arg)->
-+				      timer, &ret, sizeof(&ret));
-+			ret = 0;
-+		}
-+		break;
-+	default:
-+		ret = -ENOTTY;
-+	}
-+
-+	return ret;
-+}
-+
-+static int gptu_open(struct inode *inode, struct file *file)
-+{
-+	return 0;
-+}
-+
-+static int gptu_release(struct inode *inode, struct file *file)
-+{
-+	return 0;
-+}
-+
-+int __init lq_gptu_init(void)
-+{
-+	int ret;
-+	unsigned int i;
-+
-+	ltq_w32(0, LQ_GPTU_IRNEN);
-+	ltq_w32(0xfff, LQ_GPTU_IRNCR);
-+
-+	memset(&timer_dev, 0, sizeof(timer_dev));
-+	mutex_init(&timer_dev.gptu_mutex);
-+
-+	lq_enable_gptu();
-+	timer_dev.number_of_timers = GPTU_ID_CFG * 2;
-+	lq_disable_gptu();
-+	if (timer_dev.number_of_timers > MAX_NUM_OF_32BIT_TIMER_BLOCKS * 2)
-+		timer_dev.number_of_timers = MAX_NUM_OF_32BIT_TIMER_BLOCKS * 2;
-+	printk(KERN_INFO "gptu: totally %d 16-bit timers/counters\n", timer_dev.number_of_timers);
-+
-+	ret = misc_register(&gptu_miscdev);
-+	if (ret) {
-+		printk(KERN_ERR "gptu: can't misc_register, get error %d\n", -ret);
-+		return ret;
-+	} else {
-+		printk(KERN_INFO "gptu: misc_register on minor %d\n", gptu_miscdev.minor);
-+	}
-+
-+	for (i = 0; i < timer_dev.number_of_timers; i++) {
-+		ret = request_irq(TIMER_INTERRUPT + i, timer_irq_handler, IRQF_TIMER, gptu_miscdev.name, &timer_dev.timer[i]);
-+		if (ret) {
-+			for (; i >= 0; i--)
-+				free_irq(TIMER_INTERRUPT + i, &timer_dev.timer[i]);
-+			misc_deregister(&gptu_miscdev);
-+			printk(KERN_ERR "gptu: failed in requesting irq (%d), get error %d\n", i, -ret);
-+			return ret;
-+		} else {
-+			timer_dev.timer[i].irq = TIMER_INTERRUPT + i;
-+			disable_irq(timer_dev.timer[i].irq);
-+			printk(KERN_INFO "gptu: succeeded to request irq %d\n", timer_dev.timer[i].irq);
-+		}
-+	}
-+
-+	return 0;
-+}
-+
-+void __exit lq_gptu_exit(void)
-+{
-+	unsigned int i;
-+
-+	for (i = 0; i < timer_dev.number_of_timers; i++) {
-+		if (timer_dev.timer[i].f_irq_on)
-+			disable_irq(timer_dev.timer[i].irq);
-+		free_irq(timer_dev.timer[i].irq, &timer_dev.timer[i]);
-+	}
-+	lq_disable_gptu();
-+	misc_deregister(&gptu_miscdev);
-+}
-+
-+module_init(lq_gptu_init);
-+module_exit(lq_gptu_exit);
-+
-+#endif
diff --git a/target/linux/lantiq/patches-3.18/0009-MIPS-lantiq-command-line-work-around.patch b/target/linux/lantiq/patches-3.18/0009-MIPS-lantiq-command-line-work-around.patch
deleted file mode 100644
index 88bcbc4b5c..0000000000
--- a/target/linux/lantiq/patches-3.18/0009-MIPS-lantiq-command-line-work-around.patch
+++ /dev/null
@@ -1,21 +0,0 @@
-From ed348924cd59ef0c8a4bc4e015e2b7e581a00fa8 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Tue, 12 Aug 2014 21:40:41 +0200
-Subject: [PATCH 09/36] MIPS: lantiq: command line work around
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- arch/mips/lantiq/prom.c |    2 ++
- 1 file changed, 2 insertions(+)
-
---- a/arch/mips/lantiq/prom.c
-+++ b/arch/mips/lantiq/prom.c
-@@ -74,6 +74,8 @@ void __init plat_mem_setup(void)
- 	 * parsed resulting in our memory appearing
- 	 */
- 	__dt_setup_arch(&__image_dtb);
-+
-+	strlcpy(arcs_cmdline, boot_command_line, COMMAND_LINE_SIZE);
- }
- 
- void __init device_tree_init(void)
diff --git a/target/linux/lantiq/patches-3.18/0010-MIPS-lantiq-export-soc-type.patch b/target/linux/lantiq/patches-3.18/0010-MIPS-lantiq-export-soc-type.patch
deleted file mode 100644
index e78b290a64..0000000000
--- a/target/linux/lantiq/patches-3.18/0010-MIPS-lantiq-export-soc-type.patch
+++ /dev/null
@@ -1,39 +0,0 @@
-From 6804142b47f2634b0657e4dfcec7a34e982b6ddb Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Wed, 10 Sep 2014 22:29:21 +0200
-Subject: [PATCH 10/36] MIPS: lantiq: export soc type
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Signed-off-by: Alvaro Fernandez Rojas <noltari@gmail.com>
----
- arch/mips/include/asm/mach-lantiq/lantiq.h |    2 ++
- arch/mips/lantiq/prom.c                    |    5 +++++
- 2 files changed, 7 insertions(+)
-
---- a/arch/mips/include/asm/mach-lantiq/lantiq.h
-+++ b/arch/mips/include/asm/mach-lantiq/lantiq.h
-@@ -48,6 +48,8 @@ extern struct clk *clk_get_ppe(void);
- extern unsigned char ltq_boot_select(void);
- /* find out what caused the last cpu reset */
- extern int ltq_reset_cause(void);
-+/* find out the soc type */
-+extern int ltq_soc_type(void);
- 
- #define IOPORT_RESOURCE_START	0x10000000
- #define IOPORT_RESOURCE_END	0xffffffff
---- a/arch/mips/lantiq/prom.c
-+++ b/arch/mips/lantiq/prom.c
-@@ -36,6 +36,11 @@ const char *get_system_type(void)
- 	return soc_info.sys_type;
- }
- 
-+int ltq_soc_type(void)
-+{
-+	return soc_info.type;
-+}
-+
- void prom_free_prom_memory(void)
- {
- }
diff --git a/target/linux/lantiq/patches-3.18/0011-lantiq-add-support-for-xrx200-firmware-depending-on-.patch b/target/linux/lantiq/patches-3.18/0011-lantiq-add-support-for-xrx200-firmware-depending-on-.patch
deleted file mode 100644
index 3e22244e96..0000000000
--- a/target/linux/lantiq/patches-3.18/0011-lantiq-add-support-for-xrx200-firmware-depending-on-.patch
+++ /dev/null
@@ -1,41 +0,0 @@
-From 85f0df34dee96048515ef1e01d88524bd579f8e0 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Wed, 10 Sep 2014 22:39:19 +0200
-Subject: [PATCH 11/36] lantiq: add support for xrx200 firmware depending on
- soc type
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Signed-off-by: Alvaro Fernandez Rojas <noltari@gmail.com>
----
- arch/mips/lantiq/xway/xrx200_phy_fw.c |   18 +++++++++++++++++-
- 1 file changed, 17 insertions(+), 1 deletion(-)
-
---- a/arch/mips/lantiq/xway/xrx200_phy_fw.c
-+++ b/arch/mips/lantiq/xway/xrx200_phy_fw.c
-@@ -24,7 +24,23 @@ static dma_addr_t xway_gphy_load(struct
- 	void *fw_addr;
- 	size_t size;
- 
--	if (of_property_read_string(pdev->dev.of_node, "firmware", &fw_name)) {
-+	if (of_get_property(pdev->dev.of_node, "firmware1", NULL) || of_get_property(pdev->dev.of_node, "firmware2", NULL)) {
-+		switch(ltq_soc_type()) {
-+			case SOC_TYPE_VR9:
-+				if (of_property_read_string(pdev->dev.of_node, "firmware1", &fw_name)) {
-+					dev_err(&pdev->dev, "failed to load firmware filename\n");
-+					return 0;
-+				}
-+				break;
-+			case SOC_TYPE_VR9_2:
-+				if (of_property_read_string(pdev->dev.of_node, "firmware2", &fw_name)) {
-+					dev_err(&pdev->dev, "failed to load firmware filename\n");
-+					return 0;
-+				}
-+				break;
-+		}
-+	}
-+	else if (of_property_read_string(pdev->dev.of_node, "firmware", &fw_name)) {
- 		dev_err(&pdev->dev, "failed to load firmware filename\n");
- 		return 0;
- 	}
diff --git a/target/linux/lantiq/patches-3.18/0012-pinctrl-lantiq-fix-up-pinmux.patch b/target/linux/lantiq/patches-3.18/0012-pinctrl-lantiq-fix-up-pinmux.patch
deleted file mode 100644
index ecd143f91f..0000000000
--- a/target/linux/lantiq/patches-3.18/0012-pinctrl-lantiq-fix-up-pinmux.patch
+++ /dev/null
@@ -1,79 +0,0 @@
-From 25494c55a4007a1409f53ddbafd661636e47ea34 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Fri, 9 Aug 2013 20:38:15 +0200
-Subject: [PATCH 12/36] pinctrl/lantiq: fix up pinmux
-
-We found out how to set the gphy led pinmuxing.
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/pinctrl/pinctrl-xway.c |   28 ++++++++++++++++++++++++++--
- 1 file changed, 26 insertions(+), 2 deletions(-)
-
---- a/drivers/pinctrl/pinctrl-xway.c
-+++ b/drivers/pinctrl/pinctrl-xway.c
-@@ -609,10 +609,9 @@ static struct pinctrl_desc xway_pctrl_de
- 	.confops	= &xway_pinconf_ops,
- };
- 
--static inline int xway_mux_apply(struct pinctrl_dev *pctrldev,
-+static int mux_apply(struct ltq_pinmux_info *info,
- 				int pin, int mux)
- {
--	struct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);
- 	int port = PORT(pin);
- 	u32 alt1_reg = GPIO_ALT1(pin);
- 
-@@ -632,6 +631,14 @@ static inline int xway_mux_apply(struct
- 	return 0;
- }
- 
-+static inline int xway_mux_apply(struct pinctrl_dev *pctrldev,
-+				int pin, int mux)
-+{
-+	struct ltq_pinmux_info *info = pinctrl_dev_get_drvdata(pctrldev);
-+
-+	return mux_apply(info, pin, mux);
-+}
-+
- static const struct ltq_cfg_param xway_cfg_params[] = {
- 	{"lantiq,pull",		LTQ_PINCONF_PARAM_PULL},
- 	{"lantiq,open-drain",	LTQ_PINCONF_PARAM_OPEN_DRAIN},
-@@ -676,6 +683,10 @@ static int xway_gpio_dir_out(struct gpio
- {
- 	struct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);
- 
-+	if (PORT(pin) == PORT3)
-+		gpio_setbit(info->membase[0], GPIO3_OD, PORT_PIN(pin));
-+	else
-+		gpio_setbit(info->membase[0], GPIO_OD(pin), PORT_PIN(pin));
- 	gpio_setbit(info->membase[0], GPIO_DIR(pin), PORT_PIN(pin));
- 	xway_gpio_set(chip, pin, val);
- 
-@@ -696,6 +707,18 @@ static void xway_gpio_free(struct gpio_c
- 	pinctrl_free_gpio(gpio);
- }
- 
-+static int xway_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
-+{
-+	struct ltq_pinmux_info *info = dev_get_drvdata(chip->dev);
-+	int i;
-+
-+	for (i = 0; i < info->num_exin; i++)
-+		if (info->exin[i] == offset)
-+			return ltq_eiu_get_irq(i);
-+
-+	return -1;
-+}
-+
- static struct gpio_chip xway_chip = {
- 	.label = "gpio-xway",
- 	.direction_input = xway_gpio_dir_in,
-@@ -704,6 +727,7 @@ static struct gpio_chip xway_chip = {
- 	.set = xway_gpio_set,
- 	.request = xway_gpio_req,
- 	.free = xway_gpio_free,
-+	.to_irq = xway_gpio_to_irq,
- 	.base = -1,
- };
- 
diff --git a/target/linux/lantiq/patches-3.18/0013-MTD-lantiq-xway-fix-invalid-operator.patch b/target/linux/lantiq/patches-3.18/0013-MTD-lantiq-xway-fix-invalid-operator.patch
deleted file mode 100644
index c6d3819c2f..0000000000
--- a/target/linux/lantiq/patches-3.18/0013-MTD-lantiq-xway-fix-invalid-operator.patch
+++ /dev/null
@@ -1,24 +0,0 @@
-From 8e34da603f442624bb70e887d8f42064bb924224 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Sun, 28 Jul 2013 18:03:54 +0200
-Subject: [PATCH 13/36] MTD: lantiq: xway: fix invalid operator
-
-xway_read_byte should use a logic or and not an add operator when working out
-the nand address.
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/mtd/nand/xway_nand.c |    2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/mtd/nand/xway_nand.c
-+++ b/drivers/mtd/nand/xway_nand.c
-@@ -124,7 +124,7 @@ static unsigned char xway_read_byte(stru
- 	int ret;
- 
- 	spin_lock_irqsave(&ebu_lock, flags);
--	ret = ltq_r8((void __iomem *)(nandaddr + NAND_READ_DATA));
-+	ret = ltq_r8((void __iomem *)(nandaddr | NAND_READ_DATA));
- 	spin_unlock_irqrestore(&ebu_lock, flags);
- 
- 	return ret;
diff --git a/target/linux/lantiq/patches-3.18/0014-MTD-lantiq-xway-the-latched-command-should-be-persis.patch b/target/linux/lantiq/patches-3.18/0014-MTD-lantiq-xway-the-latched-command-should-be-persis.patch
deleted file mode 100644
index 6a7785b016..0000000000
--- a/target/linux/lantiq/patches-3.18/0014-MTD-lantiq-xway-the-latched-command-should-be-persis.patch
+++ /dev/null
@@ -1,44 +0,0 @@
-From b454cefd675fc1bd3d8c690c1bd1d8f4678e9922 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Sun, 28 Jul 2013 18:06:39 +0200
-Subject: [PATCH 14/36] MTD: lantiq: xway: the latched command should be
- persistent
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/mtd/nand/xway_nand.c |   12 ++++++------
- 1 file changed, 6 insertions(+), 6 deletions(-)
-
---- a/drivers/mtd/nand/xway_nand.c
-+++ b/drivers/mtd/nand/xway_nand.c
-@@ -54,6 +54,8 @@
- #define NAND_CON_CSMUX		(1 << 1)
- #define NAND_CON_NANDM		1
- 
-+static u32 xway_latchcmd;
-+
- static void xway_reset_chip(struct nand_chip *chip)
- {
- 	unsigned long nandaddr = (unsigned long) chip->IO_ADDR_W;
-@@ -94,17 +96,15 @@ static void xway_cmd_ctrl(struct mtd_inf
- 	unsigned long flags;
- 
- 	if (ctrl & NAND_CTRL_CHANGE) {
--		nandaddr &= ~(NAND_WRITE_CMD | NAND_WRITE_ADDR);
- 		if (ctrl & NAND_CLE)
--			nandaddr |= NAND_WRITE_CMD;
--		else
--			nandaddr |= NAND_WRITE_ADDR;
--		this->IO_ADDR_W = (void __iomem *) nandaddr;
-+			xway_latchcmd = NAND_WRITE_CMD;
-+		else if (ctrl & NAND_ALE)
-+			xway_latchcmd = NAND_WRITE_ADDR;
- 	}
- 
- 	if (cmd != NAND_CMD_NONE) {
- 		spin_lock_irqsave(&ebu_lock, flags);
--		writeb(cmd, this->IO_ADDR_W);
-+		writeb(cmd, (void __iomem *) (nandaddr | xway_latchcmd));
- 		while ((ltq_ebu_r32(EBU_NAND_WAIT) & NAND_WAIT_WR_C) == 0)
- 			;
- 		spin_unlock_irqrestore(&ebu_lock, flags);
diff --git a/target/linux/lantiq/patches-3.18/0015-MTD-lantiq-xway-remove-endless-loop.patch b/target/linux/lantiq/patches-3.18/0015-MTD-lantiq-xway-remove-endless-loop.patch
deleted file mode 100644
index 4bd166863b..0000000000
--- a/target/linux/lantiq/patches-3.18/0015-MTD-lantiq-xway-remove-endless-loop.patch
+++ /dev/null
@@ -1,41 +0,0 @@
-From 76e153079f02d26e3357302d2886a0c8aaaec64d Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Sun, 28 Jul 2013 18:02:06 +0200
-Subject: [PATCH 15/36] MTD: lantiq: xway: remove endless loop
-
-The reset loop logic could run into a endless loop. Lets fix it as requested.
-
---> http://lists.infradead.org/pipermail/linux-mtd/2012-September/044240.html
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/mtd/nand/xway_nand.c |   10 ++++++++--
- 1 file changed, 8 insertions(+), 2 deletions(-)
-
---- a/drivers/mtd/nand/xway_nand.c
-+++ b/drivers/mtd/nand/xway_nand.c
-@@ -59,16 +59,22 @@ static u32 xway_latchcmd;
- static void xway_reset_chip(struct nand_chip *chip)
- {
- 	unsigned long nandaddr = (unsigned long) chip->IO_ADDR_W;
-+	unsigned long timeout;
- 	unsigned long flags;
- 
- 	nandaddr &= ~NAND_WRITE_ADDR;
- 	nandaddr |= NAND_WRITE_CMD;
- 
- 	/* finish with a reset */
-+	timeout = jiffies + msecs_to_jiffies(20);
-+
- 	spin_lock_irqsave(&ebu_lock, flags);
- 	writeb(NAND_WRITE_CMD_RESET, (void __iomem *) nandaddr);
--	while ((ltq_ebu_r32(EBU_NAND_WAIT) & NAND_WAIT_WR_C) == 0)
--		;
-+	do {
-+		if ((ltq_ebu_r32(EBU_NAND_WAIT) & NAND_WAIT_WR_C) == 0)
-+			break;
-+		cond_resched();
-+	} while (!time_after_eq(jiffies, timeout));
- 	spin_unlock_irqrestore(&ebu_lock, flags);
- }
- 
diff --git a/target/linux/lantiq/patches-3.18/0016-MTD-lantiq-xway-add-missing-write_buf-and-read_buf-t.patch b/target/linux/lantiq/patches-3.18/0016-MTD-lantiq-xway-add-missing-write_buf-and-read_buf-t.patch
deleted file mode 100644
index f20878cd25..0000000000
--- a/target/linux/lantiq/patches-3.18/0016-MTD-lantiq-xway-add-missing-write_buf-and-read_buf-t.patch
+++ /dev/null
@@ -1,55 +0,0 @@
-From 65df9d63eaee02c25e879b33dd42aceb78e57842 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Sun, 28 Jul 2013 17:59:51 +0200
-Subject: [PATCH 16/36] MTD: lantiq: xway: add missing write_buf and read_buf
- to nand driver
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/mtd/nand/xway_nand.c |   28 ++++++++++++++++++++++++++++
- 1 file changed, 28 insertions(+)
-
---- a/drivers/mtd/nand/xway_nand.c
-+++ b/drivers/mtd/nand/xway_nand.c
-@@ -136,6 +136,32 @@ static unsigned char xway_read_byte(stru
- 	return ret;
- }
- 
-+static void xway_read_buf(struct mtd_info *mtd, u_char *buf, int len)
-+{
-+	struct nand_chip *this = mtd->priv;
-+	unsigned long nandaddr = (unsigned long) this->IO_ADDR_R;
-+	unsigned long flags;
-+	int i;
-+
-+	spin_lock_irqsave(&ebu_lock, flags);
-+	for (i = 0; i < len; i++)
-+		buf[i] = ltq_r8((void __iomem *)(nandaddr | NAND_READ_DATA));
-+	spin_unlock_irqrestore(&ebu_lock, flags);
-+}
-+
-+static void xway_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
-+{
-+	struct nand_chip *this = mtd->priv;
-+	unsigned long nandaddr = (unsigned long) this->IO_ADDR_W;
-+	unsigned long flags;
-+	int i;
-+
-+	spin_lock_irqsave(&ebu_lock, flags);
-+	for (i = 0; i < len; i++)
-+		ltq_w8(buf[i], (void __iomem *)(nandaddr | NAND_WRITE_DATA));
-+	spin_unlock_irqrestore(&ebu_lock, flags);
-+}
-+
- static int xway_nand_probe(struct platform_device *pdev)
- {
- 	struct nand_chip *this = platform_get_drvdata(pdev);
-@@ -181,6 +207,8 @@ static struct platform_nand_data xway_na
- 		.dev_ready	= xway_dev_ready,
- 		.select_chip	= xway_select_chip,
- 		.read_byte	= xway_read_byte,
-+		.read_buf	= xway_read_buf,
-+		.write_buf	= xway_write_buf,
- 	}
- };
- 
diff --git a/target/linux/lantiq/patches-3.18/0017-MTD-xway-fix-nand-locking.patch b/target/linux/lantiq/patches-3.18/0017-MTD-xway-fix-nand-locking.patch
deleted file mode 100644
index 737469aab5..0000000000
--- a/target/linux/lantiq/patches-3.18/0017-MTD-xway-fix-nand-locking.patch
+++ /dev/null
@@ -1,89 +0,0 @@
-From aa705c1b0860da91f2ed1a4c0b57337e6de689e1 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Thu, 7 Aug 2014 18:55:31 +0200
-Subject: [PATCH 17/36] MTD: xway: fix nand locking
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/mtd/nand/xway_nand.c |   15 +++------------
- 1 file changed, 3 insertions(+), 12 deletions(-)
-
---- a/drivers/mtd/nand/xway_nand.c
-+++ b/drivers/mtd/nand/xway_nand.c
-@@ -80,13 +80,16 @@ static void xway_reset_chip(struct nand_
- 
- static void xway_select_chip(struct mtd_info *mtd, int chip)
- {
-+	static unsigned long csflags;
- 
- 	switch (chip) {
- 	case -1:
- 		ltq_ebu_w32_mask(NAND_CON_CE, 0, EBU_NAND_CON);
- 		ltq_ebu_w32_mask(NAND_CON_NANDM, 0, EBU_NAND_CON);
-+		spin_unlock_irqrestore(&ebu_lock, csflags);
- 		break;
- 	case 0:
-+		spin_lock_irqsave(&ebu_lock, csflags);
- 		ltq_ebu_w32_mask(0, NAND_CON_NANDM, EBU_NAND_CON);
- 		ltq_ebu_w32_mask(0, NAND_CON_CE, EBU_NAND_CON);
- 		break;
-@@ -99,7 +102,6 @@ static void xway_cmd_ctrl(struct mtd_inf
- {
- 	struct nand_chip *this = mtd->priv;
- 	unsigned long nandaddr = (unsigned long) this->IO_ADDR_W;
--	unsigned long flags;
- 
- 	if (ctrl & NAND_CTRL_CHANGE) {
- 		if (ctrl & NAND_CLE)
-@@ -109,11 +111,9 @@ static void xway_cmd_ctrl(struct mtd_inf
- 	}
- 
- 	if (cmd != NAND_CMD_NONE) {
--		spin_lock_irqsave(&ebu_lock, flags);
- 		writeb(cmd, (void __iomem *) (nandaddr | xway_latchcmd));
- 		while ((ltq_ebu_r32(EBU_NAND_WAIT) & NAND_WAIT_WR_C) == 0)
- 			;
--		spin_unlock_irqrestore(&ebu_lock, flags);
- 	}
- }
- 
-@@ -126,12 +126,9 @@ static unsigned char xway_read_byte(stru
- {
- 	struct nand_chip *this = mtd->priv;
- 	unsigned long nandaddr = (unsigned long) this->IO_ADDR_R;
--	unsigned long flags;
- 	int ret;
- 
--	spin_lock_irqsave(&ebu_lock, flags);
- 	ret = ltq_r8((void __iomem *)(nandaddr | NAND_READ_DATA));
--	spin_unlock_irqrestore(&ebu_lock, flags);
- 
- 	return ret;
- }
-@@ -140,26 +137,20 @@ static void xway_read_buf(struct mtd_inf
- {
- 	struct nand_chip *this = mtd->priv;
- 	unsigned long nandaddr = (unsigned long) this->IO_ADDR_R;
--	unsigned long flags;
- 	int i;
- 
--	spin_lock_irqsave(&ebu_lock, flags);
- 	for (i = 0; i < len; i++)
- 		buf[i] = ltq_r8((void __iomem *)(nandaddr | NAND_READ_DATA));
--	spin_unlock_irqrestore(&ebu_lock, flags);
- }
- 
- static void xway_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
- {
- 	struct nand_chip *this = mtd->priv;
- 	unsigned long nandaddr = (unsigned long) this->IO_ADDR_W;
--	unsigned long flags;
- 	int i;
- 
--	spin_lock_irqsave(&ebu_lock, flags);
- 	for (i = 0; i < len; i++)
- 		ltq_w8(buf[i], (void __iomem *)(nandaddr | NAND_WRITE_DATA));
--	spin_unlock_irqrestore(&ebu_lock, flags);
- }
- 
- static int xway_nand_probe(struct platform_device *pdev)
diff --git a/target/linux/lantiq/patches-3.18/0018-MTD-nand-lots-of-xrx200-fixes.patch b/target/linux/lantiq/patches-3.18/0018-MTD-nand-lots-of-xrx200-fixes.patch
deleted file mode 100644
index 5500861c22..0000000000
--- a/target/linux/lantiq/patches-3.18/0018-MTD-nand-lots-of-xrx200-fixes.patch
+++ /dev/null
@@ -1,125 +0,0 @@
-From 997a8965db8417266bea3fbdcfa3e5655a1b52fa Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Tue, 9 Sep 2014 23:12:15 +0200
-Subject: [PATCH 18/36] MTD: nand: lots of xrx200 fixes
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/mtd/nand/xway_nand.c |   63 ++++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 63 insertions(+)
-
---- a/drivers/mtd/nand/xway_nand.c
-+++ b/drivers/mtd/nand/xway_nand.c
-@@ -54,8 +54,27 @@
- #define NAND_CON_CSMUX		(1 << 1)
- #define NAND_CON_NANDM		1
- 
-+#define DANUBE_PCI_REG32( addr )    (*(volatile u32 *)(addr))
-+#define PCI_CR_PR_OFFSET	    (KSEG1+0x1E105400)
-+#define PCI_CR_PC_ARB		    (PCI_CR_PR_OFFSET + 0x0080)
-+
- static u32 xway_latchcmd;
- 
-+/*
-+ * req_mask provides a mechanism to prevent interference between
-+ * nand and pci (probably only relevant for the BT Home Hub 2B).
-+ * Setting it causes the corresponding pci req pins to be masked
-+ * during nand access, and also moves ebu locking from the read/write
-+ * functions to the chip select function to ensure that the whole
-+ * operation runs with interrupts disabled.
-+ * In addition it switches on some extra waiting in xway_cmd_ctrl().
-+ * This seems to be necessary if the ebu_cs1 pin has open-drain disabled,
-+ * which in turn seems to be necessary for the nor chip to be recognised
-+ * reliably, on a board (Home Hub 2B again) which has both nor and nand.
-+ */
-+
-+static __be32 req_mask = 0;
-+
- static void xway_reset_chip(struct nand_chip *chip)
- {
- 	unsigned long nandaddr = (unsigned long) chip->IO_ADDR_W;
-@@ -86,12 +105,24 @@ static void xway_select_chip(struct mtd_
- 	case -1:
- 		ltq_ebu_w32_mask(NAND_CON_CE, 0, EBU_NAND_CON);
- 		ltq_ebu_w32_mask(NAND_CON_NANDM, 0, EBU_NAND_CON);
-+
-+		if (req_mask) {
-+			/* Unmask all external PCI request */
-+			DANUBE_PCI_REG32(PCI_CR_PC_ARB) &= ~(req_mask << 16);
-+		}
- 		spin_unlock_irqrestore(&ebu_lock, csflags);
-+
- 		break;
- 	case 0:
- 		spin_lock_irqsave(&ebu_lock, csflags);
-+		if (req_mask) {
-+			/* Mask all external PCI request */
-+			DANUBE_PCI_REG32(PCI_CR_PC_ARB) |= (req_mask << 16);
-+		}
-+
- 		ltq_ebu_w32_mask(0, NAND_CON_NANDM, EBU_NAND_CON);
- 		ltq_ebu_w32_mask(0, NAND_CON_CE, EBU_NAND_CON);
-+
- 		break;
- 	default:
- 		BUG();
-@@ -103,6 +134,12 @@ static void xway_cmd_ctrl(struct mtd_inf
- 	struct nand_chip *this = mtd->priv;
- 	unsigned long nandaddr = (unsigned long) this->IO_ADDR_W;
- 
-+	if (req_mask) {
-+		if (cmd != NAND_CMD_STATUS)
-+			ltq_ebu_w32(EBU_NAND_WAIT, 0); /* Clear nand ready */
-+	}
-+
-+
- 	if (ctrl & NAND_CTRL_CHANGE) {
- 		if (ctrl & NAND_CLE)
- 			xway_latchcmd = NAND_WRITE_CMD;
-@@ -115,6 +152,24 @@ static void xway_cmd_ctrl(struct mtd_inf
- 		while ((ltq_ebu_r32(EBU_NAND_WAIT) & NAND_WAIT_WR_C) == 0)
- 			;
- 	}
-+
-+	if (req_mask) {
-+	       /*
-+		* program and erase have their own busy handlers
-+		* status and sequential in needs no delay
-+		*/
-+		switch (cmd) {
-+			case NAND_CMD_ERASE1:
-+			case NAND_CMD_SEQIN:
-+			case NAND_CMD_STATUS:
-+			case NAND_CMD_READID:
-+			return;
-+		}
-+
-+		/* wait until command is processed */
-+		while ((ltq_ebu_r32(EBU_NAND_WAIT) & NAND_WAIT_RD) == 0)
-+			;
-+	}
- }
- 
- static int xway_dev_ready(struct mtd_info *mtd)
-@@ -157,6 +212,8 @@ static int xway_nand_probe(struct platfo
- {
- 	struct nand_chip *this = platform_get_drvdata(pdev);
- 	unsigned long nandaddr = (unsigned long) this->IO_ADDR_W;
-+	const __be32 *req_mask_ptr = of_get_property(pdev->dev.of_node,
-+					"req-mask", NULL);
- 	const __be32 *cs = of_get_property(pdev->dev.of_node,
- 					"lantiq,cs", NULL);
- 	u32 cs_flag = 0;
-@@ -165,6 +222,12 @@ static int xway_nand_probe(struct platfo
- 	if (cs && (*cs == 1))
- 		cs_flag = NAND_CON_IN_CS1 | NAND_CON_OUT_CS1;
- 
-+	/*
-+	 * Load the PCI req lines to mask from the device tree. If the
-+	 * property is not present, setting req_mask to 0 disables masking.
-+	 */
-+	req_mask = (req_mask_ptr ? *req_mask_ptr : 0);
-+
- 	/* setup the EBU to run in NAND mode on our base addr */
- 	ltq_ebu_w32(CPHYSADDR(nandaddr)
- 		| ADDSEL1_MASK(3) | ADDSEL1_REGEN, EBU_ADDSEL1);
diff --git a/target/linux/lantiq/patches-3.18/0020-MTD-lantiq-handle-NO_XIP-on-cfi0001-flash.patch b/target/linux/lantiq/patches-3.18/0020-MTD-lantiq-handle-NO_XIP-on-cfi0001-flash.patch
deleted file mode 100644
index 36a899d4f8..0000000000
--- a/target/linux/lantiq/patches-3.18/0020-MTD-lantiq-handle-NO_XIP-on-cfi0001-flash.patch
+++ /dev/null
@@ -1,25 +0,0 @@
-From e3b20f04e9f9cae1babe091fdc1d08d7703ae344 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Thu, 7 Aug 2014 18:18:00 +0200
-Subject: [PATCH 20/36] MTD: lantiq: handle NO_XIP on cfi0001 flash
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/mtd/maps/lantiq-flash.c |    6 +++++-
- 1 file changed, 5 insertions(+), 1 deletion(-)
-
---- a/drivers/mtd/maps/lantiq-flash.c
-+++ b/drivers/mtd/maps/lantiq-flash.c
-@@ -139,7 +139,11 @@ ltq_mtd_probe(struct platform_device *pd
- 	if (!ltq_mtd->map)
- 		return -ENOMEM;
- 
--	ltq_mtd->map->phys = ltq_mtd->res->start;
-+	if (of_find_property(pdev->dev.of_node, "lantiq,noxip", NULL))
-+		ltq_mtd->map->phys = NO_XIP;
-+	else
-+		ltq_mtd->map->phys = ltq_mtd->res->start;
-+	ltq_mtd->res->start;
- 	ltq_mtd->map->size = resource_size(ltq_mtd->res);
- 	ltq_mtd->map->virt = devm_ioremap_resource(&pdev->dev, ltq_mtd->res);
- 	if (IS_ERR(ltq_mtd->map->virt))
diff --git a/target/linux/lantiq/patches-3.18/0022-MTD-m25p80-allow-loading-mtd-name-from-OF.patch b/target/linux/lantiq/patches-3.18/0022-MTD-m25p80-allow-loading-mtd-name-from-OF.patch
deleted file mode 100644
index 203eb9495e..0000000000
--- a/target/linux/lantiq/patches-3.18/0022-MTD-m25p80-allow-loading-mtd-name-from-OF.patch
+++ /dev/null
@@ -1,44 +0,0 @@
-From 4400e1f593ea40a51912128adb4f53d59e62cad8 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Wed, 10 Sep 2014 22:40:18 +0200
-Subject: [PATCH 22/36] MTD: m25p80: allow loading mtd name from OF
-
-In accordance with the physmap flash we should honour the linux,mtd-name
-property when deciding what name the mtd device has.
-
-Signed-off-by: Thomas Langer <thomas.langer@lantiq.com>
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/mtd/devices/m25p80.c |    6 ++++++
- 1 file changed, 6 insertions(+)
-
---- a/drivers/mtd/devices/m25p80.c
-+++ b/drivers/mtd/devices/m25p80.c
-@@ -19,6 +19,7 @@
- #include <linux/errno.h>
- #include <linux/module.h>
- #include <linux/device.h>
-+#include <linux/of.h>
- 
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
-@@ -198,6 +199,10 @@ static int m25p_probe(struct spi_device
- 	enum read_mode mode = SPI_NOR_NORMAL;
- 	char *flash_name = NULL;
- 	int ret;
-+	const char __maybe_unused	*of_mtd_name = NULL;
-+
-+	of_property_read_string(spi->dev.of_node,
-+		"linux,mtd-name", &of_mtd_name);
- 
- 	data = dev_get_platdata(&spi->dev);
- 
-@@ -229,6 +234,8 @@ static int m25p_probe(struct spi_device
- 
- 	if (data && data->name)
- 		flash->mtd.name = data->name;
-+	else if (of_mtd_name)
-+		flash->mtd.name = of_mtd_name;
- 
- 	/* For some (historical?) reason many platforms provide two different
- 	 * names in flash_platform_data: "name" and "type". Quite often name is
diff --git a/target/linux/lantiq/patches-3.18/0023-NET-PHY-adds-driver-for-lantiq-PHY11G.patch b/target/linux/lantiq/patches-3.18/0023-NET-PHY-adds-driver-for-lantiq-PHY11G.patch
deleted file mode 100644
index 4574b99a0e..0000000000
--- a/target/linux/lantiq/patches-3.18/0023-NET-PHY-adds-driver-for-lantiq-PHY11G.patch
+++ /dev/null
@@ -1,271 +0,0 @@
-From 0a63ab263725c427051a8bbaa0732b749627da27 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Thu, 7 Aug 2014 18:15:36 +0200
-Subject: [PATCH 23/36] NET: PHY: adds driver for lantiq PHY11G
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/net/phy/Kconfig  |    5 +
- drivers/net/phy/Makefile |    1 +
- drivers/net/phy/lantiq.c |  231 ++++++++++++++++++++++++++++++++++++++++++++++
- 3 files changed, 237 insertions(+)
- create mode 100644 drivers/net/phy/lantiq.c
-
---- a/drivers/net/phy/Kconfig
-+++ b/drivers/net/phy/Kconfig
-@@ -164,6 +164,11 @@ config RTL8306_PHY
- 	tristate "Driver for Realtek RTL8306S switches"
- 	select SWCONFIG
- 
-+config LANTIQ_PHY
-+	tristate "Driver for Lantiq PHYs"
-+	---help---
-+	  Supports the 11G and 22E PHYs.
-+
- config FIXED_PHY
- 	bool "Driver for MDIO Bus/PHY emulation with fixed speed/link PHYs"
- 	depends on PHYLIB=y
---- a/drivers/net/phy/Makefile
-+++ b/drivers/net/phy/Makefile
-@@ -40,6 +40,7 @@ obj-$(CONFIG_NATIONAL_PHY)	+= national.o
- obj-$(CONFIG_DP83640_PHY)	+= dp83640.o
- obj-$(CONFIG_STE10XP)		+= ste10Xp.o
- obj-$(CONFIG_MICREL_PHY)	+= micrel.o
-+obj-$(CONFIG_LANTIQ_PHY)        += lantiq.o
- obj-$(CONFIG_MDIO_OCTEON)	+= mdio-octeon.o
- obj-$(CONFIG_MICREL_KS8995MA)	+= spi_ks8995.o
- obj-$(CONFIG_AT803X_PHY)	+= at803x.o
---- /dev/null
-+++ b/drivers/net/phy/lantiq.c
-@@ -0,0 +1,231 @@
-+/*
-+ *   This program is free software; you can redistribute it and/or modify
-+ *   it under the terms of the GNU General Public License as published by
-+ *   the Free Software Foundation; either version 2 of the License, or
-+ *   (at your option) any later version.
-+ *
-+ *   This program is distributed in the hope that it will be useful,
-+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ *   GNU General Public License for more details.
-+ *
-+ *   You should have received a copy of the GNU General Public License
-+ *   along with this program; if not, write to the Free Software
-+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-+ *
-+ *   Copyright (C) 2012 Daniel Schwierzeck <daniel.schwierzeck@googlemail.com>
-+ */
-+
-+#include <linux/module.h>
-+#include <linux/phy.h>
-+
-+#define MII_MMDCTRL		0x0d
-+#define MII_MMDDATA		0x0e
-+
-+#define MII_VR9_11G_IMASK	0x19	/* interrupt mask */
-+#define MII_VR9_11G_ISTAT	0x1a	/* interrupt status */
-+
-+#define INT_VR9_11G_WOL		BIT(15)	/* Wake-On-LAN */
-+#define INT_VR9_11G_ANE		BIT(11)	/* Auto-Neg error */
-+#define INT_VR9_11G_ANC		BIT(10)	/* Auto-Neg complete */
-+#define INT_VR9_11G_ADSC	BIT(5)	/* Link auto-downspeed detect */
-+#define INT_VR9_11G_DXMC	BIT(2)	/* Duplex mode change */
-+#define INT_VR9_11G_LSPC	BIT(1)	/* Link speed change */
-+#define INT_VR9_11G_LSTC	BIT(0)	/* Link state change */
-+#define INT_VR9_11G_MASK	(INT_VR9_11G_LSTC | INT_VR9_11G_ADSC)
-+
-+#define ADVERTISED_MPD		BIT(10)	/* Multi-port device */
-+
-+#define MMD_DEVAD		0x1f
-+#define MMD_ACTYPE_SHIFT	14
-+#define MMD_ACTYPE_ADDRESS	(0 << MMD_ACTYPE_SHIFT)
-+#define MMD_ACTYPE_DATA		(1 << MMD_ACTYPE_SHIFT)
-+#define MMD_ACTYPE_DATA_PI	(2 << MMD_ACTYPE_SHIFT)
-+#define MMD_ACTYPE_DATA_PIWR	(3 << MMD_ACTYPE_SHIFT)
-+
-+static __maybe_unused int vr9_gphy_mmd_read(struct phy_device *phydev,
-+						u16 regnum)
-+{
-+	phy_write(phydev, MII_MMDCTRL, MMD_ACTYPE_ADDRESS | MMD_DEVAD);
-+	phy_write(phydev, MII_MMDDATA, regnum);
-+	phy_write(phydev, MII_MMDCTRL, MMD_ACTYPE_DATA | MMD_DEVAD);
-+
-+	return phy_read(phydev, MII_MMDDATA);
-+}
-+
-+static __maybe_unused int vr9_gphy_mmd_write(struct phy_device *phydev,
-+						u16 regnum, u16 val)
-+{
-+	phy_write(phydev, MII_MMDCTRL, MMD_ACTYPE_ADDRESS | MMD_DEVAD);
-+	phy_write(phydev, MII_MMDDATA, regnum);
-+	phy_write(phydev, MII_MMDCTRL, MMD_ACTYPE_DATA | MMD_DEVAD);
-+	phy_write(phydev, MII_MMDDATA, val);
-+
-+	return 0;
-+}
-+
-+static int vr9_gphy_config_init(struct phy_device *phydev)
-+{
-+	int err;
-+
-+	dev_dbg(&phydev->dev, "%s\n", __func__);
-+
-+	/* Mask all interrupts */
-+	err = phy_write(phydev, MII_VR9_11G_IMASK, 0);
-+	if (err)
-+		return err;
-+
-+	/* Clear all pending interrupts */
-+	phy_read(phydev, MII_VR9_11G_ISTAT);
-+
-+	vr9_gphy_mmd_write(phydev, 0x1e0, 0xc5);
-+	vr9_gphy_mmd_write(phydev, 0x1e1, 0x67);
-+	vr9_gphy_mmd_write(phydev, 0x1e2, 0x42);
-+	vr9_gphy_mmd_write(phydev, 0x1e3, 0x10);
-+	vr9_gphy_mmd_write(phydev, 0x1e4, 0x70);
-+	vr9_gphy_mmd_write(phydev, 0x1e5, 0x03);
-+	vr9_gphy_mmd_write(phydev, 0x1e6, 0x20);
-+	vr9_gphy_mmd_write(phydev, 0x1e7, 0x00);
-+	vr9_gphy_mmd_write(phydev, 0x1e8, 0x40);
-+	vr9_gphy_mmd_write(phydev, 0x1e9, 0x20);
-+
-+	return 0;
-+}
-+
-+static int vr9_gphy_config_aneg(struct phy_device *phydev)
-+{
-+	int reg, err;
-+
-+	/* Advertise as multi-port device */
-+	reg = phy_read(phydev, MII_CTRL1000);
-+	reg |= ADVERTISED_MPD;
-+	err = phy_write(phydev, MII_CTRL1000, reg);
-+	if (err)
-+		return err;
-+
-+	return genphy_config_aneg(phydev);
-+}
-+
-+static int vr9_gphy_ack_interrupt(struct phy_device *phydev)
-+{
-+	int reg;
-+
-+	/*
-+	 * Possible IRQ numbers:
-+	 * - IM3_IRL18 for GPHY0
-+	 * - IM3_IRL17 for GPHY1
-+	 *
-+	 * Due to a silicon bug IRQ lines are not really independent from
-+	 * each other. Sometimes the two lines are driven at the same time
-+	 * if only one GPHY core raises the interrupt.
-+	 */
-+
-+	reg = phy_read(phydev, MII_VR9_11G_ISTAT);
-+
-+	return (reg < 0) ? reg : 0;
-+}
-+
-+static int vr9_gphy_did_interrupt(struct phy_device *phydev)
-+{
-+	int reg;
-+
-+	reg = phy_read(phydev, MII_VR9_11G_ISTAT);
-+
-+	return reg > 0;
-+}
-+
-+static int vr9_gphy_config_intr(struct phy_device *phydev)
-+{
-+	int err;
-+
-+	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
-+		err = phy_write(phydev, MII_VR9_11G_IMASK, INT_VR9_11G_MASK);
-+	else
-+		err = phy_write(phydev, MII_VR9_11G_IMASK, 0);
-+
-+	return err;
-+}
-+
-+static struct phy_driver lantiq_phy[] = {
-+	{
-+		.phy_id		= 0xd565a400,
-+		.phy_id_mask	= 0xffffffff,
-+		.name		= "Lantiq XWAY PEF7071",
-+		.features	= (PHY_GBIT_FEATURES | SUPPORTED_Pause),
-+		.flags		= 0, /*PHY_HAS_INTERRUPT,*/
-+		.config_init	= vr9_gphy_config_init,
-+		.config_aneg	= vr9_gphy_config_aneg,
-+		.read_status	= genphy_read_status,
-+		.ack_interrupt	= vr9_gphy_ack_interrupt,
-+		.did_interrupt	= vr9_gphy_did_interrupt,
-+		.config_intr	= vr9_gphy_config_intr,
-+		.driver		= { .owner = THIS_MODULE },
-+	}, {
-+		.phy_id		= 0x030260D0,
-+		.phy_id_mask	= 0xfffffff0,
-+		.name		= "Lantiq XWAY VR9 GPHY 11G v1.3",
-+		.features	= (PHY_GBIT_FEATURES | SUPPORTED_Pause),
-+		.flags		= 0, /*PHY_HAS_INTERRUPT,*/
-+		.config_init	= vr9_gphy_config_init,
-+		.config_aneg	= vr9_gphy_config_aneg,
-+		.read_status	= genphy_read_status,
-+		.ack_interrupt	= vr9_gphy_ack_interrupt,
-+		.did_interrupt	= vr9_gphy_did_interrupt,
-+		.config_intr	= vr9_gphy_config_intr,
-+		.driver		= { .owner = THIS_MODULE },
-+	}, {
-+		.phy_id		= 0xd565a408,
-+		.phy_id_mask	= 0xfffffff8,
-+		.name		= "Lantiq XWAY VR9 GPHY 11G v1.4",
-+		.features	= (PHY_GBIT_FEATURES | SUPPORTED_Pause),
-+		.flags		= 0, /*PHY_HAS_INTERRUPT,*/
-+		.config_init	= vr9_gphy_config_init,
-+		.config_aneg	= vr9_gphy_config_aneg,
-+		.read_status	= genphy_read_status,
-+		.ack_interrupt	= vr9_gphy_ack_interrupt,
-+		.did_interrupt	= vr9_gphy_did_interrupt,
-+		.config_intr	= vr9_gphy_config_intr,
-+		.driver		= { .owner = THIS_MODULE },
-+	}, {
-+		.phy_id		= 0xd565a418,
-+		.phy_id_mask	= 0xfffffff8,
-+		.name		= "Lantiq XWAY XRX PHY22F v1.4",
-+		.features	= (PHY_BASIC_FEATURES | SUPPORTED_Pause),
-+		.flags		= 0, /*PHY_HAS_INTERRUPT,*/
-+		.config_init	= vr9_gphy_config_init,
-+		.config_aneg	= vr9_gphy_config_aneg,
-+		.read_status	= genphy_read_status,
-+		.ack_interrupt	= vr9_gphy_ack_interrupt,
-+		.did_interrupt	= vr9_gphy_did_interrupt,
-+		.config_intr	= vr9_gphy_config_intr,
-+		.driver		= { .owner = THIS_MODULE },
-+	},
-+};
-+
-+static int __init ltq_phy_init(void)
-+{
-+	int i;
-+
-+	for (i = 0; i < ARRAY_SIZE(lantiq_phy); i++) {
-+		int err = phy_driver_register(&lantiq_phy[i]);
-+		if (err)
-+			pr_err("lantiq_phy: failed to load %s\n", lantiq_phy[i].name);
-+	}
-+
-+	return 0;
-+}
-+
-+static void __exit ltq_phy_exit(void)
-+{
-+	int i;
-+
-+	for (i = 0; i < ARRAY_SIZE(lantiq_phy); i++)
-+		phy_driver_unregister(&lantiq_phy[i]);
-+}
-+
-+module_init(ltq_phy_init);
-+module_exit(ltq_phy_exit);
-+
-+MODULE_DESCRIPTION("Lantiq PHY drivers");
-+MODULE_AUTHOR("Daniel Schwierzeck <daniel.schwierzeck@googlemail.com>");
-+MODULE_LICENSE("GPL");
diff --git a/target/linux/lantiq/patches-3.18/0024-NET-lantiq-adds-PHY11G-firmware-blobs.patch b/target/linux/lantiq/patches-3.18/0024-NET-lantiq-adds-PHY11G-firmware-blobs.patch
deleted file mode 100644
index b69b2a900f..0000000000
--- a/target/linux/lantiq/patches-3.18/0024-NET-lantiq-adds-PHY11G-firmware-blobs.patch
+++ /dev/null
@@ -1,364 +0,0 @@
-From 77e89d5a28be35058041c79e9874ab26f222c603 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Mon, 22 Oct 2012 09:26:24 +0200
-Subject: [PATCH 24/36] NET: lantiq: adds PHY11G firmware blobs
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- firmware/Makefile       |    4 +
- firmware/lantiq/COPYING |  286 +++++++++++++++++++++++++++++++++++++++++++++++
- firmware/lantiq/README  |   45 ++++++++
- 3 files changed, 335 insertions(+)
- create mode 100644 firmware/lantiq/COPYING
- create mode 100644 firmware/lantiq/README
-
---- a/firmware/Makefile
-+++ b/firmware/Makefile
-@@ -134,6 +134,10 @@ fw-shipped-$(CONFIG_USB_SERIAL_KEYSPAN_P
- fw-shipped-$(CONFIG_USB_SERIAL_XIRCOM) += keyspan_pda/xircom_pgs.fw
- fw-shipped-$(CONFIG_USB_VICAM) += vicam/firmware.fw
- fw-shipped-$(CONFIG_VIDEO_CPIA2) += cpia2/stv0672_vp4.bin
-+fw-shipped-$(CONFIG_LANTIQ_XRX200) += lantiq/vr9_phy11g_a1x.bin
-+fw-shipped-$(CONFIG_LANTIQ_XRX200) += lantiq/vr9_phy11g_a2x.bin
-+fw-shipped-$(CONFIG_LANTIQ_XRX200) += lantiq/vr9_phy22f_a1x.bin
-+fw-shipped-$(CONFIG_LANTIQ_XRX200) += lantiq/vr9_phy22f_a2x.bin
- fw-shipped-$(CONFIG_YAM) += yam/1200.bin yam/9600.bin
- 
- fw-shipped-all := $(fw-shipped-y) $(fw-shipped-m) $(fw-shipped-)
---- /dev/null
-+++ b/firmware/lantiq/COPYING
-@@ -0,0 +1,286 @@
-+All firmware files are copyrighted by Lantiq Deutschland GmbH.
-+The files have been extracted from header files found in Lantiq BSPs.
-+If not stated otherwise all files are licensed under GPL.
-+
-+=======================================================================
-+
-+		    GNU GENERAL PUBLIC LICENSE
-+		       Version 2, June 1991
-+
-+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-+ Everyone is permitted to copy and distribute verbatim copies
-+ of this license document, but changing it is not allowed.
-+
-+			    Preamble
-+
-+  The licenses for most software are designed to take away your
-+freedom to share and change it.  By contrast, the GNU General Public
-+License is intended to guarantee your freedom to share and change free
-+software--to make sure the software is free for all its users.  This
-+General Public License applies to most of the Free Software
-+Foundation's software and to any other program whose authors commit to
-+using it.  (Some other Free Software Foundation software is covered by
-+the GNU Library General Public License instead.)  You can apply it to
-+your programs, too.
-+
-+  When we speak of free software, we are referring to freedom, not
-+price.  Our General Public Licenses are designed to make sure that you
-+have the freedom to distribute copies of free software (and charge for
-+this service if you wish), that you receive source code or can get it
-+if you want it, that you can change the software or use pieces of it
-+in new free programs; and that you know you can do these things.
-+
-+  To protect your rights, we need to make restrictions that forbid
-+anyone to deny you these rights or to ask you to surrender the rights.
-+These restrictions translate to certain responsibilities for you if you
-+distribute copies of the software, or if you modify it.
-+
-+  For example, if you distribute copies of such a program, whether
-+gratis or for a fee, you must give the recipients all the rights that
-+you have.  You must make sure that they, too, receive or can get the
-+source code.  And you must show them these terms so they know their
-+rights.
-+
-+  We protect your rights with two steps: (1) copyright the software, and
-+(2) offer you this license which gives you legal permission to copy,
-+distribute and/or modify the software.
-+
-+  Also, for each author's protection and ours, we want to make certain
-+that everyone understands that there is no warranty for this free
-+software.  If the software is modified by someone else and passed on, we
-+want its recipients to know that what they have is not the original, so
-+that any problems introduced by others will not reflect on the original
-+authors' reputations.
-+
-+  Finally, any free program is threatened constantly by software
-+patents.  We wish to avoid the danger that redistributors of a free
-+program will individually obtain patent licenses, in effect making the
-+program proprietary.  To prevent this, we have made it clear that any
-+patent must be licensed for everyone's free use or not licensed at all.
-+
-+  The precise terms and conditions for copying, distribution and
-+modification follow.
-+
-+		    GNU GENERAL PUBLIC LICENSE
-+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-+
-+  0. This License applies to any program or other work which contains
-+a notice placed by the copyright holder saying it may be distributed
-+under the terms of this General Public License.  The "Program", below,
-+refers to any such program or work, and a "work based on the Program"
-+means either the Program or any derivative work under copyright law:
-+that is to say, a work containing the Program or a portion of it,
-+either verbatim or with modifications and/or translated into another
-+language.  (Hereinafter, translation is included without limitation in
-+the term "modification".)  Each licensee is addressed as "you".
-+
-+Activities other than copying, distribution and modification are not
-+covered by this License; they are outside its scope.  The act of
-+running the Program is not restricted, and the output from the Program
-+is covered only if its contents constitute a work based on the
-+Program (independent of having been made by running the Program).
-+Whether that is true depends on what the Program does.
-+
-+  1. You may copy and distribute verbatim copies of the Program's
-+source code as you receive it, in any medium, provided that you
-+conspicuously and appropriately publish on each copy an appropriate
-+copyright notice and disclaimer of warranty; keep intact all the
-+notices that refer to this License and to the absence of any warranty;
-+and give any other recipients of the Program a copy of this License
-+along with the Program.
-+
-+You may charge a fee for the physical act of transferring a copy, and
-+you may at your option offer warranty protection in exchange for a fee.
-+
-+  2. You may modify your copy or copies of the Program or any portion
-+of it, thus forming a work based on the Program, and copy and
-+distribute such modifications or work under the terms of Section 1
-+above, provided that you also meet all of these conditions:
-+
-+    a) You must cause the modified files to carry prominent notices
-+    stating that you changed the files and the date of any change.
-+
-+    b) You must cause any work that you distribute or publish, that in
-+    whole or in part contains or is derived from the Program or any
-+    part thereof, to be licensed as a whole at no charge to all third
-+    parties under the terms of this License.
-+
-+    c) If the modified program normally reads commands interactively
-+    when run, you must cause it, when started running for such
-+    interactive use in the most ordinary way, to print or display an
-+    announcement including an appropriate copyright notice and a
-+    notice that there is no warranty (or else, saying that you provide
-+    a warranty) and that users may redistribute the program under
-+    these conditions, and telling the user how to view a copy of this
-+    License.  (Exception: if the Program itself is interactive but
-+    does not normally print such an announcement, your work based on
-+    the Program is not required to print an announcement.)
-+
-+These requirements apply to the modified work as a whole.  If
-+identifiable sections of that work are not derived from the Program,
-+and can be reasonably considered independent and separate works in
-+themselves, then this License, and its terms, do not apply to those
-+sections when you distribute them as separate works.  But when you
-+distribute the same sections as part of a whole which is a work based
-+on the Program, the distribution of the whole must be on the terms of
-+this License, whose permissions for other licensees extend to the
-+entire whole, and thus to each and every part regardless of who wrote it.
-+
-+Thus, it is not the intent of this section to claim rights or contest
-+your rights to work written entirely by you; rather, the intent is to
-+exercise the right to control the distribution of derivative or
-+collective works based on the Program.
-+
-+In addition, mere aggregation of another work not based on the Program
-+with the Program (or with a work based on the Program) on a volume of
-+a storage or distribution medium does not bring the other work under
-+the scope of this License.
-+
-+  3. You may copy and distribute the Program (or a work based on it,
-+under Section 2) in object code or executable form under the terms of
-+Sections 1 and 2 above provided that you also do one of the following:
-+
-+    a) Accompany it with the complete corresponding machine-readable
-+    source code, which must be distributed under the terms of Sections
-+    1 and 2 above on a medium customarily used for software interchange; or,
-+
-+    b) Accompany it with a written offer, valid for at least three
-+    years, to give any third party, for a charge no more than your
-+    cost of physically performing source distribution, a complete
-+    machine-readable copy of the corresponding source code, to be
-+    distributed under the terms of Sections 1 and 2 above on a medium
-+    customarily used for software interchange; or,
-+
-+    c) Accompany it with the information you received as to the offer
-+    to distribute corresponding source code.  (This alternative is
-+    allowed only for noncommercial distribution and only if you
-+    received the program in object code or executable form with such
-+    an offer, in accord with Subsection b above.)
-+
-+The source code for a work means the preferred form of the work for
-+making modifications to it.  For an executable work, complete source
-+code means all the source code for all modules it contains, plus any
-+associated interface definition files, plus the scripts used to
-+control compilation and installation of the executable.  However, as a
-+special exception, the source code distributed need not include
-+anything that is normally distributed (in either source or binary
-+form) with the major components (compiler, kernel, and so on) of the
-+operating system on which the executable runs, unless that component
-+itself accompanies the executable.
-+
-+If distribution of executable or object code is made by offering
-+access to copy from a designated place, then offering equivalent
-+access to copy the source code from the same place counts as
-+distribution of the source code, even though third parties are not
-+compelled to copy the source along with the object code.
-+
-+  4. You may not copy, modify, sublicense, or distribute the Program
-+except as expressly provided under this License.  Any attempt
-+otherwise to copy, modify, sublicense or distribute the Program is
-+void, and will automatically terminate your rights under this License.
-+However, parties who have received copies, or rights, from you under
-+this License will not have their licenses terminated so long as such
-+parties remain in full compliance.
-+
-+  5. You are not required to accept this License, since you have not
-+signed it.  However, nothing else grants you permission to modify or
-+distribute the Program or its derivative works.  These actions are
-+prohibited by law if you do not accept this License.  Therefore, by
-+modifying or distributing the Program (or any work based on the
-+Program), you indicate your acceptance of this License to do so, and
-+all its terms and conditions for copying, distributing or modifying
-+the Program or works based on it.
-+
-+  6. Each time you redistribute the Program (or any work based on the
-+Program), the recipient automatically receives a license from the
-+original licensor to copy, distribute or modify the Program subject to
-+these terms and conditions.  You may not impose any further
-+restrictions on the recipients' exercise of the rights granted herein.
-+You are not responsible for enforcing compliance by third parties to
-+this License.
-+
-+  7. If, as a consequence of a court judgment or allegation of patent
-+infringement or for any other reason (not limited to patent issues),
-+conditions are imposed on you (whether by court order, agreement or
-+otherwise) that contradict the conditions of this License, they do not
-+excuse you from the conditions of this License.  If you cannot
-+distribute so as to satisfy simultaneously your obligations under this
-+License and any other pertinent obligations, then as a consequence you
-+may not distribute the Program at all.  For example, if a patent
-+license would not permit royalty-free redistribution of the Program by
-+all those who receive copies directly or indirectly through you, then
-+the only way you could satisfy both it and this License would be to
-+refrain entirely from distribution of the Program.
-+
-+If any portion of this section is held invalid or unenforceable under
-+any particular circumstance, the balance of the section is intended to
-+apply and the section as a whole is intended to apply in other
-+circumstances.
-+
-+It is not the purpose of this section to induce you to infringe any
-+patents or other property right claims or to contest validity of any
-+such claims; this section has the sole purpose of protecting the
-+integrity of the free software distribution system, which is
-+implemented by public license practices.  Many people have made
-+generous contributions to the wide range of software distributed
-+through that system in reliance on consistent application of that
-+system; it is up to the author/donor to decide if he or she is willing
-+to distribute software through any other system and a licensee cannot
-+impose that choice.
-+
-+This section is intended to make thoroughly clear what is believed to
-+be a consequence of the rest of this License.
-+
-+  8. If the distribution and/or use of the Program is restricted in
-+certain countries either by patents or by copyrighted interfaces, the
-+original copyright holder who places the Program under this License
-+may add an explicit geographical distribution limitation excluding
-+those countries, so that distribution is permitted only in or among
-+countries not thus excluded.  In such case, this License incorporates
-+the limitation as if written in the body of this License.
-+
-+  9. The Free Software Foundation may publish revised and/or new versions
-+of the General Public License from time to time.  Such new versions will
-+be similar in spirit to the present version, but may differ in detail to
-+address new problems or concerns.
-+
-+Each version is given a distinguishing version number.  If the Program
-+specifies a version number of this License which applies to it and "any
-+later version", you have the option of following the terms and conditions
-+either of that version or of any later version published by the Free
-+Software Foundation.  If the Program does not specify a version number of
-+this License, you may choose any version ever published by the Free Software
-+Foundation.
-+
-+  10. If you wish to incorporate parts of the Program into other free
-+programs whose distribution conditions are different, write to the author
-+to ask for permission.  For software which is copyrighted by the Free
-+Software Foundation, write to the Free Software Foundation; we sometimes
-+make exceptions for this.  Our decision will be guided by the two goals
-+of preserving the free status of all derivatives of our free software and
-+of promoting the sharing and reuse of software generally.
-+
-+			    NO WARRANTY
-+
-+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-+REPAIR OR CORRECTION.
-+
-+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-+POSSIBILITY OF SUCH DAMAGES.
-+
-+		     END OF TERMS AND CONDITIONS
---- /dev/null
-+++ b/firmware/lantiq/README
-@@ -0,0 +1,45 @@
-+#
-+# This program is free software; you can redistribute it and/or
-+# modify it under the terms of the GNU General Public License as
-+# published by the Free Software Foundation; either version 2 of
-+# the License, or (at your option) any later version.
-+#
-+# This program is distributed in the hope that it will be useful,
-+# but WITHOUT ANY WARRANTY; without even the implied warranty of
-+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+# GNU General Public License for more details.
-+#
-+# You should have received a copy of the GNU General Public License
-+# along with this program; if not, write to the Free Software
-+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-+# MA 02111-1307 USA
-+#
-+# (C) Copyright 2007 - 2012
-+# Lantiq Deutschland GmbH
-+#
-+# (C) Copyright 2012
-+# Daniel Schwierzeck <daniel.schwierzeck@googlemail.com>
-+#
-+
-+#
-+# How to use
-+#
-+Configure kernel with:
-+CONFIG_FW_LOADER=y
-+CONFIG_EXTRA_FIRMWARE_DIR="FIRMWARE_DIR"
-+CONFIG_EXTRA_FIRMWARE="FIRMWARE_FILES"
-+
-+where FIRMWARE_DIR should point to this git tree and FIRMWARE_FILES is a list
-+of space separated files from list below.
-+
-+#
-+# Firmware files
-+#
-+
-+# GPHY core on Lantiq XWAY VR9 v1.1
-+lantiq/vr9_phy11g_a1x.bin
-+lantiq/vr9_phy22f_a1x.bin
-+
-+# GPHY core on Lantiq XWAY VR9 v1.2
-+lantiq/vr9_phy11g_a2x.bin
-+lantiq/vr9_phy22f_a2x.bin
diff --git a/target/linux/lantiq/patches-3.18/0025-NET-MIPS-lantiq-adds-xrx200-net.patch b/target/linux/lantiq/patches-3.18/0025-NET-MIPS-lantiq-adds-xrx200-net.patch
deleted file mode 100644
index f2a9d1bbab..0000000000
--- a/target/linux/lantiq/patches-3.18/0025-NET-MIPS-lantiq-adds-xrx200-net.patch
+++ /dev/null
@@ -1,3339 +0,0 @@
-From fb0c9601f4414c39ff68e26b88681bef0bb04954 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Mon, 22 Oct 2012 12:22:23 +0200
-Subject: [PATCH 25/36] NET: MIPS: lantiq: adds xrx200-net
-
----
- drivers/net/ethernet/Kconfig            |    8 +-
- drivers/net/ethernet/Makefile           |    1 +
- drivers/net/ethernet/lantiq_pce.h       |  163 +++
- drivers/net/ethernet/lantiq_xrx200.c    | 1798 +++++++++++++++++++++++++++++++
- drivers/net/ethernet/lantiq_xrx200_sw.h | 1328 +++++++++++++++++++++++
- 5 files changed, 3297 insertions(+), 1 deletion(-)
- create mode 100644 drivers/net/ethernet/lantiq_pce.h
- create mode 100644 drivers/net/ethernet/lantiq_xrx200.c
- create mode 100644 drivers/net/ethernet/lantiq_xrx200_sw.h
-
---- a/drivers/net/ethernet/Kconfig
-+++ b/drivers/net/ethernet/Kconfig
-@@ -101,7 +101,13 @@ config LANTIQ_ETOP
- 	tristate "Lantiq SoC ETOP driver"
- 	depends on SOC_TYPE_XWAY
- 	---help---
--	  Support for the MII0 inside the Lantiq SoC
-+	  Support for the MII0 inside the Lantiq ADSL SoC
-+
-+config LANTIQ_XRX200
-+	tristate "Lantiq SoC XRX200 driver"
-+	depends on SOC_TYPE_XWAY
-+	---help---
-+	  Support for the MII0 inside the Lantiq VDSL SoC
- 
- source "drivers/net/ethernet/marvell/Kconfig"
- source "drivers/net/ethernet/mellanox/Kconfig"
---- a/drivers/net/ethernet/Makefile
-+++ b/drivers/net/ethernet/Makefile
-@@ -43,6 +43,7 @@ obj-$(CONFIG_IP1000) += icplus/
- obj-$(CONFIG_JME) += jme.o
- obj-$(CONFIG_KORINA) += korina.o
- obj-$(CONFIG_LANTIQ_ETOP) += lantiq_etop.o
-+obj-$(CONFIG_LANTIQ_XRX200) += lantiq_xrx200.o
- obj-$(CONFIG_NET_VENDOR_MARVELL) += marvell/
- obj-$(CONFIG_NET_VENDOR_MELLANOX) += mellanox/
- obj-$(CONFIG_NET_VENDOR_MICREL) += micrel/
---- /dev/null
-+++ b/drivers/net/ethernet/lantiq_pce.h
-@@ -0,0 +1,163 @@
-+/*
-+ *   This program is free software; you can redistribute it and/or modify it
-+ *   under the terms of the GNU General Public License version 2 as published
-+ *   by the Free Software Foundation.
-+ *
-+ *   This program is distributed in the hope that it will be useful,
-+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ *   GNU General Public License for more details.
-+ *
-+ *   You should have received a copy of the GNU General Public License
-+ *   along with this program; if not, write to the Free Software
-+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-+ *
-+ *   Copyright (C) 2010 Lantiq Deutschland GmbH
-+ *   Copyright (C) 2012 John Crispin <blogic@openwrt.org>
-+ *
-+ *   PCE microcode extracted from UGW5.2 switch api
-+ */
-+
-+/* Switch API Micro Code V0.3 */
-+enum {
-+	OUT_MAC0 = 0,
-+	OUT_MAC1,
-+	OUT_MAC2,
-+	OUT_MAC3,
-+	OUT_MAC4,
-+	OUT_MAC5,
-+	OUT_ETHTYP,
-+	OUT_VTAG0,
-+	OUT_VTAG1,
-+	OUT_ITAG0,
-+	OUT_ITAG1,	/*10 */
-+	OUT_ITAG2,
-+	OUT_ITAG3,
-+	OUT_IP0,
-+	OUT_IP1,
-+	OUT_IP2,
-+	OUT_IP3,
-+	OUT_SIP0,
-+	OUT_SIP1,
-+	OUT_SIP2,
-+	OUT_SIP3,	/*20*/
-+	OUT_SIP4,
-+	OUT_SIP5,
-+	OUT_SIP6,
-+	OUT_SIP7,
-+	OUT_DIP0,
-+	OUT_DIP1,
-+	OUT_DIP2,
-+	OUT_DIP3,
-+	OUT_DIP4,
-+	OUT_DIP5,	/*30*/
-+	OUT_DIP6,
-+	OUT_DIP7,
-+	OUT_SESID,
-+	OUT_PROT,
-+	OUT_APP0,
-+	OUT_APP1,
-+	OUT_IGMP0,
-+	OUT_IGMP1,
-+	OUT_IPOFF,	/*39*/
-+	OUT_NONE =  63
-+};
-+
-+/* parser's microcode length type */
-+#define INSTR		0
-+#define IPV6		1
-+#define LENACCU		2
-+
-+/* parser's microcode flag type */
-+enum {
-+	FLAG_ITAG =  0,
-+	FLAG_VLAN,
-+	FLAG_SNAP,
-+	FLAG_PPPOE,
-+	FLAG_IPV6,
-+	FLAG_IPV6FL,
-+	FLAG_IPV4,
-+	FLAG_IGMP,
-+	FLAG_TU,
-+	FLAG_HOP,
-+	FLAG_NN1,	/*10 */
-+	FLAG_NN2,
-+	FLAG_END,
-+	FLAG_NO,	/*13*/
-+};
-+
-+/* Micro code version V2_11 (extension for parsing IPv6 in PPPoE) */
-+#define MC_ENTRY(val, msk, ns, out, len, type, flags, ipv4_len) \
-+	{ {val, msk, (ns<<10 | out<<4 | len>>1), (len&1)<<15 | type<<13 | flags<<9 | ipv4_len<<8 }}
-+struct pce_microcode {
-+	unsigned short val[4];
-+/*	unsigned short val_2;
-+	unsigned short val_1;
-+	unsigned short val_0;*/
-+} pce_microcode[] = {
-+	/*      value    mask    ns  fields      L  type     flags       ipv4_len */
-+	MC_ENTRY(0x88c3, 0xFFFF,  1, OUT_ITAG0,  4, INSTR,   FLAG_ITAG,  0),
-+	MC_ENTRY(0x8100, 0xFFFF,  2, OUT_VTAG0,  2, INSTR,   FLAG_VLAN,  0),
-+	MC_ENTRY(0x88A8, 0xFFFF,  1, OUT_VTAG0,  2, INSTR,   FLAG_VLAN,  0),
-+	MC_ENTRY(0x8100, 0xFFFF,  1, OUT_VTAG0,  2, INSTR,   FLAG_VLAN,  0),
-+	MC_ENTRY(0x8864, 0xFFFF, 17, OUT_ETHTYP, 1, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0800, 0xFFFF, 21, OUT_ETHTYP, 1, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x86DD, 0xFFFF, 22, OUT_ETHTYP, 1, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x8863, 0xFFFF, 16, OUT_ETHTYP, 1, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0000, 0xF800, 10, OUT_NONE,   0, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0000, 0x0000, 38, OUT_ETHTYP, 1, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0600, 0x0600, 38, OUT_ETHTYP, 1, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0000, 0x0000, 12, OUT_NONE,   1, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0xAAAA, 0xFFFF, 14, OUT_NONE,   1, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0300, 0xFF00, 39, OUT_NONE,   0, INSTR,   FLAG_SNAP,  0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_DIP7,   3, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0000, 0x0000, 18, OUT_DIP7,   3, INSTR,   FLAG_PPPOE, 0),
-+	MC_ENTRY(0x0021, 0xFFFF, 21, OUT_NONE,   1, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0057, 0xFFFF, 22, OUT_NONE,   1, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x4000, 0xF000, 24, OUT_IP0,    4, INSTR,   FLAG_IPV4,  1),
-+	MC_ENTRY(0x6000, 0xF000, 27, OUT_IP0,    3, INSTR,   FLAG_IPV6,  0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0000, 0x0000, 25, OUT_IP3,    2, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0000, 0x0000, 26, OUT_SIP0,   4, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0000, 0x0000, 38, OUT_NONE,   0, LENACCU, FLAG_NO,    0),
-+	MC_ENTRY(0x1100, 0xFF00, 37, OUT_PROT,   1, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0600, 0xFF00, 37, OUT_PROT,   1, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0000, 0xFF00, 33, OUT_IP3,   17, INSTR,   FLAG_HOP,   0),
-+	MC_ENTRY(0x2B00, 0xFF00, 33, OUT_IP3,   17, INSTR,   FLAG_NN1,   0),
-+	MC_ENTRY(0x3C00, 0xFF00, 33, OUT_IP3,   17, INSTR,   FLAG_NN2,   0),
-+	MC_ENTRY(0x0000, 0x0000, 37, OUT_PROT,   1, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0000, 0xFF00, 33, OUT_NONE,   0, IPV6,    FLAG_HOP,   0),
-+	MC_ENTRY(0x2B00, 0xFF00, 33, OUT_NONE,   0, IPV6,    FLAG_NN1,   0),
-+	MC_ENTRY(0x3C00, 0xFF00, 33, OUT_NONE,   0, IPV6,    FLAG_NN2,   0),
-+	MC_ENTRY(0x0000, 0x0000, 38, OUT_PROT,   1, IPV6,    FLAG_NO,    0),
-+	MC_ENTRY(0x0000, 0x0000, 38, OUT_SIP0,  16, INSTR,   FLAG_NO,    0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_APP0,   4, INSTR,   FLAG_IGMP,  0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+	MC_ENTRY(0x0000, 0x0000, 39, OUT_NONE,   0, INSTR,   FLAG_END,   0),
-+};
---- /dev/null
-+++ b/drivers/net/ethernet/lantiq_xrx200.c
-@@ -0,0 +1,1796 @@
-+/*
-+ *   This program is free software; you can redistribute it and/or modify it
-+ *   under the terms of the GNU General Public License version 2 as published
-+ *   by the Free Software Foundation.
-+ *
-+ *   This program is distributed in the hope that it will be useful,
-+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ *   GNU General Public License for more details.
-+ *
-+ *   You should have received a copy of the GNU General Public License
-+ *   along with this program; if not, write to the Free Software
-+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-+ *
-+ *   Copyright (C) 2010 Lantiq Deutschland
-+ *   Copyright (C) 2012 John Crispin <blogic@openwrt.org>
-+ */
-+
-+#include <linux/switch.h>
-+#include <linux/etherdevice.h>
-+#include <linux/module.h>
-+#include <linux/platform_device.h>
-+#include <linux/interrupt.h>
-+#include <linux/clk.h>
-+#include <asm/delay.h>
-+
-+#include <linux/of_net.h>
-+#include <linux/of_mdio.h>
-+#include <linux/of_gpio.h>
-+
-+#include <xway_dma.h>
-+#include <lantiq_soc.h>
-+
-+#include "lantiq_pce.h"
-+#include "lantiq_xrx200_sw.h"
-+
-+#define SW_POLLING
-+#define SW_ROUTING
-+#define SW_PORTMAP
-+
-+#ifdef SW_ROUTING
-+  #ifdef SW_PORTMAP
-+#define XRX200_MAX_DEV		2
-+  #else
-+#define XRX200_MAX_DEV		2
-+  #endif
-+#else
-+#define XRX200_MAX_DEV		1
-+#endif
-+
-+#define XRX200_MAX_VLAN		64
-+#define XRX200_PCE_ACTVLAN_IDX	0x01
-+#define XRX200_PCE_VLANMAP_IDX	0x02
-+
-+#define XRX200_MAX_PORT		7
-+#define XRX200_MAX_DMA		8
-+
-+#define XRX200_HEADROOM		4
-+
-+#define XRX200_TX_TIMEOUT	(10 * HZ)
-+
-+/* port type */
-+#define XRX200_PORT_TYPE_PHY	1
-+#define XRX200_PORT_TYPE_MAC	2
-+
-+/* DMA */
-+#define XRX200_DMA_DATA_LEN	0x600
-+#define XRX200_DMA_IRQ		INT_NUM_IM2_IRL0
-+#define XRX200_DMA_RX		0
-+#define XRX200_DMA_TX		1
-+#define XRX200_DMA_IS_TX(x)	(x%2)
-+#define XRX200_DMA_IS_RX(x)	(!XRX200_DMA_IS_TX(x))
-+
-+/* fetch / store dma */
-+#define FDMA_PCTRL0		0x2A00
-+#define FDMA_PCTRLx(x)		(FDMA_PCTRL0 + (x * 0x18))
-+#define SDMA_PCTRL0		0x2F00
-+#define SDMA_PCTRLx(x)		(SDMA_PCTRL0 + (x * 0x18))
-+
-+/* buffer management */
-+#define BM_PCFG0		0x200
-+#define BM_PCFGx(x)		(BM_PCFG0 + (x * 8))
-+
-+/* MDIO */
-+#define MDIO_GLOB		0x0000
-+#define MDIO_CTRL		0x0020
-+#define MDIO_READ		0x0024
-+#define MDIO_WRITE		0x0028
-+#define MDIO_PHY0		0x0054
-+#define MDIO_PHY(x)		(0x0054 - (x * sizeof(unsigned)))
-+#define MDIO_CLK_CFG0		0x002C
-+#define MDIO_CLK_CFG1		0x0030
-+
-+#define MDIO_GLOB_ENABLE	0x8000
-+#define MDIO_BUSY		BIT(12)
-+#define MDIO_RD			BIT(11)
-+#define MDIO_WR			BIT(10)
-+#define MDIO_MASK		0x1f
-+#define MDIO_ADDRSHIFT		5
-+#define MDIO1_25MHZ		9
-+
-+#define MDIO_PHY_LINK_DOWN	0x4000
-+#define MDIO_PHY_LINK_UP	0x2000
-+
-+#define MDIO_PHY_SPEED_M10	0x0000
-+#define MDIO_PHY_SPEED_M100	0x0800
-+#define MDIO_PHY_SPEED_G1	0x1000
-+
-+#define MDIO_PHY_FDUP_EN	0x0200
-+#define MDIO_PHY_FDUP_DIS	0x0600
-+
-+#define MDIO_PHY_LINK_MASK	0x6000
-+#define MDIO_PHY_SPEED_MASK	0x1800
-+#define MDIO_PHY_FDUP_MASK	0x0600
-+#define MDIO_PHY_ADDR_MASK	0x001f
-+#define MDIO_UPDATE_MASK	MDIO_PHY_ADDR_MASK | MDIO_PHY_LINK_MASK | \
-+					MDIO_PHY_SPEED_MASK | MDIO_PHY_FDUP_MASK
-+
-+/* MII */
-+#define MII_CFG(p)		(p * 8)
-+
-+#define MII_CFG_EN		BIT(14)
-+
-+#define MII_CFG_MODE_MIIP	0x0
-+#define MII_CFG_MODE_MIIM	0x1
-+#define MII_CFG_MODE_RMIIP	0x2
-+#define MII_CFG_MODE_RMIIM	0x3
-+#define MII_CFG_MODE_RGMII	0x4
-+#define MII_CFG_MODE_MASK	0xf
-+
-+#define MII_CFG_RATE_M2P5	0x00
-+#define MII_CFG_RATE_M25	0x10
-+#define MII_CFG_RATE_M125	0x20
-+#define MII_CFG_RATE_M50	0x30
-+#define MII_CFG_RATE_AUTO	0x40
-+#define MII_CFG_RATE_MASK	0x70
-+
-+/* cpu port mac */
-+#define PMAC_HD_CTL		0x0000
-+#define PMAC_RX_IPG		0x0024
-+#define PMAC_EWAN		0x002c
-+
-+#define PMAC_IPG_MASK		0xf
-+#define PMAC_HD_CTL_AS		0x0008
-+#define PMAC_HD_CTL_AC		0x0004
-+#define PMAC_HD_CTL_RXSH	0x0040
-+#define PMAC_HD_CTL_AST		0x0080
-+#define PMAC_HD_CTL_RST		0x0100
-+
-+/* PCE */
-+#define PCE_TBL_KEY(x)		(0x1100 + ((7 - x) * 4))
-+#define PCE_TBL_MASK		0x1120
-+#define PCE_TBL_VAL(x)		(0x1124 + ((4 - x) * 4))
-+#define PCE_TBL_ADDR		0x1138
-+#define PCE_TBL_CTRL		0x113c
-+#define PCE_PMAP1		0x114c
-+#define PCE_PMAP2		0x1150
-+#define PCE_PMAP3		0x1154
-+#define PCE_GCTRL_REG(x)	(0x1158 + (x * 4))
-+#define PCE_PCTRL_REG(p, x)	(0x1200 + (((p * 0xa) + x) * 4))
-+
-+#define PCE_TBL_BUSY		BIT(15)
-+#define PCE_TBL_CFG_ADDR_MASK	0x1f
-+#define PCE_TBL_CFG_ADWR	0x20
-+#define PCE_TBL_CFG_ADWR_MASK	0x60
-+#define PCE_INGRESS		BIT(11)
-+
-+/* MAC */
-+#define MAC_FLEN_REG		(0x2314)
-+#define MAC_CTRL_REG(p, x)	(0x240c + (((p * 0xc) + x) * 4))
-+
-+/* buffer management */
-+#define BM_PCFG(p)		(0x200 + (p * 8))
-+
-+/* special tag in TX path header */
-+#define SPID_SHIFT		24
-+#define DPID_SHIFT		16
-+#define DPID_ENABLE		1
-+#define SPID_CPU_PORT		2
-+#define PORT_MAP_SEL		BIT(15)
-+#define PORT_MAP_EN		BIT(14)
-+#define PORT_MAP_SHIFT		1
-+#define PORT_MAP_MASK		0x3f
-+
-+#define SPPID_MASK		0x7
-+#define SPPID_SHIFT		4
-+
-+/* MII regs not yet in linux */
-+#define MDIO_DEVAD_NONE		(-1)
-+#define ADVERTIZE_MPD		(1 << 10)
-+
-+struct xrx200_port {
-+	u8 num;
-+	u8 phy_addr;
-+	u16 flags;
-+	phy_interface_t phy_if;
-+
-+	int link;
-+	int gpio;
-+	enum of_gpio_flags gpio_flags;
-+
-+	struct phy_device *phydev;
-+	struct device_node *phy_node;
-+};
-+
-+struct xrx200_chan {
-+	int idx;
-+	int refcount;
-+	int tx_free;
-+
-+	struct net_device dummy_dev;
-+	struct net_device *devs[XRX200_MAX_DEV];
-+
-+	struct tasklet_struct tasklet;
-+	struct napi_struct napi;
-+	struct ltq_dma_channel dma;
-+	struct sk_buff *skb[LTQ_DESC_NUM];
-+};
-+
-+struct xrx200_hw {
-+	struct clk *clk;
-+	struct mii_bus *mii_bus;
-+
-+	struct xrx200_chan chan[XRX200_MAX_DMA];
-+
-+	struct net_device *devs[XRX200_MAX_DEV];
-+	int num_devs;
-+
-+	int port_map[XRX200_MAX_PORT];
-+	unsigned short wan_map;
-+
-+	spinlock_t lock;
-+
-+	struct switch_dev swdev;
-+};
-+
-+struct xrx200_priv {
-+	struct net_device_stats stats;
-+	int id;
-+
-+	struct xrx200_port port[XRX200_MAX_PORT];
-+	int num_port;
-+	bool wan;
-+	bool sw;
-+	unsigned short port_map;
-+	unsigned char mac[6];
-+
-+	struct xrx200_hw *hw;
-+};
-+
-+static __iomem void *xrx200_switch_membase;
-+static __iomem void *xrx200_mii_membase;
-+static __iomem void *xrx200_mdio_membase;
-+static __iomem void *xrx200_pmac_membase;
-+
-+#define ltq_switch_r32(x)	ltq_r32(xrx200_switch_membase + (x))
-+#define ltq_switch_w32(x, y)	ltq_w32(x, xrx200_switch_membase + (y))
-+#define ltq_switch_w32_mask(x, y, z) \
-+			ltq_w32_mask(x, y, xrx200_switch_membase + (z))
-+
-+#define ltq_mdio_r32(x)		ltq_r32(xrx200_mdio_membase + (x))
-+#define ltq_mdio_w32(x, y)	ltq_w32(x, xrx200_mdio_membase + (y))
-+#define ltq_mdio_w32_mask(x, y, z) \
-+			ltq_w32_mask(x, y, xrx200_mdio_membase + (z))
-+
-+#define ltq_mii_r32(x)		ltq_r32(xrx200_mii_membase + (x))
-+#define ltq_mii_w32(x, y)	ltq_w32(x, xrx200_mii_membase + (y))
-+#define ltq_mii_w32_mask(x, y, z) \
-+			ltq_w32_mask(x, y, xrx200_mii_membase + (z))
-+
-+#define ltq_pmac_r32(x)		ltq_r32(xrx200_pmac_membase + (x))
-+#define ltq_pmac_w32(x, y)	ltq_w32(x, xrx200_pmac_membase + (y))
-+#define ltq_pmac_w32_mask(x, y, z) \
-+			ltq_w32_mask(x, y, xrx200_pmac_membase + (z))
-+
-+#define XRX200_GLOBAL_REGATTR(reg) \
-+	.id = reg, \
-+	.type = SWITCH_TYPE_INT, \
-+	.set = xrx200_set_global_attr, \
-+	.get = xrx200_get_global_attr
-+
-+#define XRX200_PORT_REGATTR(reg) \
-+	.id = reg, \
-+	.type = SWITCH_TYPE_INT, \
-+	.set = xrx200_set_port_attr, \
-+	.get = xrx200_get_port_attr
-+
-+static int xrx200sw_read_x(int reg, int x)
-+{
-+	int value, mask, addr;
-+
-+	addr = xrx200sw_reg[reg].offset + (xrx200sw_reg[reg].mult * x);
-+	value = ltq_switch_r32(addr);
-+	mask = (1 << xrx200sw_reg[reg].size) - 1;
-+	value = (value >> xrx200sw_reg[reg].shift);
-+
-+	return (value & mask);
-+}
-+
-+static int xrx200sw_read(int reg)
-+{
-+	return xrx200sw_read_x(reg, 0);
-+}
-+
-+static void xrx200sw_write_x(int value, int reg, int x)
-+{
-+	int mask, addr;
-+
-+	addr = xrx200sw_reg[reg].offset + (xrx200sw_reg[reg].mult * x);
-+	mask = (1 << xrx200sw_reg[reg].size) - 1;
-+	mask = (mask << xrx200sw_reg[reg].shift);
-+	value = (value << xrx200sw_reg[reg].shift) & mask;
-+
-+	ltq_switch_w32_mask(mask, value, addr);
-+}
-+
-+static void xrx200sw_write(int value, int reg)
-+{
-+	xrx200sw_write_x(value, reg, 0);
-+}
-+
-+struct xrx200_pce_table_entry {
-+	int index;	// PCE_TBL_ADDR.ADDR = pData->table_index
-+	int table; 	// PCE_TBL_CTRL.ADDR = pData->table
-+	unsigned short key[8];
-+	unsigned short val[5];
-+	unsigned short mask;
-+	unsigned short type;
-+	unsigned short valid;
-+	unsigned short gmap;
-+};
-+
-+static int xrx200_pce_table_entry_read(struct xrx200_pce_table_entry *tbl)
-+{
-+	// wait until hardware is ready
-+	while (xrx200sw_read(XRX200_PCE_TBL_CTRL_BAS)) {};
-+
-+	// prepare the table access:
-+	// PCE_TBL_ADDR.ADDR = pData->table_index
-+	xrx200sw_write(tbl->index, XRX200_PCE_TBL_ADDR_ADDR);
-+	// PCE_TBL_CTRL.ADDR = pData->table
-+	xrx200sw_write(tbl->table, XRX200_PCE_TBL_CTRL_ADDR);
-+
-+	//(address-based read)
-+	xrx200sw_write(0, XRX200_PCE_TBL_CTRL_OPMOD); // OPMOD_ADRD
-+
-+	xrx200sw_write(1, XRX200_PCE_TBL_CTRL_BAS); // start access
-+
-+	// wait until hardware is ready
-+	while (xrx200sw_read(XRX200_PCE_TBL_CTRL_BAS)) {};
-+
-+	// read the keys
-+	tbl->key[7] = xrx200sw_read(XRX200_PCE_TBL_KEY_7);
-+	tbl->key[6] = xrx200sw_read(XRX200_PCE_TBL_KEY_6);
-+	tbl->key[5] = xrx200sw_read(XRX200_PCE_TBL_KEY_5);
-+	tbl->key[4] = xrx200sw_read(XRX200_PCE_TBL_KEY_4);
-+	tbl->key[3] = xrx200sw_read(XRX200_PCE_TBL_KEY_3);
-+	tbl->key[2] = xrx200sw_read(XRX200_PCE_TBL_KEY_2);
-+	tbl->key[1] = xrx200sw_read(XRX200_PCE_TBL_KEY_1);
-+	tbl->key[0] = xrx200sw_read(XRX200_PCE_TBL_KEY_0);
-+
-+	// read the values
-+	tbl->val[4] = xrx200sw_read(XRX200_PCE_TBL_VAL_4);
-+	tbl->val[3] = xrx200sw_read(XRX200_PCE_TBL_VAL_3);
-+	tbl->val[2] = xrx200sw_read(XRX200_PCE_TBL_VAL_2);
-+	tbl->val[1] = xrx200sw_read(XRX200_PCE_TBL_VAL_1);
-+	tbl->val[0] = xrx200sw_read(XRX200_PCE_TBL_VAL_0);
-+
-+	// read the mask
-+	tbl->mask = xrx200sw_read(XRX200_PCE_TBL_MASK_0);
-+	// read the type
-+	tbl->type = xrx200sw_read(XRX200_PCE_TBL_CTRL_TYPE);
-+	// read the valid flag
-+	tbl->valid = xrx200sw_read(XRX200_PCE_TBL_CTRL_VLD);
-+	// read the group map
-+	tbl->gmap = xrx200sw_read(XRX200_PCE_TBL_CTRL_GMAP);
-+
-+	return 0;
-+}
-+
-+static int xrx200_pce_table_entry_write(struct xrx200_pce_table_entry *tbl)
-+{
-+	// wait until hardware is ready
-+	while (xrx200sw_read(XRX200_PCE_TBL_CTRL_BAS)) {};
-+
-+	// prepare the table access:
-+	// PCE_TBL_ADDR.ADDR = pData->table_index
-+	xrx200sw_write(tbl->index, XRX200_PCE_TBL_ADDR_ADDR);
-+	// PCE_TBL_CTRL.ADDR = pData->table
-+	xrx200sw_write(tbl->table, XRX200_PCE_TBL_CTRL_ADDR);
-+
-+	//(address-based write)
-+	xrx200sw_write(1, XRX200_PCE_TBL_CTRL_OPMOD); // OPMOD_ADRD
-+
-+	// read the keys
-+	xrx200sw_write(tbl->key[7], XRX200_PCE_TBL_KEY_7);
-+	xrx200sw_write(tbl->key[6], XRX200_PCE_TBL_KEY_6);
-+	xrx200sw_write(tbl->key[5], XRX200_PCE_TBL_KEY_5);
-+	xrx200sw_write(tbl->key[4], XRX200_PCE_TBL_KEY_4);
-+	xrx200sw_write(tbl->key[3], XRX200_PCE_TBL_KEY_3);
-+	xrx200sw_write(tbl->key[2], XRX200_PCE_TBL_KEY_2);
-+	xrx200sw_write(tbl->key[1], XRX200_PCE_TBL_KEY_1);
-+	xrx200sw_write(tbl->key[0], XRX200_PCE_TBL_KEY_0);
-+
-+	// read the values
-+	xrx200sw_write(tbl->val[4], XRX200_PCE_TBL_VAL_4);
-+	xrx200sw_write(tbl->val[3], XRX200_PCE_TBL_VAL_3);
-+	xrx200sw_write(tbl->val[2], XRX200_PCE_TBL_VAL_2);
-+	xrx200sw_write(tbl->val[1], XRX200_PCE_TBL_VAL_1);
-+	xrx200sw_write(tbl->val[0], XRX200_PCE_TBL_VAL_0);
-+
-+	// read the mask
-+	xrx200sw_write(tbl->mask, XRX200_PCE_TBL_MASK_0);
-+	// read the type
-+	xrx200sw_write(tbl->type, XRX200_PCE_TBL_CTRL_TYPE);
-+	// read the valid flag
-+	xrx200sw_write(tbl->valid, XRX200_PCE_TBL_CTRL_VLD);
-+	// read the group map
-+	xrx200sw_write(tbl->gmap, XRX200_PCE_TBL_CTRL_GMAP);
-+
-+	xrx200sw_write(1, XRX200_PCE_TBL_CTRL_BAS); // start access
-+
-+	// wait until hardware is ready
-+	while (xrx200sw_read(XRX200_PCE_TBL_CTRL_BAS)) {};
-+
-+	return 0;
-+}
-+
-+static void xrx200sw_fixup_pvids(void)
-+{
-+	int index, p, portmap, untagged;
-+	struct xrx200_pce_table_entry tem;
-+	struct xrx200_pce_table_entry tev;
-+
-+	portmap = 0;
-+	for (p = 0; p < XRX200_MAX_PORT; p++)
-+		portmap |= BIT(p);
-+
-+	tem.table = XRX200_PCE_VLANMAP_IDX;
-+	tev.table = XRX200_PCE_ACTVLAN_IDX;
-+
-+	for (index = XRX200_MAX_VLAN; index-- > 0;)
-+	{
-+		tev.index = index;
-+		xrx200_pce_table_entry_read(&tev);
-+
-+		if (tev.valid == 0)
-+			continue;
-+
-+		tem.index = index;
-+		xrx200_pce_table_entry_read(&tem);
-+
-+		if (tem.val[0] == 0)
-+			continue;
-+
-+		untagged = portmap & (tem.val[1] ^ tem.val[2]);
-+
-+		for (p = 0; p < XRX200_MAX_PORT; p++)
-+			if (untagged & BIT(p))
-+			{
-+				portmap &= ~BIT(p);
-+				xrx200sw_write_x(index, XRX200_PCE_DEFPVID_PVID, p);
-+			}
-+
-+		for (p = 0; p < XRX200_MAX_PORT; p++)
-+			if (portmap & BIT(p))
-+				xrx200sw_write_x(index, XRX200_PCE_DEFPVID_PVID, p);
-+	}
-+}
-+
-+// swconfig interface
-+static void xrx200_hw_init(struct xrx200_hw *hw);
-+
-+// global
-+static int xrx200sw_reset_switch(struct switch_dev *dev)
-+{
-+	struct xrx200_hw *hw = container_of(dev, struct xrx200_hw, swdev);
-+
-+	xrx200_hw_init(hw);
-+
-+	return 0;
-+}
-+
-+static int xrx200_set_vlan_mode_enable(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
-+{
-+	int p;
-+
-+	if ((attr->max > 0) && (val->value.i > attr->max))
-+		return -EINVAL;
-+
-+	for (p = 0; p < XRX200_MAX_PORT; p++) {
-+		xrx200sw_write_x(val->value.i, XRX200_PCE_VCTRL_VEMR, p);
-+		xrx200sw_write_x(val->value.i, XRX200_PCE_VCTRL_VIMR, p);
-+	}
-+
-+	xrx200sw_write(val->value.i, XRX200_PCE_GCTRL_0_VLAN);
-+	return 0;
-+}
-+
-+static int xrx200_get_vlan_mode_enable(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
-+{
-+	val->value.i = xrx200sw_read(attr->id);
-+	return 0;
-+}
-+
-+static int xrx200_set_global_attr(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
-+{
-+	if ((attr->max > 0) && (val->value.i > attr->max))
-+		return -EINVAL;
-+
-+	xrx200sw_write(val->value.i, attr->id);
-+	return 0;
-+}
-+
-+static int xrx200_get_global_attr(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
-+{
-+	val->value.i = xrx200sw_read(attr->id);
-+	return 0;
-+}
-+
-+// vlan
-+static int xrx200sw_set_vlan_vid(struct switch_dev *dev, const struct switch_attr *attr,
-+				 struct switch_val *val)
-+{
-+	int i;
-+	struct xrx200_pce_table_entry tev;
-+	struct xrx200_pce_table_entry tem;
-+
-+	tev.table = XRX200_PCE_ACTVLAN_IDX;
-+
-+	for (i = 0; i < XRX200_MAX_VLAN; i++)
-+	{
-+		tev.index = i;
-+		xrx200_pce_table_entry_read(&tev);
-+		if (tev.key[0] == val->value.i && i != val->port_vlan)
-+			return -EINVAL;
-+	}
-+
-+	tev.index = val->port_vlan;
-+	xrx200_pce_table_entry_read(&tev);
-+	tev.key[0] = val->value.i;
-+	tev.valid = val->value.i > 0;
-+	xrx200_pce_table_entry_write(&tev);
-+
-+	tem.table = XRX200_PCE_VLANMAP_IDX;
-+	tem.index = val->port_vlan;
-+	xrx200_pce_table_entry_read(&tem);
-+	tem.val[0] = val->value.i;
-+	xrx200_pce_table_entry_write(&tem);
-+
-+	xrx200sw_fixup_pvids();
-+	return 0;
-+}
-+
-+static int xrx200sw_get_vlan_vid(struct switch_dev *dev, const struct switch_attr *attr,
-+				 struct switch_val *val)
-+{
-+	struct xrx200_pce_table_entry te;
-+
-+	te.table = XRX200_PCE_ACTVLAN_IDX;
-+	te.index = val->port_vlan;
-+	xrx200_pce_table_entry_read(&te);
-+	val->value.i = te.key[0];
-+
-+	return 0;
-+}
-+
-+static int xrx200sw_set_vlan_ports(struct switch_dev *dev, struct switch_val *val)
-+{
-+	int i, portmap, tagmap, untagged;
-+	struct xrx200_pce_table_entry tem;
-+
-+	portmap = 0;
-+	tagmap = 0;
-+	for (i = 0; i < val->len; i++)
-+	{
-+		struct switch_port *p = &val->value.ports[i];
-+
-+		portmap |= (1 << p->id);
-+		if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED))
-+			tagmap |= (1 << p->id);
-+	}
-+
-+	tem.table = XRX200_PCE_VLANMAP_IDX;
-+
-+	untagged = portmap ^ tagmap;
-+	for (i = 0; i < XRX200_MAX_VLAN; i++)
-+	{
-+		tem.index = i;
-+		xrx200_pce_table_entry_read(&tem);
-+
-+		if (tem.val[0] == 0)
-+			continue;
-+
-+		if ((untagged & (tem.val[1] ^ tem.val[2])) && (val->port_vlan != i))
-+			return -EINVAL;
-+	}
-+
-+	tem.index = val->port_vlan;
-+	xrx200_pce_table_entry_read(&tem);
-+
-+	// auto-enable this vlan if not enabled already
-+	if (tem.val[0] == 0)
-+	{
-+		struct switch_val v;
-+		v.port_vlan = val->port_vlan;
-+		v.value.i = val->port_vlan;
-+		if(xrx200sw_set_vlan_vid(dev, NULL, &v))
-+			return -EINVAL;
-+
-+		//read updated tem
-+		tem.index = val->port_vlan;
-+		xrx200_pce_table_entry_read(&tem);
-+	}
-+
-+	tem.val[1] = portmap;
-+	tem.val[2] = tagmap;
-+	xrx200_pce_table_entry_write(&tem);
-+
-+	xrx200sw_fixup_pvids();
-+
-+	return 0;
-+}
-+
-+static int xrx200sw_get_vlan_ports(struct switch_dev *dev, struct switch_val *val)
-+{
-+	int i;
-+	unsigned short ports, tags;
-+	struct xrx200_pce_table_entry tem;
-+
-+	tem.table = XRX200_PCE_VLANMAP_IDX;
-+	tem.index = val->port_vlan;
-+	xrx200_pce_table_entry_read(&tem);
-+
-+	ports = tem.val[1];
-+	tags = tem.val[2];
-+
-+	for (i = 0; i < XRX200_MAX_PORT; i++) {
-+		struct switch_port *p;
-+
-+		if (!(ports & (1 << i)))
-+			continue;
-+
-+		p = &val->value.ports[val->len++];
-+		p->id = i;
-+		if (tags & (1 << i))
-+			p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
-+		else
-+			p->flags = 0;
-+	}
-+
-+	return 0;
-+}
-+
-+static int xrx200sw_set_vlan_enable(struct switch_dev *dev, const struct switch_attr *attr,
-+				 struct switch_val *val)
-+{
-+	struct xrx200_pce_table_entry tev;
-+
-+	tev.table = XRX200_PCE_ACTVLAN_IDX;
-+	tev.index = val->port_vlan;
-+	xrx200_pce_table_entry_read(&tev);
-+
-+	if (tev.key[0] == 0)
-+		return -EINVAL;
-+
-+	tev.valid = val->value.i;
-+	xrx200_pce_table_entry_write(&tev);
-+
-+	xrx200sw_fixup_pvids();
-+	return 0;
-+}
-+
-+static int xrx200sw_get_vlan_enable(struct switch_dev *dev, const struct switch_attr *attr,
-+				 struct switch_val *val)
-+{
-+	struct xrx200_pce_table_entry tev;
-+
-+	tev.table = XRX200_PCE_ACTVLAN_IDX;
-+	tev.index = val->port_vlan;
-+	xrx200_pce_table_entry_read(&tev);
-+	val->value.i = tev.valid;
-+
-+	return 0;
-+}
-+
-+// port
-+static int xrx200sw_get_port_pvid(struct switch_dev *dev, int port, int *val)
-+{
-+	struct xrx200_pce_table_entry tev;
-+
-+	if (port >= XRX200_MAX_PORT)
-+		return -EINVAL;
-+
-+	tev.table = XRX200_PCE_ACTVLAN_IDX;
-+	tev.index = xrx200sw_read_x(XRX200_PCE_DEFPVID_PVID, port);
-+	xrx200_pce_table_entry_read(&tev);
-+
-+	*val = tev.key[0];
-+	return 0;
-+}
-+
-+static int xrx200sw_get_port_link(struct switch_dev *dev,
-+				  int port,
-+				  struct switch_port_link *link)
-+{
-+	if (port >= XRX200_MAX_PORT)
-+		return -EINVAL;
-+
-+	link->link = xrx200sw_read_x(XRX200_MAC_PSTAT_LSTAT, port);
-+	if (!link->link)
-+		return 0;
-+
-+	link->duplex = xrx200sw_read_x(XRX200_MAC_PSTAT_FDUP, port);
-+
-+	link->rx_flow = !!(xrx200sw_read_x(XRX200_MAC_CTRL_0_FCON, port) && 0x0010);
-+	link->tx_flow = !!(xrx200sw_read_x(XRX200_MAC_CTRL_0_FCON, port) && 0x0020);
-+	link->aneg = !(xrx200sw_read_x(XRX200_MAC_CTRL_0_FCON, port));
-+
-+	link->speed = SWITCH_PORT_SPEED_10;
-+	if (xrx200sw_read_x(XRX200_MAC_PSTAT_MBIT, port))
-+		link->speed = SWITCH_PORT_SPEED_100;
-+	if (xrx200sw_read_x(XRX200_MAC_PSTAT_GBIT, port))
-+		link->speed = SWITCH_PORT_SPEED_1000;
-+
-+	return 0;
-+}
-+
-+static int xrx200_set_port_attr(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
-+{
-+	printk("%s %s(%d)\n", __FILE__, __func__, __LINE__);
-+	if (val->port_vlan >= XRX200_MAX_PORT)
-+		return -EINVAL;
-+
-+	if ((attr->max > 0) && (val->value.i > attr->max))
-+		return -EINVAL;
-+
-+	xrx200sw_write_x(val->value.i, attr->id, val->port_vlan);
-+	return 0;
-+}
-+
-+static int xrx200_get_port_attr(struct switch_dev *dev, const struct switch_attr *attr, struct switch_val *val)
-+{
-+	if (val->port_vlan >= XRX200_MAX_PORT)
-+		return -EINVAL;
-+
-+	val->value.i = xrx200sw_read_x(attr->id, val->port_vlan);
-+	return 0;
-+}
-+
-+// attributes
-+static struct switch_attr xrx200sw_globals[] = {
-+	{
-+		.type = SWITCH_TYPE_INT,
-+		.set = xrx200_set_vlan_mode_enable,
-+		.get = xrx200_get_vlan_mode_enable,
-+		.name = "enable_vlan",
-+		.description = "Enable VLAN mode",
-+		.max = 1},
-+};
-+
-+static struct switch_attr xrx200sw_port[] = {
-+	{
-+	XRX200_PORT_REGATTR(XRX200_PCE_VCTRL_UVR),
-+	.name = "uvr",
-+	.description = "Unknown VLAN Rule",
-+	.max = 1,
-+	},
-+	{
-+	XRX200_PORT_REGATTR(XRX200_PCE_VCTRL_VSR),
-+	.name = "vsr",
-+	.description = "VLAN Security Rule",
-+	.max = 1,
-+	},
-+	{
-+	XRX200_PORT_REGATTR(XRX200_PCE_VCTRL_VINR),
-+	.name = "vinr",
-+	.description = "VLAN Ingress Tag Rule",
-+	.max = 2,
-+	},
-+	{
-+	XRX200_PORT_REGATTR(XRX200_PCE_PCTRL_0_TVM),
-+	.name = "tvm",
-+	.description = "Transparent VLAN Mode",
-+	.max = 1,
-+	},
-+};
-+
-+static struct switch_attr xrx200sw_vlan[] = {
-+	{
-+		.type = SWITCH_TYPE_INT,
-+		.name = "vid",
-+		.description = "VLAN ID (0-4094)",
-+		.set = xrx200sw_set_vlan_vid,
-+		.get = xrx200sw_get_vlan_vid,
-+		.max = 4094,
-+	},
-+	{
-+		.type = SWITCH_TYPE_INT,
-+		.name = "enable",
-+		.description = "Enable VLAN",
-+		.set = xrx200sw_set_vlan_enable,
-+		.get = xrx200sw_get_vlan_enable,
-+		.max = 1,
-+	},
-+};
-+
-+static const struct switch_dev_ops xrx200sw_ops = {
-+	.attr_global = {
-+		.attr = xrx200sw_globals,
-+		.n_attr = ARRAY_SIZE(xrx200sw_globals),
-+	},
-+	.attr_port = {
-+		.attr = xrx200sw_port,
-+		.n_attr = ARRAY_SIZE(xrx200sw_port),
-+	},
-+	.attr_vlan = {
-+		.attr = xrx200sw_vlan,
-+		.n_attr = ARRAY_SIZE(xrx200sw_vlan),
-+	},
-+	.get_vlan_ports = xrx200sw_get_vlan_ports,
-+	.set_vlan_ports = xrx200sw_set_vlan_ports,
-+	.get_port_pvid = xrx200sw_get_port_pvid,
-+	.reset_switch = xrx200sw_reset_switch,
-+	.get_port_link = xrx200sw_get_port_link,
-+//	.get_port_stats = xrx200sw_get_port_stats, //TODO
-+};
-+
-+static int xrx200sw_init(struct xrx200_hw *hw)
-+{
-+	int netdev_num;
-+
-+	for (netdev_num = 0; netdev_num < hw->num_devs; netdev_num++)
-+	{
-+		struct switch_dev *swdev;
-+		struct net_device *dev = hw->devs[netdev_num];
-+		struct xrx200_priv *priv = netdev_priv(dev);
-+		if (!priv->sw)
-+			continue;
-+
-+		swdev = &hw->swdev;
-+
-+		swdev->name = "Lantiq XRX200 Switch";
-+		swdev->vlans = XRX200_MAX_VLAN;
-+		swdev->ports = XRX200_MAX_PORT;
-+		swdev->cpu_port = 6;
-+		swdev->ops = &xrx200sw_ops;
-+
-+		register_switch(swdev, dev);
-+		return 0; // enough switches
-+	}
-+	return 0;
-+}
-+
-+static int xrx200_open(struct net_device *dev)
-+{
-+	struct xrx200_priv *priv = netdev_priv(dev);
-+	unsigned long flags;
-+	int i;
-+
-+	for (i = 0; i < XRX200_MAX_DMA; i++) {
-+		if (!priv->hw->chan[i].dma.irq)
-+			continue;
-+		spin_lock_irqsave(&priv->hw->lock, flags);
-+		if (!priv->hw->chan[i].refcount) {
-+			if (XRX200_DMA_IS_RX(i))
-+				napi_enable(&priv->hw->chan[i].napi);
-+			ltq_dma_open(&priv->hw->chan[i].dma);
-+		}
-+		priv->hw->chan[i].refcount++;
-+		spin_unlock_irqrestore(&priv->hw->lock, flags);
-+	}
-+	for (i = 0; i < priv->num_port; i++)
-+		if (priv->port[i].phydev)
-+			phy_start(priv->port[i].phydev);
-+	netif_start_queue(dev);
-+
-+	return 0;
-+}
-+
-+static int xrx200_close(struct net_device *dev)
-+{
-+	struct xrx200_priv *priv = netdev_priv(dev);
-+	unsigned long flags;
-+	int i;
-+
-+	netif_stop_queue(dev);
-+
-+	for (i = 0; i < priv->num_port; i++)
-+		if (priv->port[i].phydev)
-+			phy_stop(priv->port[i].phydev);
-+
-+	for (i = 0; i < XRX200_MAX_DMA; i++) {
-+		if (!priv->hw->chan[i].dma.irq)
-+			continue;
-+		spin_lock_irqsave(&priv->hw->lock, flags);
-+		priv->hw->chan[i].refcount--;
-+		if (!priv->hw->chan[i].refcount) {
-+			if (XRX200_DMA_IS_RX(i))
-+				napi_disable(&priv->hw->chan[i].napi);
-+			ltq_dma_close(&priv->hw->chan[XRX200_DMA_RX].dma);
-+		}
-+		spin_unlock_irqrestore(&priv->hw->lock, flags);
-+	}
-+
-+	return 0;
-+}
-+
-+static int xrx200_alloc_skb(struct xrx200_chan *ch)
-+{
-+#define DMA_PAD	(NET_IP_ALIGN + NET_SKB_PAD)
-+	ch->skb[ch->dma.desc] = dev_alloc_skb(XRX200_DMA_DATA_LEN + DMA_PAD);
-+	if (!ch->skb[ch->dma.desc])
-+		return -ENOMEM;
-+
-+	skb_reserve(ch->skb[ch->dma.desc], NET_SKB_PAD);
-+	ch->dma.desc_base[ch->dma.desc].addr = dma_map_single(NULL,
-+		ch->skb[ch->dma.desc]->data, XRX200_DMA_DATA_LEN,
-+			DMA_FROM_DEVICE);
-+	ch->dma.desc_base[ch->dma.desc].addr =
-+		CPHYSADDR(ch->skb[ch->dma.desc]->data);
-+	ch->dma.desc_base[ch->dma.desc].ctl =
-+		LTQ_DMA_OWN | LTQ_DMA_RX_OFFSET(NET_IP_ALIGN) |
-+		XRX200_DMA_DATA_LEN;
-+	skb_reserve(ch->skb[ch->dma.desc], NET_IP_ALIGN);
-+
-+	return 0;
-+}
-+
-+static void xrx200_hw_receive(struct xrx200_chan *ch, int id)
-+{
-+	struct net_device *dev = ch->devs[id];
-+	struct xrx200_priv *priv = netdev_priv(dev);
-+	struct ltq_dma_desc *desc = &ch->dma.desc_base[ch->dma.desc];
-+	struct sk_buff *skb = ch->skb[ch->dma.desc];
-+	int len = (desc->ctl & LTQ_DMA_SIZE_MASK);
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&priv->hw->lock, flags);
-+	if (xrx200_alloc_skb(ch)) {
-+		netdev_err(dev,
-+			"failed to allocate new rx buffer, stopping DMA\n");
-+		ltq_dma_close(&ch->dma);
-+	}
-+
-+	ch->dma.desc++;
-+	ch->dma.desc %= LTQ_DESC_NUM;
-+	spin_unlock_irqrestore(&priv->hw->lock, flags);
-+
-+	skb_put(skb, len);
-+#ifdef SW_ROUTING
-+	skb_pull(skb, 8);
-+#endif
-+	skb->dev = dev;
-+	skb->protocol = eth_type_trans(skb, dev);
-+	netif_receive_skb(skb);
-+	priv->stats.rx_packets++;
-+	priv->stats.rx_bytes+=len;
-+}
-+
-+static int xrx200_poll_rx(struct napi_struct *napi, int budget)
-+{
-+	struct xrx200_chan *ch = container_of(napi,
-+				struct xrx200_chan, napi);
-+	struct xrx200_priv *priv = netdev_priv(ch->devs[0]);
-+	int rx = 0;
-+	int complete = 0;
-+	unsigned long flags;
-+
-+	while ((rx < budget) && !complete) {
-+		struct ltq_dma_desc *desc = &ch->dma.desc_base[ch->dma.desc];
-+		if ((desc->ctl & (LTQ_DMA_OWN | LTQ_DMA_C)) == LTQ_DMA_C) {
-+#ifdef SW_ROUTING
-+			struct sk_buff *skb = ch->skb[ch->dma.desc];
-+			u32 *special_tag = (u32*)skb->data;
-+			int port = (special_tag[1] >> SPPID_SHIFT) & SPPID_MASK;
-+			xrx200_hw_receive(ch, priv->hw->port_map[port]);
-+#else
-+			xrx200_hw_receive(ch, 0);
-+#endif
-+			rx++;
-+		} else {
-+			complete = 1;
-+		}
-+	}
-+	if (complete || !rx) {
-+		napi_complete(&ch->napi);
-+		spin_lock_irqsave(&priv->hw->lock, flags);
-+		ltq_dma_ack_irq(&ch->dma);
-+		spin_unlock_irqrestore(&priv->hw->lock, flags);
-+	}
-+	return rx;
-+}
-+
-+static void xrx200_tx_housekeeping(unsigned long ptr)
-+{
-+	struct xrx200_hw *hw = (struct xrx200_hw *) ptr;
-+	struct xrx200_chan *ch = &hw->chan[XRX200_DMA_TX];
-+	unsigned long flags;
-+	int i;
-+
-+	spin_lock_irqsave(&hw->lock, flags);
-+	while ((ch->dma.desc_base[ch->tx_free].ctl & (LTQ_DMA_OWN | LTQ_DMA_C)) == LTQ_DMA_C) {
-+		dev_kfree_skb_any(ch->skb[ch->tx_free]);
-+		ch->skb[ch->tx_free] = NULL;
-+		memset(&ch->dma.desc_base[ch->tx_free], 0,
-+			sizeof(struct ltq_dma_desc));
-+		ch->tx_free++;
-+		ch->tx_free %= LTQ_DESC_NUM;
-+	}
-+	spin_unlock_irqrestore(&hw->lock, flags);
-+
-+	for (i = 0; i < XRX200_MAX_DEV && ch->devs[i]; i++) {
-+		struct netdev_queue *txq =
-+			netdev_get_tx_queue(ch->devs[i], 0);
-+		if (netif_tx_queue_stopped(txq))
-+			netif_tx_start_queue(txq);
-+	}
-+
-+	spin_lock_irqsave(&hw->lock, flags);
-+	ltq_dma_ack_irq(&ch->dma);
-+	spin_unlock_irqrestore(&hw->lock, flags);
-+}
-+
-+static struct net_device_stats *xrx200_get_stats (struct net_device *dev)
-+{
-+	struct xrx200_priv *priv = netdev_priv(dev);
-+
-+	return &priv->stats;
-+}
-+
-+static void xrx200_tx_timeout(struct net_device *dev)
-+{
-+	struct xrx200_priv *priv = netdev_priv(dev);
-+
-+	printk(KERN_ERR "%s: transmit timed out, disable the dma channel irq\n", dev->name);
-+
-+	priv->stats.tx_errors++;
-+	netif_wake_queue(dev);
-+}
-+
-+static int xrx200_start_xmit(struct sk_buff *skb, struct net_device *dev)
-+{
-+	int queue = skb_get_queue_mapping(skb);
-+	struct netdev_queue *txq = netdev_get_tx_queue(dev, queue);
-+	struct xrx200_priv *priv = netdev_priv(dev);
-+	struct xrx200_chan *ch = &priv->hw->chan[XRX200_DMA_TX];
-+	struct ltq_dma_desc *desc = &ch->dma.desc_base[ch->dma.desc];
-+	unsigned long flags;
-+	u32 byte_offset;
-+	int len;
-+#ifdef SW_ROUTING
-+  #ifdef SW_PORTMAP
-+	u32 special_tag = (SPID_CPU_PORT << SPID_SHIFT) | PORT_MAP_SEL | PORT_MAP_EN | DPID_ENABLE;
-+  #else
-+	u32 special_tag = (SPID_CPU_PORT << SPID_SHIFT) | DPID_ENABLE;
-+  #endif
-+#endif
-+
-+	len = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
-+
-+	if ((desc->ctl & (LTQ_DMA_OWN | LTQ_DMA_C)) || ch->skb[ch->dma.desc]) {
-+		netdev_err(dev, "tx ring full\n");
-+		netif_tx_stop_queue(txq);
-+		return NETDEV_TX_BUSY;
-+	}
-+#ifdef SW_ROUTING
-+  #ifdef SW_PORTMAP
-+	special_tag |= priv->port_map << PORT_MAP_SHIFT;
-+  #else
-+	if(priv->id)
-+		special_tag |= (1 << DPID_SHIFT);
-+  #endif
-+	if(skb_headroom(skb) < 4) {
-+		struct sk_buff *tmp = skb_realloc_headroom(skb, 4);
-+		dev_kfree_skb_any(skb);
-+		skb = tmp;
-+	}
-+	skb_push(skb, 4);
-+	memcpy(skb->data, &special_tag, sizeof(u32));
-+	len += 4;
-+#endif
-+
-+	/* dma needs to start on a 16 byte aligned address */
-+	byte_offset = CPHYSADDR(skb->data) % 16;
-+	ch->skb[ch->dma.desc] = skb;
-+
-+	dev->trans_start = jiffies;
-+
-+	spin_lock_irqsave(&priv->hw->lock, flags);
-+	desc->addr = ((unsigned int) dma_map_single(NULL, skb->data, len,
-+						DMA_TO_DEVICE)) - byte_offset;
-+	wmb();
-+	desc->ctl = LTQ_DMA_OWN | LTQ_DMA_SOP | LTQ_DMA_EOP |
-+		LTQ_DMA_TX_OFFSET(byte_offset) | (len & LTQ_DMA_SIZE_MASK);
-+	ch->dma.desc++;
-+	ch->dma.desc %= LTQ_DESC_NUM;
-+	spin_unlock_irqrestore(&priv->hw->lock, flags);
-+
-+	if (ch->dma.desc_base[ch->dma.desc].ctl & LTQ_DMA_OWN)
-+		netif_tx_stop_queue(txq);
-+
-+	priv->stats.tx_packets++;
-+	priv->stats.tx_bytes+=len;
-+
-+	return NETDEV_TX_OK;
-+}
-+
-+static irqreturn_t xrx200_dma_irq(int irq, void *priv)
-+{
-+	struct xrx200_hw *hw = priv;
-+	int ch = irq - XRX200_DMA_IRQ;
-+
-+	if (ch % 2)
-+		tasklet_schedule(&hw->chan[ch].tasklet);
-+	else
-+		napi_schedule(&hw->chan[ch].napi);
-+
-+	return IRQ_HANDLED;
-+}
-+
-+static int xrx200_dma_init(struct xrx200_hw *hw)
-+{
-+	int i, err = 0;
-+
-+	ltq_dma_init_port(DMA_PORT_ETOP);
-+
-+	for (i = 0; i < 8 && !err; i++) {
-+		int irq = XRX200_DMA_IRQ + i;
-+		struct xrx200_chan *ch = &hw->chan[i];
-+
-+		ch->idx = ch->dma.nr = i;
-+
-+		if (i == XRX200_DMA_TX) {
-+			ltq_dma_alloc_tx(&ch->dma);
-+			err = request_irq(irq, xrx200_dma_irq, 0, "vrx200_tx", hw);
-+		} else if (i == XRX200_DMA_RX) {
-+			ltq_dma_alloc_rx(&ch->dma);
-+			for (ch->dma.desc = 0; ch->dma.desc < LTQ_DESC_NUM;
-+					ch->dma.desc++)
-+				if (xrx200_alloc_skb(ch))
-+					err = -ENOMEM;
-+			ch->dma.desc = 0;
-+			err = request_irq(irq, xrx200_dma_irq, 0, "vrx200_rx", hw);
-+		} else
-+			continue;
-+
-+		if (!err)
-+			ch->dma.irq = irq;
-+	}
-+
-+	return err;
-+}
-+
-+#ifdef SW_POLLING
-+static void xrx200_gmac_update(struct xrx200_port *port)
-+{
-+	u16 phyaddr = port->phydev->addr & MDIO_PHY_ADDR_MASK;
-+	u16 miimode = ltq_mii_r32(MII_CFG(port->num)) & MII_CFG_MODE_MASK;
-+	u16 miirate = 0;
-+
-+	switch (port->phydev->speed) {
-+	case SPEED_1000:
-+		phyaddr |= MDIO_PHY_SPEED_G1;
-+		miirate = MII_CFG_RATE_M125;
-+		break;
-+
-+	case SPEED_100:
-+		phyaddr |= MDIO_PHY_SPEED_M100;
-+		switch (miimode) {
-+		case MII_CFG_MODE_RMIIM:
-+		case MII_CFG_MODE_RMIIP:
-+			miirate = MII_CFG_RATE_M50;
-+			break;
-+		default:
-+			miirate = MII_CFG_RATE_M25;
-+			break;
-+		}
-+		break;
-+
-+	default:
-+		phyaddr |= MDIO_PHY_SPEED_M10;
-+		miirate = MII_CFG_RATE_M2P5;
-+		break;
-+	}
-+
-+	if (port->phydev->link)
-+		phyaddr |= MDIO_PHY_LINK_UP;
-+	else
-+		phyaddr |= MDIO_PHY_LINK_DOWN;
-+
-+	if (port->phydev->duplex == DUPLEX_FULL)
-+		phyaddr |= MDIO_PHY_FDUP_EN;
-+	else
-+		phyaddr |= MDIO_PHY_FDUP_DIS;
-+
-+	ltq_mdio_w32_mask(MDIO_UPDATE_MASK, phyaddr, MDIO_PHY(port->num));
-+	ltq_mii_w32_mask(MII_CFG_RATE_MASK, miirate, MII_CFG(port->num));
-+	udelay(1);
-+}
-+#else
-+static void xrx200_gmac_update(struct xrx200_port *port)
-+{
-+
-+}
-+#endif
-+
-+static void xrx200_mdio_link(struct net_device *dev)
-+{
-+	struct xrx200_priv *priv = netdev_priv(dev);
-+	int i;
-+
-+	for (i = 0; i < priv->num_port; i++) {
-+		if (!priv->port[i].phydev)
-+			continue;
-+
-+		if (priv->port[i].link != priv->port[i].phydev->link) {
-+			xrx200_gmac_update(&priv->port[i]);
-+			priv->port[i].link = priv->port[i].phydev->link;
-+			netdev_info(dev, "port %d %s link\n",
-+				priv->port[i].num,
-+				(priv->port[i].link)?("got"):("lost"));
-+		}
-+	}
-+}
-+
-+static inline int xrx200_mdio_poll(struct mii_bus *bus)
-+{
-+	unsigned cnt = 10000;
-+
-+	while (likely(cnt--)) {
-+		unsigned ctrl = ltq_mdio_r32(MDIO_CTRL);
-+		if ((ctrl & MDIO_BUSY) == 0)
-+			return 0;
-+	}
-+
-+	return 1;
-+}
-+
-+static int xrx200_mdio_wr(struct mii_bus *bus, int addr, int reg, u16 val)
-+{
-+	if (xrx200_mdio_poll(bus))
-+		return 1;
-+
-+	ltq_mdio_w32(val, MDIO_WRITE);
-+	ltq_mdio_w32(MDIO_BUSY | MDIO_WR |
-+		((addr & MDIO_MASK) << MDIO_ADDRSHIFT) |
-+		(reg & MDIO_MASK),
-+		MDIO_CTRL);
-+
-+	return 0;
-+}
-+
-+static int xrx200_mdio_rd(struct mii_bus *bus, int addr, int reg)
-+{
-+	if (xrx200_mdio_poll(bus))
-+		return -1;
-+
-+	ltq_mdio_w32(MDIO_BUSY | MDIO_RD |
-+		((addr & MDIO_MASK) << MDIO_ADDRSHIFT) |
-+		(reg & MDIO_MASK),
-+		MDIO_CTRL);
-+
-+	if (xrx200_mdio_poll(bus))
-+		return -1;
-+
-+	return ltq_mdio_r32(MDIO_READ);
-+}
-+
-+static int xrx200_mdio_probe(struct net_device *dev, struct xrx200_port *port)
-+{
-+	struct xrx200_priv *priv = netdev_priv(dev);
-+	struct phy_device *phydev = NULL;
-+	unsigned val;
-+
-+	phydev = priv->hw->mii_bus->phy_map[port->phy_addr];
-+
-+	if (!phydev) {
-+		netdev_err(dev, "no PHY found\n");
-+		return -ENODEV;
-+	}
-+
-+	phydev = phy_connect(dev, dev_name(&phydev->dev), &xrx200_mdio_link,
-+				port->phy_if);
-+
-+	if (IS_ERR(phydev)) {
-+		netdev_err(dev, "Could not attach to PHY\n");
-+		return PTR_ERR(phydev);
-+	}
-+
-+	phydev->supported &= (SUPPORTED_10baseT_Half
-+			| SUPPORTED_10baseT_Full
-+			| SUPPORTED_100baseT_Half
-+			| SUPPORTED_100baseT_Full
-+			| SUPPORTED_1000baseT_Half
-+			| SUPPORTED_1000baseT_Full
-+			| SUPPORTED_Autoneg
-+			| SUPPORTED_MII
-+			| SUPPORTED_TP);
-+	phydev->advertising = phydev->supported;
-+	port->phydev = phydev;
-+
-+	pr_info("%s: attached PHY [%s] (phy_addr=%s, irq=%d)\n",
-+		dev->name, phydev->drv->name,
-+		dev_name(&phydev->dev), phydev->irq);
-+
-+#ifdef SW_POLLING
-+	phy_read_status(phydev);
-+
-+	val = xrx200_mdio_rd(priv->hw->mii_bus, MDIO_DEVAD_NONE, MII_CTRL1000);
-+	val |= ADVERTIZE_MPD;
-+	xrx200_mdio_wr(priv->hw->mii_bus, MDIO_DEVAD_NONE, MII_CTRL1000, val);
-+	xrx200_mdio_wr(priv->hw->mii_bus, 0, 0, 0x1040);
-+
-+	phy_start_aneg(phydev);
-+#endif
-+	return 0;
-+}
-+
-+static void xrx200_port_config(struct xrx200_priv *priv,
-+		const struct xrx200_port *port)
-+{
-+	u16 miimode = 0;
-+
-+	switch (port->num) {
-+	case 0: /* xMII0 */
-+	case 1: /* xMII1 */
-+		switch (port->phy_if) {
-+		case PHY_INTERFACE_MODE_MII:
-+			if (port->flags & XRX200_PORT_TYPE_PHY)
-+				/* MII MAC mode, connected to external PHY */
-+				miimode = MII_CFG_MODE_MIIM;
-+			else
-+				/* MII PHY mode, connected to external MAC */
-+				miimode = MII_CFG_MODE_MIIP;
-+			break;
-+		case PHY_INTERFACE_MODE_RMII:
-+			if (port->flags & XRX200_PORT_TYPE_PHY)
-+				/* RMII MAC mode, connected to external PHY */
-+				miimode = MII_CFG_MODE_RMIIM;
-+			else
-+				/* RMII PHY mode, connected to external MAC */
-+				miimode = MII_CFG_MODE_RMIIP;
-+			break;
-+		case PHY_INTERFACE_MODE_RGMII:
-+			/* RGMII MAC mode, connected to external PHY */
-+			miimode = MII_CFG_MODE_RGMII;
-+			break;
-+		default:
-+			break;
-+		}
-+		break;
-+	case 2: /* internal GPHY0 */
-+	case 3: /* internal GPHY0 */
-+	case 4: /* internal GPHY1 */
-+		switch (port->phy_if) {
-+			case PHY_INTERFACE_MODE_MII:
-+			case PHY_INTERFACE_MODE_GMII:
-+				/* MII MAC mode, connected to internal GPHY */
-+				miimode = MII_CFG_MODE_MIIM;
-+				break;
-+			default:
-+				break;
-+		}
-+		break;
-+	case 5: /* internal GPHY1 or xMII2 */
-+		switch (port->phy_if) {
-+		case PHY_INTERFACE_MODE_MII:
-+			/* MII MAC mode, connected to internal GPHY */
-+			miimode = MII_CFG_MODE_MIIM;
-+			break;
-+		case PHY_INTERFACE_MODE_RGMII:
-+			/* RGMII MAC mode, connected to external PHY */
-+			miimode = MII_CFG_MODE_RGMII;
-+			break;
-+		default:
-+			break;
-+		}
-+		break;
-+	default:
-+		break;
-+	}
-+
-+	ltq_mii_w32_mask(MII_CFG_MODE_MASK, miimode | MII_CFG_EN,
-+		MII_CFG(port->num));
-+}
-+
-+static int xrx200_init(struct net_device *dev)
-+{
-+	struct xrx200_priv *priv = netdev_priv(dev);
-+	struct sockaddr mac;
-+	int err, i;
-+
-+#ifndef SW_POLLING
-+	unsigned int reg = 0;
-+
-+	/* enable auto polling */
-+	for (i = 0; i < priv->num_port; i++)
-+		reg |= BIT(priv->port[i].num);
-+	ltq_mdio_w32(reg, MDIO_CLK_CFG0);
-+	ltq_mdio_w32(MDIO1_25MHZ, MDIO_CLK_CFG1);
-+#endif
-+
-+	/* setup each port */
-+	for (i = 0; i < priv->num_port; i++)
-+		xrx200_port_config(priv, &priv->port[i]);
-+
-+	memcpy(&mac.sa_data, priv->mac, ETH_ALEN);
-+	if (!is_valid_ether_addr(mac.sa_data)) {
-+		pr_warn("net-xrx200: invalid MAC, using random\n");
-+		eth_random_addr(mac.sa_data);
-+		dev->addr_assign_type |= NET_ADDR_RANDOM;
-+	}
-+
-+	err = eth_mac_addr(dev, &mac);
-+	if (err)
-+		goto err_netdev;
-+
-+	for (i = 0; i < priv->num_port; i++)
-+		if (xrx200_mdio_probe(dev, &priv->port[i]))
-+			pr_warn("xrx200-mdio: probing phy of port %d failed\n",
-+					 priv->port[i].num);
-+
-+	return 0;
-+
-+err_netdev:
-+	unregister_netdev(dev);
-+	free_netdev(dev);
-+	return err;
-+}
-+
-+static void xrx200_pci_microcode(void)
-+{
-+	int i;
-+
-+	ltq_switch_w32_mask(PCE_TBL_CFG_ADDR_MASK | PCE_TBL_CFG_ADWR_MASK,
-+		PCE_TBL_CFG_ADWR, PCE_TBL_CTRL);
-+	ltq_switch_w32(0, PCE_TBL_MASK);
-+
-+	for (i = 0; i < ARRAY_SIZE(pce_microcode); i++) {
-+		ltq_switch_w32(i, PCE_TBL_ADDR);
-+		ltq_switch_w32(pce_microcode[i].val[3], PCE_TBL_VAL(0));
-+		ltq_switch_w32(pce_microcode[i].val[2], PCE_TBL_VAL(1));
-+		ltq_switch_w32(pce_microcode[i].val[1], PCE_TBL_VAL(2));
-+		ltq_switch_w32(pce_microcode[i].val[0], PCE_TBL_VAL(3));
-+
-+		// start the table access:
-+		ltq_switch_w32_mask(0, PCE_TBL_BUSY, PCE_TBL_CTRL);
-+		while (ltq_switch_r32(PCE_TBL_CTRL) & PCE_TBL_BUSY);
-+	}
-+
-+	/* tell the switch that the microcode is loaded */
-+	ltq_switch_w32_mask(0, BIT(3), PCE_GCTRL_REG(0));
-+}
-+
-+static void xrx200_hw_init(struct xrx200_hw *hw)
-+{
-+	int i;
-+
-+	/* enable clock gate */
-+	clk_enable(hw->clk);
-+
-+	ltq_switch_w32(1, 0);
-+	mdelay(100);
-+	ltq_switch_w32(0, 0);
-+	/*
-+	 * TODO: we should really disbale all phys/miis here and explicitly
-+	 * enable them in the device secific init function
-+	 */
-+
-+	/* disable port fetch/store dma */
-+	for (i = 0; i < 7; i++ ) {
-+		ltq_switch_w32(0, FDMA_PCTRLx(i));
-+		ltq_switch_w32(0, SDMA_PCTRLx(i));
-+	}
-+
-+	/* enable Switch */
-+	ltq_mdio_w32_mask(0, MDIO_GLOB_ENABLE, MDIO_GLOB);
-+
-+	/* load the pce microcode */
-+	xrx200_pci_microcode();
-+
-+	/* Default unknown Broadcat/Multicast/Unicast port maps */
-+	ltq_switch_w32(0x7f, PCE_PMAP1);
-+	ltq_switch_w32(0x7f, PCE_PMAP2);
-+	ltq_switch_w32(0x7f, PCE_PMAP3);
-+
-+	/* RMON Counter Enable for all physical ports */
-+	for (i = 0; i < 7; i++)
-+		ltq_switch_w32(0x1, BM_PCFG(i));
-+
-+	/* disable auto polling */
-+	ltq_mdio_w32(0x0, MDIO_CLK_CFG0);
-+
-+	/* enable port statistic counters */
-+	for (i = 0; i < 7; i++)
-+		ltq_switch_w32(0x1, BM_PCFGx(i));
-+
-+	/* set IPG to 12 */
-+	ltq_pmac_w32_mask(PMAC_IPG_MASK, 0xb, PMAC_RX_IPG);
-+
-+#ifdef SW_ROUTING
-+	/* enable status header, enable CRC */
-+	ltq_pmac_w32_mask(0,
-+		PMAC_HD_CTL_RST | PMAC_HD_CTL_AST | PMAC_HD_CTL_RXSH | PMAC_HD_CTL_AS | PMAC_HD_CTL_AC,
-+		PMAC_HD_CTL);
-+#else
-+	/* disable status header, enable CRC */
-+	ltq_pmac_w32_mask(PMAC_HD_CTL_AST | PMAC_HD_CTL_RXSH | PMAC_HD_CTL_AS,
-+		PMAC_HD_CTL_AC,
-+		PMAC_HD_CTL);
-+#endif
-+
-+	/* enable port fetch/store dma & VLAN Modification */
-+	for (i = 0; i < 7; i++ ) {
-+		ltq_switch_w32_mask(0, 0x19, FDMA_PCTRLx(i));
-+		ltq_switch_w32_mask(0, 0x01, SDMA_PCTRLx(i));
-+		ltq_switch_w32_mask(0, PCE_INGRESS, PCE_PCTRL_REG(i, 0));
-+	}
-+
-+	/* enable special tag insertion on cpu port */
-+	ltq_switch_w32_mask(0, 0x02, FDMA_PCTRLx(6));
-+	ltq_switch_w32_mask(0, PCE_INGRESS, PCE_PCTRL_REG(6, 0));
-+	ltq_switch_w32_mask(0, BIT(3), MAC_CTRL_REG(6, 2));
-+	ltq_switch_w32(1518 + 8 + 4 * 2, MAC_FLEN_REG);
-+}
-+
-+static void xrx200_hw_cleanup(struct xrx200_hw *hw)
-+{
-+	int i;
-+
-+	/* disable the switch */
-+	ltq_mdio_w32_mask(MDIO_GLOB_ENABLE, 0, MDIO_GLOB);
-+
-+	/* free the channels and IRQs */
-+	for (i = 0; i < 2; i++) {
-+		ltq_dma_free(&hw->chan[i].dma);
-+		if (hw->chan[i].dma.irq)
-+			free_irq(hw->chan[i].dma.irq, hw);
-+	}
-+
-+	/* free the allocated RX ring */
-+	for (i = 0; i < LTQ_DESC_NUM; i++)
-+		dev_kfree_skb_any(hw->chan[XRX200_DMA_RX].skb[i]);
-+
-+	/* clear the mdio bus */
-+	mdiobus_unregister(hw->mii_bus);
-+	mdiobus_free(hw->mii_bus);
-+
-+	/* release the clock */
-+	clk_disable(hw->clk);
-+	clk_put(hw->clk);
-+}
-+
-+static int xrx200_of_mdio(struct xrx200_hw *hw, struct device_node *np)
-+{
-+	hw->mii_bus = mdiobus_alloc();
-+	if (!hw->mii_bus)
-+		return -ENOMEM;
-+
-+	hw->mii_bus->read = xrx200_mdio_rd;
-+	hw->mii_bus->write = xrx200_mdio_wr;
-+	hw->mii_bus->name = "lantiq,xrx200-mdio";
-+	snprintf(hw->mii_bus->id, MII_BUS_ID_SIZE, "%x", 0);
-+
-+	if (of_mdiobus_register(hw->mii_bus, np)) {
-+		mdiobus_free(hw->mii_bus);
-+		return -ENXIO;
-+	}
-+
-+	return 0;
-+}
-+
-+static void xrx200_of_port(struct xrx200_priv *priv, struct device_node *port)
-+{
-+	const __be32 *addr, *id = of_get_property(port, "reg", NULL);
-+	struct xrx200_port *p = &priv->port[priv->num_port];
-+
-+	if (!id)
-+		return;
-+
-+	memset(p, 0, sizeof(struct xrx200_port));
-+	p->phy_node = of_parse_phandle(port, "phy-handle", 0);
-+	addr = of_get_property(p->phy_node, "reg", NULL);
-+	if (!addr)
-+		return;
-+
-+	p->num = *id;
-+	p->phy_addr = *addr;
-+	p->phy_if = of_get_phy_mode(port);
-+	if (p->phy_addr > 0x10)
-+		p->flags = XRX200_PORT_TYPE_MAC;
-+	else
-+		p->flags = XRX200_PORT_TYPE_PHY;
-+	priv->num_port++;
-+
-+	p->gpio = of_get_gpio_flags(port, 0, &p->gpio_flags);
-+	if (gpio_is_valid(p->gpio))
-+		if (!gpio_request(p->gpio, "phy-reset")) {
-+			gpio_direction_output(p->gpio,
-+				(p->gpio_flags & OF_GPIO_ACTIVE_LOW) ? (1) : (0));
-+			udelay(100);
-+			gpio_set_value(p->gpio, (p->gpio_flags & OF_GPIO_ACTIVE_LOW) ? (0) : (1));
-+		}
-+	/* is this port a wan port ? */
-+	if (priv->wan)
-+		priv->hw->wan_map |= BIT(p->num);
-+
-+	priv->port_map |= BIT(p->num);
-+
-+	/* store the port id in the hw struct so we can map ports -> devices */
-+	priv->hw->port_map[p->num] = priv->hw->num_devs;
-+}
-+
-+static const struct net_device_ops xrx200_netdev_ops = {
-+	.ndo_init		= xrx200_init,
-+	.ndo_open		= xrx200_open,
-+	.ndo_stop		= xrx200_close,
-+	.ndo_start_xmit		= xrx200_start_xmit,
-+	.ndo_set_mac_address	= eth_mac_addr,
-+	.ndo_validate_addr	= eth_validate_addr,
-+	.ndo_change_mtu		= eth_change_mtu,
-+	.ndo_get_stats		= xrx200_get_stats,
-+	.ndo_tx_timeout		= xrx200_tx_timeout,
-+};
-+
-+static void xrx200_of_iface(struct xrx200_hw *hw, struct device_node *iface)
-+{
-+	struct xrx200_priv *priv;
-+	struct device_node *port;
-+	const __be32 *wan;
-+
-+	/* alloc the network device */
-+	hw->devs[hw->num_devs] = alloc_etherdev(sizeof(struct xrx200_priv));
-+	if (!hw->devs[hw->num_devs])
-+		return;
-+
-+	/* setup the network device */
-+	strcpy(hw->devs[hw->num_devs]->name, "eth%d");
-+	hw->devs[hw->num_devs]->netdev_ops = &xrx200_netdev_ops;
-+	hw->devs[hw->num_devs]->watchdog_timeo = XRX200_TX_TIMEOUT;
-+	hw->devs[hw->num_devs]->needed_headroom = XRX200_HEADROOM;
-+
-+	/* setup our private data */
-+	priv = netdev_priv(hw->devs[hw->num_devs]);
-+	priv->hw = hw;
-+	of_get_mac_address_mtd(iface, priv->mac);
-+	priv->id = hw->num_devs;
-+
-+	/* is this the wan interface ? */
-+	wan = of_get_property(iface, "lantiq,wan", NULL);
-+	if (wan && (*wan == 1))
-+		priv->wan = 1;
-+
-+	/* should the switch be enabled on this interface ? */
-+	if (of_find_property(iface, "lantiq,switch", NULL))
-+		priv->sw = 1;
-+
-+	/* load the ports that are part of the interface */
-+	for_each_child_of_node(iface, port)
-+		if (of_device_is_compatible(port, "lantiq,xrx200-pdi-port"))
-+			xrx200_of_port(priv, port);
-+
-+	/* register the actual device */
-+	if (!register_netdev(hw->devs[hw->num_devs]))
-+		hw->num_devs++;
-+}
-+
-+static struct xrx200_hw xrx200_hw;
-+
-+static int xrx200_probe(struct platform_device *pdev)
-+{
-+	struct resource *res[4];
-+	struct device_node *mdio_np, *iface_np;
-+	int i;
-+
-+	/* load the memory ranges */
-+	for (i = 0; i < 4; i++) {
-+		res[i] = platform_get_resource(pdev, IORESOURCE_MEM, i);
-+		if (!res[i]) {
-+			dev_err(&pdev->dev, "failed to get resources\n");
-+			return -ENOENT;
-+		}
-+	}
-+	xrx200_switch_membase = devm_ioremap_resource(&pdev->dev, res[0]);
-+	xrx200_mdio_membase = devm_ioremap_resource(&pdev->dev, res[1]);
-+	xrx200_mii_membase = devm_ioremap_resource(&pdev->dev, res[2]);
-+	xrx200_pmac_membase = devm_ioremap_resource(&pdev->dev, res[3]);
-+	if (!xrx200_switch_membase || !xrx200_mdio_membase ||
-+			!xrx200_mii_membase || !xrx200_pmac_membase) {
-+		dev_err(&pdev->dev, "failed to request and remap io ranges \n");
-+		return -ENOMEM;
-+	}
-+
-+	/* get the clock */
-+	xrx200_hw.clk = clk_get(&pdev->dev, NULL);
-+	if (IS_ERR(xrx200_hw.clk)) {
-+		dev_err(&pdev->dev, "failed to get clock\n");
-+		return PTR_ERR(xrx200_hw.clk);
-+	}
-+
-+	/* bring up the dma engine and IP core */
-+	spin_lock_init(&xrx200_hw.lock);
-+	xrx200_dma_init(&xrx200_hw);
-+	xrx200_hw_init(&xrx200_hw);
-+	tasklet_init(&xrx200_hw.chan[XRX200_DMA_TX].tasklet, xrx200_tx_housekeeping, (u32) &xrx200_hw);
-+
-+	/* bring up the mdio bus */
-+	mdio_np = of_find_compatible_node(pdev->dev.of_node, NULL,
-+				"lantiq,xrx200-mdio");
-+	if (mdio_np)
-+		if (xrx200_of_mdio(&xrx200_hw, mdio_np))
-+			dev_err(&pdev->dev, "mdio probe failed\n");
-+
-+	/* load the interfaces */
-+	for_each_child_of_node(pdev->dev.of_node, iface_np)
-+		if (of_device_is_compatible(iface_np, "lantiq,xrx200-pdi")) {
-+			if (xrx200_hw.num_devs < XRX200_MAX_DEV)
-+				xrx200_of_iface(&xrx200_hw, iface_np);
-+			else
-+				dev_err(&pdev->dev,
-+					"only %d interfaces allowed\n",
-+					XRX200_MAX_DEV);
-+		}
-+
-+	if (!xrx200_hw.num_devs) {
-+		xrx200_hw_cleanup(&xrx200_hw);
-+		dev_err(&pdev->dev, "failed to load interfaces\n");
-+		return -ENOENT;
-+	}
-+
-+	xrx200sw_init(&xrx200_hw);
-+
-+	/* set wan port mask */
-+	ltq_pmac_w32(xrx200_hw.wan_map, PMAC_EWAN);
-+
-+	for (i = 0; i < xrx200_hw.num_devs; i++) {
-+		xrx200_hw.chan[XRX200_DMA_RX].devs[i] = xrx200_hw.devs[i];
-+		xrx200_hw.chan[XRX200_DMA_TX].devs[i] = xrx200_hw.devs[i];
-+	}
-+
-+	/* setup NAPI */
-+	init_dummy_netdev(&xrx200_hw.chan[XRX200_DMA_RX].dummy_dev);
-+	netif_napi_add(&xrx200_hw.chan[XRX200_DMA_RX].dummy_dev,
-+			&xrx200_hw.chan[XRX200_DMA_RX].napi, xrx200_poll_rx, 32);
-+
-+	platform_set_drvdata(pdev, &xrx200_hw);
-+
-+	return 0;
-+}
-+
-+static int xrx200_remove(struct platform_device *pdev)
-+{
-+	struct net_device *dev = platform_get_drvdata(pdev);
-+	struct xrx200_priv *priv;
-+
-+	if (!dev)
-+		return 0;
-+
-+	priv = netdev_priv(dev);
-+
-+	/* free stack related instances */
-+	netif_stop_queue(dev);
-+	netif_napi_del(&xrx200_hw.chan[XRX200_DMA_RX].napi);
-+
-+	/* shut down hardware */
-+	xrx200_hw_cleanup(&xrx200_hw);
-+
-+	/* remove the actual device */
-+	unregister_netdev(dev);
-+	free_netdev(dev);
-+
-+	return 0;
-+}
-+
-+static const struct of_device_id xrx200_match[] = {
-+	{ .compatible = "lantiq,xrx200-net" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, xrx200_match);
-+
-+static struct platform_driver xrx200_driver = {
-+	.probe = xrx200_probe,
-+	.remove = xrx200_remove,
-+	.driver = {
-+		.name = "lantiq,xrx200-net",
-+		.of_match_table = xrx200_match,
-+		.owner = THIS_MODULE,
-+	},
-+};
-+
-+module_platform_driver(xrx200_driver);
-+
-+MODULE_AUTHOR("John Crispin <blogic@openwrt.org>");
-+MODULE_DESCRIPTION("Lantiq SoC XRX200 ethernet");
-+MODULE_LICENSE("GPL");
---- /dev/null
-+++ b/drivers/net/ethernet/lantiq_xrx200_sw.h
-@@ -0,0 +1,1328 @@
-+/*
-+ *   This program is free software; you can redistribute it and/or modify it
-+ *   under the terms of the GNU General Public License version 2 as published
-+ *   by the Free Software Foundation.
-+ *
-+ *   This program is distributed in the hope that it will be useful,
-+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ *   GNU General Public License for more details.
-+ *
-+ *   You should have received a copy of the GNU General Public License
-+ *   along with this program; if not, write to the Free Software
-+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-+ *
-+ *   Copyright (C) 2010 Lantiq Deutschland GmbH
-+ *   Copyright (C) 2013 Antonios Vamporakis <vamporakis@yahoo.com>
-+ *
-+ *   VR9 switch registers extracted from 310TUJ0 switch api
-+ *   WARNING mult values of 0x00 may not be correct
-+ *
-+ */
-+
-+enum {
-+//	XRX200_ETHSW_SWRES,            /* Ethernet Switch ResetControl Register */
-+//	XRX200_ETHSW_SWRES_R1,         /* Hardware Reset */
-+//	XRX200_ETHSW_SWRES_R0,         /* Register Configuration */
-+//	XRX200_ETHSW_CLK_MAC_GAT,      /* Ethernet Switch Clock ControlRegister  */
-+//	XRX200_ETHSW_CLK_EXP_SLEEP,    /* Exponent to put system into sleep */
-+//	XRX200_ETHSW_CLK_EXP_WAKE,     /* Exponent to wake up system */
-+//	XRX200_ETHSW_CLK_CLK2_EN,      /* CLK2 Input for MAC */
-+//	XRX200_ETHSW_CLK_EXT_DIV_EN,   /* External Clock Divider Enable */
-+//	XRX200_ETHSW_CLK_RAM_DBG_EN,   /* Clock Gating Enable */
-+//	XRX200_ETHSW_CLK_REG_GAT_EN,   /* Clock Gating Enable */
-+//	XRX200_ETHSW_CLK_GAT_EN,       /* Clock Gating Enable */
-+//	XRX200_ETHSW_CLK_MAC_GAT_EN,   /* Clock Gating Enable */
-+//	XRX200_ETHSW_DBG_STEP,         /* Ethernet Switch Debug ControlRegister */
-+//	XRX200_ETHSW_DBG_CLK_SEL,      /* Trigger Enable */
-+//	XRX200_ETHSW_DBG_MON_EN,       /* Monitoring Enable */
-+//	XRX200_ETHSW_DBG_TRIG_EN,      /* Trigger Enable */
-+//	XRX200_ETHSW_DBG_MODE,         /* Debug Mode */
-+//	XRX200_ETHSW_DBG_STEP_TIME,    /* Clock Step Size */
-+//	XRX200_ETHSW_SSB_MODE,         /* Ethernet Switch SharedSegment Buffer Mode Register */
-+//	XRX200_ETHSW_SSB_MODE_ADDE,    /* Memory Address */
-+//	XRX200_ETHSW_SSB_MODE_MODE,    /* Memory Access Mode */
-+//	XRX200_ETHSW_SSB_ADDR,         /* Ethernet Switch SharedSegment Buffer Address Register */
-+//	XRX200_ETHSW_SSB_ADDR_ADDE,    /* Memory Address */
-+//	XRX200_ETHSW_SSB_DATA,         /* Ethernet Switch SharedSegment Buffer Data Register */
-+//	XRX200_ETHSW_SSB_DATA_DATA,    /* Data Value */
-+//	XRX200_ETHSW_CAP_0,            /* Ethernet Switch CapabilityRegister 0 */
-+//	XRX200_ETHSW_CAP_0_SPEED,      /* Clock frequency */
-+//	XRX200_ETHSW_CAP_1,            /* Ethernet Switch CapabilityRegister 1 */
-+//	XRX200_ETHSW_CAP_1_GMAC,       /* MAC operation mode */
-+//	XRX200_ETHSW_CAP_1_QUEUE,      /* Number of queues */
-+//	XRX200_ETHSW_CAP_1_VPORTS,     /* Number of virtual ports */
-+//	XRX200_ETHSW_CAP_1_PPORTS,     /* Number of physical ports */
-+//	XRX200_ETHSW_CAP_2,            /* Ethernet Switch CapabilityRegister 2 */
-+//	XRX200_ETHSW_CAP_2_PACKETS,    /* Number of packets */
-+//	XRX200_ETHSW_CAP_3,            /* Ethernet Switch CapabilityRegister 3 */
-+//	XRX200_ETHSW_CAP_3_METERS,     /* Number of traffic meters */
-+//	XRX200_ETHSW_CAP_3_SHAPERS,    /* Number of traffic shapers */
-+//	XRX200_ETHSW_CAP_4,            /* Ethernet Switch CapabilityRegister 4 */
-+//	XRX200_ETHSW_CAP_4_PPPOE,      /* PPPoE table size */
-+//	XRX200_ETHSW_CAP_4_VLAN,       /* Active VLAN table size */
-+//	XRX200_ETHSW_CAP_5,            /* Ethernet Switch CapabilityRegister 5 */
-+//	XRX200_ETHSW_CAP_5_IPPLEN,     /* IP packet length table size */
-+//	XRX200_ETHSW_CAP_5_PROT,       /* Protocol table size */
-+//	XRX200_ETHSW_CAP_6,            /* Ethernet Switch CapabilityRegister 6 */
-+//	XRX200_ETHSW_CAP_6_MACDASA,    /* MAC DA/SA table size */
-+//	XRX200_ETHSW_CAP_6_APPL,       /* Application table size */
-+//	XRX200_ETHSW_CAP_7,            /* Ethernet Switch CapabilityRegister 7 */
-+//	XRX200_ETHSW_CAP_7_IPDASAM,    /* IP DA/SA MSB table size */
-+//	XRX200_ETHSW_CAP_7_IPDASAL,    /* IP DA/SA LSB table size */
-+//	XRX200_ETHSW_CAP_8,            /* Ethernet Switch CapabilityRegister 8 */
-+//	XRX200_ETHSW_CAP_8_MCAST,      /* Multicast table size */
-+//	XRX200_ETHSW_CAP_9,            /* Ethernet Switch CapabilityRegister 9 */
-+//	XRX200_ETHSW_CAP_9_FLAGG,      /* Flow Aggregation table size */
-+//	XRX200_ETHSW_CAP_10,           /* Ethernet Switch CapabilityRegister 10 */
-+//	XRX200_ETHSW_CAP_10_MACBT,     /* MAC bridging table size */
-+//	XRX200_ETHSW_CAP_11,           /* Ethernet Switch CapabilityRegister 11 */
-+//	XRX200_ETHSW_CAP_11_BSIZEL,    /* Packet buffer size (lower part, in byte) */
-+//	XRX200_ETHSW_CAP_12,           /* Ethernet Switch CapabilityRegister 12 */
-+//	XRX200_ETHSW_CAP_12_BSIZEH,    /* Packet buffer size (higher part, in byte) */
-+//	XRX200_ETHSW_VERSION_REV,      /* Ethernet Switch VersionRegister */
-+//	XRX200_ETHSW_VERSION_MOD_ID,   /* Module Identification */
-+//	XRX200_ETHSW_VERSION_REV_ID,   /* Hardware Revision Identification */
-+//	XRX200_ETHSW_IER,              /* Interrupt Enable Register */
-+//	XRX200_ETHSW_IER_FDMAIE,       /* Fetch DMA Interrupt Enable */
-+//	XRX200_ETHSW_IER_SDMAIE,       /* Store DMA Interrupt Enable */
-+//	XRX200_ETHSW_IER_MACIE,        /* Ethernet MAC Interrupt Enable */
-+//	XRX200_ETHSW_IER_PCEIE,        /* Parser and Classification Engine Interrupt Enable */
-+//	XRX200_ETHSW_IER_BMIE,         /* Buffer Manager Interrupt Enable */
-+//	XRX200_ETHSW_ISR,              /* Interrupt Status Register */
-+//	XRX200_ETHSW_ISR_FDMAINT,      /* Fetch DMA Interrupt */
-+//	XRX200_ETHSW_ISR_SDMAINT,      /* Store DMA Interrupt */
-+//	XRX200_ETHSW_ISR_MACINT,       /* Ethernet MAC Interrupt */
-+//	XRX200_ETHSW_ISR_PCEINT,       /* Parser and Classification Engine Interrupt */
-+//	XRX200_ETHSW_ISR_BMINT,        /* Buffer Manager Interrupt */
-+//	XRX200_ETHSW_SPARE_0,          /* Ethernet Switch SpareCells 0 */
-+//	XRX200_ETHSW_SPARE_0_SPARE,    /* SPARE0  */
-+//	XRX200_ETHSW_SPARE_1,          /* Ethernet Switch SpareCells 1 */
-+//	XRX200_ETHSW_SPARE_1_SPARE,    /* SPARE1  */
-+//	XRX200_ETHSW_SPARE_2,          /* Ethernet Switch SpareCells 2 */
-+//	XRX200_ETHSW_SPARE_2_SPARE,    /* SPARE2  */
-+//	XRX200_ETHSW_SPARE_3,          /* Ethernet Switch SpareCells 3 */
-+//	XRX200_ETHSW_SPARE_3_SPARE,    /* SPARE3  */
-+//	XRX200_ETHSW_SPARE_4,          /* Ethernet Switch SpareCells 4 */
-+//	XRX200_ETHSW_SPARE_4_SPARE,    /* SPARE4  */
-+//	XRX200_ETHSW_SPARE_5,          /* Ethernet Switch SpareCells 5 */
-+//	XRX200_ETHSW_SPARE_5_SPARE,    /* SPARE5  */
-+//	XRX200_ETHSW_SPARE_6,          /* Ethernet Switch SpareCells 6 */
-+//	XRX200_ETHSW_SPARE_6_SPARE,    /* SPARE6  */
-+//	XRX200_ETHSW_SPARE_7,          /* Ethernet Switch SpareCells 7 */
-+//	XRX200_ETHSW_SPARE_7_SPARE,    /* SPARE7  */
-+//	XRX200_ETHSW_SPARE_8,          /* Ethernet Switch SpareCells 8 */
-+//	XRX200_ETHSW_SPARE_8_SPARE,    /* SPARE8  */
-+//	XRX200_ETHSW_SPARE_9,          /* Ethernet Switch SpareCells 9 */
-+//	XRX200_ETHSW_SPARE_9_SPARE,    /* SPARE9  */
-+//	XRX200_ETHSW_SPARE_10,         /* Ethernet Switch SpareCells 10 */
-+//	XRX200_ETHSW_SPARE_10_SPARE,   /* SPARE10  */
-+//	XRX200_ETHSW_SPARE_11,         /* Ethernet Switch SpareCells 11 */
-+//	XRX200_ETHSW_SPARE_11_SPARE,   /* SPARE11  */
-+//	XRX200_ETHSW_SPARE_12,         /* Ethernet Switch SpareCells 12 */
-+//	XRX200_ETHSW_SPARE_12_SPARE,   /* SPARE12  */
-+//	XRX200_ETHSW_SPARE_13,         /* Ethernet Switch SpareCells 13 */
-+//	XRX200_ETHSW_SPARE_13_SPARE,   /* SPARE13  */
-+//	XRX200_ETHSW_SPARE_14,         /* Ethernet Switch SpareCells 14 */
-+//	XRX200_ETHSW_SPARE_14_SPARE,   /* SPARE14  */
-+//	XRX200_ETHSW_SPARE_15,         /* Ethernet Switch SpareCells 15 */
-+//	XRX200_ETHSW_SPARE_15_SPARE,   /* SPARE15  */
-+//	XRX200_BM_RAM_VAL_3,           /* RAM Value Register 3 */
-+//	XRX200_BM_RAM_VAL_3_VAL3,      /* Data value [15:0] */
-+//	XRX200_BM_RAM_VAL_2,           /* RAM Value Register 2 */
-+//	XRX200_BM_RAM_VAL_2_VAL2,      /* Data value [15:0] */
-+//	XRX200_BM_RAM_VAL_1,           /* RAM Value Register 1 */
-+//	XRX200_BM_RAM_VAL_1_VAL1,      /* Data value [15:0] */
-+//	XRX200_BM_RAM_VAL_0,           /* RAM Value Register 0 */
-+//	XRX200_BM_RAM_VAL_0_VAL0,      /* Data value [15:0] */
-+//	XRX200_BM_RAM_ADDR,            /* RAM Address Register */
-+//	XRX200_BM_RAM_ADDR_ADDR,       /* RAM Address */
-+//	XRX200_BM_RAM_CTRL,            /* RAM Access Control Register */
-+//	XRX200_BM_RAM_CTRL_BAS,        /* Access Busy/Access Start */
-+//	XRX200_BM_RAM_CTRL_OPMOD,      /* Lookup Table Access Operation Mode */
-+//	XRX200_BM_RAM_CTRL_ADDR,       /* Address for RAM selection */
-+//	XRX200_BM_FSQM_GCTRL,          /* Free Segment Queue ManagerGlobal Control Register */
-+//	XRX200_BM_FSQM_GCTRL_SEGNUM,   /* Maximum Segment Number */
-+//	XRX200_BM_CONS_SEG,            /* Number of Consumed SegmentsRegister */
-+//	XRX200_BM_CONS_SEG_FSEG,       /* Number of Consumed Segments */
-+//	XRX200_BM_CONS_PKT,            /* Number of Consumed PacketPointers Register */
-+//	XRX200_BM_CONS_PKT_FQP,        /* Number of Consumed Packet Pointers */
-+//	XRX200_BM_GCTRL_F,             /* Buffer Manager Global ControlRegister 0 */
-+//	XRX200_BM_GCTRL_BM_STA,        /* Buffer Manager Initialization Status Bit */
-+//	XRX200_BM_GCTRL_SAT,           /* RMON Counter Update Mode */
-+//	XRX200_BM_GCTRL_FR_RBC,        /* Freeze RMON RX Bad Byte 64 Bit Counter */
-+//	XRX200_BM_GCTRL_FR_RGC,        /* Freeze RMON RX Good Byte 64 Bit Counter */
-+//	XRX200_BM_GCTRL_FR_TGC,        /* Freeze RMON TX Good Byte 64 Bit Counter */
-+//	XRX200_BM_GCTRL_I_FIN,         /* RAM initialization finished */
-+//	XRX200_BM_GCTRL_CX_INI,        /* PQM Context RAM initialization */
-+//	XRX200_BM_GCTRL_FP_INI,        /* FPQM RAM initialization */
-+//	XRX200_BM_GCTRL_FS_INI,        /* FSQM RAM initialization */
-+//	XRX200_BM_GCTRL_R_SRES,        /* Software Reset for RMON */
-+//	XRX200_BM_GCTRL_S_SRES,        /* Software Reset for Scheduler */
-+//	XRX200_BM_GCTRL_A_SRES,        /* Software Reset for AVG */
-+//	XRX200_BM_GCTRL_P_SRES,        /* Software Reset for PQM */
-+//	XRX200_BM_GCTRL_F_SRES,        /* Software Reset for FSQM */
-+//	XRX200_BM_QUEUE_GCTRL,         /* Queue Manager GlobalControl Register 0 */
-+//	XRX200_BM_QUEUE_GCTRL_GL_MOD,  /* WRED Mode Signal */
-+//	XRX200_BM_QUEUE_GCTRL_AQUI,    /* Average Queue Update Interval */
-+//	XRX200_BM_QUEUE_GCTRL_AQWF,    /* Average Queue Weight Factor */
-+//	XRX200_BM_QUEUE_GCTRL_QAVGEN,  /* Queue Average Calculation Enable */
-+//	XRX200_BM_QUEUE_GCTRL_DPROB,   /* Drop Probability Profile */
-+//	XRX200_BM_WRED_RTH_0,          /* WRED Red Threshold Register0 */
-+//	XRX200_BM_WRED_RTH_0_MINTH,    /* Minimum Threshold */
-+//	XRX200_BM_WRED_RTH_1,          /* WRED Red Threshold Register1 */
-+//	XRX200_BM_WRED_RTH_1_MAXTH,    /* Maximum Threshold */
-+//	XRX200_BM_WRED_YTH_0,          /* WRED Yellow ThresholdRegister 0 */
-+//	XRX200_BM_WRED_YTH_0_MINTH,    /* Minimum Threshold */
-+//	XRX200_BM_WRED_YTH_1,          /* WRED Yellow ThresholdRegister 1 */
-+//	XRX200_BM_WRED_YTH_1_MAXTH,    /* Maximum Threshold */
-+//	XRX200_BM_WRED_GTH_0,          /* WRED Green ThresholdRegister 0 */
-+//	XRX200_BM_WRED_GTH_0_MINTH,    /* Minimum Threshold */
-+//	XRX200_BM_WRED_GTH_1,          /* WRED Green ThresholdRegister 1 */
-+//	XRX200_BM_WRED_GTH_1_MAXTH,    /* Maximum Threshold */
-+//	XRX200_BM_DROP_GTH_0_THR,      /* Drop Threshold ConfigurationRegister 0 */
-+//	XRX200_BM_DROP_GTH_0_THR_FQ,   /* Threshold for frames marked red */
-+//	XRX200_BM_DROP_GTH_1_THY,      /* Drop Threshold ConfigurationRegister 1 */
-+//	XRX200_BM_DROP_GTH_1_THY_FQ,   /* Threshold for frames marked yellow */
-+//	XRX200_BM_DROP_GTH_2_THG,      /* Drop Threshold ConfigurationRegister 2 */
-+//	XRX200_BM_DROP_GTH_2_THG_FQ,   /* Threshold for frames marked green */
-+//	XRX200_BM_IER,                 /* Buffer Manager Global InterruptEnable Register */
-+//	XRX200_BM_IER_CNT4,            /* Counter Group 4 (RMON-CLASSIFICATION) Interrupt Enable */
-+//	XRX200_BM_IER_CNT3,            /* Counter Group 3 (RMON-PQM) Interrupt Enable */
-+//	XRX200_BM_IER_CNT2,            /* Counter Group 2 (RMON-SCHEDULER) Interrupt Enable */
-+//	XRX200_BM_IER_CNT1,            /* Counter Group 1 (RMON-QFETCH) Interrupt Enable */
-+//	XRX200_BM_IER_CNT0,            /* Counter Group 0 (RMON-QSTOR) Interrupt Enable */
-+//	XRX200_BM_IER_DEQ,             /* PQM dequeue Interrupt Enable */
-+//	XRX200_BM_IER_ENQ,             /* PQM Enqueue Interrupt Enable */
-+//	XRX200_BM_IER_FSQM,            /* Buffer Empty Interrupt Enable */
-+//	XRX200_BM_ISR,                 /* Buffer Manager Global InterruptStatus Register */
-+//	XRX200_BM_ISR_CNT4,            /* Counter Group 4 Interrupt */
-+//	XRX200_BM_ISR_CNT3,            /* Counter Group 3 Interrupt */
-+//	XRX200_BM_ISR_CNT2,            /* Counter Group 2 Interrupt */
-+//	XRX200_BM_ISR_CNT1,            /* Counter Group 1 Interrupt */
-+//	XRX200_BM_ISR_CNT0,            /* Counter Group 0 Interrupt */
-+//	XRX200_BM_ISR_DEQ,             /* PQM dequeue Interrupt Enable */
-+//	XRX200_BM_ISR_ENQ,             /* PQM Enqueue Interrupt */
-+//	XRX200_BM_ISR_FSQM,            /* Buffer Empty Interrupt */
-+//	XRX200_BM_CISEL,               /* Buffer Manager RMON CounterInterrupt Select Register */
-+//	XRX200_BM_CISEL_PORT,          /* Port Number */
-+//	XRX200_BM_DEBUG_CTRL_DBG,      /* Debug Control Register */
-+//	XRX200_BM_DEBUG_CTRL_DBG_SEL,  /* Select Signal for Debug Multiplexer */
-+//	XRX200_BM_DEBUG_VAL_DBG,       /* Debug Value Register */
-+//	XRX200_BM_DEBUG_VAL_DBG_DAT,   /* Debug Data Value */
-+//	XRX200_BM_PCFG,                /* Buffer Manager PortConfiguration Register */
-+//	XRX200_BM_PCFG_CNTEN,          /* RMON Counter Enable */
-+//	XRX200_BM_RMON_CTRL_RAM1,      /* Buffer ManagerRMON Control Register */
-+//	XRX200_BM_RMON_CTRL_RAM2_RES,  /* Software Reset for RMON RAM2 */
-+//	XRX200_BM_RMON_CTRL_RAM1_RES,  /* Software Reset for RMON RAM1 */
-+//	XRX200_PQM_DP,                 /* Packet Queue ManagerDrop Probability Register */
-+//	XRX200_PQM_DP_DPROB,           /* Drop Probability Profile */
-+//	XRX200_PQM_RS,                 /* Packet Queue ManagerRate Shaper Assignment Register */
-+//	XRX200_PQM_RS_EN2,             /* Rate Shaper 2 Enable */
-+//	XRX200_PQM_RS_RS2,             /* Rate Shaper 2 */
-+//	XRX200_PQM_RS_EN1,             /* Rate Shaper 1 Enable */
-+//	XRX200_PQM_RS_RS1,             /* Rate Shaper 1 */
-+//	XRX200_RS_CTRL,                /* Rate Shaper ControlRegister */
-+//	XRX200_RS_CTRL_RSEN,           /* Rate Shaper Enable */
-+//	XRX200_RS_CBS,                 /* Rate Shaper CommittedBurst Size Register */
-+//	XRX200_RS_CBS_CBS,             /* Committed Burst Size */
-+//	XRX200_RS_IBS,                 /* Rate Shaper InstantaneousBurst Size Register */
-+//	XRX200_RS_IBS_IBS,             /* Instantaneous Burst Size */
-+//	XRX200_RS_CIR_EXP,             /* Rate Shaper RateExponent Register */
-+//	XRX200_RS_CIR_EXP_EXP,         /* Exponent */
-+//	XRX200_RS_CIR_MANT,            /* Rate Shaper RateMantissa Register */
-+//	XRX200_RS_CIR_MANT_MANT,       /* Mantissa */
-+	XRX200_PCE_TBL_KEY_7,          /* Table Key Data 7 */
-+//	XRX200_PCE_TBL_KEY_7_KEY7,     /* Key Value[15:0] */
-+	XRX200_PCE_TBL_KEY_6,          /* Table Key Data 6 */
-+//	XRX200_PCE_TBL_KEY_6_KEY6,     /* Key Value[15:0] */
-+	XRX200_PCE_TBL_KEY_5,          /* Table Key Data 5 */
-+//	XRX200_PCE_TBL_KEY_5_KEY5,     /* Key Value[15:0] */
-+	XRX200_PCE_TBL_KEY_4,          /* Table Key Data 4 */
-+//	XRX200_PCE_TBL_KEY_4_KEY4,     /* Key Value[15:0] */
-+	XRX200_PCE_TBL_KEY_3,          /* Table Key Data 3 */
-+//	XRX200_PCE_TBL_KEY_3_KEY3,     /* Key Value[15:0] */
-+	XRX200_PCE_TBL_KEY_2,          /* Table Key Data 2 */
-+//	XRX200_PCE_TBL_KEY_2_KEY2,     /* Key Value[15:0] */
-+	XRX200_PCE_TBL_KEY_1,          /* Table Key Data 1 */
-+//	XRX200_PCE_TBL_KEY_1_KEY1,     /* Key Value[31:16] */
-+	XRX200_PCE_TBL_KEY_0,          /* Table Key Data 0 */
-+//	XRX200_PCE_TBL_KEY_0_KEY0,     /* Key Value[15:0] */
-+	XRX200_PCE_TBL_MASK_0,         /* Table Mask Write Register0 */
-+//	XRX200_PCE_TBL_MASK_0_MASK0,   /* Mask Pattern [15:0] */
-+	XRX200_PCE_TBL_VAL_4,          /* Table Value Register4 */
-+//	XRX200_PCE_TBL_VAL_4_VAL4,     /* Data value [15:0] */
-+	XRX200_PCE_TBL_VAL_3,          /* Table Value Register3 */
-+//	XRX200_PCE_TBL_VAL_3_VAL3,     /* Data value [15:0] */
-+	XRX200_PCE_TBL_VAL_2,          /* Table Value Register2 */
-+//	XRX200_PCE_TBL_VAL_2_VAL2,     /* Data value [15:0] */
-+	XRX200_PCE_TBL_VAL_1,          /* Table Value Register1 */
-+//	XRX200_PCE_TBL_VAL_1_VAL1,     /* Data value [15:0] */
-+	XRX200_PCE_TBL_VAL_0,          /* Table Value Register0 */
-+//	XRX200_PCE_TBL_VAL_0_VAL0,     /* Data value [15:0] */
-+//	XRX200_PCE_TBL_ADDR,           /* Table Entry AddressRegister */
-+	XRX200_PCE_TBL_ADDR_ADDR,      /* Table Address */
-+//	XRX200_PCE_TBL_CTRL,           /* Table Access ControlRegister */
-+	XRX200_PCE_TBL_CTRL_BAS,       /* Access Busy/Access Start */
-+	XRX200_PCE_TBL_CTRL_TYPE,      /* Lookup Entry Type */
-+	XRX200_PCE_TBL_CTRL_VLD,       /* Lookup Entry Valid */
-+	XRX200_PCE_TBL_CTRL_GMAP,      /* Group Map */
-+	XRX200_PCE_TBL_CTRL_OPMOD,     /* Lookup Table Access Operation Mode */
-+	XRX200_PCE_TBL_CTRL_ADDR,      /* Lookup Table Address */
-+//	XRX200_PCE_TBL_STAT,           /* Table General StatusRegister */
-+//	XRX200_PCE_TBL_STAT_TBUSY,     /* Table Access Busy */
-+//	XRX200_PCE_TBL_STAT_TEMPT,     /* Table Empty */
-+//	XRX200_PCE_TBL_STAT_TFUL,      /* Table Full */
-+//	XRX200_PCE_AGE_0,              /* Aging Counter ConfigurationRegister 0 */
-+//	XRX200_PCE_AGE_0_EXP,          /* Aging Counter Exponent Value  */
-+//	XRX200_PCE_AGE_1,              /* Aging Counter ConfigurationRegister 1 */
-+//	XRX200_PCE_AGE_1_MANT,         /* Aging Counter Mantissa Value  */
-+//	XRX200_PCE_PMAP_1,             /* Port Map Register 1 */
-+//	XRX200_PCE_PMAP_1_MPMAP,       /* Monitoring Port Map */
-+//	XRX200_PCE_PMAP_2,             /* Port Map Register 2 */
-+//	XRX200_PCE_PMAP_2_DMCPMAP,     /* Default Multicast Port Map */
-+//	XRX200_PCE_PMAP_3,             /* Port Map Register 3 */
-+//	XRX200_PCE_PMAP_3_UUCMAP,      /* Default Unknown Unicast Port Map */
-+//	XRX200_PCE_GCTRL_0,            /* PCE Global Control Register0 */
-+//	XRX200_PCE_GCTRL_0_IGMP,       /* IGMP Mode Selection */
-+	XRX200_PCE_GCTRL_0_VLAN,       /* VLAN-aware Switching */
-+//	XRX200_PCE_GCTRL_0_NOPM,       /* No Port Map Forwarding */
-+//	XRX200_PCE_GCTRL_0_SCONUC,     /* Unknown Unicast Storm Control */
-+//	XRX200_PCE_GCTRL_0_SCONMC,     /* Multicast Storm Control */
-+//	XRX200_PCE_GCTRL_0_SCONBC,     /* Broadcast Storm Control */
-+//	XRX200_PCE_GCTRL_0_SCONMOD,    /* Storm Control Mode */
-+//	XRX200_PCE_GCTRL_0_SCONMET,    /* Storm Control Metering Instance */
-+//	XRX200_PCE_GCTRL_0_MC_VALID,   /* Access Request */
-+//	XRX200_PCE_GCTRL_0_PLCKMOD,    /* Port Lock Mode */
-+//	XRX200_PCE_GCTRL_0_PLIMMOD,    /* MAC Address Learning Limitation Mode */
-+//	XRX200_PCE_GCTRL_0_MTFL,       /* MAC Table Flushing */
-+//	XRX200_PCE_GCTRL_1,            /* PCE Global Control Register1 */
-+//	XRX200_PCE_GCTRL_1_PCE_DIS,    /* PCE Disable after currently processed packet */
-+//	XRX200_PCE_GCTRL_1_LRNMOD,     /* MAC Address Learning Mode */
-+//	XRX200_PCE_TCM_GLOB_CTRL,      /* Three-color MarkerGlobal Control Register */
-+//	XRX200_PCE_TCM_GLOB_CTRL_DPRED, /* Re-marking Drop Precedence Red Encoding */
-+//	XRX200_PCE_TCM_GLOB_CTRL_DPYEL, /* Re-marking Drop Precedence Yellow Encoding */
-+//	XRX200_PCE_TCM_GLOB_CTRL_DPGRN, /* Re-marking Drop Precedence Green Encoding */
-+//	XRX200_PCE_IGMP_CTRL,          /* IGMP Control Register */
-+//	XRX200_PCE_IGMP_CTRL_FAGEEN,   /* Force Aging of Table Entries Enable */
-+//	XRX200_PCE_IGMP_CTRL_FLEAVE,   /* Fast Leave Enable */
-+//	XRX200_PCE_IGMP_CTRL_DMRTEN,   /* Default Maximum Response Time Enable */
-+//	XRX200_PCE_IGMP_CTRL_JASUP,    /* Join Aggregation Suppression Enable */
-+//	XRX200_PCE_IGMP_CTRL_REPSUP,   /* Report Suppression Enable */
-+//	XRX200_PCE_IGMP_CTRL_SRPEN,    /* Snooping of Router Port Enable */
-+//	XRX200_PCE_IGMP_CTRL_ROB,      /* Robustness Variable */
-+//	XRX200_PCE_IGMP_CTRL_DMRT,     /* IGMP Default Maximum Response Time */
-+//	XRX200_PCE_IGMP_DRPM,          /* IGMP Default RouterPort Map Register */
-+//	XRX200_PCE_IGMP_DRPM_DRPM,     /* IGMP Default Router Port Map */
-+//	XRX200_PCE_IGMP_AGE_0,         /* IGMP Aging Register0 */
-+//	XRX200_PCE_IGMP_AGE_0_MANT,    /* IGMP Group Aging Time Mantissa */
-+//	XRX200_PCE_IGMP_AGE_0_EXP,     /* IGMP Group Aging Time Exponent */
-+//	XRX200_PCE_IGMP_AGE_1,         /* IGMP Aging Register1 */
-+//	XRX200_PCE_IGMP_AGE_1_MANT,    /* IGMP Router Port Aging Time Mantissa */
-+//	XRX200_PCE_IGMP_STAT,          /* IGMP Status Register */
-+//	XRX200_PCE_IGMP_STAT_IGPM,     /* IGMP Port Map */
-+//	XRX200_WOL_GLB_CTRL,           /* Wake-on-LAN ControlRegister */
-+//	XRX200_WOL_GLB_CTRL_PASSEN,    /* WoL Password Enable */
-+//	XRX200_WOL_DA_0,               /* Wake-on-LAN DestinationAddress Register 0 */
-+//	XRX200_WOL_DA_0_DA0,           /* WoL Destination Address [15:0] */
-+//	XRX200_WOL_DA_1,               /* Wake-on-LAN DestinationAddress Register 1 */
-+//	XRX200_WOL_DA_1_DA1,           /* WoL Destination Address [31:16] */
-+//	XRX200_WOL_DA_2,               /* Wake-on-LAN DestinationAddress Register 2 */
-+//	XRX200_WOL_DA_2_DA2,           /* WoL Destination Address [47:32] */
-+//	XRX200_WOL_PW_0,               /* Wake-on-LAN Password Register0 */
-+//	XRX200_WOL_PW_0_PW0,           /* WoL Password [15:0] */
-+//	XRX200_WOL_PW_1,               /* Wake-on-LAN Password Register1 */
-+//	XRX200_WOL_PW_1_PW1,           /* WoL Password [31:16] */
-+//	XRX200_WOL_PW_2,               /* Wake-on-LAN Password Register2 */
-+//	XRX200_WOL_PW_2_PW2,           /* WoL Password [47:32] */
-+//	XRX200_PCE_IER_0_PINT,         /* Parser and ClassificationEngine Global Interrupt Enable Register 0 */
-+//	XRX200_PCE_IER_0_PINT_15,      /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_14,      /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_13,      /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_12,      /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_11,      /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_10,      /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_9,       /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_8,       /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_7,       /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_6,       /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_5,       /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_4,       /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_3,       /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_2,       /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_1,       /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_0_PINT_0,       /* Port Interrupt Enable */
-+//	XRX200_PCE_IER_1,              /* Parser and ClassificationEngine Global Interrupt Enable Register 1 */
-+//	XRX200_PCE_IER_1_FLOWINT,      /* Traffic Flow Table Interrupt Rule matched Interrupt Enable */
-+//	XRX200_PCE_IER_1_CPH2,         /* Classification Phase 2 Ready Interrupt Enable */
-+//	XRX200_PCE_IER_1_CPH1,         /* Classification Phase 1 Ready Interrupt Enable */
-+//	XRX200_PCE_IER_1_CPH0,         /* Classification Phase 0 Ready Interrupt Enable */
-+//	XRX200_PCE_IER_1_PRDY,         /* Parser Ready Interrupt Enable */
-+//	XRX200_PCE_IER_1_IGTF,         /* IGMP Table Full Interrupt Enable */
-+//	XRX200_PCE_IER_1_MTF,          /* MAC Table Full Interrupt Enable */
-+//	XRX200_PCE_ISR_0_PINT,         /* Parser and ClassificationEngine Global Interrupt Status Register 0 */
-+//	XRX200_PCE_ISR_0_PINT_15,      /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_14,      /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_13,      /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_12,      /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_11,      /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_10,      /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_9,       /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_8,       /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_7,       /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_6,       /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_5,       /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_4,       /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_3,       /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_2,       /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_1,       /* Port Interrupt */
-+//	XRX200_PCE_ISR_0_PINT_0,       /* Port Interrupt */
-+//	XRX200_PCE_ISR_1,              /* Parser and ClassificationEngine Global Interrupt Status Register 1 */
-+//	XRX200_PCE_ISR_1_FLOWINT,      /* Traffic Flow Table Interrupt Rule matched */
-+//	XRX200_PCE_ISR_1_CPH2,         /* Classification Phase 2 Ready Interrupt */
-+//	XRX200_PCE_ISR_1_CPH1,         /* Classification Phase 1 Ready Interrupt */
-+//	XRX200_PCE_ISR_1_CPH0,         /* Classification Phase 0 Ready Interrupt */
-+//	XRX200_PCE_ISR_1_PRDY,         /* Parser Ready Interrupt */
-+//	XRX200_PCE_ISR_1_IGTF,         /* IGMP Table Full Interrupt */
-+//	XRX200_PCE_ISR_1_MTF,          /* MAC Table Full Interrupt */
-+//	XRX200_PARSER_STAT_FIFO,       /* Parser Status Register */
-+//	XRX200_PARSER_STAT_FSM_DAT_CNT, /* Parser FSM Data Counter */
-+//	XRX200_PARSER_STAT_FSM_STATE,  /* Parser FSM State */
-+//	XRX200_PARSER_STAT_PKT_ERR,    /* Packet error detected */
-+//	XRX200_PARSER_STAT_FSM_FIN,    /* Parser FSM finished */
-+//	XRX200_PARSER_STAT_FSM_START,  /* Parser FSM start */
-+//	XRX200_PARSER_STAT_FIFO_RDY,   /* Parser FIFO ready for read. */
-+//	XRX200_PARSER_STAT_FIFO_FULL,  /* Parser */
-+//	XRX200_PCE_PCTRL_0,            /* PCE Port ControlRegister 0 */
-+//	XRX200_PCE_PCTRL_0_MCST,       /* Multicast Forwarding Mode Selection */
-+//	XRX200_PCE_PCTRL_0_EGSTEN,     /* Table-based Egress Special Tag Enable */
-+//	XRX200_PCE_PCTRL_0_IGSTEN,     /* Ingress Special Tag Enable */
-+//	XRX200_PCE_PCTRL_0_PCPEN,      /* PCP Remarking Mode */
-+//	XRX200_PCE_PCTRL_0_CLPEN,      /* Class Remarking Mode */
-+//	XRX200_PCE_PCTRL_0_DPEN,       /* Drop Precedence Remarking Mode */
-+//	XRX200_PCE_PCTRL_0_CMOD,       /* Three-color Marker Color Mode */
-+//	XRX200_PCE_PCTRL_0_VREP,       /* VLAN Replacement Mode */
-+	XRX200_PCE_PCTRL_0_TVM,        /* Transparent VLAN Mode */
-+//	XRX200_PCE_PCTRL_0_PLOCK,      /* Port Locking Enable */
-+//	XRX200_PCE_PCTRL_0_AGEDIS,     /* Aging Disable */
-+//	XRX200_PCE_PCTRL_0_PSTATE,     /* Port State */
-+//	XRX200_PCE_PCTRL_1,            /* PCE Port ControlRegister 1 */
-+//	XRX200_PCE_PCTRL_1_LRNLIM,     /* MAC Address Learning Limit */
-+//	XRX200_PCE_PCTRL_2,            /* PCE Port ControlRegister 2 */
-+//	XRX200_PCE_PCTRL_2_DSCPMOD,    /* DSCP Mode Selection */
-+//	XRX200_PCE_PCTRL_2_DSCP,       /* Enable DSCP to select the Class of Service */
-+//	XRX200_PCE_PCTRL_2_PCP,        /* Enable VLAN PCP to select the Class of Service */
-+//	XRX200_PCE_PCTRL_2_PCLASS,     /* Port-based Traffic Class */
-+//	XRX200_PCE_PCTRL_3_VIO,        /* PCE Port ControlRegister 3 */
-+//	XRX200_PCE_PCTRL_3_EDIR,       /* Egress Redirection Mode */
-+//	XRX200_PCE_PCTRL_3_RXDMIR,     /* Receive Mirroring Enable for dropped frames */
-+//	XRX200_PCE_PCTRL_3_RXVMIR,     /* Receive Mirroring Enable for valid frames */
-+//	XRX200_PCE_PCTRL_3_TXMIR,      /* Transmit Mirroring Enable */
-+//	XRX200_PCE_PCTRL_3_VIO_7,      /* Violation Type 7 Mirroring Enable */
-+//	XRX200_PCE_PCTRL_3_VIO_6,      /* Violation Type 6 Mirroring Enable */
-+//	XRX200_PCE_PCTRL_3_VIO_5,      /* Violation Type 5 Mirroring Enable */
-+//	XRX200_PCE_PCTRL_3_VIO_4,      /* Violation Type 4 Mirroring Enable */
-+//	XRX200_PCE_PCTRL_3_VIO_3,      /* Violation Type 3 Mirroring Enable */
-+//	XRX200_PCE_PCTRL_3_VIO_2,      /* Violation Type 2 Mirroring Enable */
-+//	XRX200_PCE_PCTRL_3_VIO_1,      /* Violation Type 1 Mirroring Enable */
-+//	XRX200_PCE_PCTRL_3_VIO_0,      /* Violation Type 0 Mirroring Enable */
-+//	XRX200_WOL_CTRL,               /* Wake-on-LAN ControlRegister */
-+//	XRX200_WOL_CTRL_PORT,          /* WoL Enable */
-+//	XRX200_PCE_VCTRL,              /* PCE VLAN ControlRegister */
-+	XRX200_PCE_VCTRL_VSR,          /* VLAN Security Rule */
-+	XRX200_PCE_VCTRL_VEMR,         /* VLAN Egress Member Violation Rule */
-+	XRX200_PCE_VCTRL_VIMR,         /* VLAN Ingress Member Violation Rule */
-+	XRX200_PCE_VCTRL_VINR,         /* VLAN Ingress Tag Rule */
-+	XRX200_PCE_VCTRL_UVR,          /* Unknown VLAN Rule */
-+//	XRX200_PCE_DEFPVID,            /* PCE Default PortVID Register */
-+	XRX200_PCE_DEFPVID_PVID,       /* Default Port VID Index */
-+//	XRX200_PCE_PSTAT,              /* PCE Port StatusRegister */
-+//	XRX200_PCE_PSTAT_LRNCNT,       /* Learning Count */
-+//	XRX200_PCE_PIER,               /* Parser and ClassificationEngine Port Interrupt Enable Register */
-+//	XRX200_PCE_PIER_CLDRP,         /* Classification Drop Interrupt Enable */
-+//	XRX200_PCE_PIER_PTDRP,         /* Port Drop Interrupt Enable */
-+//	XRX200_PCE_PIER_VLAN,          /* VLAN Violation Interrupt Enable */
-+//	XRX200_PCE_PIER_WOL,           /* Wake-on-LAN Interrupt Enable */
-+//	XRX200_PCE_PIER_LOCK,          /* Port Limit Alert Interrupt Enable */
-+//	XRX200_PCE_PIER_LIM,           /* Port Lock Alert Interrupt Enable */
-+//	XRX200_PCE_PISR,               /* Parser and ClassificationEngine Port Interrupt Status Register */
-+//	XRX200_PCE_PISR_CLDRP,         /* Classification Drop Interrupt */
-+//	XRX200_PCE_PISR_PTDRP,         /* Port Drop Interrupt */
-+//	XRX200_PCE_PISR_VLAN,          /* VLAN Violation Interrupt */
-+//	XRX200_PCE_PISR_WOL,           /* Wake-on-LAN Interrupt */
-+//	XRX200_PCE_PISR_LOCK,          /* Port Lock Alert Interrupt */
-+//	XRX200_PCE_PISR_LIMIT,         /* Port Limitation Alert Interrupt */
-+//	XRX200_PCE_TCM_CTRL,           /* Three-colorMarker Control Register */
-+//	XRX200_PCE_TCM_CTRL_TCMEN,     /* Three-color Marker metering instance enable */
-+//	XRX200_PCE_TCM_STAT,           /* Three-colorMarker Status Register */
-+//	XRX200_PCE_TCM_STAT_AL1,       /* Three-color Marker Alert 1 Status */
-+//	XRX200_PCE_TCM_STAT_AL0,       /* Three-color Marker Alert 0 Status */
-+//	XRX200_PCE_TCM_CBS,            /* Three-color MarkerCommitted Burst Size Register */
-+//	XRX200_PCE_TCM_CBS_CBS,        /* Committed Burst Size */
-+//	XRX200_PCE_TCM_EBS,            /* Three-color MarkerExcess Burst Size Register */
-+//	XRX200_PCE_TCM_EBS_EBS,        /* Excess Burst Size */
-+//	XRX200_PCE_TCM_IBS,            /* Three-color MarkerInstantaneous Burst Size Register */
-+//	XRX200_PCE_TCM_IBS_IBS,        /* Instantaneous Burst Size */
-+//	XRX200_PCE_TCM_CIR_MANT,       /* Three-colorMarker Constant Information Rate Mantissa Register */
-+//	XRX200_PCE_TCM_CIR_MANT_MANT,  /* Rate Counter Mantissa */
-+//	XRX200_PCE_TCM_CIR_EXP,        /* Three-colorMarker Constant Information Rate Exponent Register */
-+//	XRX200_PCE_TCM_CIR_EXP_EXP,    /* Rate Counter Exponent */
-+//	XRX200_MAC_TEST,               /* MAC Test Register */
-+//	XRX200_MAC_TEST_JTP,           /* Jitter Test Pattern */
-+//	XRX200_MAC_PFAD_CFG,           /* MAC Pause FrameSource Address Configuration Register */
-+//	XRX200_MAC_PFAD_CFG_SAMOD,     /* Source Address Mode */
-+//	XRX200_MAC_PFSA_0,             /* Pause Frame SourceAddress Part 0  */
-+//	XRX200_MAC_PFSA_0_PFAD,        /* Pause Frame Source Address Part 0 */
-+//	XRX200_MAC_PFSA_1,             /* Pause Frame SourceAddress Part 1  */
-+//	XRX200_MAC_PFSA_1_PFAD,        /* Pause Frame Source Address Part 1 */
-+//	XRX200_MAC_PFSA_2,             /* Pause Frame SourceAddress Part 2  */
-+//	XRX200_MAC_PFSA_2_PFAD,        /* Pause Frame Source Address Part 2 */
-+//	XRX200_MAC_FLEN,               /* MAC Frame Length Register */
-+//	XRX200_MAC_FLEN_LEN,           /* Maximum Frame Length */
-+//	XRX200_MAC_VLAN_ETYPE_0,       /* MAC VLAN EthertypeRegister 0 */
-+//	XRX200_MAC_VLAN_ETYPE_0_OUTER, /* Ethertype */
-+//	XRX200_MAC_VLAN_ETYPE_1,       /* MAC VLAN EthertypeRegister 1 */
-+//	XRX200_MAC_VLAN_ETYPE_1_INNER, /* Ethertype */
-+//	XRX200_MAC_IER,                /* MAC Interrupt EnableRegister */
-+//	XRX200_MAC_IER_MACIEN,         /* MAC Interrupt Enable */
-+//	XRX200_MAC_ISR,                /* MAC Interrupt StatusRegister */
-+//	XRX200_MAC_ISR_MACINT,         /* MAC Interrupt */
-+//	XRX200_MAC_PSTAT,              /* MAC Port Status Register */
-+//	XRX200_MAC_PSTAT_PACT,         /* PHY Active Status */
-+	XRX200_MAC_PSTAT_GBIT,         /* Gigabit Speed Status */
-+	XRX200_MAC_PSTAT_MBIT,         /* Megabit Speed Status */
-+	XRX200_MAC_PSTAT_FDUP,         /* Full Duplex Status */
-+//	XRX200_MAC_PSTAT_RXPAU,        /* Receive Pause Status */
-+//	XRX200_MAC_PSTAT_TXPAU,        /* Transmit Pause Status */
-+//	XRX200_MAC_PSTAT_RXPAUEN,      /* Receive Pause Enable Status */
-+//	XRX200_MAC_PSTAT_TXPAUEN,      /* Transmit Pause Enable Status */
-+	XRX200_MAC_PSTAT_LSTAT,        /* Link Status */
-+//	XRX200_MAC_PSTAT_CRS,          /* Carrier Sense Status */
-+//	XRX200_MAC_PSTAT_TXLPI,        /* Transmit Low-power Idle Status */
-+//	XRX200_MAC_PSTAT_RXLPI,        /* Receive Low-power Idle Status */
-+//	XRX200_MAC_PISR,               /* MAC Interrupt Status Register */
-+//	XRX200_MAC_PISR_PACT,          /* PHY Active Status */
-+//	XRX200_MAC_PISR_SPEED,         /* Megabit Speed Status */
-+//	XRX200_MAC_PISR_FDUP,          /* Full Duplex Status */
-+//	XRX200_MAC_PISR_RXPAUEN,       /* Receive Pause Enable Status */
-+//	XRX200_MAC_PISR_TXPAUEN,       /* Transmit Pause Enable Status */
-+//	XRX200_MAC_PISR_LPIOFF,        /* Receive Low-power Idle Mode is left */
-+//	XRX200_MAC_PISR_LPION,         /* Receive Low-power Idle Mode is entered */
-+//	XRX200_MAC_PISR_JAM,           /* Jam Status Detected */
-+//	XRX200_MAC_PISR_TOOSHORT,      /* Too Short Frame Error Detected */
-+//	XRX200_MAC_PISR_TOOLONG,       /* Too Long Frame Error Detected */
-+//	XRX200_MAC_PISR_LENERR,        /* Length Mismatch Error Detected */
-+//	XRX200_MAC_PISR_FCSERR,        /* Frame Checksum Error Detected */
-+//	XRX200_MAC_PISR_TXPAUSE,       /* Pause Frame Transmitted */
-+//	XRX200_MAC_PISR_RXPAUSE,       /* Pause Frame Received */
-+//	XRX200_MAC_PIER,               /* MAC Interrupt Enable Register */
-+//	XRX200_MAC_PIER_PACT,          /* PHY Active Status */
-+//	XRX200_MAC_PIER_SPEED,         /* Megabit Speed Status */
-+//	XRX200_MAC_PIER_FDUP,          /* Full Duplex Status */
-+//	XRX200_MAC_PIER_RXPAUEN,       /* Receive Pause Enable Status */
-+//	XRX200_MAC_PIER_TXPAUEN,       /* Transmit Pause Enable Status */
-+//	XRX200_MAC_PIER_LPIOFF,        /* Low-power Idle Off Interrupt Mask */
-+//	XRX200_MAC_PIER_LPION,         /* Low-power Idle On Interrupt Mask */
-+//	XRX200_MAC_PIER_JAM,           /* Jam Status Interrupt Mask */
-+//	XRX200_MAC_PIER_TOOSHORT,      /* Too Short Frame Error Interrupt Mask */
-+//	XRX200_MAC_PIER_TOOLONG,       /* Too Long Frame Error Interrupt Mask */
-+//	XRX200_MAC_PIER_LENERR,        /* Length Mismatch Error Interrupt Mask */
-+//	XRX200_MAC_PIER_FCSERR,        /* Frame Checksum Error Interrupt Mask */
-+//	XRX200_MAC_PIER_TXPAUSE,       /* Transmit Pause Frame Interrupt Mask */
-+//	XRX200_MAC_PIER_RXPAUSE,       /* Receive Pause Frame Interrupt Mask */
-+//	XRX200_MAC_CTRL_0,             /* MAC Control Register0 */
-+//	XRX200_MAC_CTRL_0_LCOL,        /* Late Collision Control */
-+//	XRX200_MAC_CTRL_0_BM,          /* Burst Mode Control */
-+//	XRX200_MAC_CTRL_0_APADEN,      /* Automatic VLAN Padding Enable */
-+//	XRX200_MAC_CTRL_0_VPAD2EN,     /* Stacked VLAN Padding Enable */
-+//	XRX200_MAC_CTRL_0_VPADEN,      /* VLAN Padding Enable */
-+//	XRX200_MAC_CTRL_0_PADEN,       /* Padding Enable */
-+//	XRX200_MAC_CTRL_0_FCS,         /* Transmit FCS Control */
-+	XRX200_MAC_CTRL_0_FCON,        /* Flow Control Mode */
-+//	XRX200_MAC_CTRL_0_FDUP,        /* Full Duplex Control */
-+//	XRX200_MAC_CTRL_0_GMII,        /* GMII/MII interface mode selection */
-+//	XRX200_MAC_CTRL_1,             /* MAC Control Register1 */
-+//	XRX200_MAC_CTRL_1_SHORTPRE,    /* Short Preamble Control */
-+//	XRX200_MAC_CTRL_1_IPG,         /* Minimum Inter Packet Gap Size */
-+//	XRX200_MAC_CTRL_2,             /* MAC Control Register2 */
-+//	XRX200_MAC_CTRL_2_MLEN,        /* Maximum Untagged Frame Length */
-+//	XRX200_MAC_CTRL_2_LCHKL,       /* Frame Length Check Long Enable */
-+//	XRX200_MAC_CTRL_2_LCHKS,       /* Frame Length Check Short Enable */
-+//	XRX200_MAC_CTRL_3,             /* MAC Control Register3 */
-+//	XRX200_MAC_CTRL_3_RCNT,        /* Retry Count */
-+//	XRX200_MAC_CTRL_4,             /* MAC Control Register4 */
-+//	XRX200_MAC_CTRL_4_LPIEN,       /* LPI Mode Enable */
-+//	XRX200_MAC_CTRL_4_WAIT,        /* LPI Wait Time */
-+//	XRX200_MAC_CTRL_5_PJPS,        /* MAC Control Register5 */
-+//	XRX200_MAC_CTRL_5_PJPS_NOBP,   /* Prolonged Jam pattern size during no-backpressure state */
-+//	XRX200_MAC_CTRL_5_PJPS_BP,     /* Prolonged Jam pattern size during backpressure state */
-+//	XRX200_MAC_CTRL_6_XBUF,        /* Transmit and ReceiveBuffer Control Register */
-+//	XRX200_MAC_CTRL_6_RBUF_DLY_WP, /* Delay */
-+//	XRX200_MAC_CTRL_6_RBUF_INIT,   /* Receive Buffer Initialization */
-+//	XRX200_MAC_CTRL_6_RBUF_BYPASS, /* Bypass the Receive Buffer */
-+//	XRX200_MAC_CTRL_6_XBUF_DLY_WP, /* Delay */
-+//	XRX200_MAC_CTRL_6_XBUF_INIT,   /* Initialize the Transmit Buffer */
-+//	XRX200_MAC_CTRL_6_XBUF_BYPASS, /* Bypass the Transmit Buffer */
-+//	XRX200_MAC_BUFST_XBUF,         /* MAC Receive and TransmitBuffer Status Register */
-+//	XRX200_MAC_BUFST_RBUF_UFL,     /* Receive Buffer Underflow Indicator */
-+//	XRX200_MAC_BUFST_RBUF_OFL,     /* Receive Buffer Overflow Indicator */
-+//	XRX200_MAC_BUFST_XBUF_UFL,     /* Transmit Buffer Underflow Indicator */
-+//	XRX200_MAC_BUFST_XBUF_OFL,     /* Transmit Buffer Overflow Indicator */
-+//	XRX200_MAC_TESTEN,             /* MAC Test Enable Register */
-+//	XRX200_MAC_TESTEN_JTEN,        /* Jitter Test Enable */
-+//	XRX200_MAC_TESTEN_TXER,        /* Transmit Error Insertion */
-+//	XRX200_MAC_TESTEN_LOOP,        /* MAC Loopback Enable */
-+//	XRX200_FDMA_CTRL,              /* Ethernet Switch FetchDMA Control Register */
-+//	XRX200_FDMA_CTRL_LPI_THRESHOLD, /* Low Power Idle Threshold */
-+//	XRX200_FDMA_CTRL_LPI_MODE,     /* Low Power Idle Mode */
-+//	XRX200_FDMA_CTRL_EGSTAG,       /* Egress Special Tag Size */
-+//	XRX200_FDMA_CTRL_IGSTAG,       /* Ingress Special Tag Size */
-+//	XRX200_FDMA_CTRL_EXCOL,        /* Excessive Collision Handling */
-+//	XRX200_FDMA_STETYPE,           /* Special Tag EthertypeControl Register */
-+//	XRX200_FDMA_STETYPE_ETYPE,     /* Special Tag Ethertype */
-+//	XRX200_FDMA_VTETYPE,           /* VLAN Tag EthertypeControl Register */
-+//	XRX200_FDMA_VTETYPE_ETYPE,     /* VLAN Tag Ethertype */
-+//	XRX200_FDMA_STAT_0,            /* FDMA Status Register0 */
-+//	XRX200_FDMA_STAT_0_FSMS,       /* FSM states status */
-+//	XRX200_FDMA_IER,               /* Fetch DMA Global InterruptEnable Register */
-+//	XRX200_FDMA_IER_PCKD,          /* Packet Drop Interrupt Enable */
-+//	XRX200_FDMA_IER_PCKR,          /* Packet Ready Interrupt Enable */
-+//	XRX200_FDMA_IER_PCKT,          /* Packet Sent Interrupt Enable */
-+//	XRX200_FDMA_ISR,               /* Fetch DMA Global InterruptStatus Register */
-+//	XRX200_FDMA_ISR_PCKTD,         /* Packet Drop */
-+//	XRX200_FDMA_ISR_PCKR,          /* Packet is Ready for Transmission */
-+//	XRX200_FDMA_ISR_PCKT,          /* Packet Sent Event */
-+//	XRX200_FDMA_PCTRL,             /* Ethernet SwitchFetch DMA Port Control Register */
-+//	XRX200_FDMA_PCTRL_VLANMOD,     /* VLAN Modification Enable */
-+//	XRX200_FDMA_PCTRL_DSCPRM,      /* DSCP Re-marking Enable */
-+//	XRX200_FDMA_PCTRL_STEN,        /* Special Tag Insertion Enable */
-+//	XRX200_FDMA_PCTRL_EN,          /* FDMA Port Enable */
-+//	XRX200_FDMA_PRIO,              /* Ethernet SwitchFetch DMA Port Priority Register */
-+//	XRX200_FDMA_PRIO_PRIO,         /* FDMA PRIO */
-+//	XRX200_FDMA_PSTAT0,            /* Ethernet SwitchFetch DMA Port Status Register 0 */
-+//	XRX200_FDMA_PSTAT0_PKT_AVAIL,  /* Port Egress Packet Available */
-+//	XRX200_FDMA_PSTAT0_POK,        /* Port Status OK */
-+//	XRX200_FDMA_PSTAT0_PSEG,       /* Port Egress Segment Count */
-+//	XRX200_FDMA_PSTAT1_HDR,        /* Ethernet SwitchFetch DMA Port Status Register 1 */
-+//	XRX200_FDMA_PSTAT1_HDR_PTR,    /* Header Pointer */
-+//	XRX200_FDMA_TSTAMP0,           /* Egress TimeStamp Register 0 */
-+//	XRX200_FDMA_TSTAMP0_TSTL,      /* Time Stamp [15:0] */
-+//	XRX200_FDMA_TSTAMP1,           /* Egress TimeStamp Register 1 */
-+//	XRX200_FDMA_TSTAMP1_TSTH,      /* Time Stamp [31:16] */
-+//	XRX200_SDMA_CTRL,              /* Ethernet Switch StoreDMA Control Register */
-+//	XRX200_SDMA_CTRL_TSTEN,        /* Time Stamp Enable */
-+//	XRX200_SDMA_FCTHR1,            /* SDMA Flow Control Threshold1 Register */
-+//	XRX200_SDMA_FCTHR1_THR1,       /* Threshold 1 */
-+//	XRX200_SDMA_FCTHR2,            /* SDMA Flow Control Threshold2 Register */
-+//	XRX200_SDMA_FCTHR2_THR2,       /* Threshold 2 */
-+//	XRX200_SDMA_FCTHR3,            /* SDMA Flow Control Threshold3 Register */
-+//	XRX200_SDMA_FCTHR3_THR3,       /* Threshold 3 */
-+//	XRX200_SDMA_FCTHR4,            /* SDMA Flow Control Threshold4 Register */
-+//	XRX200_SDMA_FCTHR4_THR4,       /* Threshold 4 */
-+//	XRX200_SDMA_FCTHR5,            /* SDMA Flow Control Threshold5 Register */
-+//	XRX200_SDMA_FCTHR5_THR5,       /* Threshold 5 */
-+//	XRX200_SDMA_FCTHR6,            /* SDMA Flow Control Threshold6 Register */
-+//	XRX200_SDMA_FCTHR6_THR6,       /* Threshold 6 */
-+//	XRX200_SDMA_FCTHR7,            /* SDMA Flow Control Threshold7 Register */
-+//	XRX200_SDMA_FCTHR7_THR7,       /* Threshold 7 */
-+//	XRX200_SDMA_STAT_0,            /* SDMA Status Register0 */
-+//	XRX200_SDMA_STAT_0_BPS_FILL,   /* Back Pressure Status */
-+//	XRX200_SDMA_STAT_0_BPS_PNT,    /* Back Pressure Status */
-+//	XRX200_SDMA_STAT_0_DROP,       /* Back Pressure Status */
-+//	XRX200_SDMA_STAT_1,            /* SDMA Status Register1 */
-+//	XRX200_SDMA_STAT_1_FILL,       /* Buffer Filling Level */
-+//	XRX200_SDMA_STAT_2,            /* SDMA Status Register2 */
-+//	XRX200_SDMA_STAT_2_FSMS,       /* FSM states status */
-+//	XRX200_SDMA_IER,               /* SDMA Interrupt Enable Register */
-+//	XRX200_SDMA_IER_BPEX,          /* Buffer Pointers Exceeded */
-+//	XRX200_SDMA_IER_BFULL,         /* Buffer Full */
-+//	XRX200_SDMA_IER_FERR,          /* Frame Error */
-+//	XRX200_SDMA_IER_FRX,           /* Frame Received Successfully */
-+//	XRX200_SDMA_ISR,               /* SDMA Interrupt Status Register */
-+//	XRX200_SDMA_ISR_BPEX,          /* Packet Descriptors Exceeded */
-+//	XRX200_SDMA_ISR_BFULL,         /* Buffer Full */
-+//	XRX200_SDMA_ISR_FERR,          /* Frame Error */
-+//	XRX200_SDMA_ISR_FRX,           /* Frame Received Successfully */
-+//	XRX200_SDMA_PCTRL,             /* Ethernet SwitchStore DMA Port Control Register */
-+//	XRX200_SDMA_PCTRL_DTHR,        /* Drop Threshold Selection */
-+//	XRX200_SDMA_PCTRL_PTHR,        /* Pause Threshold Selection */
-+//	XRX200_SDMA_PCTRL_PHYEFWD,     /* Forward PHY Error Frames */
-+//	XRX200_SDMA_PCTRL_ALGFWD,      /* Forward Alignment Error Frames */
-+//	XRX200_SDMA_PCTRL_LENFWD,      /* Forward Length Errored Frames */
-+//	XRX200_SDMA_PCTRL_OSFWD,       /* Forward Oversized Frames */
-+//	XRX200_SDMA_PCTRL_USFWD,       /* Forward Undersized Frames */
-+//	XRX200_SDMA_PCTRL_FCSIGN,      /* Ignore FCS Errors */
-+//	XRX200_SDMA_PCTRL_FCSFWD,      /* Forward FCS Errored Frames */
-+//	XRX200_SDMA_PCTRL_PAUFWD,      /* Pause Frame Forwarding */
-+//	XRX200_SDMA_PCTRL_MFCEN,       /* Metering Flow Control Enable */
-+//	XRX200_SDMA_PCTRL_FCEN,        /* Flow Control Enable */
-+//	XRX200_SDMA_PCTRL_PEN,         /* Port Enable */
-+//	XRX200_SDMA_PRIO,              /* Ethernet SwitchStore DMA Port Priority Register */
-+//	XRX200_SDMA_PRIO_PRIO,         /* SDMA PRIO */
-+//	XRX200_SDMA_PSTAT0_HDR,        /* Ethernet SwitchStore DMA Port Status Register 0 */
-+//	XRX200_SDMA_PSTAT0_HDR_PTR,    /* Port Ingress Queue Header Pointer */
-+//	XRX200_SDMA_PSTAT1,            /* Ethernet SwitchStore DMA Port Status Register 1 */
-+//	XRX200_SDMA_PSTAT1_PPKT,       /* Port Ingress Packet Count */
-+//	XRX200_SDMA_TSTAMP0,           /* Ingress TimeStamp Register 0 */
-+//	XRX200_SDMA_TSTAMP0_TSTL,      /* Time Stamp [15:0] */
-+//	XRX200_SDMA_TSTAMP1,           /* Ingress TimeStamp Register 1 */
-+//	XRX200_SDMA_TSTAMP1_TSTH,      /* Time Stamp [31:16] */
-+};
-+
-+
-+struct xrx200sw_reg {
-+	int offset;
-+	int shift;
-+	int size;
-+	int mult;
-+} xrx200sw_reg[] = {
-+//	offeset	     shift    size	mult
-+//	{0x0000,	 0,	16,	0x00}, /* XRX200_ETHSW_SWRES             Ethernet Switch ResetControl Register */
-+//	{0x0000,	 1,	 1,	0x00}, /* XRX200_ETHSW_SWRES_R1          Hardware Reset */
-+//	{0x0000,	 0,	 1,	0x00}, /* XRX200_ETHSW_SWRES_R0          Register Configuration */
-+//	{0x0004,	 0,	16,	0x00}, /* XRX200_ETHSW_CLK_MAC_GAT       Ethernet Switch Clock ControlRegister  */
-+//	{0x0004,	12,	 4,	0x00}, /* XRX200_ETHSW_CLK_EXP_SLEEP     Exponent to put system into sleep */
-+//	{0x0004,	 8,	 4,	0x00}, /* XRX200_ETHSW_CLK_EXP_WAKE      Exponent to wake up system */
-+//	{0x0004,	 7,	 1,	0x00}, /* XRX200_ETHSW_CLK_CLK2_EN       CLK2 Input for MAC */
-+//	{0x0004,	 6,	 1,	0x00}, /* XRX200_ETHSW_CLK_EXT_DIV_EN    External Clock Divider Enable */
-+//	{0x0004,	 5,	 1,	0x00}, /* XRX200_ETHSW_CLK_RAM_DBG_EN    Clock Gating Enable */
-+//	{0x0004,	 4,	 1,	0x00}, /* XRX200_ETHSW_CLK_REG_GAT_EN    Clock Gating Enable */
-+//	{0x0004,	 3,	 1,	0x00}, /* XRX200_ETHSW_CLK_GAT_EN        Clock Gating Enable */
-+//	{0x0004,	 2,	 1,	0x00}, /* XRX200_ETHSW_CLK_MAC_GAT_EN    Clock Gating Enable */
-+//	{0x0008,	 0,	16,	0x00}, /* XRX200_ETHSW_DBG_STEP          Ethernet Switch Debug ControlRegister */
-+//	{0x0008,	12,	 4,	0x00}, /* XRX200_ETHSW_DBG_CLK_SEL       Trigger Enable */
-+//	{0x0008,	11,	 1,	0x00}, /* XRX200_ETHSW_DBG_MON_EN        Monitoring Enable */
-+//	{0x0008,	 9,	 2,	0x00}, /* XRX200_ETHSW_DBG_TRIG_EN       Trigger Enable */
-+//	{0x0008,	 8,	 1,	0x00}, /* XRX200_ETHSW_DBG_MODE          Debug Mode */
-+//	{0x0008,	 0,	 8,	0x00}, /* XRX200_ETHSW_DBG_STEP_TIME     Clock Step Size */
-+//	{0x000C,	 0,	16,	0x00}, /* XRX200_ETHSW_SSB_MODE          Ethernet Switch SharedSegment Buffer Mode Register */
-+//	{0x000C,	 2,	 4,	0x00}, /* XRX200_ETHSW_SSB_MODE_ADDE     Memory Address */
-+//	{0x000C,	 0,	 2,	0x00}, /* XRX200_ETHSW_SSB_MODE_MODE     Memory Access Mode */
-+//	{0x0010,	 0,	16,	0x00}, /* XRX200_ETHSW_SSB_ADDR          Ethernet Switch SharedSegment Buffer Address Register */
-+//	{0x0010,	 0,	16,	0x00}, /* XRX200_ETHSW_SSB_ADDR_ADDE     Memory Address */
-+//	{0x0014,	 0,	16,	0x00}, /* XRX200_ETHSW_SSB_DATA          Ethernet Switch SharedSegment Buffer Data Register */
-+//	{0x0014,	 0,	16,	0x00}, /* XRX200_ETHSW_SSB_DATA_DATA     Data Value */
-+//	{0x0018,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_0             Ethernet Switch CapabilityRegister 0 */
-+//	{0x0018,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_0_SPEED       Clock frequency */
-+//	{0x001C,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_1             Ethernet Switch CapabilityRegister 1 */
-+//	{0x001C,	15,	 1,	0x00}, /* XRX200_ETHSW_CAP_1_GMAC        MAC operation mode */
-+//	{0x001C,	 8,	 7,	0x00}, /* XRX200_ETHSW_CAP_1_QUEUE       Number of queues */
-+//	{0x001C,	 4,	 4,	0x00}, /* XRX200_ETHSW_CAP_1_VPORTS      Number of virtual ports */
-+//	{0x001C,	 0,	 4,	0x00}, /* XRX200_ETHSW_CAP_1_PPORTS      Number of physical ports */
-+//	{0x0020,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_2             Ethernet Switch CapabilityRegister 2 */
-+//	{0x0020,	 0,	11,	0x00}, /* XRX200_ETHSW_CAP_2_PACKETS     Number of packets */
-+//	{0x0024,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_3             Ethernet Switch CapabilityRegister 3 */
-+//	{0x0024,	 8,	 8,	0x00}, /* XRX200_ETHSW_CAP_3_METERS      Number of traffic meters */
-+//	{0x0024,	 0,	 8,	0x00}, /* XRX200_ETHSW_CAP_3_SHAPERS     Number of traffic shapers */
-+//	{0x0028,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_4             Ethernet Switch CapabilityRegister 4 */
-+//	{0x0028,	 8,	 8,	0x00}, /* XRX200_ETHSW_CAP_4_PPPOE       PPPoE table size */
-+//	{0x0028,	 0,	 8,	0x00}, /* XRX200_ETHSW_CAP_4_VLAN        Active VLAN table size */
-+//	{0x002C,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_5             Ethernet Switch CapabilityRegister 5 */
-+//	{0x002C,	 8,	 8,	0x00}, /* XRX200_ETHSW_CAP_5_IPPLEN      IP packet length table size */
-+//	{0x002C,	 0,	 8,	0x00}, /* XRX200_ETHSW_CAP_5_PROT        Protocol table size */
-+//	{0x0030,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_6             Ethernet Switch CapabilityRegister 6 */
-+//	{0x0030,	 8,	 8,	0x00}, /* XRX200_ETHSW_CAP_6_MACDASA     MAC DA/SA table size */
-+//	{0x0030,	 0,	 8,	0x00}, /* XRX200_ETHSW_CAP_6_APPL        Application table size */
-+//	{0x0034,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_7             Ethernet Switch CapabilityRegister 7 */
-+//	{0x0034,	 8,	 8,	0x00}, /* XRX200_ETHSW_CAP_7_IPDASAM     IP DA/SA MSB table size */
-+//	{0x0034,	 0,	 8,	0x00}, /* XRX200_ETHSW_CAP_7_IPDASAL     IP DA/SA LSB table size */
-+//	{0x0038,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_8             Ethernet Switch CapabilityRegister 8 */
-+//	{0x0038,	 0,	 8,	0x00}, /* XRX200_ETHSW_CAP_8_MCAST       Multicast table size */
-+//	{0x003C,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_9             Ethernet Switch CapabilityRegister 9 */
-+//	{0x003C,	 0,	 8,	0x00}, /* XRX200_ETHSW_CAP_9_FLAGG       Flow Aggregation table size */
-+//	{0x0040,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_10            Ethernet Switch CapabilityRegister 10 */
-+//	{0x0040,	 0,	13,	0x00}, /* XRX200_ETHSW_CAP_10_MACBT      MAC bridging table size */
-+//	{0x0044,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_11            Ethernet Switch CapabilityRegister 11 */
-+//	{0x0044,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_11_BSIZEL     Packet buffer size (lower part, in byte) */
-+//	{0x0048,	 0,	16,	0x00}, /* XRX200_ETHSW_CAP_12            Ethernet Switch CapabilityRegister 12 */
-+//	{0x0048,	 0,	 3,	0x00}, /* XRX200_ETHSW_CAP_12_BSIZEH     Packet buffer size (higher part, in byte) */
-+//	{0x004C,	 0,	16,	0x00}, /* XRX200_ETHSW_VERSION_REV       Ethernet Switch VersionRegister */
-+//	{0x004C,	 8,	 8,	0x00}, /* XRX200_ETHSW_VERSION_MOD_ID    Module Identification */
-+//	{0x004C,	 0,	 8,	0x00}, /* XRX200_ETHSW_VERSION_REV_ID    Hardware Revision Identification */
-+//	{0x0050,	 0,	16,	0x00}, /* XRX200_ETHSW_IER               Interrupt Enable Register */
-+//	{0x0050,	 4,	 1,	0x00}, /* XRX200_ETHSW_IER_FDMAIE        Fetch DMA Interrupt Enable */
-+//	{0x0050,	 3,	 1,	0x00}, /* XRX200_ETHSW_IER_SDMAIE        Store DMA Interrupt Enable */
-+//	{0x0050,	 2,	 1,	0x00}, /* XRX200_ETHSW_IER_MACIE         Ethernet MAC Interrupt Enable */
-+//	{0x0050,	 1,	 1,	0x00}, /* XRX200_ETHSW_IER_PCEIE         Parser and Classification Engine Interrupt Enable */
-+//	{0x0050,	 0,	 1,	0x00}, /* XRX200_ETHSW_IER_BMIE          Buffer Manager Interrupt Enable */
-+//	{0x0054,	 0,	16,	0x00}, /* XRX200_ETHSW_ISR               Interrupt Status Register */
-+//	{0x0054,	 4,	 1,	0x00}, /* XRX200_ETHSW_ISR_FDMAINT       Fetch DMA Interrupt */
-+//	{0x0054,	 3,	 1,	0x00}, /* XRX200_ETHSW_ISR_SDMAINT       Store DMA Interrupt */
-+//	{0x0054,	 2,	 1,	0x00}, /* XRX200_ETHSW_ISR_MACINT        Ethernet MAC Interrupt */
-+//	{0x0054,	 1,	 1,	0x00}, /* XRX200_ETHSW_ISR_PCEINT        Parser and Classification Engine Interrupt */
-+//	{0x0054,	 0,	 1,	0x00}, /* XRX200_ETHSW_ISR_BMINT         Buffer Manager Interrupt */
-+//	{0x0058,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_0           Ethernet Switch SpareCells 0 */
-+//	{0x0058,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_0_SPARE     SPARE0  */
-+//	{0x005C,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_1           Ethernet Switch SpareCells 1 */
-+//	{0x005C,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_1_SPARE     SPARE1  */
-+//	{0x0060,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_2           Ethernet Switch SpareCells 2 */
-+//	{0x0060,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_2_SPARE     SPARE2  */
-+//	{0x0064,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_3           Ethernet Switch SpareCells 3 */
-+//	{0x0064,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_3_SPARE     SPARE3  */
-+//	{0x0068,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_4           Ethernet Switch SpareCells 4 */
-+//	{0x0068,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_4_SPARE     SPARE4  */
-+//	{0x006C,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_5           Ethernet Switch SpareCells 5 */
-+//	{0x006C,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_5_SPARE     SPARE5  */
-+//	{0x0070,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_6           Ethernet Switch SpareCells 6 */
-+//	{0x0070,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_6_SPARE     SPARE6  */
-+//	{0x0074,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_7           Ethernet Switch SpareCells 7 */
-+//	{0x0074,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_7_SPARE     SPARE7  */
-+//	{0x0078,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_8           Ethernet Switch SpareCells 8 */
-+//	{0x0078,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_8_SPARE     SPARE8  */
-+//	{0x007C,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_9           Ethernet Switch SpareCells 9 */
-+//	{0x007C,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_9_SPARE     SPARE9  */
-+//	{0x0080,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_10          Ethernet Switch SpareCells 10 */
-+//	{0x0080,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_10_SPARE    SPARE10  */
-+//	{0x0084,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_11          Ethernet Switch SpareCells 11 */
-+//	{0x0084,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_11_SPARE    SPARE11  */
-+//	{0x0088,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_12          Ethernet Switch SpareCells 12 */
-+//	{0x0088,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_12_SPARE    SPARE12  */
-+//	{0x008C,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_13          Ethernet Switch SpareCells 13 */
-+//	{0x008C,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_13_SPARE    SPARE13  */
-+//	{0x0090,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_14          Ethernet Switch SpareCells 14 */
-+//	{0x0090,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_14_SPARE    SPARE14  */
-+//	{0x0094,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_15          Ethernet Switch SpareCells 15 */
-+//	{0x0094,	 0,	16,	0x00}, /* XRX200_ETHSW_SPARE_15_SPARE    SPARE15  */
-+//	{0x0100,	 0,	16,	0x00}, /* XRX200_BM_RAM_VAL_3            RAM Value Register 3 */
-+//	{0x0100,	 0,	16,	0x00}, /* XRX200_BM_RAM_VAL_3_VAL3       Data value [15:0] */
-+//	{0x0104,	 0,	16,	0x00}, /* XRX200_BM_RAM_VAL_2            RAM Value Register 2 */
-+//	{0x0104,	 0,	16,	0x00}, /* XRX200_BM_RAM_VAL_2_VAL2       Data value [15:0] */
-+//	{0x0108,	 0,	16,	0x00}, /* XRX200_BM_RAM_VAL_1            RAM Value Register 1 */
-+//	{0x0108,	 0,	16,	0x00}, /* XRX200_BM_RAM_VAL_1_VAL1       Data value [15:0] */
-+//	{0x010C,	 0,	16,	0x00}, /* XRX200_BM_RAM_VAL_0            RAM Value Register 0 */
-+//	{0x010C,	 0,	16,	0x00}, /* XRX200_BM_RAM_VAL_0_VAL0       Data value [15:0] */
-+//	{0x0110,	 0,	16,	0x00}, /* XRX200_BM_RAM_ADDR             RAM Address Register */
-+//	{0x0110,	 0,	11,	0x00}, /* XRX200_BM_RAM_ADDR_ADDR        RAM Address */
-+//	{0x0114,	 0,	16,	0x00}, /* XRX200_BM_RAM_CTRL             RAM Access Control Register */
-+//	{0x0114,	15,	 1,	0x00}, /* XRX200_BM_RAM_CTRL_BAS         Access Busy/Access Start */
-+//	{0x0114,	 5,	 1,	0x00}, /* XRX200_BM_RAM_CTRL_OPMOD       Lookup Table Access Operation Mode */
-+//	{0x0114,	 0,	 5,	0x00}, /* XRX200_BM_RAM_CTRL_ADDR        Address for RAM selection */
-+//	{0x0118,	 0,	16,	0x00}, /* XRX200_BM_FSQM_GCTRL           Free Segment Queue ManagerGlobal Control Register */
-+//	{0x0118,	 0,	10,	0x00}, /* XRX200_BM_FSQM_GCTRL_SEGNUM    Maximum Segment Number */
-+//	{0x011C,	 0,	16,	0x00}, /* XRX200_BM_CONS_SEG             Number of Consumed SegmentsRegister */
-+//	{0x011C,	 0,	10,	0x00}, /* XRX200_BM_CONS_SEG_FSEG        Number of Consumed Segments */
-+//	{0x0120,	 0,	16,	0x00}, /* XRX200_BM_CONS_PKT             Number of Consumed PacketPointers Register */
-+//	{0x0120,	 0,	11,	0x00}, /* XRX200_BM_CONS_PKT_FQP         Number of Consumed Packet Pointers */
-+//	{0x0124,	 0,	16,	0x00}, /* XRX200_BM_GCTRL_F              Buffer Manager Global ControlRegister 0 */
-+//	{0x0124,	13,	 1,	0x00}, /* XRX200_BM_GCTRL_BM_STA         Buffer Manager Initialization Status Bit */
-+//	{0x0124,	12,	 1,	0x00}, /* XRX200_BM_GCTRL_SAT            RMON Counter Update Mode */
-+//	{0x0124,	11,	 1,	0x00}, /* XRX200_BM_GCTRL_FR_RBC         Freeze RMON RX Bad Byte 64 Bit Counter */
-+//	{0x0124,	10,	 1,	0x00}, /* XRX200_BM_GCTRL_FR_RGC         Freeze RMON RX Good Byte 64 Bit Counter */
-+//	{0x0124,	 9,	 1,	0x00}, /* XRX200_BM_GCTRL_FR_TGC         Freeze RMON TX Good Byte 64 Bit Counter */
-+//	{0x0124,	 8,	 1,	0x00}, /* XRX200_BM_GCTRL_I_FIN          RAM initialization finished */
-+//	{0x0124,	 7,	 1,	0x00}, /* XRX200_BM_GCTRL_CX_INI         PQM Context RAM initialization */
-+//	{0x0124,	 6,	 1,	0x00}, /* XRX200_BM_GCTRL_FP_INI         FPQM RAM initialization */
-+//	{0x0124,	 5,	 1,	0x00}, /* XRX200_BM_GCTRL_FS_INI         FSQM RAM initialization */
-+//	{0x0124,	 4,	 1,	0x00}, /* XRX200_BM_GCTRL_R_SRES         Software Reset for RMON */
-+//	{0x0124,	 3,	 1,	0x00}, /* XRX200_BM_GCTRL_S_SRES         Software Reset for Scheduler */
-+//	{0x0124,	 2,	 1,	0x00}, /* XRX200_BM_GCTRL_A_SRES         Software Reset for AVG */
-+//	{0x0124,	 1,	 1,	0x00}, /* XRX200_BM_GCTRL_P_SRES         Software Reset for PQM */
-+//	{0x0124,	 0,	 1,	0x00}, /* XRX200_BM_GCTRL_F_SRES         Software Reset for FSQM */
-+//	{0x0128,	 0,	16,	0x00}, /* XRX200_BM_QUEUE_GCTRL          Queue Manager GlobalControl Register 0 */
-+//	{0x0128,	10,	 1,	0x00}, /* XRX200_BM_QUEUE_GCTRL_GL_MOD   WRED Mode Signal */
-+//	{0x0128,	 7,	 3,	0x00}, /* XRX200_BM_QUEUE_GCTRL_AQUI     Average Queue Update Interval */
-+//	{0x0128,	 3,	 4,	0x00}, /* XRX200_BM_QUEUE_GCTRL_AQWF     Average Queue Weight Factor */
-+//	{0x0128,	 2,	 1,	0x00}, /* XRX200_BM_QUEUE_GCTRL_QAVGEN   Queue Average Calculation Enable */
-+//	{0x0128,	 0,	 2,	0x00}, /* XRX200_BM_QUEUE_GCTRL_DPROB    Drop Probability Profile */
-+//	{0x012C,	 0,	16,	0x00}, /* XRX200_BM_WRED_RTH_0           WRED Red Threshold Register0 */
-+//	{0x012C,	 0,	10,	0x00}, /* XRX200_BM_WRED_RTH_0_MINTH     Minimum Threshold */
-+//	{0x0130,	 0,	16,	0x00}, /* XRX200_BM_WRED_RTH_1           WRED Red Threshold Register1 */
-+//	{0x0130,	 0,	10,	0x00}, /* XRX200_BM_WRED_RTH_1_MAXTH     Maximum Threshold */
-+//	{0x0134,	 0,	16,	0x00}, /* XRX200_BM_WRED_YTH_0           WRED Yellow ThresholdRegister 0 */
-+//	{0x0134,	 0,	10,	0x00}, /* XRX200_BM_WRED_YTH_0_MINTH     Minimum Threshold */
-+//	{0x0138,	 0,	16,	0x00}, /* XRX200_BM_WRED_YTH_1           WRED Yellow ThresholdRegister 1 */
-+//	{0x0138,	 0,	10,	0x00}, /* XRX200_BM_WRED_YTH_1_MAXTH     Maximum Threshold */
-+//	{0x013C,	 0,	16,	0x00}, /* XRX200_BM_WRED_GTH_0           WRED Green ThresholdRegister 0 */
-+//	{0x013C,	 0,	10,	0x00}, /* XRX200_BM_WRED_GTH_0_MINTH     Minimum Threshold */
-+//	{0x0140,	 0,	16,	0x00}, /* XRX200_BM_WRED_GTH_1           WRED Green ThresholdRegister 1 */
-+//	{0x0140,	 0,	10,	0x00}, /* XRX200_BM_WRED_GTH_1_MAXTH     Maximum Threshold */
-+//	{0x0144,	 0,	16,	0x00}, /* XRX200_BM_DROP_GTH_0_THR       Drop Threshold ConfigurationRegister 0 */
-+//	{0x0144,	 0,	11,	0x00}, /* XRX200_BM_DROP_GTH_0_THR_FQ    Threshold for frames marked red */
-+//	{0x0148,	 0,	16,	0x00}, /* XRX200_BM_DROP_GTH_1_THY       Drop Threshold ConfigurationRegister 1 */
-+//	{0x0148,	 0,	11,	0x00}, /* XRX200_BM_DROP_GTH_1_THY_FQ    Threshold for frames marked yellow */
-+//	{0x014C,	 0,	16,	0x00}, /* XRX200_BM_DROP_GTH_2_THG       Drop Threshold ConfigurationRegister 2 */
-+//	{0x014C,	 0,	11,	0x00}, /* XRX200_BM_DROP_GTH_2_THG_FQ    Threshold for frames marked green */
-+//	{0x0150,	 0,	16,	0x00}, /* XRX200_BM_IER                  Buffer Manager Global InterruptEnable Register */
-+//	{0x0150,	 7,	 1,	0x00}, /* XRX200_BM_IER_CNT4             Counter Group 4 (RMON-CLASSIFICATION) Interrupt Enable */
-+//	{0x0150,	 6,	 1,	0x00}, /* XRX200_BM_IER_CNT3             Counter Group 3 (RMON-PQM) Interrupt Enable */
-+//	{0x0150,	 5,	 1,	0x00}, /* XRX200_BM_IER_CNT2             Counter Group 2 (RMON-SCHEDULER) Interrupt Enable */
-+//	{0x0150,	 4,	 1,	0x00}, /* XRX200_BM_IER_CNT1             Counter Group 1 (RMON-QFETCH) Interrupt Enable */
-+//	{0x0150,	 3,	 1,	0x00}, /* XRX200_BM_IER_CNT0             Counter Group 0 (RMON-QSTOR) Interrupt Enable */
-+//	{0x0150,	 2,	 1,	0x00}, /* XRX200_BM_IER_DEQ              PQM dequeue Interrupt Enable */
-+//	{0x0150,	 1,	 1,	0x00}, /* XRX200_BM_IER_ENQ              PQM Enqueue Interrupt Enable */
-+//	{0x0150,	 0,	 1,	0x00}, /* XRX200_BM_IER_FSQM             Buffer Empty Interrupt Enable */
-+//	{0x0154,	 0,	16,	0x00}, /* XRX200_BM_ISR                  Buffer Manager Global InterruptStatus Register */
-+//	{0x0154,	 7,	 1,	0x00}, /* XRX200_BM_ISR_CNT4             Counter Group 4 Interrupt */
-+//	{0x0154,	 6,	 1,	0x00}, /* XRX200_BM_ISR_CNT3             Counter Group 3 Interrupt */
-+//	{0x0154,	 5,	 1,	0x00}, /* XRX200_BM_ISR_CNT2             Counter Group 2 Interrupt */
-+//	{0x0154,	 4,	 1,	0x00}, /* XRX200_BM_ISR_CNT1             Counter Group 1 Interrupt */
-+//	{0x0154,	 3,	 1,	0x00}, /* XRX200_BM_ISR_CNT0             Counter Group 0 Interrupt */
-+//	{0x0154,	 2,	 1,	0x00}, /* XRX200_BM_ISR_DEQ              PQM dequeue Interrupt Enable */
-+//	{0x0154,	 1,	 1,	0x00}, /* XRX200_BM_ISR_ENQ              PQM Enqueue Interrupt */
-+//	{0x0154,	 0,	 1,	0x00}, /* XRX200_BM_ISR_FSQM             Buffer Empty Interrupt */
-+//	{0x0158,	 0,	16,	0x00}, /* XRX200_BM_CISEL                Buffer Manager RMON CounterInterrupt Select Register */
-+//	{0x0158,	 0,	 3,	0x00}, /* XRX200_BM_CISEL_PORT           Port Number */
-+//	{0x015C,	 0,	16,	0x00}, /* XRX200_BM_DEBUG_CTRL_DBG       Debug Control Register */
-+//	{0x015C,	 0,	 8,	0x00}, /* XRX200_BM_DEBUG_CTRL_DBG_SEL   Select Signal for Debug Multiplexer */
-+//	{0x0160,	 0,	16,	0x00}, /* XRX200_BM_DEBUG_VAL_DBG        Debug Value Register */
-+//	{0x0160,	 0,	16,	0x00}, /* XRX200_BM_DEBUG_VAL_DBG_DAT    Debug Data Value */
-+//	{0x0200,	 0,	16,	0x08}, /* XRX200_BM_PCFG                 Buffer Manager PortConfiguration Register */
-+//	{0x0200,	 0,	 1,	0x08}, /* XRX200_BM_PCFG_CNTEN           RMON Counter Enable */
-+//	{0x0204,	 0,	16,	0x08}, /* XRX200_BM_RMON_CTRL_RAM1       Buffer ManagerRMON Control Register */
-+//	{0x0204,	 1,	 1,	0x08}, /* XRX200_BM_RMON_CTRL_RAM2_RES   Software Reset for RMON RAM2 */
-+//	{0x0204,	 0,	 1,	0x08}, /* XRX200_BM_RMON_CTRL_RAM1_RES   Software Reset for RMON RAM1 */
-+//	{0x0400,	 0,	16,	0x08}, /* XRX200_PQM_DP                  Packet Queue ManagerDrop Probability Register */
-+//	{0x0400,	 0,	 2,	0x08}, /* XRX200_PQM_DP_DPROB            Drop Probability Profile */
-+//	{0x0404,	 0,	16,	0x08}, /* XRX200_PQM_RS                  Packet Queue ManagerRate Shaper Assignment Register */
-+//	{0x0404,	15,	 1,	0x08}, /* XRX200_PQM_RS_EN2              Rate Shaper 2 Enable */
-+//	{0x0404,	 8,	 6,	0x08}, /* XRX200_PQM_RS_RS2              Rate Shaper 2 */
-+//	{0x0404,	 7,	 1,	0x08}, /* XRX200_PQM_RS_EN1              Rate Shaper 1 Enable */
-+//	{0x0404,	 0,	 6,	0x08}, /* XRX200_PQM_RS_RS1              Rate Shaper 1 */
-+//	{0x0500,	 0,	16,	0x14}, /* XRX200_RS_CTRL                 Rate Shaper ControlRegister */
-+//	{0x0500,	 0,	 1,	0x14}, /* XRX200_RS_CTRL_RSEN            Rate Shaper Enable */
-+//	{0x0504,	 0,	16,	0x14}, /* XRX200_RS_CBS                  Rate Shaper CommittedBurst Size Register */
-+//	{0x0504,	 0,	10,	0x14}, /* XRX200_RS_CBS_CBS              Committed Burst Size */
-+//	{0x0508,	 0,	16,	0x14}, /* XRX200_RS_IBS                  Rate Shaper InstantaneousBurst Size Register */
-+//	{0x0508,	 0,	 2,	0x14}, /* XRX200_RS_IBS_IBS              Instantaneous Burst Size */
-+//	{0x050C,	 0,	16,	0x14}, /* XRX200_RS_CIR_EXP              Rate Shaper RateExponent Register */
-+//	{0x050C,	 0,	 4,	0x14}, /* XRX200_RS_CIR_EXP_EXP          Exponent */
-+//	{0x0510,	 0,	16,	0x14}, /* XRX200_RS_CIR_MANT             Rate Shaper RateMantissa Register */
-+//	{0x0510,	 0,	10,	0x14}, /* XRX200_RS_CIR_MANT_MANT        Mantissa */
-+	{0x1100,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_7           Table Key Data 7 */
-+//	{0x1100,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_7_KEY7      Key Value[15:0] */
-+	{0x1104,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_6           Table Key Data 6 */
-+//	{0x1104,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_6_KEY6      Key Value[15:0] */
-+	{0x1108,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_5           Table Key Data 5 */
-+//	{0x1108,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_5_KEY5      Key Value[15:0] */
-+	{0x110C,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_4           Table Key Data 4 */
-+//	{0x110C,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_4_KEY4      Key Value[15:0] */
-+	{0x1110,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_3           Table Key Data 3 */
-+//	{0x1110,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_3_KEY3      Key Value[15:0] */
-+	{0x1114,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_2           Table Key Data 2 */
-+//	{0x1114,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_2_KEY2      Key Value[15:0] */
-+	{0x1118,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_1           Table Key Data 1 */
-+//	{0x1118,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_1_KEY1      Key Value[31:16] */
-+	{0x111C,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_0           Table Key Data 0 */
-+//	{0x111C,	 0,	16,	0x00}, /* XRX200_PCE_TBL_KEY_0_KEY0      Key Value[15:0] */
-+	{0x1120,	 0,	16,	0x00}, /* XRX200_PCE_TBL_MASK_0          Table Mask Write Register0 */
-+//	{0x1120,	 0,	16,	0x00}, /* XRX200_PCE_TBL_MASK_0_MASK0    Mask Pattern [15:0] */
-+	{0x1124,	 0,	16,	0x00}, /* XRX200_PCE_TBL_VAL_4           Table Value Register4 */
-+//	{0x1124,	 0,	16,	0x00}, /* XRX200_PCE_TBL_VAL_4_VAL4      Data value [15:0] */
-+	{0x1128,	 0,	16,	0x00}, /* XRX200_PCE_TBL_VAL_3           Table Value Register3 */
-+//	{0x1128,	 0,	16,	0x00}, /* XRX200_PCE_TBL_VAL_3_VAL3      Data value [15:0] */
-+	{0x112C,	 0,	16,	0x00}, /* XRX200_PCE_TBL_VAL_2           Table Value Register2 */
-+//	{0x112C,	 0,	16,	0x00}, /* XRX200_PCE_TBL_VAL_2_VAL2      Data value [15:0] */
-+	{0x1130,	 0,	16,	0x00}, /* XRX200_PCE_TBL_VAL_1           Table Value Register1 */
-+//	{0x1130,	 0,	16,	0x00}, /* XRX200_PCE_TBL_VAL_1_VAL1      Data value [15:0] */
-+	{0x1134,	 0,	16,	0x00}, /* XRX200_PCE_TBL_VAL_0           Table Value Register0 */
-+//	{0x1134,	 0,	16,	0x00}, /* XRX200_PCE_TBL_VAL_0_VAL0      Data value [15:0] */
-+//	{0x1138,	 0,	16,	0x00}, /* XRX200_PCE_TBL_ADDR            Table Entry AddressRegister */
-+	{0x1138,	 0,	11,	0x00}, /* XRX200_PCE_TBL_ADDR_ADDR       Table Address */
-+//	{0x113C,	 0,	16,	0x00}, /* XRX200_PCE_TBL_CTRL            Table Access ControlRegister */
-+	{0x113C,	15,	 1,	0x00}, /* XRX200_PCE_TBL_CTRL_BAS        Access Busy/Access Start */
-+	{0x113C,	13,	 1,	0x00}, /* XRX200_PCE_TBL_CTRL_TYPE       Lookup Entry Type */
-+	{0x113C,	12,	 1,	0x00}, /* XRX200_PCE_TBL_CTRL_VLD        Lookup Entry Valid */
-+	{0x113C,	 7,	 4,	0x00}, /* XRX200_PCE_TBL_CTRL_GMAP       Group Map */
-+	{0x113C,	 5,	 2,	0x00}, /* XRX200_PCE_TBL_CTRL_OPMOD      Lookup Table Access Operation Mode */
-+	{0x113C,	 0,	 5,	0x00}, /* XRX200_PCE_TBL_CTRL_ADDR       Lookup Table Address */
-+//	{0x1140,	 0,	16,	0x00}, /* XRX200_PCE_TBL_STAT            Table General StatusRegister */
-+//	{0x1140,	 2,	 1,	0x00}, /* XRX200_PCE_TBL_STAT_TBUSY      Table Access Busy */
-+//	{0x1140,	 1,	 1,	0x00}, /* XRX200_PCE_TBL_STAT_TEMPT      Table Empty */
-+//	{0x1140,	 0,	 1,	0x00}, /* XRX200_PCE_TBL_STAT_TFUL       Table Full */
-+//	{0x1144,	 0,	16,	0x00}, /* XRX200_PCE_AGE_0               Aging Counter ConfigurationRegister 0 */
-+//	{0x1144,	 0,	 4,	0x00}, /* XRX200_PCE_AGE_0_EXP           Aging Counter Exponent Value  */
-+//	{0x1148,	 0,	16,	0x00}, /* XRX200_PCE_AGE_1               Aging Counter ConfigurationRegister 1 */
-+//	{0x1148,	 0,	16,	0x00}, /* XRX200_PCE_AGE_1_MANT          Aging Counter Mantissa Value  */
-+//	{0x114C,	 0,	16,	0x00}, /* XRX200_PCE_PMAP_1              Port Map Register 1 */
-+//	{0x114C,	 0,	16,	0x00}, /* XRX200_PCE_PMAP_1_MPMAP        Monitoring Port Map */
-+//	{0x1150,	 0,	16,	0x00}, /* XRX200_PCE_PMAP_2              Port Map Register 2 */
-+//	{0x1150,	 0,	16,	0x00}, /* XRX200_PCE_PMAP_2_DMCPMAP      Default Multicast Port Map */
-+//	{0x1154,	 0,	16,	0x00}, /* XRX200_PCE_PMAP_3              Port Map Register 3 */
-+//	{0x1154,	 0,	16,	0x00}, /* XRX200_PCE_PMAP_3_UUCMAP       Default Unknown Unicast Port Map */
-+//	{0x1158,	 0,	16,	0x00}, /* XRX200_PCE_GCTRL_0             PCE Global Control Register0 */
-+//	{0x1158,	15,	 1,	0x00}, /* XRX200_PCE_GCTRL_0_IGMP        IGMP Mode Selection */
-+	{0x1158,	14,	 1,	0x00}, /* XRX200_PCE_GCTRL_0_VLAN        VLAN-aware Switching */
-+//	{0x1158,	13,	 1,	0x00}, /* XRX200_PCE_GCTRL_0_NOPM        No Port Map Forwarding */
-+//	{0x1158,	12,	 1,	0x00}, /* XRX200_PCE_GCTRL_0_SCONUC      Unknown Unicast Storm Control */
-+//	{0x1158,	11,	 1,	0x00}, /* XRX200_PCE_GCTRL_0_SCONMC      Multicast Storm Control */
-+//	{0x1158,	10,	 1,	0x00}, /* XRX200_PCE_GCTRL_0_SCONBC      Broadcast Storm Control */
-+//	{0x1158,	 8,	 2,	0x00}, /* XRX200_PCE_GCTRL_0_SCONMOD     Storm Control Mode */
-+//	{0x1158,	 4,	 4,	0x00}, /* XRX200_PCE_GCTRL_0_SCONMET     Storm Control Metering Instance */
-+//	{0x1158,	 3,	 1,	0x00}, /* XRX200_PCE_GCTRL_0_MC_VALID    Access Request */
-+//	{0x1158,	 2,	 1,	0x00}, /* XRX200_PCE_GCTRL_0_PLCKMOD     Port Lock Mode */
-+//	{0x1158,	 1,	 1,	0x00}, /* XRX200_PCE_GCTRL_0_PLIMMOD     MAC Address Learning Limitation Mode */
-+//	{0x1158,	 0,	 1,	0x00}, /* XRX200_PCE_GCTRL_0_MTFL        MAC Table Flushing */
-+//	{0x115C,	 0,	16,	0x00}, /* XRX200_PCE_GCTRL_1             PCE Global Control Register1 */
-+//	{0x115C,	 1,	 1,	0x00}, /* XRX200_PCE_GCTRL_1_PCE_DIS     PCE Disable after currently processed packet */
-+//	{0x115C,	 0,	 1,	0x00}, /* XRX200_PCE_GCTRL_1_LRNMOD      MAC Address Learning Mode */
-+//	{0x1160,	 0,	16,	0x00}, /* XRX200_PCE_TCM_GLOB_CTRL       Three-color MarkerGlobal Control Register */
-+//	{0x1160,	 6,	 3,	0x00}, /* XRX200_PCE_TCM_GLOB_CTRL_DPRED Re-marking Drop Precedence Red Encoding */
-+//	{0x1160,	 3,	 3,	0x00}, /* XRX200_PCE_TCM_GLOB_CTRL_DPYEL Re-marking Drop Precedence Yellow Encoding */
-+//	{0x1160,	 0,	 3,	0x00}, /* XRX200_PCE_TCM_GLOB_CTRL_DPGRN Re-marking Drop Precedence Green Encoding */
-+//	{0x1164,	 0,	16,	0x00}, /* XRX200_PCE_IGMP_CTRL           IGMP Control Register */
-+//	{0x1164,	15,	 1,	0x00}, /* XRX200_PCE_IGMP_CTRL_FAGEEN    Force Aging of Table Entries Enable */
-+//	{0x1164,	14,	 1,	0x00}, /* XRX200_PCE_IGMP_CTRL_FLEAVE    Fast Leave Enable */
-+//	{0x1164,	13,	 1,	0x00}, /* XRX200_PCE_IGMP_CTRL_DMRTEN    Default Maximum Response Time Enable */
-+//	{0x1164,	12,	 1,	0x00}, /* XRX200_PCE_IGMP_CTRL_JASUP     Join Aggregation Suppression Enable */
-+//	{0x1164,	11,	 1,	0x00}, /* XRX200_PCE_IGMP_CTRL_REPSUP    Report Suppression Enable */
-+//	{0x1164,	10,	 1,	0x00}, /* XRX200_PCE_IGMP_CTRL_SRPEN     Snooping of Router Port Enable */
-+//	{0x1164,	 8,	 2,	0x00}, /* XRX200_PCE_IGMP_CTRL_ROB       Robustness Variable */
-+//	{0x1164,	 0,	 8,	0x00}, /* XRX200_PCE_IGMP_CTRL_DMRT      IGMP Default Maximum Response Time */
-+//	{0x1168,	 0,	16,	0x00}, /* XRX200_PCE_IGMP_DRPM           IGMP Default RouterPort Map Register */
-+//	{0x1168,	 0,	16,	0x00}, /* XRX200_PCE_IGMP_DRPM_DRPM      IGMP Default Router Port Map */
-+//	{0x116C,	 0,	16,	0x00}, /* XRX200_PCE_IGMP_AGE_0          IGMP Aging Register0 */
-+//	{0x116C,	 3,	 8,	0x00}, /* XRX200_PCE_IGMP_AGE_0_MANT     IGMP Group Aging Time Mantissa */
-+//	{0x116C,	 0,	 3,	0x00}, /* XRX200_PCE_IGMP_AGE_0_EXP      IGMP Group Aging Time Exponent */
-+//	{0x1170,	 0,	16,	0x00}, /* XRX200_PCE_IGMP_AGE_1          IGMP Aging Register1 */
-+//	{0x1170,	 0,	12,	0x00}, /* XRX200_PCE_IGMP_AGE_1_MANT     IGMP Router Port Aging Time Mantissa */
-+//	{0x1174,	 0,	16,	0x00}, /* XRX200_PCE_IGMP_STAT           IGMP Status Register */
-+//	{0x1174,	 0,	16,	0x00}, /* XRX200_PCE_IGMP_STAT_IGPM      IGMP Port Map */
-+//	{0x1178,	 0,	16,	0x00}, /* XRX200_WOL_GLB_CTRL            Wake-on-LAN ControlRegister */
-+//	{0x1178,	 0,	 1,	0x00}, /* XRX200_WOL_GLB_CTRL_PASSEN     WoL Password Enable */
-+//	{0x117C,	 0,	16,	0x00}, /* XRX200_WOL_DA_0                Wake-on-LAN DestinationAddress Register 0 */
-+//	{0x117C,	 0,	16,	0x00}, /* XRX200_WOL_DA_0_DA0            WoL Destination Address [15:0] */
-+//	{0x1180,	 0,	16,	0x00}, /* XRX200_WOL_DA_1                Wake-on-LAN DestinationAddress Register 1 */
-+//	{0x1180,	 0,	16,	0x00}, /* XRX200_WOL_DA_1_DA1            WoL Destination Address [31:16] */
-+//	{0x1184,	 0,	16,	0x00}, /* XRX200_WOL_DA_2                Wake-on-LAN DestinationAddress Register 2 */
-+//	{0x1184,	 0,	16,	0x00}, /* XRX200_WOL_DA_2_DA2            WoL Destination Address [47:32] */
-+//	{0x1188,	 0,	16,	0x00}, /* XRX200_WOL_PW_0                Wake-on-LAN Password Register0 */
-+//	{0x1188,	 0,	16,	0x00}, /* XRX200_WOL_PW_0_PW0            WoL Password [15:0] */
-+//	{0x118C,	 0,	16,	0x00}, /* XRX200_WOL_PW_1                Wake-on-LAN Password Register1 */
-+//	{0x118C,	 0,	16,	0x00}, /* XRX200_WOL_PW_1_PW1            WoL Password [31:16] */
-+//	{0x1190,	 0,	16,	0x00}, /* XRX200_WOL_PW_2                Wake-on-LAN Password Register2 */
-+//	{0x1190,	 0,	16,	0x00}, /* XRX200_WOL_PW_2_PW2            WoL Password [47:32] */
-+//	{0x1194,	 0,	16,	0x00}, /* XRX200_PCE_IER_0_PINT          Parser and ClassificationEngine Global Interrupt Enable Register 0 */
-+//	{0x1194,	15,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_15       Port Interrupt Enable */
-+//	{0x1194,	14,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_14       Port Interrupt Enable */
-+//	{0x1194,	13,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_13       Port Interrupt Enable */
-+//	{0x1194,	12,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_12       Port Interrupt Enable */
-+//	{0x1194,	11,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_11       Port Interrupt Enable */
-+//	{0x1194,	10,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_10       Port Interrupt Enable */
-+//	{0x1194,	 9,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_9        Port Interrupt Enable */
-+//	{0x1194,	 8,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_8        Port Interrupt Enable */
-+//	{0x1194,	 7,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_7        Port Interrupt Enable */
-+//	{0x1194,	 6,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_6        Port Interrupt Enable */
-+//	{0x1194,	 5,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_5        Port Interrupt Enable */
-+//	{0x1194,	 4,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_4        Port Interrupt Enable */
-+//	{0x1194,	 3,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_3        Port Interrupt Enable */
-+//	{0x1194,	 2,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_2        Port Interrupt Enable */
-+//	{0x1194,	 1,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_1        Port Interrupt Enable */
-+//	{0x1194,	 0,	 1,	0x00}, /* XRX200_PCE_IER_0_PINT_0        Port Interrupt Enable */
-+//	{0x1198,	 0,	16,	0x00}, /* XRX200_PCE_IER_1               Parser and ClassificationEngine Global Interrupt Enable Register 1 */
-+//	{0x1198,	 6,	 1,	0x00}, /* XRX200_PCE_IER_1_FLOWINT       Traffic Flow Table Interrupt Rule matched Interrupt Enable */
-+//	{0x1198,	 5,	 1,	0x00}, /* XRX200_PCE_IER_1_CPH2          Classification Phase 2 Ready Interrupt Enable */
-+//	{0x1198,	 4,	 1,	0x00}, /* XRX200_PCE_IER_1_CPH1          Classification Phase 1 Ready Interrupt Enable */
-+//	{0x1198,	 3,	 1,	0x00}, /* XRX200_PCE_IER_1_CPH0          Classification Phase 0 Ready Interrupt Enable */
-+//	{0x1198,	 2,	 1,	0x00}, /* XRX200_PCE_IER_1_PRDY          Parser Ready Interrupt Enable */
-+//	{0x1198,	 1,	 1,	0x00}, /* XRX200_PCE_IER_1_IGTF          IGMP Table Full Interrupt Enable */
-+//	{0x1198,	 0,	 1,	0x00}, /* XRX200_PCE_IER_1_MTF           MAC Table Full Interrupt Enable */
-+//	{0x119C,	 0,	16,	0x00}, /* XRX200_PCE_ISR_0_PINT          Parser and ClassificationEngine Global Interrupt Status Register 0 */
-+//	{0x119C,	15,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_15       Port Interrupt */
-+//	{0x119C,	14,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_14       Port Interrupt */
-+//	{0x119C,	13,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_13       Port Interrupt */
-+//	{0x119C,	12,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_12       Port Interrupt */
-+//	{0x119C,	11,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_11       Port Interrupt */
-+//	{0x119C,	10,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_10       Port Interrupt */
-+//	{0x119C,	 9,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_9        Port Interrupt */
-+//	{0x119C,	 8,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_8        Port Interrupt */
-+//	{0x119C,	 7,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_7        Port Interrupt */
-+//	{0x119C,	 6,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_6        Port Interrupt */
-+//	{0x119C,	 5,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_5        Port Interrupt */
-+//	{0x119C,	 4,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_4        Port Interrupt */
-+//	{0x119C,	 3,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_3        Port Interrupt */
-+//	{0x119C,	 2,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_2        Port Interrupt */
-+//	{0x119C,	 1,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_1        Port Interrupt */
-+//	{0x119C,	 0,	 1,	0x00}, /* XRX200_PCE_ISR_0_PINT_0        Port Interrupt */
-+//	{0x11A0,	 0,	16,	0x00}, /* XRX200_PCE_ISR_1               Parser and ClassificationEngine Global Interrupt Status Register 1 */
-+//	{0x11A0,	 6,	 1,	0x00}, /* XRX200_PCE_ISR_1_FLOWINT       Traffic Flow Table Interrupt Rule matched */
-+//	{0x11A0,	 5,	 1,	0x00}, /* XRX200_PCE_ISR_1_CPH2          Classification Phase 2 Ready Interrupt */
-+//	{0x11A0,	 4,	 1,	0x00}, /* XRX200_PCE_ISR_1_CPH1          Classification Phase 1 Ready Interrupt */
-+//	{0x11A0,	 3,	 1,	0x00}, /* XRX200_PCE_ISR_1_CPH0          Classification Phase 0 Ready Interrupt */
-+//	{0x11A0,	 2,	 1,	0x00}, /* XRX200_PCE_ISR_1_PRDY          Parser Ready Interrupt */
-+//	{0x11A0,	 1,	 1,	0x00}, /* XRX200_PCE_ISR_1_IGTF          IGMP Table Full Interrupt */
-+//	{0x11A0,	 0,	 1,	0x00}, /* XRX200_PCE_ISR_1_MTF           MAC Table Full Interrupt */
-+//	{0x11A4,	 0,	16,	0x00}, /* XRX200_PARSER_STAT_FIFO        Parser Status Register */
-+//	{0x11A4,	 8,	 8,	0x00}, /* XRX200_PARSER_STAT_FSM_DAT_CNT Parser FSM Data Counter */
-+//	{0x11A4,	 5,	 3,	0x00}, /* XRX200_PARSER_STAT_FSM_STATE   Parser FSM State */
-+//	{0x11A4,	 4,	 1,	0x00}, /* XRX200_PARSER_STAT_PKT_ERR     Packet error detected */
-+//	{0x11A4,	 3,	 1,	0x00}, /* XRX200_PARSER_STAT_FSM_FIN     Parser FSM finished */
-+//	{0x11A4,	 2,	 1,	0x00}, /* XRX200_PARSER_STAT_FSM_START   Parser FSM start */
-+//	{0x11A4,	 1,	 1,	0x00}, /* XRX200_PARSER_STAT_FIFO_RDY    Parser FIFO ready for read. */
-+//	{0x11A4,	 0,	 1,	0x00}, /* XRX200_PARSER_STAT_FIFO_FULL   Parser */
-+//	{0x1200,	 0,	16,	0x28}, /* XRX200_PCE_PCTRL_0             PCE Port ControlRegister 0 */
-+//	{0x1200,	13,	 1,	0x28}, /* XRX200_PCE_PCTRL_0_MCST        Multicast Forwarding Mode Selection */
-+//	{0x1200,	12,	 1,	0x28}, /* XRX200_PCE_PCTRL_0_EGSTEN      Table-based Egress Special Tag Enable */
-+//	{0x1200,	11,	 1,	0x28}, /* XRX200_PCE_PCTRL_0_IGSTEN      Ingress Special Tag Enable */
-+//	{0x1200,	10,	 1,	0x28}, /* XRX200_PCE_PCTRL_0_PCPEN       PCP Remarking Mode */
-+//	{0x1200,	 9,	 1,	0x28}, /* XRX200_PCE_PCTRL_0_CLPEN       Class Remarking Mode */
-+//	{0x1200,	 8,	 1,	0x28}, /* XRX200_PCE_PCTRL_0_DPEN        Drop Precedence Remarking Mode */
-+//	{0x1200,	 7,	 1,	0x28}, /* XRX200_PCE_PCTRL_0_CMOD        Three-color Marker Color Mode */
-+//	{0x1200,	 6,	 1,	0x28}, /* XRX200_PCE_PCTRL_0_VREP        VLAN Replacement Mode */
-+	{0x1200,	 5,	 1,	0x28}, /* XRX200_PCE_PCTRL_0_TVM         Transparent VLAN Mode */
-+//	{0x1200,	 4,	 1,	0x28}, /* XRX200_PCE_PCTRL_0_PLOCK       Port Locking Enable */
-+//	{0x1200,	 3,	 1,	0x28}, /* XRX200_PCE_PCTRL_0_AGEDIS      Aging Disable */
-+//	{0x1200,	 0,	 3,	0x28}, /* XRX200_PCE_PCTRL_0_PSTATE      Port State */
-+//	{0x1204,	 0,	16,	0x28}, /* XRX200_PCE_PCTRL_1             PCE Port ControlRegister 1 */
-+//	{0x1204,	 0,	 8,	0x28}, /* XRX200_PCE_PCTRL_1_LRNLIM      MAC Address Learning Limit */
-+//	{0x1208,	 0,	16,	0x28}, /* XRX200_PCE_PCTRL_2             PCE Port ControlRegister 2 */
-+//	{0x1208,	 7,	 1,	0x28}, /* XRX200_PCE_PCTRL_2_DSCPMOD     DSCP Mode Selection */
-+//	{0x1208,	 5,	 2,	0x28}, /* XRX200_PCE_PCTRL_2_DSCP        Enable DSCP to select the Class of Service */
-+//	{0x1208,	 4,	 1,	0x28}, /* XRX200_PCE_PCTRL_2_PCP         Enable VLAN PCP to select the Class of Service */
-+//	{0x1208,	 0,	 4,	0x28}, /* XRX200_PCE_PCTRL_2_PCLASS      Port-based Traffic Class */
-+//	{0x120C,	 0,	16,	0x28}, /* XRX200_PCE_PCTRL_3_VIO         PCE Port ControlRegister 3 */
-+//	{0x120C,	11,	 1,	0x28}, /* XRX200_PCE_PCTRL_3_EDIR        Egress Redirection Mode */
-+//	{0x120C,	10,	 1,	0x28}, /* XRX200_PCE_PCTRL_3_RXDMIR      Receive Mirroring Enable for dropped frames */
-+//	{0x120C,	 9,	 1,	0x28}, /* XRX200_PCE_PCTRL_3_RXVMIR      Receive Mirroring Enable for valid frames */
-+//	{0x120C,	 8,	 1,	0x28}, /* XRX200_PCE_PCTRL_3_TXMIR       Transmit Mirroring Enable */
-+//	{0x120C,	 7,	 1,	0x28}, /* XRX200_PCE_PCTRL_3_VIO_7       Violation Type 7 Mirroring Enable */
-+//	{0x120C,	 6,	 1,	0x28}, /* XRX200_PCE_PCTRL_3_VIO_6       Violation Type 6 Mirroring Enable */
-+//	{0x120C,	 5,	 1,	0x28}, /* XRX200_PCE_PCTRL_3_VIO_5       Violation Type 5 Mirroring Enable */
-+//	{0x120C,	 4,	 1,	0x28}, /* XRX200_PCE_PCTRL_3_VIO_4       Violation Type 4 Mirroring Enable */
-+//	{0x120C,	 3,	 1,	0x28}, /* XRX200_PCE_PCTRL_3_VIO_3       Violation Type 3 Mirroring Enable */
-+//	{0x120C,	 2,	 1,	0x28}, /* XRX200_PCE_PCTRL_3_VIO_2       Violation Type 2 Mirroring Enable */
-+//	{0x120C,	 1,	 1,	0x28}, /* XRX200_PCE_PCTRL_3_VIO_1       Violation Type 1 Mirroring Enable */
-+//	{0x120C,	 0,	 1,	0x28}, /* XRX200_PCE_PCTRL_3_VIO_0       Violation Type 0 Mirroring Enable */
-+//	{0x1210,	 0,	16,	0x28}, /* XRX200_WOL_CTRL                Wake-on-LAN ControlRegister */
-+//	{0x1210,	 0,	 1,	0x28}, /* XRX200_WOL_CTRL_PORT           WoL Enable */
-+//	{0x1214,	 0,	16,	0x28}, /* XRX200_PCE_VCTRL               PCE VLAN ControlRegister */
-+	{0x1214,	 5,	 1,	0x28}, /* XRX200_PCE_VCTRL_VSR           VLAN Security Rule */
-+	{0x1214,	 4,	 1,	0x28}, /* XRX200_PCE_VCTRL_VEMR          VLAN Egress Member Violation Rule */
-+	{0x1214,	 3,	 1,	0x28}, /* XRX200_PCE_VCTRL_VIMR          VLAN Ingress Member Violation Rule */
-+	{0x1214,	 1,	 2,	0x28}, /* XRX200_PCE_VCTRL_VINR          VLAN Ingress Tag Rule */
-+	{0x1214,	 0,	 1,	0x28}, /* XRX200_PCE_VCTRL_UVR           Unknown VLAN Rule */
-+//	{0x1218,	 0,	16,	0x28}, /* XRX200_PCE_DEFPVID             PCE Default PortVID Register */
-+	{0x1218,	 0,	 6,	0x28}, /* XRX200_PCE_DEFPVID_PVID        Default Port VID Index */
-+//	{0x121C,	 0,	16,	0x28}, /* XRX200_PCE_PSTAT               PCE Port StatusRegister */
-+//	{0x121C,	 0,	16,	0x28}, /* XRX200_PCE_PSTAT_LRNCNT        Learning Count */
-+//	{0x1220,	 0,	16,	0x28}, /* XRX200_PCE_PIER                Parser and ClassificationEngine Port Interrupt Enable Register */
-+//	{0x1220,	 5,	 1,	0x28}, /* XRX200_PCE_PIER_CLDRP          Classification Drop Interrupt Enable */
-+//	{0x1220,	 4,	 1,	0x28}, /* XRX200_PCE_PIER_PTDRP          Port Drop Interrupt Enable */
-+//	{0x1220,	 3,	 1,	0x28}, /* XRX200_PCE_PIER_VLAN           VLAN Violation Interrupt Enable */
-+//	{0x1220,	 2,	 1,	0x28}, /* XRX200_PCE_PIER_WOL            Wake-on-LAN Interrupt Enable */
-+//	{0x1220,	 1,	 1,	0x28}, /* XRX200_PCE_PIER_LOCK           Port Limit Alert Interrupt Enable */
-+//	{0x1220,	 0,	 1,	0x28}, /* XRX200_PCE_PIER_LIM            Port Lock Alert Interrupt Enable */
-+//	{0x1224,	 0,	16,	0x28}, /* XRX200_PCE_PISR                Parser and ClassificationEngine Port Interrupt Status Register */
-+//	{0x1224,	 5,	 1,	0x28}, /* XRX200_PCE_PISR_CLDRP          Classification Drop Interrupt */
-+//	{0x1224,	 4,	 1,	0x28}, /* XRX200_PCE_PISR_PTDRP          Port Drop Interrupt */
-+//	{0x1224,	 3,	 1,	0x28}, /* XRX200_PCE_PISR_VLAN           VLAN Violation Interrupt */
-+//	{0x1224,	 2,	 1,	0x28}, /* XRX200_PCE_PISR_WOL            Wake-on-LAN Interrupt */
-+//	{0x1224,	 1,	 1,	0x28}, /* XRX200_PCE_PISR_LOCK           Port Lock Alert Interrupt */
-+//	{0x1224,	 0,	 1,	0x28}, /* XRX200_PCE_PISR_LIMIT          Port Limitation Alert Interrupt */
-+//	{0x1600,	 0,	16,	0x1c}, /* XRX200_PCE_TCM_CTRL            Three-colorMarker Control Register */
-+//	{0x1600,	 0,	 1,	0x1c}, /* XRX200_PCE_TCM_CTRL_TCMEN      Three-color Marker metering instance enable */
-+//	{0x1604,	 0,	16,	0x1c}, /* XRX200_PCE_TCM_STAT            Three-colorMarker Status Register */
-+//	{0x1604,	 1,	 1,	0x1c}, /* XRX200_PCE_TCM_STAT_AL1        Three-color Marker Alert 1 Status */
-+//	{0x1604,	 0,	 1,	0x1c}, /* XRX200_PCE_TCM_STAT_AL0        Three-color Marker Alert 0 Status */
-+//	{0x1608,	 0,	16,	0x1c}, /* XRX200_PCE_TCM_CBS             Three-color MarkerCommitted Burst Size Register */
-+//	{0x1608,	 0,	10,	0x1c}, /* XRX200_PCE_TCM_CBS_CBS         Committed Burst Size */
-+//	{0x160C,	 0,	16,	0x1c}, /* XRX200_PCE_TCM_EBS             Three-color MarkerExcess Burst Size Register */
-+//	{0x160C,	 0,	10,	0x1c}, /* XRX200_PCE_TCM_EBS_EBS         Excess Burst Size */
-+//	{0x1610,	 0,	16,	0x1c}, /* XRX200_PCE_TCM_IBS             Three-color MarkerInstantaneous Burst Size Register */
-+//	{0x1610,	 0,	 2,	0x1c}, /* XRX200_PCE_TCM_IBS_IBS         Instantaneous Burst Size */
-+//	{0x1614,	 0,	16,	0x1c}, /* XRX200_PCE_TCM_CIR_MANT        Three-colorMarker Constant Information Rate Mantissa Register */
-+//	{0x1614,	 0,	10,	0x1c}, /* XRX200_PCE_TCM_CIR_MANT_MANT   Rate Counter Mantissa */
-+//	{0x1618,	 0,	16,	0x1c}, /* XRX200_PCE_TCM_CIR_EXP         Three-colorMarker Constant Information Rate Exponent Register */
-+//	{0x1618,	 0,	 4,	0x1c}, /* XRX200_PCE_TCM_CIR_EXP_EXP     Rate Counter Exponent */
-+//	{0x2300,	 0,	16,	0x00}, /* XRX200_MAC_TEST                MAC Test Register */
-+//	{0x2300,	 0,	16,	0x00}, /* XRX200_MAC_TEST_JTP            Jitter Test Pattern */
-+//	{0x2304,	 0,	16,	0x00}, /* XRX200_MAC_PFAD_CFG            MAC Pause FrameSource Address Configuration Register */
-+//	{0x2304,	 0,	 1,	0x00}, /* XRX200_MAC_PFAD_CFG_SAMOD      Source Address Mode */
-+//	{0x2308,	 0,	16,	0x00}, /* XRX200_MAC_PFSA_0              Pause Frame SourceAddress Part 0  */
-+//	{0x2308,	 0,	16,	0x00}, /* XRX200_MAC_PFSA_0_PFAD         Pause Frame Source Address Part 0 */
-+//	{0x230C,	 0,	16,	0x00}, /* XRX200_MAC_PFSA_1              Pause Frame SourceAddress Part 1  */
-+//	{0x230C,	 0,	16,	0x00}, /* XRX200_MAC_PFSA_1_PFAD         Pause Frame Source Address Part 1 */
-+//	{0x2310,	 0,	16,	0x00}, /* XRX200_MAC_PFSA_2              Pause Frame SourceAddress Part 2  */
-+//	{0x2310,	 0,	16,	0x00}, /* XRX200_MAC_PFSA_2_PFAD         Pause Frame Source Address Part 2 */
-+//	{0x2314,	 0,	16,	0x00}, /* XRX200_MAC_FLEN                MAC Frame Length Register */
-+//	{0x2314,	 0,	14,	0x00}, /* XRX200_MAC_FLEN_LEN            Maximum Frame Length */
-+//	{0x2318,	 0,	16,	0x00}, /* XRX200_MAC_VLAN_ETYPE_0        MAC VLAN EthertypeRegister 0 */
-+//	{0x2318,	 0,	16,	0x00}, /* XRX200_MAC_VLAN_ETYPE_0_OUTER  Ethertype */
-+//	{0x231C,	 0,	16,	0x00}, /* XRX200_MAC_VLAN_ETYPE_1        MAC VLAN EthertypeRegister 1 */
-+//	{0x231C,	 0,	16,	0x00}, /* XRX200_MAC_VLAN_ETYPE_1_INNER  Ethertype */
-+//	{0x2320,	 0,	16,	0x00}, /* XRX200_MAC_IER                 MAC Interrupt EnableRegister */
-+//	{0x2320,	 0,	 8,	0x00}, /* XRX200_MAC_IER_MACIEN          MAC Interrupt Enable */
-+//	{0x2324,	 0,	16,	0x00}, /* XRX200_MAC_ISR                 MAC Interrupt StatusRegister */
-+//	{0x2324,	 0,	 8,	0x00}, /* XRX200_MAC_ISR_MACINT          MAC Interrupt */
-+//	{0x2400,	 0,	16,	0x30}, /* XRX200_MAC_PSTAT               MAC Port Status Register */
-+//	{0x2400,	11,	 1,	0x30}, /* XRX200_MAC_PSTAT_PACT          PHY Active Status */
-+	{0x2400,	10,	 1,	0x30}, /* XRX200_MAC_PSTAT_GBIT          Gigabit Speed Status */
-+	{0x2400,	 9,	 1,	0x30}, /* XRX200_MAC_PSTAT_MBIT          Megabit Speed Status */
-+	{0x2400,	 8,	 1,	0x30}, /* XRX200_MAC_PSTAT_FDUP          Full Duplex Status */
-+//	{0x2400,	 7,	 1,	0x30}, /* XRX200_MAC_PSTAT_RXPAU         Receive Pause Status */
-+//	{0x2400,	 6,	 1,	0x30}, /* XRX200_MAC_PSTAT_TXPAU         Transmit Pause Status */
-+//	{0x2400,	 5,	 1,	0x30}, /* XRX200_MAC_PSTAT_RXPAUEN       Receive Pause Enable Status */
-+//	{0x2400,	 4,	 1,	0x30}, /* XRX200_MAC_PSTAT_TXPAUEN       Transmit Pause Enable Status */
-+	{0x2400,	 3,	 1,	0x30}, /* XRX200_MAC_PSTAT_LSTAT         Link Status */
-+//	{0x2400,	 2,	 1,	0x30}, /* XRX200_MAC_PSTAT_CRS           Carrier Sense Status */
-+//	{0x2400,	 1,	 1,	0x30}, /* XRX200_MAC_PSTAT_TXLPI         Transmit Low-power Idle Status */
-+//	{0x2400,	 0,	 1,	0x30}, /* XRX200_MAC_PSTAT_RXLPI         Receive Low-power Idle Status */
-+//	{0x2404,	 0,	16,	0x30}, /* XRX200_MAC_PISR                MAC Interrupt Status Register */
-+//	{0x2404,	13,	 1,	0x30}, /* XRX200_MAC_PISR_PACT           PHY Active Status */
-+//	{0x2404,	12,	 1,	0x30}, /* XRX200_MAC_PISR_SPEED          Megabit Speed Status */
-+//	{0x2404,	11,	 1,	0x30}, /* XRX200_MAC_PISR_FDUP           Full Duplex Status */
-+//	{0x2404,	10,	 1,	0x30}, /* XRX200_MAC_PISR_RXPAUEN        Receive Pause Enable Status */
-+//	{0x2404,	 9,	 1,	0x30}, /* XRX200_MAC_PISR_TXPAUEN        Transmit Pause Enable Status */
-+//	{0x2404,	 8,	 1,	0x30}, /* XRX200_MAC_PISR_LPIOFF         Receive Low-power Idle Mode is left */
-+//	{0x2404,	 7,	 1,	0x30}, /* XRX200_MAC_PISR_LPION          Receive Low-power Idle Mode is entered */
-+//	{0x2404,	 6,	 1,	0x30}, /* XRX200_MAC_PISR_JAM            Jam Status Detected */
-+//	{0x2404,	 5,	 1,	0x30}, /* XRX200_MAC_PISR_TOOSHORT       Too Short Frame Error Detected */
-+//	{0x2404,	 4,	 1,	0x30}, /* XRX200_MAC_PISR_TOOLONG        Too Long Frame Error Detected */
-+//	{0x2404,	 3,	 1,	0x30}, /* XRX200_MAC_PISR_LENERR         Length Mismatch Error Detected */
-+//	{0x2404,	 2,	 1,	0x30}, /* XRX200_MAC_PISR_FCSERR         Frame Checksum Error Detected */
-+//	{0x2404,	 1,	 1,	0x30}, /* XRX200_MAC_PISR_TXPAUSE        Pause Frame Transmitted */
-+//	{0x2404,	 0,	 1,	0x30}, /* XRX200_MAC_PISR_RXPAUSE        Pause Frame Received */
-+//	{0x2408,	 0,	16,	0x30}, /* XRX200_MAC_PIER                MAC Interrupt Enable Register */
-+//	{0x2408,	13,	 1,	0x30}, /* XRX200_MAC_PIER_PACT           PHY Active Status */
-+//	{0x2408,	12,	 1,	0x30}, /* XRX200_MAC_PIER_SPEED          Megabit Speed Status */
-+//	{0x2408,	11,	 1,	0x30}, /* XRX200_MAC_PIER_FDUP           Full Duplex Status */
-+//	{0x2408,	10,	 1,	0x30}, /* XRX200_MAC_PIER_RXPAUEN        Receive Pause Enable Status */
-+//	{0x2408,	 9,	 1,	0x30}, /* XRX200_MAC_PIER_TXPAUEN        Transmit Pause Enable Status */
-+//	{0x2408,	 8,	 1,	0x30}, /* XRX200_MAC_PIER_LPIOFF         Low-power Idle Off Interrupt Mask */
-+//	{0x2408,	 7,	 1,	0x30}, /* XRX200_MAC_PIER_LPION          Low-power Idle On Interrupt Mask */
-+//	{0x2408,	 6,	 1,	0x30}, /* XRX200_MAC_PIER_JAM            Jam Status Interrupt Mask */
-+//	{0x2408,	 5,	 1,	0x30}, /* XRX200_MAC_PIER_TOOSHORT       Too Short Frame Error Interrupt Mask */
-+//	{0x2408,	 4,	 1,	0x30}, /* XRX200_MAC_PIER_TOOLONG        Too Long Frame Error Interrupt Mask */
-+//	{0x2408,	 3,	 1,	0x30}, /* XRX200_MAC_PIER_LENERR         Length Mismatch Error Interrupt Mask */
-+//	{0x2408,	 2,	 1,	0x30}, /* XRX200_MAC_PIER_FCSERR         Frame Checksum Error Interrupt Mask */
-+//	{0x2408,	 1,	 1,	0x30}, /* XRX200_MAC_PIER_TXPAUSE        Transmit Pause Frame Interrupt Mask */
-+//	{0x2408,	 0,	 1,	0x30}, /* XRX200_MAC_PIER_RXPAUSE        Receive Pause Frame Interrupt Mask */
-+//	{0x240C,	 0,	16,	0x30}, /* XRX200_MAC_CTRL_0              MAC Control Register0 */
-+//	{0x240C,	13,	 2,	0x30}, /* XRX200_MAC_CTRL_0_LCOL         Late Collision Control */
-+//	{0x240C,	12,	 1,	0x30}, /* XRX200_MAC_CTRL_0_BM           Burst Mode Control */
-+//	{0x240C,	11,	 1,	0x30}, /* XRX200_MAC_CTRL_0_APADEN       Automatic VLAN Padding Enable */
-+//	{0x240C,	10,	 1,	0x30}, /* XRX200_MAC_CTRL_0_VPAD2EN      Stacked VLAN Padding Enable */
-+//	{0x240C,	 9,	 1,	0x30}, /* XRX200_MAC_CTRL_0_VPADEN       VLAN Padding Enable */
-+//	{0x240C,	 8,	 1,	0x30}, /* XRX200_MAC_CTRL_0_PADEN        Padding Enable */
-+//	{0x240C,	 7,	 1,	0x30}, /* XRX200_MAC_CTRL_0_FCS          Transmit FCS Control */
-+	{0x240C,	 4,	 3,	0x30}, /* XRX200_MAC_CTRL_0_FCON         Flow Control Mode */
-+//	{0x240C,	 2,	 2,	0x30}, /* XRX200_MAC_CTRL_0_FDUP         Full Duplex Control */
-+//	{0x240C,	 0,	 2,	0x30}, /* XRX200_MAC_CTRL_0_GMII         GMII/MII interface mode selection */
-+//	{0x2410,	 0,	16,	0x30}, /* XRX200_MAC_CTRL_1              MAC Control Register1 */
-+//	{0x2410,	 8,	 1,	0x30}, /* XRX200_MAC_CTRL_1_SHORTPRE     Short Preamble Control */
-+//	{0x2410,	 0,	 4,	0x30}, /* XRX200_MAC_CTRL_1_IPG          Minimum Inter Packet Gap Size */
-+//	{0x2414,	 0,	16,	0x30}, /* XRX200_MAC_CTRL_2              MAC Control Register2 */
-+//	{0x2414,	 3,	 1,	0x30}, /* XRX200_MAC_CTRL_2_MLEN         Maximum Untagged Frame Length */
-+//	{0x2414,	 2,	 1,	0x30}, /* XRX200_MAC_CTRL_2_LCHKL        Frame Length Check Long Enable */
-+//	{0x2414,	 0,	 2,	0x30}, /* XRX200_MAC_CTRL_2_LCHKS        Frame Length Check Short Enable */
-+//	{0x2418,	 0,	16,	0x30}, /* XRX200_MAC_CTRL_3              MAC Control Register3 */
-+//	{0x2418,	 0,	 4,	0x30}, /* XRX200_MAC_CTRL_3_RCNT         Retry Count */
-+//	{0x241C,	 0,	16,	0x30}, /* XRX200_MAC_CTRL_4              MAC Control Register4 */
-+//	{0x241C,	 7,	 1,	0x30}, /* XRX200_MAC_CTRL_4_LPIEN        LPI Mode Enable */
-+//	{0x241C,	 0,	 7,	0x30}, /* XRX200_MAC_CTRL_4_WAIT         LPI Wait Time */
-+//	{0x2420,	 0,	16,	0x30}, /* XRX200_MAC_CTRL_5_PJPS         MAC Control Register5 */
-+//	{0x2420,	 1,	 1,	0x30}, /* XRX200_MAC_CTRL_5_PJPS_NOBP    Prolonged Jam pattern size during no-backpressure state */
-+//	{0x2420,	 0,	 1,	0x30}, /* XRX200_MAC_CTRL_5_PJPS_BP      Prolonged Jam pattern size during backpressure state */
-+//	{0x2424,	 0,	16,	0x30}, /* XRX200_MAC_CTRL_6_XBUF         Transmit and ReceiveBuffer Control Register */
-+//	{0x2424,	 9,	 3,	0x30}, /* XRX200_MAC_CTRL_6_RBUF_DLY_WP  Delay */
-+//	{0x2424,	 8,	 1,	0x30}, /* XRX200_MAC_CTRL_6_RBUF_INIT    Receive Buffer Initialization */
-+//	{0x2424,	 6,	 1,	0x30}, /* XRX200_MAC_CTRL_6_RBUF_BYPASS  Bypass the Receive Buffer */
-+//	{0x2424,	 3,	 3,	0x30}, /* XRX200_MAC_CTRL_6_XBUF_DLY_WP  Delay */
-+//	{0x2424,	 2,	 1,	0x30}, /* XRX200_MAC_CTRL_6_XBUF_INIT    Initialize the Transmit Buffer */
-+//	{0x2424,	 0,	 1,	0x30}, /* XRX200_MAC_CTRL_6_XBUF_BYPASS  Bypass the Transmit Buffer */
-+//	{0x2428,	 0,	16,	0x30}, /* XRX200_MAC_BUFST_XBUF          MAC Receive and TransmitBuffer Status Register */
-+//	{0x2428,	 3,	 1,	0x30}, /* XRX200_MAC_BUFST_RBUF_UFL      Receive Buffer Underflow Indicator */
-+//	{0x2428,	 2,	 1,	0x30}, /* XRX200_MAC_BUFST_RBUF_OFL      Receive Buffer Overflow Indicator */
-+//	{0x2428,	 1,	 1,	0x30}, /* XRX200_MAC_BUFST_XBUF_UFL      Transmit Buffer Underflow Indicator */
-+//	{0x2428,	 0,	 1,	0x30}, /* XRX200_MAC_BUFST_XBUF_OFL      Transmit Buffer Overflow Indicator */
-+//	{0x242C,	 0,	16,	0x30}, /* XRX200_MAC_TESTEN              MAC Test Enable Register */
-+//	{0x242C,	 2,	 1,	0x30}, /* XRX200_MAC_TESTEN_JTEN         Jitter Test Enable */
-+//	{0x242C,	 1,	 1,	0x30}, /* XRX200_MAC_TESTEN_TXER         Transmit Error Insertion */
-+//	{0x242C,	 0,	 1,	0x30}, /* XRX200_MAC_TESTEN_LOOP         MAC Loopback Enable */
-+//	{0x2900,	 0,	16,	0x00}, /* XRX200_FDMA_CTRL               Ethernet Switch FetchDMA Control Register */
-+//	{0x2900,	 7,	 5,	0x00}, /* XRX200_FDMA_CTRL_LPI_THRESHOLD Low Power Idle Threshold */
-+//	{0x2900,	 4,	 3,	0x00}, /* XRX200_FDMA_CTRL_LPI_MODE      Low Power Idle Mode */
-+//	{0x2900,	 2,	 2,	0x00}, /* XRX200_FDMA_CTRL_EGSTAG        Egress Special Tag Size */
-+//	{0x2900,	 1,	 1,	0x00}, /* XRX200_FDMA_CTRL_IGSTAG        Ingress Special Tag Size */
-+//	{0x2900,	 0,	 1,	0x00}, /* XRX200_FDMA_CTRL_EXCOL         Excessive Collision Handling */
-+//	{0x2904,	 0,	16,	0x00}, /* XRX200_FDMA_STETYPE            Special Tag EthertypeControl Register */
-+//	{0x2904,	 0,	16,	0x00}, /* XRX200_FDMA_STETYPE_ETYPE      Special Tag Ethertype */
-+//	{0x2908,	 0,	16,	0x00}, /* XRX200_FDMA_VTETYPE            VLAN Tag EthertypeControl Register */
-+//	{0x2908,	 0,	16,	0x00}, /* XRX200_FDMA_VTETYPE_ETYPE      VLAN Tag Ethertype */
-+//	{0x290C,	 0,	16,	0x00}, /* XRX200_FDMA_STAT_0             FDMA Status Register0 */
-+//	{0x290C,	 0,	16,	0x00}, /* XRX200_FDMA_STAT_0_FSMS        FSM states status */
-+//	{0x2910,	 0,	16,	0x00}, /* XRX200_FDMA_IER                Fetch DMA Global InterruptEnable Register */
-+//	{0x2910,	14,	 1,	0x00}, /* XRX200_FDMA_IER_PCKD           Packet Drop Interrupt Enable */
-+//	{0x2910,	13,	 1,	0x00}, /* XRX200_FDMA_IER_PCKR           Packet Ready Interrupt Enable */
-+//	{0x2910,	 0,	 8,	0x00}, /* XRX200_FDMA_IER_PCKT           Packet Sent Interrupt Enable */
-+//	{0x2914,	 0,	16,	0x00}, /* XRX200_FDMA_ISR                Fetch DMA Global InterruptStatus Register */
-+//	{0x2914,	14,	 1,	0x00}, /* XRX200_FDMA_ISR_PCKTD          Packet Drop */
-+//	{0x2914,	13,	 1,	0x00}, /* XRX200_FDMA_ISR_PCKR           Packet is Ready for Transmission */
-+//	{0x2914,	 0,	 8,	0x00}, /* XRX200_FDMA_ISR_PCKT           Packet Sent Event */
-+//	{0x2A00,	 0,	16,	0x18}, /* XRX200_FDMA_PCTRL              Ethernet SwitchFetch DMA Port Control Register */
-+//	{0x2A00,	 3,	 2,	0x18}, /* XRX200_FDMA_PCTRL_VLANMOD      VLAN Modification Enable */
-+//	{0x2A00,	 2,	 1,	0x18}, /* XRX200_FDMA_PCTRL_DSCPRM       DSCP Re-marking Enable */
-+//	{0x2A00,	 1,	 1,	0x18}, /* XRX200_FDMA_PCTRL_STEN         Special Tag Insertion Enable */
-+//	{0x2A00,	 0,	 1,	0x18}, /* XRX200_FDMA_PCTRL_EN           FDMA Port Enable */
-+//	{0x2A04,	 0,	16,	0x18}, /* XRX200_FDMA_PRIO               Ethernet SwitchFetch DMA Port Priority Register */
-+//	{0x2A04,	 0,	 2,	0x18}, /* XRX200_FDMA_PRIO_PRIO          FDMA PRIO */
-+//	{0x2A08,	 0,	16,	0x18}, /* XRX200_FDMA_PSTAT0             Ethernet SwitchFetch DMA Port Status Register 0 */
-+//	{0x2A08,	15,	 1,	0x18}, /* XRX200_FDMA_PSTAT0_PKT_AVAIL   Port Egress Packet Available */
-+//	{0x2A08,	14,	 1,	0x18}, /* XRX200_FDMA_PSTAT0_POK         Port Status OK */
-+//	{0x2A08,	 0,	 6,	0x18}, /* XRX200_FDMA_PSTAT0_PSEG        Port Egress Segment Count */
-+//	{0x2A0C,	 0,	16,	0x18}, /* XRX200_FDMA_PSTAT1_HDR         Ethernet SwitchFetch DMA Port Status Register 1 */
-+//	{0x2A0C,	 0,	10,	0x18}, /* XRX200_FDMA_PSTAT1_HDR_PTR     Header Pointer */
-+//	{0x2A10,	 0,	16,	0x18}, /* XRX200_FDMA_TSTAMP0            Egress TimeStamp Register 0 */
-+//	{0x2A10,	 0,	16,	0x18}, /* XRX200_FDMA_TSTAMP0_TSTL       Time Stamp [15:0] */
-+//	{0x2A14,	 0,	16,	0x18}, /* XRX200_FDMA_TSTAMP1            Egress TimeStamp Register 1 */
-+//	{0x2A14,	 0,	16,	0x18}, /* XRX200_FDMA_TSTAMP1_TSTH       Time Stamp [31:16] */
-+//	{0x2D00,	 0,	16,	0x00}, /* XRX200_SDMA_CTRL               Ethernet Switch StoreDMA Control Register */
-+//	{0x2D00,	 0,	 1,	0x00}, /* XRX200_SDMA_CTRL_TSTEN         Time Stamp Enable */
-+//	{0x2D04,	 0,	16,	0x00}, /* XRX200_SDMA_FCTHR1             SDMA Flow Control Threshold1 Register */
-+//	{0x2D04,	 0,	10,	0x00}, /* XRX200_SDMA_FCTHR1_THR1        Threshold 1 */
-+//	{0x2D08,	 0,	16,	0x00}, /* XRX200_SDMA_FCTHR2             SDMA Flow Control Threshold2 Register */
-+//	{0x2D08,	 0,	10,	0x00}, /* XRX200_SDMA_FCTHR2_THR2        Threshold 2 */
-+//	{0x2D0C,	 0,	16,	0x00}, /* XRX200_SDMA_FCTHR3             SDMA Flow Control Threshold3 Register */
-+//	{0x2D0C,	 0,	10,	0x00}, /* XRX200_SDMA_FCTHR3_THR3        Threshold 3 */
-+//	{0x2D10,	 0,	16,	0x00}, /* XRX200_SDMA_FCTHR4             SDMA Flow Control Threshold4 Register */
-+//	{0x2D10,	 0,	10,	0x00}, /* XRX200_SDMA_FCTHR4_THR4        Threshold 4 */
-+//	{0x2D14,	 0,	16,	0x00}, /* XRX200_SDMA_FCTHR5             SDMA Flow Control Threshold5 Register */
-+//	{0x2D14,	 0,	10,	0x00}, /* XRX200_SDMA_FCTHR5_THR5        Threshold 5 */
-+//	{0x2D18,	 0,	16,	0x00}, /* XRX200_SDMA_FCTHR6             SDMA Flow Control Threshold6 Register */
-+//	{0x2D18,	 0,	10,	0x00}, /* XRX200_SDMA_FCTHR6_THR6        Threshold 6 */
-+//	{0x2D1C,	 0,	16,	0x00}, /* XRX200_SDMA_FCTHR7             SDMA Flow Control Threshold7 Register */
-+//	{0x2D1C,	 0,	11,	0x00}, /* XRX200_SDMA_FCTHR7_THR7        Threshold 7 */
-+//	{0x2D20,	 0,	16,	0x00}, /* XRX200_SDMA_STAT_0             SDMA Status Register0 */
-+//	{0x2D20,	 4,	 3,	0x00}, /* XRX200_SDMA_STAT_0_BPS_FILL    Back Pressure Status */
-+//	{0x2D20,	 2,	 2,	0x00}, /* XRX200_SDMA_STAT_0_BPS_PNT     Back Pressure Status */
-+//	{0x2D20,	 0,	 2,	0x00}, /* XRX200_SDMA_STAT_0_DROP        Back Pressure Status */
-+//	{0x2D24,	 0,	16,	0x00}, /* XRX200_SDMA_STAT_1             SDMA Status Register1 */
-+//	{0x2D24,	 0,	10,	0x00}, /* XRX200_SDMA_STAT_1_FILL        Buffer Filling Level */
-+//	{0x2D28,	 0,	16,	0x00}, /* XRX200_SDMA_STAT_2             SDMA Status Register2 */
-+//	{0x2D28,	 0,	16,	0x00}, /* XRX200_SDMA_STAT_2_FSMS        FSM states status */
-+//	{0x2D2C,	 0,	16,	0x00}, /* XRX200_SDMA_IER                SDMA Interrupt Enable Register */
-+//	{0x2D2C,	15,	 1,	0x00}, /* XRX200_SDMA_IER_BPEX           Buffer Pointers Exceeded */
-+//	{0x2D2C,	14,	 1,	0x00}, /* XRX200_SDMA_IER_BFULL          Buffer Full */
-+//	{0x2D2C,	13,	 1,	0x00}, /* XRX200_SDMA_IER_FERR           Frame Error */
-+//	{0x2D2C,	 0,	 8,	0x00}, /* XRX200_SDMA_IER_FRX            Frame Received Successfully */
-+//	{0x2D30,	 0,	16,	0x00}, /* XRX200_SDMA_ISR                SDMA Interrupt Status Register */
-+//	{0x2D30,	15,	 1,	0x00}, /* XRX200_SDMA_ISR_BPEX           Packet Descriptors Exceeded */
-+//	{0x2D30,	14,	 1,	0x00}, /* XRX200_SDMA_ISR_BFULL          Buffer Full */
-+//	{0x2D30,	13,	 1,	0x00}, /* XRX200_SDMA_ISR_FERR           Frame Error */
-+//	{0x2D30,	 0,	 8,	0x00}, /* XRX200_SDMA_ISR_FRX            Frame Received Successfully */
-+//	{0x2F00,	 0,	16,	0x18}, /* XRX200_SDMA_PCTRL              Ethernet SwitchStore DMA Port Control Register */
-+//	{0x2F00,	13,	 2,	0x18}, /* XRX200_SDMA_PCTRL_DTHR         Drop Threshold Selection */
-+//	{0x2F00,	11,	 2,	0x18}, /* XRX200_SDMA_PCTRL_PTHR         Pause Threshold Selection */
-+//	{0x2F00,	10,	 1,	0x18}, /* XRX200_SDMA_PCTRL_PHYEFWD      Forward PHY Error Frames */
-+//	{0x2F00,	 9,	 1,	0x18}, /* XRX200_SDMA_PCTRL_ALGFWD       Forward Alignment Error Frames */
-+//	{0x2F00,	 8,	 1,	0x18}, /* XRX200_SDMA_PCTRL_LENFWD       Forward Length Errored Frames */
-+//	{0x2F00,	 7,	 1,	0x18}, /* XRX200_SDMA_PCTRL_OSFWD        Forward Oversized Frames */
-+//	{0x2F00,	 6,	 1,	0x18}, /* XRX200_SDMA_PCTRL_USFWD        Forward Undersized Frames */
-+//	{0x2F00,	 5,	 1,	0x18}, /* XRX200_SDMA_PCTRL_FCSIGN       Ignore FCS Errors */
-+//	{0x2F00,	 4,	 1,	0x18}, /* XRX200_SDMA_PCTRL_FCSFWD       Forward FCS Errored Frames */
-+//	{0x2F00,	 3,	 1,	0x18}, /* XRX200_SDMA_PCTRL_PAUFWD       Pause Frame Forwarding */
-+//	{0x2F00,	 2,	 1,	0x18}, /* XRX200_SDMA_PCTRL_MFCEN        Metering Flow Control Enable */
-+//	{0x2F00,	 1,	 1,	0x18}, /* XRX200_SDMA_PCTRL_FCEN         Flow Control Enable */
-+//	{0x2F00,	 0,	 1,	0x18}, /* XRX200_SDMA_PCTRL_PEN          Port Enable */
-+//	{0x2F04,	 0,	16,	0x18}, /* XRX200_SDMA_PRIO               Ethernet SwitchStore DMA Port Priority Register */
-+//	{0x2F04,	 0,	 2,	0x18}, /* XRX200_SDMA_PRIO_PRIO          SDMA PRIO */
-+//	{0x2F08,	 0,	16,	0x18}, /* XRX200_SDMA_PSTAT0_HDR         Ethernet SwitchStore DMA Port Status Register 0 */
-+//	{0x2F08,	 0,	10,	0x18}, /* XRX200_SDMA_PSTAT0_HDR_PTR     Port Ingress Queue Header Pointer */
-+//	{0x2F0C,	 0,	16,	0x18}, /* XRX200_SDMA_PSTAT1             Ethernet SwitchStore DMA Port Status Register 1 */
-+//	{0x2F0C,	 0,	10,	0x18}, /* XRX200_SDMA_PSTAT1_PPKT        Port Ingress Packet Count */
-+//	{0x2F10,	 0,	16,	0x18}, /* XRX200_SDMA_TSTAMP0            Ingress TimeStamp Register 0 */
-+//	{0x2F10,	 0,	16,	0x18}, /* XRX200_SDMA_TSTAMP0_TSTL       Time Stamp [15:0] */
-+//	{0x2F14,	 0,	16,	0x18}, /* XRX200_SDMA_TSTAMP1            Ingress TimeStamp Register 1 */
-+//	{0x2F14,	 0,	16,	0x18}, /* XRX200_SDMA_TSTAMP1_TSTH       Time Stamp [31:16] */
-+};
-+
-+
diff --git a/target/linux/lantiq/patches-3.18/0026-NET-multi-phy-support.patch b/target/linux/lantiq/patches-3.18/0026-NET-multi-phy-support.patch
deleted file mode 100644
index 5943602adb..0000000000
--- a/target/linux/lantiq/patches-3.18/0026-NET-multi-phy-support.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From c6feeeb407a3b8a6597ae377ba4dd138e185e3dd Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Sun, 27 Jul 2014 09:38:50 +0100
-Subject: [PATCH 26/36] NET: multi phy support
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/net/phy/phy.c |    9 ++++++---
- include/linux/phy.h   |    1 +
- 2 files changed, 7 insertions(+), 3 deletions(-)
-
---- a/drivers/net/phy/phy.c
-+++ b/drivers/net/phy/phy.c
-@@ -838,7 +838,8 @@ void phy_state_machine(struct work_struc
- 		/* If the link is down, give up on negotiation for now */
- 		if (!phydev->link) {
- 			phydev->state = PHY_NOLINK;
--			netif_carrier_off(phydev->attached_dev);
-+			if (!phydev->no_auto_carrier_off)
-+				netif_carrier_off(phydev->attached_dev);
- 			phydev->adjust_link(phydev->attached_dev);
- 			break;
- 		}
-@@ -911,7 +912,8 @@ void phy_state_machine(struct work_struc
- 			netif_carrier_on(phydev->attached_dev);
- 		} else {
- 			phydev->state = PHY_NOLINK;
--			netif_carrier_off(phydev->attached_dev);
-+			if (!phydev->no_auto_carrier_off)
-+				netif_carrier_off(phydev->attached_dev);
- 		}
- 
- 		phydev->adjust_link(phydev->attached_dev);
-@@ -923,7 +925,8 @@ void phy_state_machine(struct work_struc
- 	case PHY_HALTED:
- 		if (phydev->link) {
- 			phydev->link = 0;
--			netif_carrier_off(phydev->attached_dev);
-+			if (!phydev->no_auto_carrier_off)
-+				netif_carrier_off(phydev->attached_dev);
- 			phydev->adjust_link(phydev->attached_dev);
- 			do_suspend = true;
- 		}
---- a/include/linux/phy.h
-+++ b/include/linux/phy.h
-@@ -364,6 +364,7 @@ struct phy_device {
- 	bool is_c45;
- 	bool is_internal;
- 	bool has_fixups;
-+	bool no_auto_carrier_off;
- 
- 	enum phy_state state;
- 
diff --git a/target/linux/lantiq/patches-3.18/0028-NET-lantiq-various-etop-fixes.patch b/target/linux/lantiq/patches-3.18/0028-NET-lantiq-various-etop-fixes.patch
deleted file mode 100644
index 187e301ed2..0000000000
--- a/target/linux/lantiq/patches-3.18/0028-NET-lantiq-various-etop-fixes.patch
+++ /dev/null
@@ -1,908 +0,0 @@
-From 870ed9cae083ff8a60a739ef7e74c5a1800533be Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Tue, 9 Sep 2014 22:45:34 +0200
-Subject: [PATCH 28/36] NET: lantiq: various etop fixes
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/net/ethernet/lantiq_etop.c |  555 +++++++++++++++++++++++++-----------
- 1 file changed, 389 insertions(+), 166 deletions(-)
-
---- a/drivers/net/ethernet/lantiq_etop.c
-+++ b/drivers/net/ethernet/lantiq_etop.c
-@@ -11,7 +11,7 @@
-  *   You should have received a copy of the GNU General Public License
-  *   along with this program; if not, see <http://www.gnu.org/licenses/>.
-  *
-- *   Copyright (C) 2011 John Crispin <blogic@openwrt.org>
-+ *   Copyright (C) 2011-12 John Crispin <blogic@openwrt.org>
-  */
- 
- #include <linux/kernel.h>
-@@ -30,11 +30,16 @@
- #include <linux/mm.h>
- #include <linux/platform_device.h>
- #include <linux/ethtool.h>
-+#include <linux/if_vlan.h>
- #include <linux/init.h>
- #include <linux/delay.h>
- #include <linux/io.h>
- #include <linux/dma-mapping.h>
- #include <linux/module.h>
-+#include <linux/clk.h>
-+#include <linux/of_net.h>
-+#include <linux/of_irq.h>
-+#include <linux/of_platform.h>
- 
- #include <asm/checksum.h>
- 
-@@ -42,7 +47,7 @@
- #include <xway_dma.h>
- #include <lantiq_platform.h>
- 
--#define LTQ_ETOP_MDIO		0x11804
-+#define LTQ_ETOP_MDIO_ACC	0x11804
- #define MDIO_REQUEST		0x80000000
- #define MDIO_READ		0x40000000
- #define MDIO_ADDR_MASK		0x1f
-@@ -51,44 +56,91 @@
- #define MDIO_REG_OFFSET		0x10
- #define MDIO_VAL_MASK		0xffff
- 
--#define PPE32_CGEN		0x800
--#define LQ_PPE32_ENET_MAC_CFG	0x1840
-+#define LTQ_ETOP_MDIO_CFG       0x11800
-+#define MDIO_CFG_MASK           0x6
-+
-+#define LTQ_ETOP_CFG            0x11808
-+#define LTQ_ETOP_IGPLEN         0x11820
-+#define LTQ_ETOP_MAC_CFG	0x11840
- 
- #define LTQ_ETOP_ENETS0		0x11850
- #define LTQ_ETOP_MAC_DA0	0x1186C
- #define LTQ_ETOP_MAC_DA1	0x11870
--#define LTQ_ETOP_CFG		0x16020
--#define LTQ_ETOP_IGPLEN		0x16080
-+
-+#define MAC_CFG_MASK		0xfff
-+#define MAC_CFG_CGEN		(1 << 11)
-+#define MAC_CFG_DUPLEX		(1 << 2)
-+#define MAC_CFG_SPEED		(1 << 1)
-+#define MAC_CFG_LINK		(1 << 0)
- 
- #define MAX_DMA_CHAN		0x8
- #define MAX_DMA_CRC_LEN		0x4
- #define MAX_DMA_DATA_LEN	0x600
- 
- #define ETOP_FTCU		BIT(28)
--#define ETOP_MII_MASK		0xf
--#define ETOP_MII_NORMAL		0xd
--#define ETOP_MII_REVERSE	0xe
- #define ETOP_PLEN_UNDER		0x40
--#define ETOP_CGEN		0x800
-+#define ETOP_CFG_MII0		0x01
- 
--/* use 2 static channels for TX/RX */
--#define LTQ_ETOP_TX_CHANNEL	1
--#define LTQ_ETOP_RX_CHANNEL	6
--#define IS_TX(x)		(x == LTQ_ETOP_TX_CHANNEL)
--#define IS_RX(x)		(x == LTQ_ETOP_RX_CHANNEL)
-+#define ETOP_CFG_MASK           0xfff
-+#define ETOP_CFG_FEN0		(1 << 8)
-+#define ETOP_CFG_SEN0		(1 << 6)
-+#define ETOP_CFG_OFF1		(1 << 3)
-+#define ETOP_CFG_REMII0		(1 << 1)
-+#define ETOP_CFG_OFF0		(1 << 0)
-+
-+#define LTQ_GBIT_MDIO_CTL	0xCC
-+#define LTQ_GBIT_MDIO_DATA	0xd0
-+#define LTQ_GBIT_GCTL0		0x68
-+#define LTQ_GBIT_PMAC_HD_CTL	0x8c
-+#define LTQ_GBIT_P0_CTL		0x4
-+#define LTQ_GBIT_PMAC_RX_IPG	0xa8
-+#define LTQ_GBIT_RGMII_CTL	0x78
-+
-+#define PMAC_HD_CTL_AS		(1 << 19)
-+#define PMAC_HD_CTL_RXSH	(1 << 22)
-+
-+/* Switch Enable (0=disable, 1=enable) */
-+#define GCTL0_SE		0x80000000
-+/* Disable MDIO auto polling (0=disable, 1=enable) */
-+#define PX_CTL_DMDIO		0x00400000
-+
-+/* MDC clock divider, clock = 25MHz/((MDC_CLOCK + 1) * 2) */
-+#define MDC_CLOCK_MASK		0xff000000
-+#define MDC_CLOCK_OFFSET	24
-+
-+/* register information for the gbit's MDIO bus */
-+#define MDIO_XR9_REQUEST	0x00008000
-+#define MDIO_XR9_READ		0x00000800
-+#define MDIO_XR9_WRITE		0x00000400
-+#define MDIO_XR9_REG_MASK	0x1f
-+#define MDIO_XR9_ADDR_MASK	0x1f
-+#define MDIO_XR9_RD_MASK	0xffff
-+#define MDIO_XR9_REG_OFFSET	0
-+#define MDIO_XR9_ADDR_OFFSET	5
-+#define MDIO_XR9_WR_OFFSET	16
- 
-+#define LTQ_DMA_ETOP	((of_machine_is_compatible("lantiq,ase")) ? \
-+			(INT_NUM_IM3_IRL0) : (INT_NUM_IM2_IRL0))
-+
-+/* the newer xway socks have a embedded 3/7 port gbit multiplexer */
- #define ltq_etop_r32(x)		ltq_r32(ltq_etop_membase + (x))
- #define ltq_etop_w32(x, y)	ltq_w32(x, ltq_etop_membase + (y))
- #define ltq_etop_w32_mask(x, y, z)	\
- 		ltq_w32_mask(x, y, ltq_etop_membase + (z))
- 
--#define DRV_VERSION	"1.0"
-+#define ltq_gbit_r32(x)		ltq_r32(ltq_gbit_membase + (x))
-+#define ltq_gbit_w32(x, y)	ltq_w32(x, ltq_gbit_membase + (y))
-+#define ltq_gbit_w32_mask(x, y, z)	\
-+		ltq_w32_mask(x, y, ltq_gbit_membase + (z))
-+
-+#define DRV_VERSION	"1.2"
- 
- static void __iomem *ltq_etop_membase;
-+static void __iomem *ltq_gbit_membase;
- 
- struct ltq_etop_chan {
--	int idx;
- 	int tx_free;
-+	int irq;
- 	struct net_device *netdev;
- 	struct napi_struct napi;
- 	struct ltq_dma_channel dma;
-@@ -98,22 +150,35 @@ struct ltq_etop_chan {
- struct ltq_etop_priv {
- 	struct net_device *netdev;
- 	struct platform_device *pdev;
--	struct ltq_eth_data *pldata;
- 	struct resource *res;
- 
- 	struct mii_bus *mii_bus;
- 	struct phy_device *phydev;
- 
--	struct ltq_etop_chan ch[MAX_DMA_CHAN];
--	int tx_free[MAX_DMA_CHAN >> 1];
-+	struct ltq_etop_chan txch;
-+	struct ltq_etop_chan rxch;
-+
-+	int tx_irq;
-+	int rx_irq;
-+
-+	const void *mac;
-+	int mii_mode;
- 
- 	spinlock_t lock;
-+
-+	struct clk *clk_ppe;
-+	struct clk *clk_switch;
-+	struct clk *clk_ephy;
-+	struct clk *clk_ephycgu;
- };
- 
-+static int ltq_etop_mdio_wr(struct mii_bus *bus, int phy_addr,
-+				int phy_reg, u16 phy_data);
-+
- static int
- ltq_etop_alloc_skb(struct ltq_etop_chan *ch)
- {
--	ch->skb[ch->dma.desc] = netdev_alloc_skb(ch->netdev, MAX_DMA_DATA_LEN);
-+	ch->skb[ch->dma.desc] = dev_alloc_skb(MAX_DMA_DATA_LEN);
- 	if (!ch->skb[ch->dma.desc])
- 		return -ENOMEM;
- 	ch->dma.desc_base[ch->dma.desc].addr = dma_map_single(NULL,
-@@ -148,8 +213,11 @@ ltq_etop_hw_receive(struct ltq_etop_chan
- 	spin_unlock_irqrestore(&priv->lock, flags);
- 
- 	skb_put(skb, len);
-+	skb->dev = ch->netdev;
- 	skb->protocol = eth_type_trans(skb, ch->netdev);
- 	netif_receive_skb(skb);
-+	ch->netdev->stats.rx_packets++;
-+	ch->netdev->stats.rx_bytes += len;
- }
- 
- static int
-@@ -157,8 +225,10 @@ ltq_etop_poll_rx(struct napi_struct *nap
- {
- 	struct ltq_etop_chan *ch = container_of(napi,
- 				struct ltq_etop_chan, napi);
-+	struct ltq_etop_priv *priv = netdev_priv(ch->netdev);
- 	int rx = 0;
- 	int complete = 0;
-+	unsigned long flags;
- 
- 	while ((rx < budget) && !complete) {
- 		struct ltq_dma_desc *desc = &ch->dma.desc_base[ch->dma.desc];
-@@ -172,7 +242,9 @@ ltq_etop_poll_rx(struct napi_struct *nap
- 	}
- 	if (complete || !rx) {
- 		napi_complete(&ch->napi);
-+		spin_lock_irqsave(&priv->lock, flags);
- 		ltq_dma_ack_irq(&ch->dma);
-+		spin_unlock_irqrestore(&priv->lock, flags);
- 	}
- 	return rx;
- }
-@@ -184,12 +256,14 @@ ltq_etop_poll_tx(struct napi_struct *nap
- 		container_of(napi, struct ltq_etop_chan, napi);
- 	struct ltq_etop_priv *priv = netdev_priv(ch->netdev);
- 	struct netdev_queue *txq =
--		netdev_get_tx_queue(ch->netdev, ch->idx >> 1);
-+		netdev_get_tx_queue(ch->netdev, ch->dma.nr >> 1);
- 	unsigned long flags;
- 
- 	spin_lock_irqsave(&priv->lock, flags);
- 	while ((ch->dma.desc_base[ch->tx_free].ctl &
- 			(LTQ_DMA_OWN | LTQ_DMA_C)) == LTQ_DMA_C) {
-+		ch->netdev->stats.tx_packets++;
-+		ch->netdev->stats.tx_bytes += ch->skb[ch->tx_free]->len;
- 		dev_kfree_skb_any(ch->skb[ch->tx_free]);
- 		ch->skb[ch->tx_free] = NULL;
- 		memset(&ch->dma.desc_base[ch->tx_free], 0,
-@@ -202,7 +276,9 @@ ltq_etop_poll_tx(struct napi_struct *nap
- 	if (netif_tx_queue_stopped(txq))
- 		netif_tx_start_queue(txq);
- 	napi_complete(&ch->napi);
-+	spin_lock_irqsave(&priv->lock, flags);
- 	ltq_dma_ack_irq(&ch->dma);
-+	spin_unlock_irqrestore(&priv->lock, flags);
- 	return 1;
- }
- 
-@@ -210,9 +286,10 @@ static irqreturn_t
- ltq_etop_dma_irq(int irq, void *_priv)
- {
- 	struct ltq_etop_priv *priv = _priv;
--	int ch = irq - LTQ_DMA_CH0_INT;
--
--	napi_schedule(&priv->ch[ch].napi);
-+	if (irq == priv->txch.dma.irq)
-+		napi_schedule(&priv->txch.napi);
-+	else
-+		napi_schedule(&priv->rxch.napi);
- 	return IRQ_HANDLED;
- }
- 
-@@ -224,7 +301,7 @@ ltq_etop_free_channel(struct net_device
- 	ltq_dma_free(&ch->dma);
- 	if (ch->dma.irq)
- 		free_irq(ch->dma.irq, priv);
--	if (IS_RX(ch->idx)) {
-+	if (ch == &priv->txch) {
- 		int desc;
- 		for (desc = 0; desc < LTQ_DESC_NUM; desc++)
- 			dev_kfree_skb_any(ch->skb[ch->dma.desc]);
-@@ -235,65 +312,133 @@ static void
- ltq_etop_hw_exit(struct net_device *dev)
- {
- 	struct ltq_etop_priv *priv = netdev_priv(dev);
--	int i;
- 
--	ltq_pmu_disable(PMU_PPE);
--	for (i = 0; i < MAX_DMA_CHAN; i++)
--		if (IS_TX(i) || IS_RX(i))
--			ltq_etop_free_channel(dev, &priv->ch[i]);
-+	clk_disable(priv->clk_ppe);
-+
-+	if (of_machine_is_compatible("lantiq,ar9"))
-+		clk_disable(priv->clk_switch);
-+
-+	if (of_machine_is_compatible("lantiq,ase")) {
-+		clk_disable(priv->clk_ephy);
-+		clk_disable(priv->clk_ephycgu);
-+	}
-+
-+	ltq_etop_free_channel(dev, &priv->txch);
-+	ltq_etop_free_channel(dev, &priv->rxch);
-+}
-+
-+static void
-+ltq_etop_gbit_init(struct net_device *dev)
-+{
-+	struct ltq_etop_priv *priv = netdev_priv(dev);
-+
-+	clk_enable(priv->clk_switch);
-+
-+	/* enable gbit port0 on the SoC */
-+	ltq_gbit_w32_mask((1 << 17), (1 << 18), LTQ_GBIT_P0_CTL);
-+
-+	ltq_gbit_w32_mask(0, GCTL0_SE, LTQ_GBIT_GCTL0);
-+	/* disable MDIO auto polling mode */
-+	ltq_gbit_w32_mask(0, PX_CTL_DMDIO, LTQ_GBIT_P0_CTL);
-+	/* set 1522 packet size */
-+	ltq_gbit_w32_mask(0x300, 0, LTQ_GBIT_GCTL0);
-+	/* disable pmac & dmac headers */
-+	ltq_gbit_w32_mask(PMAC_HD_CTL_AS | PMAC_HD_CTL_RXSH, 0,
-+		LTQ_GBIT_PMAC_HD_CTL);
-+	/* Due to traffic halt when burst length 8,
-+		replace default IPG value with 0x3B */
-+	ltq_gbit_w32(0x3B, LTQ_GBIT_PMAC_RX_IPG);
-+	/* set mdc clock to 2.5 MHz */
-+	ltq_gbit_w32_mask(MDC_CLOCK_MASK, 4 << MDC_CLOCK_OFFSET,
-+		LTQ_GBIT_RGMII_CTL);
- }
- 
- static int
- ltq_etop_hw_init(struct net_device *dev)
- {
- 	struct ltq_etop_priv *priv = netdev_priv(dev);
--	int i;
-+	int mii_mode = priv->mii_mode;
- 
--	ltq_pmu_enable(PMU_PPE);
-+	clk_enable(priv->clk_ppe);
-+
-+	if (of_machine_is_compatible("lantiq,ar9")) {
-+		ltq_etop_gbit_init(dev);
-+		/* force the etops link to the gbit to MII */
-+		mii_mode = PHY_INTERFACE_MODE_MII;
-+	}
-+	ltq_etop_w32_mask(MDIO_CFG_MASK, 0, LTQ_ETOP_MDIO_CFG);
-+	ltq_etop_w32_mask(MAC_CFG_MASK, MAC_CFG_CGEN | MAC_CFG_DUPLEX |
-+			MAC_CFG_SPEED | MAC_CFG_LINK, LTQ_ETOP_MAC_CFG);
- 
--	switch (priv->pldata->mii_mode) {
-+	switch (mii_mode) {
- 	case PHY_INTERFACE_MODE_RMII:
--		ltq_etop_w32_mask(ETOP_MII_MASK,
--			ETOP_MII_REVERSE, LTQ_ETOP_CFG);
-+		ltq_etop_w32_mask(ETOP_CFG_MASK, ETOP_CFG_REMII0 | ETOP_CFG_OFF1 |
-+			ETOP_CFG_SEN0 | ETOP_CFG_FEN0, LTQ_ETOP_CFG);
- 		break;
- 
- 	case PHY_INTERFACE_MODE_MII:
--		ltq_etop_w32_mask(ETOP_MII_MASK,
--			ETOP_MII_NORMAL, LTQ_ETOP_CFG);
-+		ltq_etop_w32_mask(ETOP_CFG_MASK, ETOP_CFG_OFF1 |
-+			ETOP_CFG_SEN0 | ETOP_CFG_FEN0, LTQ_ETOP_CFG);
- 		break;
- 
- 	default:
-+		if (of_machine_is_compatible("lantiq,ase")) {
-+			clk_enable(priv->clk_ephy);
-+			/* disable external MII */
-+			ltq_etop_w32_mask(0, ETOP_CFG_MII0, LTQ_ETOP_CFG);
-+			/* enable clock for internal PHY */
-+			clk_enable(priv->clk_ephycgu);
-+			/* we need to write this magic to the internal phy to
-+			   make it work */
-+			ltq_etop_mdio_wr(NULL, 0x8, 0x12, 0xC020);
-+			pr_info("Selected EPHY mode\n");
-+			break;
-+		}
- 		netdev_err(dev, "unknown mii mode %d\n",
--			priv->pldata->mii_mode);
-+			mii_mode);
- 		return -ENOTSUPP;
- 	}
- 
--	/* enable crc generation */
--	ltq_etop_w32(PPE32_CGEN, LQ_PPE32_ENET_MAC_CFG);
-+	return 0;
-+}
-+
-+static int
-+ltq_etop_dma_init(struct net_device *dev)
-+{
-+	struct ltq_etop_priv *priv = netdev_priv(dev);
-+	int tx = priv->tx_irq - LTQ_DMA_ETOP;
-+	int rx = priv->rx_irq - LTQ_DMA_ETOP;
-+	int err;
- 
- 	ltq_dma_init_port(DMA_PORT_ETOP);
- 
--	for (i = 0; i < MAX_DMA_CHAN; i++) {
--		int irq = LTQ_DMA_CH0_INT + i;
--		struct ltq_etop_chan *ch = &priv->ch[i];
--
--		ch->idx = ch->dma.nr = i;
--
--		if (IS_TX(i)) {
--			ltq_dma_alloc_tx(&ch->dma);
--			request_irq(irq, ltq_etop_dma_irq, 0, "etop_tx", priv);
--		} else if (IS_RX(i)) {
--			ltq_dma_alloc_rx(&ch->dma);
--			for (ch->dma.desc = 0; ch->dma.desc < LTQ_DESC_NUM;
--					ch->dma.desc++)
--				if (ltq_etop_alloc_skb(ch))
--					return -ENOMEM;
--			ch->dma.desc = 0;
--			request_irq(irq, ltq_etop_dma_irq, 0, "etop_rx", priv);
-+	priv->txch.dma.nr = tx;
-+	ltq_dma_alloc_tx(&priv->txch.dma);
-+	err = request_irq(priv->tx_irq, ltq_etop_dma_irq, 0, "eth_tx", priv);
-+	if (err) {
-+		netdev_err(dev, "failed to allocate tx irq\n");
-+		goto err_out;
-+	}
-+	priv->txch.dma.irq = priv->tx_irq;
-+
-+	priv->rxch.dma.nr = rx;
-+	ltq_dma_alloc_rx(&priv->rxch.dma);
-+	for (priv->rxch.dma.desc = 0; priv->rxch.dma.desc < LTQ_DESC_NUM;
-+			priv->rxch.dma.desc++) {
-+		if (ltq_etop_alloc_skb(&priv->rxch)) {
-+			netdev_err(dev, "failed to allocate skbs\n");
-+			err = -ENOMEM;
-+			goto err_out;
- 		}
--		ch->dma.irq = irq;
- 	}
--	return 0;
-+	priv->rxch.dma.desc = 0;
-+	err = request_irq(priv->rx_irq, ltq_etop_dma_irq, 0, "eth_rx", priv);
-+	if (err)
-+		netdev_err(dev, "failed to allocate rx irq\n");
-+	else
-+		priv->rxch.dma.irq = priv->rx_irq;
-+err_out:
-+	return err;
- }
- 
- static void
-@@ -309,7 +454,10 @@ ltq_etop_get_settings(struct net_device
- {
- 	struct ltq_etop_priv *priv = netdev_priv(dev);
- 
--	return phy_ethtool_gset(priv->phydev, cmd);
-+	if (priv->phydev)
-+		return phy_ethtool_gset(priv->phydev, cmd);
-+	else
-+		return 0;
- }
- 
- static int
-@@ -317,7 +465,10 @@ ltq_etop_set_settings(struct net_device
- {
- 	struct ltq_etop_priv *priv = netdev_priv(dev);
- 
--	return phy_ethtool_sset(priv->phydev, cmd);
-+	if (priv->phydev)
-+		return phy_ethtool_sset(priv->phydev, cmd);
-+	else
-+		return 0;
- }
- 
- static int
-@@ -325,7 +476,10 @@ ltq_etop_nway_reset(struct net_device *d
- {
- 	struct ltq_etop_priv *priv = netdev_priv(dev);
- 
--	return phy_start_aneg(priv->phydev);
-+	if (priv->phydev)
-+		return phy_start_aneg(priv->phydev);
-+	else
-+		return 0;
- }
- 
- static const struct ethtool_ops ltq_etop_ethtool_ops = {
-@@ -336,6 +490,39 @@ static const struct ethtool_ops ltq_etop
- };
- 
- static int
-+ltq_etop_mdio_wr_xr9(struct mii_bus *bus, int phy_addr,
-+		int phy_reg, u16 phy_data)
-+{
-+	u32 val = MDIO_XR9_REQUEST | MDIO_XR9_WRITE |
-+		(phy_data << MDIO_XR9_WR_OFFSET) |
-+		((phy_addr & MDIO_XR9_ADDR_MASK) << MDIO_XR9_ADDR_OFFSET) |
-+		((phy_reg & MDIO_XR9_REG_MASK) << MDIO_XR9_REG_OFFSET);
-+
-+	while (ltq_gbit_r32(LTQ_GBIT_MDIO_CTL) & MDIO_XR9_REQUEST)
-+		;
-+	ltq_gbit_w32(val, LTQ_GBIT_MDIO_CTL);
-+	while (ltq_gbit_r32(LTQ_GBIT_MDIO_CTL) & MDIO_XR9_REQUEST)
-+		;
-+	return 0;
-+}
-+
-+static int
-+ltq_etop_mdio_rd_xr9(struct mii_bus *bus, int phy_addr, int phy_reg)
-+{
-+	u32 val = MDIO_XR9_REQUEST | MDIO_XR9_READ |
-+		((phy_addr & MDIO_XR9_ADDR_MASK) << MDIO_XR9_ADDR_OFFSET) |
-+		((phy_reg & MDIO_XR9_REG_MASK) << MDIO_XR9_REG_OFFSET);
-+
-+	while (ltq_gbit_r32(LTQ_GBIT_MDIO_CTL) & MDIO_XR9_REQUEST)
-+		;
-+	ltq_gbit_w32(val, LTQ_GBIT_MDIO_CTL);
-+	while (ltq_gbit_r32(LTQ_GBIT_MDIO_CTL) & MDIO_XR9_REQUEST)
-+		;
-+	val = ltq_gbit_r32(LTQ_GBIT_MDIO_DATA) & MDIO_XR9_RD_MASK;
-+	return val;
-+}
-+
-+static int
- ltq_etop_mdio_wr(struct mii_bus *bus, int phy_addr, int phy_reg, u16 phy_data)
- {
- 	u32 val = MDIO_REQUEST |
-@@ -343,9 +530,9 @@ ltq_etop_mdio_wr(struct mii_bus *bus, in
- 		((phy_reg & MDIO_REG_MASK) << MDIO_REG_OFFSET) |
- 		phy_data;
- 
--	while (ltq_etop_r32(LTQ_ETOP_MDIO) & MDIO_REQUEST)
-+	while (ltq_etop_r32(LTQ_ETOP_MDIO_ACC) & MDIO_REQUEST)
- 		;
--	ltq_etop_w32(val, LTQ_ETOP_MDIO);
-+	ltq_etop_w32(val, LTQ_ETOP_MDIO_ACC);
- 	return 0;
- }
- 
-@@ -356,12 +543,12 @@ ltq_etop_mdio_rd(struct mii_bus *bus, in
- 		((phy_addr & MDIO_ADDR_MASK) << MDIO_ADDR_OFFSET) |
- 		((phy_reg & MDIO_REG_MASK) << MDIO_REG_OFFSET);
- 
--	while (ltq_etop_r32(LTQ_ETOP_MDIO) & MDIO_REQUEST)
-+	while (ltq_etop_r32(LTQ_ETOP_MDIO_ACC) & MDIO_REQUEST)
- 		;
--	ltq_etop_w32(val, LTQ_ETOP_MDIO);
--	while (ltq_etop_r32(LTQ_ETOP_MDIO) & MDIO_REQUEST)
-+	ltq_etop_w32(val, LTQ_ETOP_MDIO_ACC);
-+	while (ltq_etop_r32(LTQ_ETOP_MDIO_ACC) & MDIO_REQUEST)
- 		;
--	val = ltq_etop_r32(LTQ_ETOP_MDIO) & MDIO_VAL_MASK;
-+	val = ltq_etop_r32(LTQ_ETOP_MDIO_ACC) & MDIO_VAL_MASK;
- 	return val;
- }
- 
-@@ -376,14 +563,18 @@ ltq_etop_mdio_probe(struct net_device *d
- {
- 	struct ltq_etop_priv *priv = netdev_priv(dev);
- 	struct phy_device *phydev = NULL;
--	int phy_addr;
-+	u32 phy_supported =  (SUPPORTED_10baseT_Half
-+			| SUPPORTED_10baseT_Full
-+			| SUPPORTED_100baseT_Half
-+			| SUPPORTED_100baseT_Full
-+			| SUPPORTED_Autoneg
-+			| SUPPORTED_MII
-+			| SUPPORTED_TP);
- 
--	for (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {
--		if (priv->mii_bus->phy_map[phy_addr]) {
--			phydev = priv->mii_bus->phy_map[phy_addr];
--			break;
--		}
--	}
-+	if (of_machine_is_compatible("lantiq,ase"))
-+		phydev = priv->mii_bus->phy_map[8];
-+	else
-+		phydev = priv->mii_bus->phy_map[0];
- 
- 	if (!phydev) {
- 		netdev_err(dev, "no PHY found\n");
-@@ -391,21 +582,18 @@ ltq_etop_mdio_probe(struct net_device *d
- 	}
- 
- 	phydev = phy_connect(dev, dev_name(&phydev->dev),
--			     &ltq_etop_mdio_link, priv->pldata->mii_mode);
-+			&ltq_etop_mdio_link, priv->mii_mode);
- 
- 	if (IS_ERR(phydev)) {
- 		netdev_err(dev, "Could not attach to PHY\n");
- 		return PTR_ERR(phydev);
- 	}
- 
--	phydev->supported &= (SUPPORTED_10baseT_Half
--			      | SUPPORTED_10baseT_Full
--			      | SUPPORTED_100baseT_Half
--			      | SUPPORTED_100baseT_Full
--			      | SUPPORTED_Autoneg
--			      | SUPPORTED_MII
--			      | SUPPORTED_TP);
-+	if (of_machine_is_compatible("lantiq,ar9"))
-+		phy_supported |= SUPPORTED_1000baseT_Half
-+			| SUPPORTED_1000baseT_Full;
- 
-+	phydev->supported &= phy_supported;
- 	phydev->advertising = phydev->supported;
- 	priv->phydev = phydev;
- 	pr_info("%s: attached PHY [%s] (phy_addr=%s, irq=%d)\n",
-@@ -430,8 +618,13 @@ ltq_etop_mdio_init(struct net_device *de
- 	}
- 
- 	priv->mii_bus->priv = dev;
--	priv->mii_bus->read = ltq_etop_mdio_rd;
--	priv->mii_bus->write = ltq_etop_mdio_wr;
-+	if (of_machine_is_compatible("lantiq,ar9")) {
-+		priv->mii_bus->read = ltq_etop_mdio_rd_xr9;
-+		priv->mii_bus->write = ltq_etop_mdio_wr_xr9;
-+	} else {
-+		priv->mii_bus->read = ltq_etop_mdio_rd;
-+		priv->mii_bus->write = ltq_etop_mdio_wr;
-+	}
- 	priv->mii_bus->name = "ltq_mii";
- 	snprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",
- 		priv->pdev->name, priv->pdev->id);
-@@ -480,17 +673,19 @@ static int
- ltq_etop_open(struct net_device *dev)
- {
- 	struct ltq_etop_priv *priv = netdev_priv(dev);
--	int i;
-+	unsigned long flags;
- 
--	for (i = 0; i < MAX_DMA_CHAN; i++) {
--		struct ltq_etop_chan *ch = &priv->ch[i];
-+	napi_enable(&priv->txch.napi);
-+	napi_enable(&priv->rxch.napi);
-+
-+	spin_lock_irqsave(&priv->lock, flags);
-+	ltq_dma_open(&priv->txch.dma);
-+	ltq_dma_open(&priv->rxch.dma);
-+	spin_unlock_irqrestore(&priv->lock, flags);
-+
-+	if (priv->phydev)
-+		phy_start(priv->phydev);
- 
--		if (!IS_TX(i) && (!IS_RX(i)))
--			continue;
--		ltq_dma_open(&ch->dma);
--		napi_enable(&ch->napi);
--	}
--	phy_start(priv->phydev);
- 	netif_tx_start_all_queues(dev);
- 	return 0;
- }
-@@ -499,18 +694,19 @@ static int
- ltq_etop_stop(struct net_device *dev)
- {
- 	struct ltq_etop_priv *priv = netdev_priv(dev);
--	int i;
-+	unsigned long flags;
- 
- 	netif_tx_stop_all_queues(dev);
--	phy_stop(priv->phydev);
--	for (i = 0; i < MAX_DMA_CHAN; i++) {
--		struct ltq_etop_chan *ch = &priv->ch[i];
--
--		if (!IS_RX(i) && !IS_TX(i))
--			continue;
--		napi_disable(&ch->napi);
--		ltq_dma_close(&ch->dma);
--	}
-+	if (priv->phydev)
-+		phy_stop(priv->phydev);
-+	napi_disable(&priv->txch.napi);
-+	napi_disable(&priv->rxch.napi);
-+
-+	spin_lock_irqsave(&priv->lock, flags);
-+	ltq_dma_close(&priv->txch.dma);
-+	ltq_dma_close(&priv->rxch.dma);
-+	spin_unlock_irqrestore(&priv->lock, flags);
-+
- 	return 0;
- }
- 
-@@ -520,16 +716,16 @@ ltq_etop_tx(struct sk_buff *skb, struct
- 	int queue = skb_get_queue_mapping(skb);
- 	struct netdev_queue *txq = netdev_get_tx_queue(dev, queue);
- 	struct ltq_etop_priv *priv = netdev_priv(dev);
--	struct ltq_etop_chan *ch = &priv->ch[(queue << 1) | 1];
--	struct ltq_dma_desc *desc = &ch->dma.desc_base[ch->dma.desc];
--	int len;
-+	struct ltq_dma_desc *desc =
-+		&priv->txch.dma.desc_base[priv->txch.dma.desc];
- 	unsigned long flags;
- 	u32 byte_offset;
-+	int len;
- 
- 	len = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
- 
--	if ((desc->ctl & (LTQ_DMA_OWN | LTQ_DMA_C)) || ch->skb[ch->dma.desc]) {
--		dev_kfree_skb_any(skb);
-+	if ((desc->ctl & (LTQ_DMA_OWN | LTQ_DMA_C)) ||
-+			priv->txch.skb[priv->txch.dma.desc]) {
- 		netdev_err(dev, "tx ring full\n");
- 		netif_tx_stop_queue(txq);
- 		return NETDEV_TX_BUSY;
-@@ -537,7 +733,7 @@ ltq_etop_tx(struct sk_buff *skb, struct
- 
- 	/* dma needs to start on a 16 byte aligned address */
- 	byte_offset = CPHYSADDR(skb->data) % 16;
--	ch->skb[ch->dma.desc] = skb;
-+	priv->txch.skb[priv->txch.dma.desc] = skb;
- 
- 	dev->trans_start = jiffies;
- 
-@@ -547,11 +743,11 @@ ltq_etop_tx(struct sk_buff *skb, struct
- 	wmb();
- 	desc->ctl = LTQ_DMA_OWN | LTQ_DMA_SOP | LTQ_DMA_EOP |
- 		LTQ_DMA_TX_OFFSET(byte_offset) | (len & LTQ_DMA_SIZE_MASK);
--	ch->dma.desc++;
--	ch->dma.desc %= LTQ_DESC_NUM;
-+	priv->txch.dma.desc++;
-+	priv->txch.dma.desc %= LTQ_DESC_NUM;
- 	spin_unlock_irqrestore(&priv->lock, flags);
- 
--	if (ch->dma.desc_base[ch->dma.desc].ctl & LTQ_DMA_OWN)
-+	if (priv->txch.dma.desc_base[priv->txch.dma.desc].ctl & LTQ_DMA_OWN)
- 		netif_tx_stop_queue(txq);
- 
- 	return NETDEV_TX_OK;
-@@ -566,8 +762,10 @@ ltq_etop_change_mtu(struct net_device *d
- 		struct ltq_etop_priv *priv = netdev_priv(dev);
- 		unsigned long flags;
- 
-+		int max = ETH_HLEN + VLAN_HLEN + new_mtu + ETH_FCS_LEN;
-+
- 		spin_lock_irqsave(&priv->lock, flags);
--		ltq_etop_w32((ETOP_PLEN_UNDER << 16) | new_mtu,
-+		ltq_etop_w32((ETOP_PLEN_UNDER << 16) | max,
- 			LTQ_ETOP_IGPLEN);
- 		spin_unlock_irqrestore(&priv->lock, flags);
- 	}
-@@ -638,6 +836,9 @@ ltq_etop_init(struct net_device *dev)
- 	if (err)
- 		goto err_hw;
- 	ltq_etop_change_mtu(dev, 1500);
-+	err = ltq_etop_dma_init(dev);
-+	if (err)
-+		goto err_hw;
- 
- 	memcpy(&mac, &priv->pldata->mac, sizeof(struct sockaddr));
- 	if (!is_valid_ether_addr(mac.sa_data)) {
-@@ -655,9 +856,10 @@ ltq_etop_init(struct net_device *dev)
- 		dev->addr_assign_type = NET_ADDR_RANDOM;
- 
- 	ltq_etop_set_multicast_list(dev);
--	err = ltq_etop_mdio_init(dev);
--	if (err)
--		goto err_netdev;
-+	if (!ltq_etop_mdio_init(dev))
-+		dev->ethtool_ops = &ltq_etop_ethtool_ops;
-+	else
-+		pr_warn("etop: mdio probe failed\n");;
- 	return 0;
- 
- err_netdev:
-@@ -677,6 +879,9 @@ ltq_etop_tx_timeout(struct net_device *d
- 	err = ltq_etop_hw_init(dev);
- 	if (err)
- 		goto err_hw;
-+	err = ltq_etop_dma_init(dev);
-+	if (err)
-+		goto err_hw;
- 	dev->trans_start = jiffies;
- 	netif_wake_queue(dev);
- 	return;
-@@ -700,14 +905,18 @@ static const struct net_device_ops ltq_e
- 	.ndo_tx_timeout = ltq_etop_tx_timeout,
- };
- 
--static int __init
--ltq_etop_probe(struct platform_device *pdev)
-+static int ltq_etop_probe(struct platform_device *pdev)
- {
- 	struct net_device *dev;
- 	struct ltq_etop_priv *priv;
--	struct resource *res;
-+	struct resource *res, *gbit_res, irqres[2];
- 	int err;
--	int i;
-+
-+	err = of_irq_to_resource_table(pdev->dev.of_node, irqres, 2);
-+	if (err != 2) {
-+		dev_err(&pdev->dev, "failed to get etop irqs\n");
-+		return -EINVAL;
-+	}
- 
- 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
- 	if (!res) {
-@@ -733,30 +942,58 @@ ltq_etop_probe(struct platform_device *p
- 		goto err_out;
- 	}
- 
--	dev = alloc_etherdev_mq(sizeof(struct ltq_etop_priv), 4);
--	if (!dev) {
--		err = -ENOMEM;
--		goto err_out;
-+	if (of_machine_is_compatible("lantiq,ar9")) {
-+		gbit_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-+		if (!gbit_res) {
-+			dev_err(&pdev->dev, "failed to get gbit resource\n");
-+			err = -ENOENT;
-+			goto err_out;
-+		}
-+		ltq_gbit_membase = devm_ioremap_nocache(&pdev->dev,
-+			gbit_res->start, resource_size(gbit_res));
-+		if (!ltq_gbit_membase) {
-+			dev_err(&pdev->dev, "failed to remap gigabit switch %d\n",
-+				pdev->id);
-+			err = -ENOMEM;
-+			goto err_out;
-+		}
- 	}
-+
-+	dev = alloc_etherdev_mq(sizeof(struct ltq_etop_priv), 4);
- 	strcpy(dev->name, "eth%d");
- 	dev->netdev_ops = &ltq_eth_netdev_ops;
--	dev->ethtool_ops = &ltq_etop_ethtool_ops;
- 	priv = netdev_priv(dev);
- 	priv->res = res;
- 	priv->pdev = pdev;
--	priv->pldata = dev_get_platdata(&pdev->dev);
- 	priv->netdev = dev;
-+	priv->tx_irq = irqres[0].start;
-+	priv->rx_irq = irqres[1].start;
-+	priv->mii_mode = of_get_phy_mode(pdev->dev.of_node);
-+	of_get_mac_address_mtd(pdev->dev.of_node, priv->mac);
-+
-+	priv->clk_ppe = clk_get(&pdev->dev, NULL);
-+	if (IS_ERR(priv->clk_ppe))
-+		return PTR_ERR(priv->clk_ppe);
-+	if (of_machine_is_compatible("lantiq,ar9")) {
-+		priv->clk_switch = clk_get(&pdev->dev, "switch");
-+		if (IS_ERR(priv->clk_switch))
-+			return PTR_ERR(priv->clk_switch);
-+	}
-+	if (of_machine_is_compatible("lantiq,ase")) {
-+		priv->clk_ephy = clk_get(&pdev->dev, "ephy");
-+		if (IS_ERR(priv->clk_ephy))
-+			return PTR_ERR(priv->clk_ephy);
-+		priv->clk_ephycgu = clk_get(&pdev->dev, "ephycgu");
-+		if (IS_ERR(priv->clk_ephycgu))
-+			return PTR_ERR(priv->clk_ephycgu);
-+	}
-+
- 	spin_lock_init(&priv->lock);
- 
--	for (i = 0; i < MAX_DMA_CHAN; i++) {
--		if (IS_TX(i))
--			netif_napi_add(dev, &priv->ch[i].napi,
--				ltq_etop_poll_tx, 8);
--		else if (IS_RX(i))
--			netif_napi_add(dev, &priv->ch[i].napi,
--				ltq_etop_poll_rx, 32);
--		priv->ch[i].netdev = dev;
--	}
-+	netif_napi_add(dev, &priv->txch.napi, ltq_etop_poll_tx, 8);
-+	netif_napi_add(dev, &priv->rxch.napi, ltq_etop_poll_rx, 32);
-+	priv->txch.netdev = dev;
-+	priv->rxch.netdev = dev;
- 
- 	err = register_netdev(dev);
- 	if (err)
-@@ -785,32 +1022,23 @@ ltq_etop_remove(struct platform_device *
- 	return 0;
- }
- 
-+static const struct of_device_id ltq_etop_match[] = {
-+	{ .compatible = "lantiq,etop-xway" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, ltq_etop_match);
-+
- static struct platform_driver ltq_mii_driver = {
-+	.probe = ltq_etop_probe,
- 	.remove = ltq_etop_remove,
- 	.driver = {
- 		.name = "ltq_etop",
- 		.owner = THIS_MODULE,
-+		.of_match_table = ltq_etop_match,
- 	},
- };
- 
--int __init
--init_ltq_etop(void)
--{
--	int ret = platform_driver_probe(&ltq_mii_driver, ltq_etop_probe);
--
--	if (ret)
--		pr_err("ltq_etop: Error registering platform driver!");
--	return ret;
--}
--
--static void __exit
--exit_ltq_etop(void)
--{
--	platform_driver_unregister(&ltq_mii_driver);
--}
--
--module_init(init_ltq_etop);
--module_exit(exit_ltq_etop);
-+module_platform_driver(ltq_mii_driver);
- 
- MODULE_AUTHOR("John Crispin <blogic@openwrt.org>");
- MODULE_DESCRIPTION("Lantiq SoC ETOP");
diff --git a/target/linux/lantiq/patches-3.18/0030-GPIO-add-named-gpio-exports.patch b/target/linux/lantiq/patches-3.18/0030-GPIO-add-named-gpio-exports.patch
deleted file mode 100644
index 855da68285..0000000000
--- a/target/linux/lantiq/patches-3.18/0030-GPIO-add-named-gpio-exports.patch
+++ /dev/null
@@ -1,166 +0,0 @@
-From cc809a441d8f2924f785eb863dfa6aef47a25b0b Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Tue, 12 Aug 2014 20:49:27 +0200
-Subject: [PATCH 30/36] GPIO: add named gpio exports
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/gpio/gpiolib-of.c     |   68 +++++++++++++++++++++++++++++++++++++++++
- drivers/gpio/gpiolib.c        |   11 +++++--
- include/asm-generic/gpio.h    |    5 +++
- include/linux/gpio/consumer.h |    8 +++++
- 4 files changed, 90 insertions(+), 2 deletions(-)
-
---- a/drivers/gpio/gpiolib-of.c
-+++ b/drivers/gpio/gpiolib-of.c
-@@ -22,6 +22,8 @@
- #include <linux/of_gpio.h>
- #include <linux/pinctrl/pinctrl.h>
- #include <linux/slab.h>
-+#include <linux/init.h>
-+#include <linux/platform_device.h>
- 
- #include "gpiolib.h"
- 
-@@ -316,3 +318,69 @@ void of_gpiochip_remove(struct gpio_chip
- 	gpiochip_remove_pin_ranges(chip);
- 	of_node_put(chip->of_node);
- }
-+
-+static struct of_device_id gpio_export_ids[] = {
-+	{ .compatible = "gpio-export" },
-+	{ /* sentinel */ }
-+};
-+
-+static int __init of_gpio_export_probe(struct platform_device *pdev)
-+{
-+	struct device_node *np = pdev->dev.of_node;
-+	struct device_node *cnp;
-+	u32 val;
-+	int nb = 0;
-+
-+	for_each_child_of_node(np, cnp) {
-+		const char *name = NULL;
-+		int gpio;
-+		bool dmc;
-+		int max_gpio = 1;
-+		int i;
-+
-+		of_property_read_string(cnp, "gpio-export,name", &name);
-+
-+		if (!name)
-+			max_gpio = of_gpio_count(cnp);
-+
-+		for (i = 0; i < max_gpio; i++) {
-+			unsigned flags = 0;
-+			enum of_gpio_flags of_flags;
-+
-+			gpio = of_get_gpio_flags(cnp, i, &of_flags);
-+
-+			if (of_flags == OF_GPIO_ACTIVE_LOW)
-+				flags |= GPIOF_ACTIVE_LOW;
-+
-+			if (!of_property_read_u32(cnp, "gpio-export,output", &val))
-+				flags |= val ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
-+			else
-+				flags |= GPIOF_IN;
-+
-+			if (devm_gpio_request_one(&pdev->dev, gpio, flags, name ? name : of_node_full_name(np)))
-+				continue;
-+
-+			dmc = of_property_read_bool(cnp, "gpio-export,direction_may_change");
-+			gpio_export_with_name(gpio, dmc, name);
-+			nb++;
-+		}
-+	}
-+
-+	dev_info(&pdev->dev, "%d gpio(s) exported\n", nb);
-+
-+	return 0;
-+}
-+
-+static struct platform_driver gpio_export_driver = {
-+	.driver		= {
-+		.name		= "gpio-export",
-+		.owner	= THIS_MODULE,
-+		.of_match_table	= of_match_ptr(gpio_export_ids),
-+	},
-+};
-+
-+static int __init of_gpio_export_init(void)
-+{
-+	return platform_driver_probe(&gpio_export_driver, of_gpio_export_probe);
-+}
-+device_initcall(of_gpio_export_init);
---- a/include/asm-generic/gpio.h
-+++ b/include/asm-generic/gpio.h
-@@ -123,6 +123,12 @@ static inline int gpio_export(unsigned g
- 	return gpiod_export(gpio_to_desc(gpio), direction_may_change);
- }
- 
-+int __gpiod_export(struct gpio_desc *desc, bool direction_may_change, const char *name);
-+static inline int gpio_export_with_name(unsigned gpio, bool direction_may_change, const char *name)
-+{
-+	return __gpiod_export(gpio_to_desc(gpio), direction_may_change, name);
-+}
-+
- static inline int gpio_export_link(struct device *dev, const char *name,
- 				   unsigned gpio)
- {
---- a/include/linux/gpio/consumer.h
-+++ b/include/linux/gpio/consumer.h
-@@ -323,6 +323,7 @@ static inline int desc_to_gpio(const str
- 
- #if IS_ENABLED(CONFIG_GPIOLIB) && IS_ENABLED(CONFIG_GPIO_SYSFS)
- 
-+int _gpiod_export(struct gpio_desc *desc, bool direction_may_change, const char *name);
- int gpiod_export(struct gpio_desc *desc, bool direction_may_change);
- int gpiod_export_link(struct device *dev, const char *name,
- 		      struct gpio_desc *desc);
-@@ -331,6 +332,13 @@ void gpiod_unexport(struct gpio_desc *de
- 
- #else  /* CONFIG_GPIOLIB && CONFIG_GPIO_SYSFS */
- 
-+static inline int _gpiod_export(struct gpio_desc *desc,
-+			       bool direction_may_change,
-+			       const char *name)
-+{
-+	return -ENOSYS;
-+}
-+
- static inline int gpiod_export(struct gpio_desc *desc,
- 			       bool direction_may_change)
- {
---- a/drivers/gpio/gpiolib-sysfs.c
-+++ b/drivers/gpio/gpiolib-sysfs.c
-@@ -517,7 +517,7 @@ static struct class gpio_class = {
-  *
-  * Returns zero on success, else an error.
-  */
--int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
-+int __gpiod_export(struct gpio_desc *desc, bool direction_may_change, const char *name)
- {
- 	struct gpio_chip	*chip;
- 	unsigned long		flags;
-@@ -566,6 +566,8 @@ int gpiod_export(struct gpio_desc *desc,
- 	offset = gpio_chip_hwgpio(desc);
- 	if (desc->chip->names && desc->chip->names[offset])
- 		ioname = desc->chip->names[offset];
-+	if (name)
-+		ioname = name;
- 
- 	dev = device_create_with_groups(&gpio_class, desc->chip->dev,
- 					MKDEV(0, 0), desc, gpio_groups,
-@@ -602,6 +604,12 @@ fail_unlock:
- 	gpiod_dbg(desc, "%s: status %d\n", __func__, status);
- 	return status;
- }
-+EXPORT_SYMBOL_GPL(__gpiod_export);
-+
-+int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
-+{
-+	return __gpiod_export(desc, direction_may_change, NULL);
-+}
- EXPORT_SYMBOL_GPL(gpiod_export);
- 
- static int match_export(struct device *dev, const void *data)
diff --git a/target/linux/lantiq/patches-3.18/0031-I2C-MIPS-lantiq-add-FALC-ON-i2c-bus-master.patch b/target/linux/lantiq/patches-3.18/0031-I2C-MIPS-lantiq-add-FALC-ON-i2c-bus-master.patch
deleted file mode 100644
index 5bebceeb5d..0000000000
--- a/target/linux/lantiq/patches-3.18/0031-I2C-MIPS-lantiq-add-FALC-ON-i2c-bus-master.patch
+++ /dev/null
@@ -1,1036 +0,0 @@
-From: John Crispin <blogic@openwrt.org>
-Date: Thu, 7 Aug 2014 18:26:42 +0200
-[PATCH 31/36] I2C: MIPS: lantiq: add FALC-ON i2c bus master
-
-This patch adds the driver needed to make the I2C bus work on FALC-ON SoCs.
-
-Signed-off-by: Thomas Langer <thomas.langer@lantiq.com>
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/i2c/busses/Kconfig      |   10 +
- drivers/i2c/busses/Makefile     |    1 +
- drivers/i2c/busses/i2c-lantiq.c |  747 +++++++++++++++++++++++++++++++++++++++
- drivers/i2c/busses/i2c-lantiq.h |  234 ++++++++++++
- 4 files changed, 992 insertions(+)
- create mode 100644 drivers/i2c/busses/i2c-lantiq.c
- create mode 100644 drivers/i2c/busses/i2c-lantiq.h
-
-diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
---- a/drivers/i2c/busses/Kconfig
-+++ b/drivers/i2c/busses/Kconfig
-@@ -554,6 +554,16 @@ config I2C_KEMPLD
- 	  This driver can also be built as a module. If so, the module
- 	  will be called i2c-kempld.
- 
-+config I2C_LANTIQ
-+	tristate "Lantiq I2C interface"
-+	depends on LANTIQ && SOC_FALCON
-+	help
-+	  If you say yes to this option, support will be included for the
-+	  Lantiq I2C core.
-+
-+	  This driver can also be built as a module. If so, the module
-+	  will be called i2c-lantiq.
-+
- config I2C_MPC
- 	tristate "MPC107/824x/85xx/512x/52xx/83xx/86xx"
- 	depends on PPC
-diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
---- a/drivers/i2c/busses/Makefile
-+++ b/drivers/i2c/busses/Makefile
-@@ -53,6 +53,7 @@ obj-$(CONFIG_I2C_IBM_IIC)	+= i2c-ibm_iic
- obj-$(CONFIG_I2C_IMX)		+= i2c-imx.o
- obj-$(CONFIG_I2C_IOP3XX)	+= i2c-iop3xx.o
- obj-$(CONFIG_I2C_KEMPLD)	+= i2c-kempld.o
-+obj-$(CONFIG_I2C_LANTIQ)	+= i2c-lantiq.o
- obj-$(CONFIG_I2C_MPC)		+= i2c-mpc.o
- obj-$(CONFIG_I2C_MV64XXX)	+= i2c-mv64xxx.o
- obj-$(CONFIG_I2C_MXS)		+= i2c-mxs.o
-diff --git a/drivers/i2c/busses/i2c-lantiq.c b/drivers/i2c/busses/i2c-lantiq.c
-new file mode 100644
---- /dev/null
-+++ b/drivers/i2c/busses/i2c-lantiq.c
-@@ -0,0 +1,744 @@
-+
-+/*
-+ * Lantiq I2C bus adapter
-+ *
-+ * Parts based on i2c-designware.c and other i2c drivers from Linux 2.6.33
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License as published by
-+ * the Free Software Foundation; either version 2 of the License, or
-+ * (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-+ *
-+ * Copyright (C) 2012 Thomas Langer <thomas.langer@lantiq.com>
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/module.h>
-+#include <linux/delay.h>
-+#include <linux/slab.h> /* for kzalloc, kfree */
-+#include <linux/i2c.h>
-+#include <linux/errno.h>
-+#include <linux/completion.h>
-+#include <linux/interrupt.h>
-+#include <linux/platform_device.h>
-+#include <linux/io.h>
-+#include <linux/of_irq.h>
-+
-+#include <lantiq_soc.h>
-+#include "i2c-lantiq.h"
-+
-+/*
-+ * CURRENT ISSUES:
-+ * - no high speed support
-+ * - ten bit mode is not tested (no slave devices)
-+ */
-+
-+/* access macros */
-+#define i2c_r32(reg)	\
-+	__raw_readl(&(priv->membase)->reg)
-+#define i2c_w32(val, reg)	\
-+	__raw_writel(val, &(priv->membase)->reg)
-+#define i2c_w32_mask(clear, set, reg)	\
-+	i2c_w32((i2c_r32(reg) & ~(clear)) | (set), reg)
-+
-+#define DRV_NAME "i2c-lantiq"
-+#define DRV_VERSION "1.00"
-+
-+#define LTQ_I2C_BUSY_TIMEOUT		20 /* ms */
-+
-+#ifdef DEBUG
-+#define LTQ_I2C_XFER_TIMEOUT		(25*HZ)
-+#else
-+#define LTQ_I2C_XFER_TIMEOUT		HZ
-+#endif
-+
-+#define LTQ_I2C_IMSC_DEFAULT_MASK	(I2C_IMSC_I2C_P_INT_EN | \
-+					 I2C_IMSC_I2C_ERR_INT_EN)
-+
-+#define LTQ_I2C_ARB_LOST		(1 << 0)
-+#define LTQ_I2C_NACK			(1 << 1)
-+#define LTQ_I2C_RX_UFL			(1 << 2)
-+#define LTQ_I2C_RX_OFL			(1 << 3)
-+#define LTQ_I2C_TX_UFL			(1 << 4)
-+#define LTQ_I2C_TX_OFL			(1 << 5)
-+
-+struct ltq_i2c {
-+	struct mutex mutex;
-+
-+
-+	/* active clock settings */
-+	unsigned int input_clock;	/* clock input for i2c hardware block */
-+	unsigned int i2c_clock;		/* approximated bus clock in kHz */
-+
-+	struct clk *clk_gate;
-+	struct clk *clk_input;
-+
-+
-+	/* resources (memory and interrupts) */
-+	int irq_lb;				/* last burst irq */
-+
-+	struct lantiq_reg_i2c __iomem *membase;	/* base of mapped registers */
-+
-+	struct i2c_adapter adap;
-+	struct device *dev;
-+
-+	struct completion cmd_complete;
-+
-+
-+	/* message transfer data */
-+	struct i2c_msg *current_msg;	/* current message */
-+	int msgs_num;		/* number of messages to handle */
-+	u8 *msg_buf;		/* current buffer */
-+	u32 msg_buf_len;	/* remaining length of current buffer */
-+	int msg_err;		/* error status of the current transfer */
-+
-+
-+	/* master status codes */
-+	enum {
-+		STATUS_IDLE,
-+		STATUS_ADDR,	/* address phase */
-+		STATUS_WRITE,
-+		STATUS_READ,
-+		STATUS_READ_END,
-+		STATUS_STOP
-+	} status;
-+};
-+
-+static irqreturn_t ltq_i2c_isr(int irq, void *dev_id);
-+
-+static inline void enable_burst_irq(struct ltq_i2c *priv)
-+{
-+	i2c_w32_mask(0, I2C_IMSC_LBREQ_INT_EN | I2C_IMSC_BREQ_INT_EN, imsc);
-+}
-+static inline void disable_burst_irq(struct ltq_i2c *priv)
-+{
-+	i2c_w32_mask(I2C_IMSC_LBREQ_INT_EN | I2C_IMSC_BREQ_INT_EN, 0, imsc);
-+}
-+
-+static void prepare_msg_send_addr(struct ltq_i2c *priv)
-+{
-+	struct i2c_msg *msg = priv->current_msg;
-+	int rd = !!(msg->flags & I2C_M_RD);	/* extends to 0 or 1 */
-+	u16 addr = msg->addr;
-+
-+	/* new i2c_msg */
-+	priv->msg_buf = msg->buf;
-+	priv->msg_buf_len = msg->len;
-+	if (rd)
-+		priv->status = STATUS_READ;
-+	else
-+		priv->status = STATUS_WRITE;
-+
-+	/* send slave address */
-+	if (msg->flags & I2C_M_TEN) {
-+		i2c_w32(0xf0 | ((addr & 0x300) >> 7) | rd, txd);
-+		i2c_w32(addr & 0xff, txd);
-+	} else {
-+		i2c_w32((addr & 0x7f) << 1 | rd, txd);
-+	}
-+}
-+
-+static void ltq_i2c_set_tx_len(struct ltq_i2c *priv)
-+{
-+	struct i2c_msg *msg = priv->current_msg;
-+	int len = (msg->flags & I2C_M_TEN) ? 2 : 1;
-+
-+	pr_debug("set_tx_len %cX\n", (msg->flags & I2C_M_RD) ? 'R' : 'T');
-+
-+	priv->status = STATUS_ADDR;
-+
-+	if (!(msg->flags & I2C_M_RD))
-+		len += msg->len;
-+	else
-+		/* set maximum received packet size (before rx int!) */
-+		i2c_w32(msg->len, mrps_ctrl);
-+	i2c_w32(len, tps_ctrl);
-+	enable_burst_irq(priv);
-+}
-+
-+static int ltq_i2c_hw_set_clock(struct i2c_adapter *adap)
-+{
-+	struct ltq_i2c *priv = i2c_get_adapdata(adap);
-+	unsigned int input_clock = clk_get_rate(priv->clk_input);
-+	u32 dec, inc = 1;
-+
-+	/* clock changed? */
-+	if (priv->input_clock == input_clock)
-+		return 0;
-+
-+	/*
-+	 * this formula is only an approximation, found by the recommended
-+	 * values in the "I2C Architecture Specification 1.7.1"
-+	 */
-+	dec = input_clock / (priv->i2c_clock * 2);
-+	if (dec <= 6)
-+		return -ENXIO;
-+
-+	i2c_w32(0, fdiv_high_cfg);
-+	i2c_w32((inc << I2C_FDIV_CFG_INC_OFFSET) |
-+		(dec << I2C_FDIV_CFG_DEC_OFFSET),
-+		fdiv_cfg);
-+
-+	dev_info(priv->dev, "setup clocks (in %d Hz, bus %d Hz, dec=%d)\n",
-+		input_clock, priv->i2c_clock, dec);
-+
-+	priv->input_clock = input_clock;
-+	return 0;
-+}
-+
-+static int ltq_i2c_hw_init(struct i2c_adapter *adap)
-+{
-+	int ret = 0;
-+	struct ltq_i2c *priv = i2c_get_adapdata(adap);
-+
-+	/* disable bus */
-+	i2c_w32_mask(I2C_RUN_CTRL_RUN_EN, 0, run_ctrl);
-+
-+#ifndef DEBUG
-+	/* set normal operation clock divider */
-+	i2c_w32(1 << I2C_CLC_RMC_OFFSET, clc);
-+#else
-+	/* for debugging a higher divider value! */
-+	i2c_w32(0xF0 << I2C_CLC_RMC_OFFSET, clc);
-+#endif
-+
-+	/* setup clock */
-+	ret = ltq_i2c_hw_set_clock(adap);
-+	if (ret != 0) {
-+		dev_warn(priv->dev, "invalid clock settings\n");
-+		return ret;
-+	}
-+
-+	/* configure fifo */
-+	i2c_w32(I2C_FIFO_CFG_TXFC | /* tx fifo as flow controller */
-+		I2C_FIFO_CFG_RXFC | /* rx fifo as flow controller */
-+		I2C_FIFO_CFG_TXFA_TXFA2 | /* tx fifo 4-byte aligned */
-+		I2C_FIFO_CFG_RXFA_RXFA2 | /* rx fifo 4-byte aligned */
-+		I2C_FIFO_CFG_TXBS_TXBS0 | /* tx fifo burst size is 1 word */
-+		I2C_FIFO_CFG_RXBS_RXBS0,  /* rx fifo burst size is 1 word */
-+		fifo_cfg);
-+
-+	/* configure address */
-+	i2c_w32(I2C_ADDR_CFG_SOPE_EN |	/* generate stop when no more data in
-+					   the fifo */
-+		I2C_ADDR_CFG_SONA_EN |	/* generate stop when NA received */
-+		I2C_ADDR_CFG_MnS_EN |	/* we are master device */
-+		0,			/* our slave address (not used!) */
-+		addr_cfg);
-+
-+	/* enable bus */
-+	i2c_w32_mask(0, I2C_RUN_CTRL_RUN_EN, run_ctrl);
-+
-+	return 0;
-+}
-+
-+static int ltq_i2c_wait_bus_not_busy(struct ltq_i2c *priv)
-+{
-+	unsigned long timeout;
-+
-+	timeout = jiffies + msecs_to_jiffies(LTQ_I2C_BUSY_TIMEOUT);
-+
-+	do {
-+		u32 stat = i2c_r32(bus_stat);
-+
-+		if ((stat & I2C_BUS_STAT_BS_MASK) == I2C_BUS_STAT_BS_FREE)
-+			return 0;
-+
-+		cond_resched();
-+	} while (!time_after_eq(jiffies, timeout));
-+
-+	dev_err(priv->dev, "timeout waiting for bus ready\n");
-+	return -ETIMEDOUT;
-+}
-+
-+static void ltq_i2c_tx(struct ltq_i2c *priv, int last)
-+{
-+	if (priv->msg_buf_len && priv->msg_buf) {
-+		i2c_w32(*priv->msg_buf, txd);
-+
-+		if (--priv->msg_buf_len)
-+			priv->msg_buf++;
-+		else
-+			priv->msg_buf = NULL;
-+	} else {
-+		last = 1;
-+	}
-+
-+	if (last)
-+		disable_burst_irq(priv);
-+}
-+
-+static void ltq_i2c_rx(struct ltq_i2c *priv, int last)
-+{
-+	u32 fifo_stat, timeout;
-+	if (priv->msg_buf_len && priv->msg_buf) {
-+		timeout = 5000000;
-+		do {
-+			fifo_stat = i2c_r32(ffs_stat);
-+		} while (!fifo_stat && --timeout);
-+		if (!timeout) {
-+			last = 1;
-+			pr_debug("\nrx timeout\n");
-+			goto err;
-+		}
-+		while (fifo_stat) {
-+			*priv->msg_buf = i2c_r32(rxd);
-+			if (--priv->msg_buf_len) {
-+				priv->msg_buf++;
-+			} else {
-+				priv->msg_buf = NULL;
-+				last = 1;
-+				break;
-+			}
-+			/*
-+			 * do not read more than burst size, otherwise no "last
-+			 * burst" is generated and the transaction is blocked!
-+			 */
-+			fifo_stat = 0;
-+		}
-+	} else {
-+		last = 1;
-+	}
-+err:
-+	if (last) {
-+		disable_burst_irq(priv);
-+
-+		if (priv->status == STATUS_READ_END) {
-+			/* 
-+			 * do the STATUS_STOP and complete() here, as sometimes
-+			 * the tx_end is already seen before this is finished
-+			 */
-+			priv->status = STATUS_STOP;
-+			complete(&priv->cmd_complete);
-+		} else {
-+			i2c_w32(I2C_ENDD_CTRL_SETEND, endd_ctrl);
-+			priv->status = STATUS_READ_END;
-+		}
-+	}
-+}
-+
-+static void ltq_i2c_xfer_init(struct ltq_i2c *priv)
-+{
-+	/* enable interrupts */
-+	i2c_w32(LTQ_I2C_IMSC_DEFAULT_MASK, imsc);
-+
-+	/* trigger transfer of first msg */
-+	ltq_i2c_set_tx_len(priv);
-+}
-+
-+static void dump_msgs(struct i2c_msg msgs[], int num, int rx)
-+{
-+#if defined(DEBUG)
-+	int i, j;
-+	pr_debug("Messages %d %s\n", num, rx ? "out" : "in");
-+	for (i = 0; i < num; i++) {
-+		pr_debug("%2d %cX Msg(%d) addr=0x%X: ", i,
-+			(msgs[i].flags & I2C_M_RD) ? 'R' : 'T',
-+			msgs[i].len, msgs[i].addr);
-+		if (!(msgs[i].flags & I2C_M_RD) || rx) {
-+			for (j = 0; j < msgs[i].len; j++)
-+				pr_debug("%02X ", msgs[i].buf[j]);
-+		}
-+		pr_debug("\n");
-+	}
-+#endif
-+}
-+
-+static void ltq_i2c_release_bus(struct ltq_i2c *priv)
-+{
-+	if ((i2c_r32(bus_stat) & I2C_BUS_STAT_BS_MASK) == I2C_BUS_STAT_BS_BM)
-+		i2c_w32(I2C_ENDD_CTRL_SETEND, endd_ctrl);
-+}
-+
-+static int ltq_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],
-+			   int num)
-+{
-+	struct ltq_i2c *priv = i2c_get_adapdata(adap);
-+	int ret;
-+
-+	dev_dbg(priv->dev, "xfer %u messages\n", num);
-+	dump_msgs(msgs, num, 0);
-+
-+	mutex_lock(&priv->mutex);
-+
-+	reinit_completion(&priv->cmd_complete);
-+	priv->current_msg = msgs;
-+	priv->msgs_num = num;
-+	priv->msg_err = 0;
-+	priv->status = STATUS_IDLE;
-+
-+	/* wait for the bus to become ready */
-+	ret = ltq_i2c_wait_bus_not_busy(priv);
-+	if (ret)
-+		goto done;
-+
-+	while (priv->msgs_num) {
-+		/* start the transfers */
-+		ltq_i2c_xfer_init(priv);
-+
-+		/* wait for transfers to complete */
-+		ret = wait_for_completion_interruptible_timeout(
-+			&priv->cmd_complete, LTQ_I2C_XFER_TIMEOUT);
-+		if (ret == 0) {
-+			dev_err(priv->dev, "controller timed out\n");
-+			ltq_i2c_hw_init(adap);
-+			ret = -ETIMEDOUT;
-+			goto done;
-+		} else if (ret < 0)
-+			goto done;
-+
-+		if (priv->msg_err) {
-+			if (priv->msg_err & LTQ_I2C_NACK)
-+				ret = -ENXIO;
-+			else
-+				ret = -EREMOTEIO;
-+			goto done;
-+		}
-+		if (--priv->msgs_num)
-+			priv->current_msg++;
-+	}
-+	/* no error? */
-+	ret = num;
-+
-+done:
-+	ltq_i2c_release_bus(priv);
-+
-+	mutex_unlock(&priv->mutex);
-+
-+	if (ret >= 0)
-+		dump_msgs(msgs, num, 1);
-+
-+	pr_debug("XFER ret %d\n", ret);
-+	return ret;
-+}
-+
-+static irqreturn_t ltq_i2c_isr_burst(int irq, void *dev_id)
-+{
-+	struct ltq_i2c *priv = dev_id;
-+	struct i2c_msg *msg = priv->current_msg;
-+	int last = (irq == priv->irq_lb);
-+
-+	if (last)
-+		pr_debug("LB ");
-+	else
-+		pr_debug("B ");
-+
-+	if (msg->flags & I2C_M_RD) {
-+		switch (priv->status) {
-+		case STATUS_ADDR:
-+			pr_debug("X");
-+			prepare_msg_send_addr(priv);
-+			disable_burst_irq(priv);
-+			break;
-+		case STATUS_READ:
-+		case STATUS_READ_END:
-+			pr_debug("R");
-+			ltq_i2c_rx(priv, last);
-+			break;
-+		default:
-+			disable_burst_irq(priv);
-+			pr_warn("Status R %d\n", priv->status);
-+			break;
-+		}
-+	} else {
-+		switch (priv->status) {
-+		case STATUS_ADDR:
-+			pr_debug("x");
-+			prepare_msg_send_addr(priv);
-+			break;
-+		case STATUS_WRITE:
-+			pr_debug("w");
-+			ltq_i2c_tx(priv, last);
-+			break;
-+		default:
-+			disable_burst_irq(priv);
-+			pr_warn("Status W %d\n", priv->status);
-+			break;
-+		}
-+	}
-+
-+	i2c_w32(I2C_ICR_BREQ_INT_CLR | I2C_ICR_LBREQ_INT_CLR, icr);
-+	return IRQ_HANDLED;
-+}
-+
-+static void ltq_i2c_isr_prot(struct ltq_i2c *priv)
-+{
-+	u32 i_pro = i2c_r32(p_irqss);
-+
-+	pr_debug("i2c-p");
-+
-+	/* not acknowledge */
-+	if (i_pro & I2C_P_IRQSS_NACK) {
-+		priv->msg_err |= LTQ_I2C_NACK;
-+		pr_debug(" nack");
-+	}
-+
-+	/* arbitration lost */
-+	if (i_pro & I2C_P_IRQSS_AL) {
-+		priv->msg_err |= LTQ_I2C_ARB_LOST;
-+		pr_debug(" arb-lost");
-+	}
-+	/* tx -> rx switch */
-+	if (i_pro & I2C_P_IRQSS_RX)
-+		pr_debug(" rx");
-+
-+	/* tx end */
-+	if (i_pro & I2C_P_IRQSS_TX_END)
-+		pr_debug(" txend");
-+	pr_debug("\n");
-+
-+	if (!priv->msg_err) {
-+		/* tx -> rx switch */
-+		if (i_pro & I2C_P_IRQSS_RX) {
-+			priv->status = STATUS_READ;
-+			enable_burst_irq(priv);
-+		}
-+		if (i_pro & I2C_P_IRQSS_TX_END) {
-+			if (priv->status == STATUS_READ)
-+				priv->status = STATUS_READ_END;
-+			else {
-+				disable_burst_irq(priv);
-+				priv->status = STATUS_STOP;
-+			}
-+		}
-+	}
-+
-+	i2c_w32(i_pro, p_irqsc);
-+}
-+
-+static irqreturn_t ltq_i2c_isr(int irq, void *dev_id)
-+{
-+	u32 i_raw, i_err = 0;
-+	struct ltq_i2c *priv = dev_id;
-+
-+	i_raw = i2c_r32(mis);
-+	pr_debug("i_raw 0x%08X\n", i_raw);
-+
-+	/* error interrupt */
-+	if (i_raw & I2C_RIS_I2C_ERR_INT_INTOCC) {
-+		i_err = i2c_r32(err_irqss);
-+		pr_debug("i_err 0x%08X bus_stat 0x%04X\n",
-+			i_err, i2c_r32(bus_stat));
-+
-+		/* tx fifo overflow (8) */
-+		if (i_err & I2C_ERR_IRQSS_TXF_OFL)
-+			priv->msg_err |= LTQ_I2C_TX_OFL;
-+
-+		/* tx fifo underflow (4) */
-+		if (i_err & I2C_ERR_IRQSS_TXF_UFL)
-+			priv->msg_err |= LTQ_I2C_TX_UFL;
-+
-+		/* rx fifo overflow (2) */
-+		if (i_err & I2C_ERR_IRQSS_RXF_OFL)
-+			priv->msg_err |= LTQ_I2C_RX_OFL;
-+
-+		/* rx fifo underflow (1) */
-+		if (i_err & I2C_ERR_IRQSS_RXF_UFL)
-+			priv->msg_err |= LTQ_I2C_RX_UFL;
-+
-+		i2c_w32(i_err, err_irqsc);
-+	}
-+
-+	/* protocol interrupt */
-+	if (i_raw & I2C_RIS_I2C_P_INT_INTOCC)
-+		ltq_i2c_isr_prot(priv);
-+
-+	if ((priv->msg_err) || (priv->status == STATUS_STOP))
-+		complete(&priv->cmd_complete);
-+
-+	return IRQ_HANDLED;
-+}
-+
-+static u32 ltq_i2c_functionality(struct i2c_adapter *adap)
-+{
-+	return	I2C_FUNC_I2C |
-+		I2C_FUNC_10BIT_ADDR |
-+		I2C_FUNC_SMBUS_EMUL;
-+}
-+
-+static struct i2c_algorithm ltq_i2c_algorithm = {
-+	.master_xfer	= ltq_i2c_xfer,
-+	.functionality	= ltq_i2c_functionality,
-+};
-+
-+static int ltq_i2c_probe(struct platform_device *pdev)
-+{
-+	struct device_node *node = pdev->dev.of_node;
-+	struct ltq_i2c *priv;
-+	struct i2c_adapter *adap;
-+	struct resource *mmres, irqres[4];
-+	int ret = 0;
-+
-+	dev_dbg(&pdev->dev, "probing\n");
-+
-+	mmres = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-+	ret = of_irq_to_resource_table(node, irqres, 4);
-+	if (!mmres || (ret != 4)) {
-+		dev_err(&pdev->dev, "no resources\n");
-+		return -ENODEV;
-+	}
-+
-+	/* allocate private data */
-+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
-+	if (!priv) {
-+		dev_err(&pdev->dev, "can't allocate private data\n");
-+		return -ENOMEM;
-+	}
-+
-+	adap = &priv->adap;
-+	i2c_set_adapdata(adap, priv);
-+	adap->owner = THIS_MODULE;
-+	adap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
-+	strlcpy(adap->name, DRV_NAME "-adapter", sizeof(adap->name));
-+	adap->algo = &ltq_i2c_algorithm;
-+
-+	if (of_property_read_u32(node, "clock-frequency", &priv->i2c_clock)) {
-+		dev_warn(&pdev->dev, "No I2C speed selected, using 100kHz\n");
-+		priv->i2c_clock = 100000;
-+	}
-+
-+	init_completion(&priv->cmd_complete);
-+	mutex_init(&priv->mutex);
-+
-+	priv->membase = devm_ioremap_resource(&pdev->dev, mmres);
-+	if (IS_ERR(priv->membase))
-+		return PTR_ERR(priv->membase);
-+
-+	priv->dev = &pdev->dev;
-+	priv->irq_lb = irqres[0].start;
-+
-+	ret = devm_request_irq(&pdev->dev, irqres[0].start, ltq_i2c_isr_burst,
-+		IRQF_DISABLED, "i2c lb", priv);
-+	if (ret) {
-+		dev_err(&pdev->dev, "can't get last burst IRQ %d\n",
-+			irqres[0].start);
-+		return -ENODEV;
-+	}
-+
-+	ret = devm_request_irq(&pdev->dev, irqres[1].start, ltq_i2c_isr_burst,
-+		IRQF_DISABLED, "i2c b", priv);
-+	if (ret) {
-+		dev_err(&pdev->dev, "can't get burst IRQ %d\n",
-+			irqres[1].start);
-+		return -ENODEV;
-+	}
-+
-+	ret = devm_request_irq(&pdev->dev, irqres[2].start, ltq_i2c_isr,
-+		IRQF_DISABLED, "i2c err", priv);
-+	if (ret) {
-+		dev_err(&pdev->dev, "can't get error IRQ %d\n",
-+			irqres[2].start);
-+		return -ENODEV;
-+	}
-+
-+	ret = devm_request_irq(&pdev->dev, irqres[3].start, ltq_i2c_isr,
-+		IRQF_DISABLED, "i2c p", priv);
-+	if (ret) {
-+		dev_err(&pdev->dev, "can't get protocol IRQ %d\n",
-+			irqres[3].start);
-+		return -ENODEV;
-+	}
-+
-+	dev_dbg(&pdev->dev, "mapped io-space to %p\n", priv->membase);
-+	dev_dbg(&pdev->dev, "use IRQs %d, %d, %d, %d\n", irqres[0].start,
-+		irqres[1].start, irqres[2].start, irqres[3].start);
-+
-+	priv->clk_gate = devm_clk_get(&pdev->dev, NULL);
-+	if (IS_ERR(priv->clk_gate)) {
-+		dev_err(&pdev->dev, "failed to get i2c clk\n");
-+		return -ENOENT;
-+	}
-+
-+	/* this is a static clock, which has no refcounting */
-+	priv->clk_input = clk_get_fpi();
-+	if (IS_ERR(priv->clk_input)) {
-+		dev_err(&pdev->dev, "failed to get fpi clk\n");
-+		return -ENOENT;
-+	}
-+
-+	clk_activate(priv->clk_gate);
-+
-+	/* add our adapter to the i2c stack */
-+	ret = i2c_add_numbered_adapter(adap);
-+	if (ret) {
-+		dev_err(&pdev->dev, "can't register I2C adapter\n");
-+		goto out;
-+	}
-+
-+	platform_set_drvdata(pdev, priv);
-+	i2c_set_adapdata(adap, priv);
-+
-+	/* print module version information */
-+	dev_dbg(&pdev->dev, "module id=%u revision=%u\n",
-+		(i2c_r32(id) & I2C_ID_ID_MASK) >> I2C_ID_ID_OFFSET,
-+		(i2c_r32(id) & I2C_ID_REV_MASK) >> I2C_ID_REV_OFFSET);
-+
-+	/* initialize HW */
-+	ret = ltq_i2c_hw_init(adap);
-+	if (ret) {
-+		dev_err(&pdev->dev, "can't configure adapter\n");
-+		i2c_del_adapter(adap);
-+		platform_set_drvdata(pdev, NULL);
-+	} else {
-+		dev_info(&pdev->dev, "version %s\n", DRV_VERSION);
-+	}
-+
-+out:
-+	/* if init failed, we need to deactivate the clock gate */
-+	if (ret)
-+		clk_deactivate(priv->clk_gate);
-+
-+	return ret;
-+}
-+
-+static int ltq_i2c_remove(struct platform_device *pdev)
-+{
-+	struct ltq_i2c *priv = platform_get_drvdata(pdev);
-+
-+	/* disable bus */
-+	i2c_w32_mask(I2C_RUN_CTRL_RUN_EN, 0, run_ctrl);
-+
-+	/* power down the core */
-+	clk_deactivate(priv->clk_gate);
-+
-+	/* remove driver */
-+	i2c_del_adapter(&priv->adap);
-+	kfree(priv);
-+
-+	dev_dbg(&pdev->dev, "removed\n");
-+	platform_set_drvdata(pdev, NULL);
-+
-+	return 0;
-+}
-+static const struct of_device_id ltq_i2c_match[] = {
-+	{ .compatible = "lantiq,lantiq-i2c" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, ltq_i2c_match);
-+
-+static struct platform_driver ltq_i2c_driver = {
-+	.probe	= ltq_i2c_probe,
-+	.remove	= ltq_i2c_remove,
-+	.driver	= {
-+		.name	= DRV_NAME,
-+		.owner	= THIS_MODULE,
-+		.of_match_table = ltq_i2c_match,
-+	},
-+};
-+
-+module_platform_driver(ltq_i2c_driver);
-+
-+MODULE_DESCRIPTION("Lantiq I2C bus adapter");
-+MODULE_AUTHOR("Thomas Langer <thomas.langer@lantiq.com>");
-+MODULE_ALIAS("platform:" DRV_NAME);
-+MODULE_LICENSE("GPL");
-+MODULE_VERSION(DRV_VERSION);
-diff --git a/drivers/i2c/busses/i2c-lantiq.h b/drivers/i2c/busses/i2c-lantiq.h
-new file mode 100644
---- /dev/null
-+++ b/drivers/i2c/busses/i2c-lantiq.h
-@@ -0,0 +1,234 @@
-+#ifndef I2C_LANTIQ_H
-+#define I2C_LANTIQ_H
-+
-+/* I2C register structure */
-+struct lantiq_reg_i2c {
-+	/* I2C Kernel Clock Control Register */
-+	unsigned int clc; /* 0x00000000 */
-+	/* Reserved */
-+	unsigned int res_0; /* 0x00000004 */
-+	/* I2C Identification Register */
-+	unsigned int id; /* 0x00000008 */
-+	/* Reserved */
-+	unsigned int res_1; /* 0x0000000C */
-+	/*
-+	 * I2C RUN Control Register
-+	 * This register enables and disables the I2C peripheral. Before
-+	 * enabling, the I2C has to be configured properly. After enabling
-+	 * no configuration is possible
-+	 */
-+	unsigned int run_ctrl; /* 0x00000010 */
-+	/*
-+	 * I2C End Data Control Register
-+	 * This register is used to either turn around the data transmission
-+	 * direction or to address another slave without sending a stop
-+	 * condition. Also the software can stop the slave-transmitter by
-+	 * sending a not-accolade when working as master-receiver or even
-+	 * stop data transmission immediately when operating as
-+	 * master-transmitter. The writing to the bits of this control
-+	 * register is only effective when in MASTER RECEIVES BYTES, MASTER
-+	 * TRANSMITS BYTES, MASTER RESTART or SLAVE RECEIVE BYTES state
-+	 */
-+	unsigned int endd_ctrl; /* 0x00000014 */
-+	/*
-+	 * I2C Fractional Divider Configuration Register
-+	 * These register is used to program the fractional divider of the I2C
-+	 * bus. Before the peripheral is switched on by setting the RUN-bit the
-+	 * two (fixed) values for the two operating frequencies are programmed
-+	 * into these (configuration) registers. The Register FDIV_HIGH_CFG has
-+	 * the same layout as I2C_FDIV_CFG.
-+	 */
-+	unsigned int fdiv_cfg; /* 0x00000018 */
-+	/*
-+	 * I2C Fractional Divider (highspeed mode) Configuration Register
-+	 * These register is used to program the fractional divider of the I2C
-+	 * bus. Before the peripheral is switched on by setting the RUN-bit the
-+	 * two (fixed) values for the two operating frequencies are programmed
-+	 * into these (configuration) registers. The Register FDIV_CFG has the
-+	 * same layout as I2C_FDIV_CFG.
-+	 */
-+	unsigned int fdiv_high_cfg; /* 0x0000001C */
-+	/* I2C Address Configuration Register */
-+	unsigned int addr_cfg; /* 0x00000020 */
-+	/* I2C Bus Status Register
-+	 * This register gives a status information of the I2C. This additional
-+	 * information can be used by the software to start proper actions.
-+	 */
-+	unsigned int bus_stat; /* 0x00000024 */
-+	/* I2C FIFO Configuration Register */
-+	unsigned int fifo_cfg; /* 0x00000028 */
-+	/* I2C Maximum Received Packet Size Register */
-+	unsigned int mrps_ctrl; /* 0x0000002C */
-+	/* I2C Received Packet Size Status Register */
-+	unsigned int rps_stat; /* 0x00000030 */
-+	/* I2C Transmit Packet Size Register */
-+	unsigned int tps_ctrl; /* 0x00000034 */
-+	/* I2C Filled FIFO Stages Status Register */
-+	unsigned int ffs_stat; /* 0x00000038 */
-+	/* Reserved */
-+	unsigned int res_2; /* 0x0000003C */
-+	/* I2C Timing Configuration Register */
-+	unsigned int tim_cfg; /* 0x00000040 */
-+	/* Reserved */
-+	unsigned int res_3[7]; /* 0x00000044 */
-+	/* I2C Error Interrupt Request Source Mask Register */
-+	unsigned int err_irqsm; /* 0x00000060 */
-+	/* I2C Error Interrupt Request Source Status Register */
-+	unsigned int err_irqss; /* 0x00000064 */
-+	/* I2C Error Interrupt Request Source Clear Register */
-+	unsigned int err_irqsc; /* 0x00000068 */
-+	/* Reserved */
-+	unsigned int res_4; /* 0x0000006C */
-+	/* I2C Protocol Interrupt Request Source Mask Register */
-+	unsigned int p_irqsm; /* 0x00000070 */
-+	/* I2C Protocol Interrupt Request Source Status Register */
-+	unsigned int p_irqss; /* 0x00000074 */
-+	/* I2C Protocol Interrupt Request Source Clear Register */
-+	unsigned int p_irqsc; /* 0x00000078 */
-+	/* Reserved */
-+	unsigned int res_5; /* 0x0000007C */
-+	/* I2C Raw Interrupt Status Register */
-+	unsigned int ris; /* 0x00000080 */
-+	/* I2C Interrupt Mask Control Register */
-+	unsigned int imsc; /* 0x00000084 */
-+	/* I2C Masked Interrupt Status Register */
-+	unsigned int mis; /* 0x00000088 */
-+	/* I2C Interrupt Clear Register */
-+	unsigned int icr; /* 0x0000008C */
-+	/* I2C Interrupt Set Register */
-+	unsigned int isr; /* 0x00000090 */
-+	/* I2C DMA Enable Register */
-+	unsigned int dmae; /* 0x00000094 */
-+	/* Reserved */
-+	unsigned int res_6[8154]; /* 0x00000098 */
-+	/* I2C Transmit Data Register */
-+	unsigned int txd; /* 0x00008000 */
-+	/* Reserved */
-+	unsigned int res_7[4095]; /* 0x00008004 */
-+	/* I2C Receive Data Register */
-+	unsigned int rxd; /* 0x0000C000 */
-+	/* Reserved */
-+	unsigned int res_8[4095]; /* 0x0000C004 */
-+};
-+
-+/*
-+ * Clock Divider for Normal Run Mode
-+ * Max 8-bit divider value. IF RMC is 0 the module is disabled. Note: As long
-+ * as the new divider value RMC is not valid, the register returns 0x0000 00xx
-+ * on reading.
-+ */
-+#define I2C_CLC_RMC_MASK 0x0000FF00
-+/* field offset */
-+#define I2C_CLC_RMC_OFFSET 8
-+
-+/* Fields of "I2C Identification Register" */
-+/* Module ID */
-+#define I2C_ID_ID_MASK 0x0000FF00
-+/* field offset */
-+#define I2C_ID_ID_OFFSET 8
-+/* Revision */
-+#define I2C_ID_REV_MASK 0x000000FF
-+/* field offset */
-+#define I2C_ID_REV_OFFSET 0
-+
-+/* Fields of "I2C Interrupt Mask Control Register" */
-+/* Enable */
-+#define I2C_IMSC_BREQ_INT_EN 0x00000008
-+/* Enable */
-+#define I2C_IMSC_LBREQ_INT_EN 0x00000004
-+
-+/* Fields of "I2C Fractional Divider Configuration Register" */
-+/* field offset */
-+#define I2C_FDIV_CFG_INC_OFFSET 16
-+
-+/* Fields of "I2C Interrupt Mask Control Register" */
-+/* Enable */
-+#define I2C_IMSC_I2C_P_INT_EN 0x00000020
-+/* Enable */
-+#define I2C_IMSC_I2C_ERR_INT_EN 0x00000010
-+
-+/* Fields of "I2C Error Interrupt Request Source Status Register" */
-+/* TXF_OFL */
-+#define I2C_ERR_IRQSS_TXF_OFL 0x00000008
-+/* TXF_UFL */
-+#define I2C_ERR_IRQSS_TXF_UFL 0x00000004
-+/* RXF_OFL */
-+#define I2C_ERR_IRQSS_RXF_OFL 0x00000002
-+/* RXF_UFL */
-+#define I2C_ERR_IRQSS_RXF_UFL 0x00000001
-+
-+/* Fields of "I2C Raw Interrupt Status Register" */
-+/* Read: Interrupt occurred. */
-+#define I2C_RIS_I2C_ERR_INT_INTOCC 0x00000010
-+/* Read: Interrupt occurred. */
-+#define I2C_RIS_I2C_P_INT_INTOCC 0x00000020
-+
-+/* Fields of "I2C FIFO Configuration Register" */
-+/* TX FIFO Flow Control */
-+#define I2C_FIFO_CFG_TXFC 0x00020000
-+/* RX FIFO Flow Control */
-+#define I2C_FIFO_CFG_RXFC 0x00010000
-+/* Word aligned (character alignment of four characters) */
-+#define I2C_FIFO_CFG_TXFA_TXFA2 0x00002000
-+/* Word aligned (character alignment of four characters) */
-+#define I2C_FIFO_CFG_RXFA_RXFA2 0x00000200
-+/* 1 word */
-+#define I2C_FIFO_CFG_TXBS_TXBS0 0x00000000
-+
-+/* Fields of "I2C FIFO Configuration Register" */
-+/* 1 word */
-+#define I2C_FIFO_CFG_RXBS_RXBS0 0x00000000
-+/* Stop on Packet End Enable */
-+#define I2C_ADDR_CFG_SOPE_EN 0x00200000
-+/* Stop on Not Acknowledge Enable */
-+#define I2C_ADDR_CFG_SONA_EN 0x00100000
-+/* Enable */
-+#define I2C_ADDR_CFG_MnS_EN 0x00080000
-+
-+/* Fields of "I2C Interrupt Clear Register" */
-+/* Clear */
-+#define I2C_ICR_BREQ_INT_CLR 0x00000008
-+/* Clear */
-+#define I2C_ICR_LBREQ_INT_CLR 0x00000004
-+
-+/* Fields of "I2C Fractional Divider Configuration Register" */
-+/* field offset */
-+#define I2C_FDIV_CFG_DEC_OFFSET 0
-+
-+/* Fields of "I2C Bus Status Register" */
-+/* Bus Status */
-+#define I2C_BUS_STAT_BS_MASK 0x00000003
-+/* Read from I2C Bus. */
-+#define I2C_BUS_STAT_RNW_READ 0x00000004
-+/* I2C Bus is free. */
-+#define I2C_BUS_STAT_BS_FREE 0x00000000
-+/*
-+ * The device is working as master and has claimed the control on the
-+ * I2C-bus (busy master).
-+ */
-+#define I2C_BUS_STAT_BS_BM 0x00000002
-+
-+/* Fields of "I2C RUN Control Register" */
-+/* Enable */
-+#define I2C_RUN_CTRL_RUN_EN 0x00000001
-+
-+/* Fields of "I2C End Data Control Register" */
-+/*
-+ * Set End of Transmission
-+ * Note:Do not write '1' to this bit when bus is free. This will cause an
-+ * abort after the first byte when a new transfer is started.
-+ */
-+#define I2C_ENDD_CTRL_SETEND 0x00000002
-+
-+/* Fields of "I2C Protocol Interrupt Request Source Status Register" */
-+/* NACK */
-+#define I2C_P_IRQSS_NACK 0x00000010
-+/* AL */
-+#define I2C_P_IRQSS_AL 0x00000008
-+/* RX */
-+#define I2C_P_IRQSS_RX 0x00000040
-+/* TX_END */
-+#define I2C_P_IRQSS_TX_END 0x00000020
-+
-+
-+#endif /* I2C_LANTIQ_H */
diff --git a/target/linux/lantiq/patches-3.18/0032-USB-fix-roothub-for-IFXHCD.patch b/target/linux/lantiq/patches-3.18/0032-USB-fix-roothub-for-IFXHCD.patch
deleted file mode 100644
index cf2c5cbd5b..0000000000
--- a/target/linux/lantiq/patches-3.18/0032-USB-fix-roothub-for-IFXHCD.patch
+++ /dev/null
@@ -1,31 +0,0 @@
-From 326714a47233e4a524afa0c8398276fddf0dbd4d Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Thu, 6 Dec 2012 19:59:53 +0100
-Subject: [PATCH 32/36] USB: fix roothub for IFXHCD
-
----
- arch/mips/lantiq/Kconfig |    1 +
- drivers/usb/core/hub.c   |    2 +-
- 2 files changed, 2 insertions(+), 1 deletion(-)
-
---- a/arch/mips/lantiq/Kconfig
-+++ b/arch/mips/lantiq/Kconfig
-@@ -3,6 +3,7 @@ if LANTIQ
- config SOC_TYPE_XWAY
- 	bool
- 	select PINCTRL_XWAY
-+	select USB_ARCH_HAS_HCD
- 	default n
- 
- choice
---- a/drivers/usb/core/hub.c
-+++ b/drivers/usb/core/hub.c
-@@ -4303,7 +4303,7 @@ hub_port_init (struct usb_hub *hub, stru
- 		udev->ttport = hdev->ttport;
- 	} else if (udev->speed != USB_SPEED_HIGH
- 			&& hdev->speed == USB_SPEED_HIGH) {
--		if (!hub->tt.hub) {
-+		if (hdev->parent && !hub->tt.hub) {
- 			dev_err(&udev->dev, "parent hub has no TT\n");
- 			retval = -EINVAL;
- 			goto fail;
diff --git a/target/linux/lantiq/patches-3.18/0033-SPI-MIPS-lantiq-adds-spi-xway.patch b/target/linux/lantiq/patches-3.18/0033-SPI-MIPS-lantiq-adds-spi-xway.patch
deleted file mode 100644
index ed00b34336..0000000000
--- a/target/linux/lantiq/patches-3.18/0033-SPI-MIPS-lantiq-adds-spi-xway.patch
+++ /dev/null
@@ -1,1020 +0,0 @@
-From e75df4f96373e5d16f8ca13aa031e54cdcfeda62 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Wed, 13 Mar 2013 09:29:37 +0100
-Subject: [PATCH 33/36] SPI: MIPS: lantiq: adds spi-xway
-
-This patch adds support for the SPI core found on several Lantiq SoCs.
-The Driver has been runtime tested in combination with m25p80 Flash Devices
-on Amazon_SE and VR9.
-
-Signed-off-by: Daniel Schwierzeck <daniel.schwierzeck@googlemail.com>
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/spi/Kconfig    |    8 +
- drivers/spi/Makefile   |    1 +
- drivers/spi/spi-xway.c |  977 ++++++++++++++++++++++++++++++++++++++++++++++++
- 3 files changed, 986 insertions(+)
- create mode 100644 drivers/spi/spi-xway.c
-
---- a/drivers/spi/Kconfig
-+++ b/drivers/spi/Kconfig
-@@ -597,6 +597,14 @@ config SPI_NUC900
- 	help
- 	  SPI driver for Nuvoton NUC900 series ARM SoCs
- 
-+config SPI_XWAY
-+	tristate "Lantiq XWAY SPI controller"
-+	depends on LANTIQ && SOC_TYPE_XWAY
-+	select SPI_BITBANG
-+	help
-+	  This driver supports the Lantiq SoC SPI controller in master
-+	  mode.
-+
- #
- # Add new SPI master controllers in alphabetical order above this line
- #
---- a/drivers/spi/Makefile
-+++ b/drivers/spi/Makefile
-@@ -86,3 +86,4 @@ obj-$(CONFIG_SPI_TXX9)			+= spi-txx9.o
- obj-$(CONFIG_SPI_XCOMM)		+= spi-xcomm.o
- obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
- obj-$(CONFIG_SPI_XTENSA_XTFPGA)		+= spi-xtensa-xtfpga.o
-+obj-$(CONFIG_SPI_XWAY)			+= spi-xway.o
---- /dev/null
-+++ b/drivers/spi/spi-xway.c
-@@ -0,0 +1,975 @@
-+/*
-+ * Lantiq SoC SPI controller
-+ *
-+ * Copyright (C) 2011 Daniel Schwierzeck <daniel.schwierzeck@googlemail.com>
-+ * Copyright (C) 2012 John Crispin <blogic@openwrt.org>
-+ *
-+ * This program is free software; you can distribute it and/or modify it
-+ * under the terms of the GNU General Public License (Version 2) as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#include <linux/init.h>
-+#include <linux/module.h>
-+#include <linux/workqueue.h>
-+#include <linux/platform_device.h>
-+#include <linux/io.h>
-+#include <linux/sched.h>
-+#include <linux/delay.h>
-+#include <linux/interrupt.h>
-+#include <linux/completion.h>
-+#include <linux/spinlock.h>
-+#include <linux/err.h>
-+#include <linux/clk.h>
-+#include <linux/spi/spi.h>
-+#include <linux/spi/spi_bitbang.h>
-+#include <linux/of_irq.h>
-+
-+#include <lantiq_soc.h>
-+
-+#define LTQ_SPI_CLC		0x00	/* Clock control */
-+#define LTQ_SPI_PISEL		0x04	/* Port input select */
-+#define LTQ_SPI_ID		0x08	/* Identification */
-+#define LTQ_SPI_CON		0x10	/* Control */
-+#define LTQ_SPI_STAT		0x14	/* Status */
-+#define LTQ_SPI_WHBSTATE	0x18	/* Write HW modified state */
-+#define LTQ_SPI_TB		0x20	/* Transmit buffer */
-+#define LTQ_SPI_RB		0x24	/* Receive buffer */
-+#define LTQ_SPI_RXFCON		0x30	/* Receive FIFO control */
-+#define LTQ_SPI_TXFCON		0x34	/* Transmit FIFO control */
-+#define LTQ_SPI_FSTAT		0x38	/* FIFO status */
-+#define LTQ_SPI_BRT		0x40	/* Baudrate timer */
-+#define LTQ_SPI_BRSTAT		0x44	/* Baudrate timer status */
-+#define LTQ_SPI_SFCON		0x60	/* Serial frame control */
-+#define LTQ_SPI_SFSTAT		0x64	/* Serial frame status */
-+#define LTQ_SPI_GPOCON		0x70	/* General purpose output control */
-+#define LTQ_SPI_GPOSTAT		0x74	/* General purpose output status */
-+#define LTQ_SPI_FGPO		0x78	/* Forced general purpose output */
-+#define LTQ_SPI_RXREQ		0x80	/* Receive request */
-+#define LTQ_SPI_RXCNT		0x84	/* Receive count */
-+#define LTQ_SPI_DMACON		0xEC	/* DMA control */
-+#define LTQ_SPI_IRNEN		0xF4	/* Interrupt node enable */
-+#define LTQ_SPI_IRNICR		0xF8	/* Interrupt node interrupt capture */
-+#define LTQ_SPI_IRNCR		0xFC	/* Interrupt node control */
-+
-+#define LTQ_SPI_CLC_SMC_SHIFT	16	/* Clock divider for sleep mode */
-+#define LTQ_SPI_CLC_SMC_MASK	0xFF
-+#define LTQ_SPI_CLC_RMC_SHIFT	8	/* Clock divider for normal run mode */
-+#define LTQ_SPI_CLC_RMC_MASK	0xFF
-+#define LTQ_SPI_CLC_DISS	BIT(1)	/* Disable status bit */
-+#define LTQ_SPI_CLC_DISR	BIT(0)	/* Disable request bit */
-+
-+#define LTQ_SPI_ID_TXFS_SHIFT	24	/* Implemented TX FIFO size */
-+#define LTQ_SPI_ID_TXFS_MASK	0x3F
-+#define LTQ_SPI_ID_RXFS_SHIFT	16	/* Implemented RX FIFO size */
-+#define LTQ_SPI_ID_RXFS_MASK	0x3F
-+#define LTQ_SPI_ID_REV_MASK	0x1F	/* Hardware revision number */
-+#define LTQ_SPI_ID_CFG		BIT(5)	/* DMA interface support */
-+
-+#define LTQ_SPI_CON_BM_SHIFT	16	/* Data width selection */
-+#define LTQ_SPI_CON_BM_MASK	0x1F
-+#define LTQ_SPI_CON_EM		BIT(24)	/* Echo mode */
-+#define LTQ_SPI_CON_IDLE	BIT(23)	/* Idle bit value */
-+#define LTQ_SPI_CON_ENBV	BIT(22)	/* Enable byte valid control */
-+#define LTQ_SPI_CON_RUEN	BIT(12)	/* Receive underflow error enable */
-+#define LTQ_SPI_CON_TUEN	BIT(11)	/* Transmit underflow error enable */
-+#define LTQ_SPI_CON_AEN		BIT(10)	/* Abort error enable */
-+#define LTQ_SPI_CON_REN		BIT(9)	/* Receive overflow error enable */
-+#define LTQ_SPI_CON_TEN		BIT(8)	/* Transmit overflow error enable */
-+#define LTQ_SPI_CON_LB		BIT(7)	/* Loopback control */
-+#define LTQ_SPI_CON_PO		BIT(6)	/* Clock polarity control */
-+#define LTQ_SPI_CON_PH		BIT(5)	/* Clock phase control */
-+#define LTQ_SPI_CON_HB		BIT(4)	/* Heading control */
-+#define LTQ_SPI_CON_RXOFF	BIT(1)	/* Switch receiver off */
-+#define LTQ_SPI_CON_TXOFF	BIT(0)	/* Switch transmitter off */
-+
-+#define LTQ_SPI_STAT_RXBV_MASK	0x7
-+#define LTQ_SPI_STAT_RXBV_SHIFT	28
-+#define LTQ_SPI_STAT_BSY	BIT(13)	/* Busy flag */
-+#define LTQ_SPI_STAT_RUE	BIT(12)	/* Receive underflow error flag */
-+#define LTQ_SPI_STAT_TUE	BIT(11)	/* Transmit underflow error flag */
-+#define LTQ_SPI_STAT_AE		BIT(10)	/* Abort error flag */
-+#define LTQ_SPI_STAT_RE		BIT(9)	/* Receive error flag */
-+#define LTQ_SPI_STAT_TE		BIT(8)	/* Transmit error flag */
-+#define LTQ_SPI_STAT_MS		BIT(1)	/* Master/slave select bit */
-+#define LTQ_SPI_STAT_EN		BIT(0)	/* Enable bit */
-+
-+#define LTQ_SPI_WHBSTATE_SETTUE	BIT(15)	/* Set transmit underflow error flag */
-+#define LTQ_SPI_WHBSTATE_SETAE	BIT(14)	/* Set abort error flag */
-+#define LTQ_SPI_WHBSTATE_SETRE	BIT(13)	/* Set receive error flag */
-+#define LTQ_SPI_WHBSTATE_SETTE	BIT(12)	/* Set transmit error flag */
-+#define LTQ_SPI_WHBSTATE_CLRTUE	BIT(11)	/* Clear transmit underflow error
-+						flag */
-+#define LTQ_SPI_WHBSTATE_CLRAE	BIT(10)	/* Clear abort error flag */
-+#define LTQ_SPI_WHBSTATE_CLRRE	BIT(9)	/* Clear receive error flag */
-+#define LTQ_SPI_WHBSTATE_CLRTE	BIT(8)	/* Clear transmit error flag */
-+#define LTQ_SPI_WHBSTATE_SETME	BIT(7)	/* Set mode error flag */
-+#define LTQ_SPI_WHBSTATE_CLRME	BIT(6)	/* Clear mode error flag */
-+#define LTQ_SPI_WHBSTATE_SETRUE	BIT(5)	/* Set receive underflow error flag */
-+#define LTQ_SPI_WHBSTATE_CLRRUE	BIT(4)	/* Clear receive underflow error flag */
-+#define LTQ_SPI_WHBSTATE_SETMS	BIT(3)	/* Set master select bit */
-+#define LTQ_SPI_WHBSTATE_CLRMS	BIT(2)	/* Clear master select bit */
-+#define LTQ_SPI_WHBSTATE_SETEN	BIT(1)	/* Set enable bit (operational mode) */
-+#define LTQ_SPI_WHBSTATE_CLREN	BIT(0)	/* Clear enable bit (config mode */
-+#define LTQ_SPI_WHBSTATE_CLR_ERRORS	0x0F50
-+
-+#define LTQ_SPI_RXFCON_RXFITL_SHIFT	8 /* FIFO interrupt trigger level */
-+#define LTQ_SPI_RXFCON_RXFITL_MASK	0x3F
-+#define LTQ_SPI_RXFCON_RXFLU		BIT(1)	/* FIFO flush */
-+#define LTQ_SPI_RXFCON_RXFEN		BIT(0)	/* FIFO enable */
-+
-+#define LTQ_SPI_TXFCON_TXFITL_SHIFT	8 /* FIFO interrupt trigger level */
-+#define LTQ_SPI_TXFCON_TXFITL_MASK	0x3F
-+#define LTQ_SPI_TXFCON_TXFLU		BIT(1)	/* FIFO flush */
-+#define LTQ_SPI_TXFCON_TXFEN		BIT(0)	/* FIFO enable */
-+
-+#define LTQ_SPI_FSTAT_RXFFL_MASK	0x3f
-+#define LTQ_SPI_FSTAT_RXFFL_SHIFT	0
-+#define LTQ_SPI_FSTAT_TXFFL_MASK	0x3f
-+#define LTQ_SPI_FSTAT_TXFFL_SHIFT	8
-+
-+#define LTQ_SPI_GPOCON_ISCSBN_SHIFT	8
-+#define LTQ_SPI_GPOCON_INVOUTN_SHIFT	0
-+
-+#define LTQ_SPI_FGPO_SETOUTN_SHIFT	8
-+#define LTQ_SPI_FGPO_CLROUTN_SHIFT	0
-+
-+#define LTQ_SPI_RXREQ_RXCNT_MASK	0xFFFF	/* Receive count value */
-+#define LTQ_SPI_RXCNT_TODO_MASK		0xFFFF	/* Recevie to-do value */
-+
-+#define LTQ_SPI_IRNEN_F		BIT(3)	/* Frame end interrupt request */
-+#define LTQ_SPI_IRNEN_E		BIT(2)	/* Error end interrupt request */
-+#define LTQ_SPI_IRNEN_T		BIT(1)	/* Transmit end interrupt request */
-+#define LTQ_SPI_IRNEN_R		BIT(0)	/* Receive end interrupt request */
-+#define LTQ_SPI_IRNEN_ALL	0xF
-+
-+struct ltq_spi {
-+	struct spi_bitbang	bitbang;
-+	struct completion	done;
-+	spinlock_t		lock;
-+
-+	struct device		*dev;
-+	void __iomem		*base;
-+	struct clk		*fpiclk;
-+	struct clk		*spiclk;
-+
-+	int			status;
-+	int			irq[3];
-+
-+	const u8		*tx;
-+	u8			*rx;
-+	u32			tx_cnt;
-+	u32			rx_cnt;
-+	u32			len;
-+	struct spi_transfer	*curr_transfer;
-+
-+	u32 (*get_tx) (struct ltq_spi *);
-+
-+	u16			txfs;
-+	u16			rxfs;
-+	unsigned		dma_support:1;
-+	unsigned		cfg_mode:1;
-+};
-+
-+static inline struct ltq_spi *ltq_spi_to_hw(struct spi_device *spi)
-+{
-+	return spi_master_get_devdata(spi->master);
-+}
-+
-+static inline u32 ltq_spi_reg_read(struct ltq_spi *hw, u32 reg)
-+{
-+	return ioread32be(hw->base + reg);
-+}
-+
-+static inline void ltq_spi_reg_write(struct ltq_spi *hw, u32 val, u32 reg)
-+{
-+	iowrite32be(val, hw->base + reg);
-+}
-+
-+static inline void ltq_spi_reg_setbit(struct ltq_spi *hw, u32 bits, u32 reg)
-+{
-+	u32 val;
-+
-+	val = ltq_spi_reg_read(hw, reg);
-+	val |= bits;
-+	ltq_spi_reg_write(hw, val, reg);
-+}
-+
-+static inline void ltq_spi_reg_clearbit(struct ltq_spi *hw, u32 bits, u32 reg)
-+{
-+	u32 val;
-+
-+	val = ltq_spi_reg_read(hw, reg);
-+	val &= ~bits;
-+	ltq_spi_reg_write(hw, val, reg);
-+}
-+
-+static void ltq_spi_hw_enable(struct ltq_spi *hw)
-+{
-+	u32 clc;
-+
-+	/* Power-up module */
-+	clk_enable(hw->spiclk);
-+
-+	/*
-+	 * Set clock divider for run mode to 1 to
-+	 * run at same frequency as FPI bus
-+	 */
-+	clc = (1 << LTQ_SPI_CLC_RMC_SHIFT);
-+	ltq_spi_reg_write(hw, clc, LTQ_SPI_CLC);
-+}
-+
-+static void ltq_spi_hw_disable(struct ltq_spi *hw)
-+{
-+	/* Set clock divider to 0 and set module disable bit */
-+	ltq_spi_reg_write(hw, LTQ_SPI_CLC_DISS, LTQ_SPI_CLC);
-+
-+	/* Power-down module */
-+	clk_disable(hw->spiclk);
-+}
-+
-+static void ltq_spi_reset_fifos(struct ltq_spi *hw)
-+{
-+	u32 val;
-+
-+	/*
-+	 * Enable and flush FIFOs. Set interrupt trigger level to
-+	 * half of FIFO count implemented in hardware.
-+	 */
-+	if (hw->txfs > 1) {
-+		val = hw->txfs << (LTQ_SPI_TXFCON_TXFITL_SHIFT - 1);
-+		val |= LTQ_SPI_TXFCON_TXFEN | LTQ_SPI_TXFCON_TXFLU;
-+		ltq_spi_reg_write(hw, val, LTQ_SPI_TXFCON);
-+	}
-+
-+	if (hw->rxfs > 1) {
-+		val = hw->rxfs << (LTQ_SPI_RXFCON_RXFITL_SHIFT - 1);
-+		val |= LTQ_SPI_RXFCON_RXFEN | LTQ_SPI_RXFCON_RXFLU;
-+		ltq_spi_reg_write(hw, val, LTQ_SPI_RXFCON);
-+	}
-+}
-+
-+static inline int ltq_spi_wait_ready(struct ltq_spi *hw)
-+{
-+	u32 stat;
-+	unsigned long timeout;
-+
-+	timeout = jiffies + msecs_to_jiffies(200);
-+
-+	do {
-+		stat = ltq_spi_reg_read(hw, LTQ_SPI_STAT);
-+		if (!(stat & LTQ_SPI_STAT_BSY))
-+			return 0;
-+
-+		cond_resched();
-+	} while (!time_after_eq(jiffies, timeout));
-+
-+	dev_err(hw->dev, "SPI wait ready timed out stat: %x\n", stat);
-+
-+	return -ETIMEDOUT;
-+}
-+
-+static void ltq_spi_config_mode_set(struct ltq_spi *hw)
-+{
-+	if (hw->cfg_mode)
-+		return;
-+
-+	/*
-+	 * Putting the SPI module in config mode is only safe if no
-+	 * transfer is in progress as indicated by busy flag STATE.BSY.
-+	 */
-+	if (ltq_spi_wait_ready(hw)) {
-+		ltq_spi_reset_fifos(hw);
-+		hw->status = -ETIMEDOUT;
-+	}
-+	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_CLREN, LTQ_SPI_WHBSTATE);
-+
-+	hw->cfg_mode = 1;
-+}
-+
-+static void ltq_spi_run_mode_set(struct ltq_spi *hw)
-+{
-+	if (!hw->cfg_mode)
-+		return;
-+
-+	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_SETEN, LTQ_SPI_WHBSTATE);
-+
-+	hw->cfg_mode = 0;
-+}
-+
-+static u32 ltq_spi_tx_word_u8(struct ltq_spi *hw)
-+{
-+	const u8 *tx = hw->tx;
-+	u32 data = *tx++;
-+
-+	hw->tx_cnt++;
-+	hw->tx++;
-+
-+	return data;
-+}
-+
-+static u32 ltq_spi_tx_word_u16(struct ltq_spi *hw)
-+{
-+	const u16 *tx = (u16 *) hw->tx;
-+	u32 data = *tx++;
-+
-+	hw->tx_cnt += 2;
-+	hw->tx += 2;
-+
-+	return data;
-+}
-+
-+static u32 ltq_spi_tx_word_u32(struct ltq_spi *hw)
-+{
-+	const u32 *tx = (u32 *) hw->tx;
-+	u32 data = *tx++;
-+
-+	hw->tx_cnt += 4;
-+	hw->tx += 4;
-+
-+	return data;
-+}
-+
-+static void ltq_spi_bits_per_word_set(struct spi_device *spi)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+	u32 bm;
-+	u8 bits_per_word = spi->bits_per_word;
-+
-+	/*
-+	 * Use either default value of SPI device or value
-+	 * from current transfer.
-+	 */
-+	if (hw->curr_transfer && hw->curr_transfer->bits_per_word)
-+		bits_per_word = hw->curr_transfer->bits_per_word;
-+
-+	if (bits_per_word <= 8)
-+		hw->get_tx = ltq_spi_tx_word_u8;
-+	else if (bits_per_word <= 16)
-+		hw->get_tx = ltq_spi_tx_word_u16;
-+	else if (bits_per_word <= 32)
-+		hw->get_tx = ltq_spi_tx_word_u32;
-+
-+	/* CON.BM value = bits_per_word - 1 */
-+	bm = (bits_per_word - 1) << LTQ_SPI_CON_BM_SHIFT;
-+
-+	ltq_spi_reg_clearbit(hw, LTQ_SPI_CON_BM_MASK <<
-+			     LTQ_SPI_CON_BM_SHIFT, LTQ_SPI_CON);
-+	ltq_spi_reg_setbit(hw, bm, LTQ_SPI_CON);
-+}
-+
-+static void ltq_spi_speed_set(struct spi_device *spi)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+	u32 br, max_speed_hz, spi_clk;
-+	u32 speed_hz = spi->max_speed_hz;
-+
-+	/*
-+	 * Use either default value of SPI device or value
-+	 * from current transfer.
-+	 */
-+	if (hw->curr_transfer && hw->curr_transfer->speed_hz)
-+		speed_hz = hw->curr_transfer->speed_hz;
-+
-+	/*
-+	 * SPI module clock is derived from FPI bus clock dependent on
-+	 * divider value in CLC.RMS which is always set to 1.
-+	 */
-+	spi_clk = clk_get_rate(hw->fpiclk);
-+
-+	/*
-+	 * Maximum SPI clock frequency in master mode is half of
-+	 * SPI module clock frequency. Maximum reload value of
-+	 * baudrate generator BR is 2^16.
-+	 */
-+	max_speed_hz = spi_clk / 2;
-+	if (speed_hz >= max_speed_hz)
-+		br = 0;
-+	else
-+		br = (max_speed_hz / speed_hz) - 1;
-+
-+	if (br > 0xFFFF)
-+		br = 0xFFFF;
-+
-+	ltq_spi_reg_write(hw, br, LTQ_SPI_BRT);
-+}
-+
-+static void ltq_spi_clockmode_set(struct spi_device *spi)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+	u32 con;
-+
-+	con = ltq_spi_reg_read(hw, LTQ_SPI_CON);
-+
-+	/*
-+	 * SPI mode mapping in CON register:
-+	 * Mode CPOL CPHA CON.PO CON.PH
-+	 *  0    0    0      0      1
-+	 *  1    0    1      0      0
-+	 *  2    1    0      1      1
-+	 *  3    1    1      1      0
-+	 */
-+	if (spi->mode & SPI_CPHA)
-+		con &= ~LTQ_SPI_CON_PH;
-+	else
-+		con |= LTQ_SPI_CON_PH;
-+
-+	if (spi->mode & SPI_CPOL)
-+		con |= LTQ_SPI_CON_PO;
-+	else
-+		con &= ~LTQ_SPI_CON_PO;
-+
-+	/* Set heading control */
-+	if (spi->mode & SPI_LSB_FIRST)
-+		con &= ~LTQ_SPI_CON_HB;
-+	else
-+		con |= LTQ_SPI_CON_HB;
-+
-+	ltq_spi_reg_write(hw, con, LTQ_SPI_CON);
-+}
-+
-+static void ltq_spi_xmit_set(struct ltq_spi *hw, struct spi_transfer *t)
-+{
-+	u32 con;
-+
-+	con = ltq_spi_reg_read(hw, LTQ_SPI_CON);
-+
-+	if (t) {
-+		if (t->tx_buf && t->rx_buf) {
-+			con &= ~(LTQ_SPI_CON_TXOFF | LTQ_SPI_CON_RXOFF);
-+		} else if (t->rx_buf) {
-+			con &= ~LTQ_SPI_CON_RXOFF;
-+			con |= LTQ_SPI_CON_TXOFF;
-+		} else if (t->tx_buf) {
-+			con &= ~LTQ_SPI_CON_TXOFF;
-+			con |= LTQ_SPI_CON_RXOFF;
-+		}
-+	} else
-+		con |= (LTQ_SPI_CON_TXOFF | LTQ_SPI_CON_RXOFF);
-+
-+	ltq_spi_reg_write(hw, con, LTQ_SPI_CON);
-+}
-+
-+static void ltq_spi_internal_cs_activate(struct spi_device *spi)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+	u32 fgpo;
-+
-+	fgpo = (1 << (spi->chip_select + LTQ_SPI_FGPO_CLROUTN_SHIFT));
-+	ltq_spi_reg_setbit(hw, fgpo, LTQ_SPI_FGPO);
-+}
-+
-+static void ltq_spi_internal_cs_deactivate(struct spi_device *spi)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+	u32 fgpo;
-+
-+	fgpo = (1 << (spi->chip_select + LTQ_SPI_FGPO_SETOUTN_SHIFT));
-+	ltq_spi_reg_setbit(hw, fgpo, LTQ_SPI_FGPO);
-+}
-+
-+static void ltq_spi_chipselect(struct spi_device *spi, int cs)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+
-+	switch (cs) {
-+	case BITBANG_CS_ACTIVE:
-+		ltq_spi_bits_per_word_set(spi);
-+		ltq_spi_speed_set(spi);
-+		ltq_spi_clockmode_set(spi);
-+		ltq_spi_run_mode_set(hw);
-+		ltq_spi_internal_cs_activate(spi);
-+		break;
-+
-+	case BITBANG_CS_INACTIVE:
-+		ltq_spi_internal_cs_deactivate(spi);
-+		ltq_spi_config_mode_set(hw);
-+		break;
-+	}
-+}
-+
-+static int ltq_spi_setup_transfer(struct spi_device *spi,
-+				  struct spi_transfer *t)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+	u8 bits_per_word = spi->bits_per_word;
-+
-+	hw->curr_transfer = t;
-+
-+	if (t && t->bits_per_word)
-+		bits_per_word = t->bits_per_word;
-+
-+	if (bits_per_word > 32)
-+		return -EINVAL;
-+
-+	ltq_spi_config_mode_set(hw);
-+
-+	return 0;
-+}
-+
-+static int ltq_spi_setup(struct spi_device *spi)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+	u32 gpocon, fgpo;
-+
-+	/* Set default word length to 8 if not set */
-+	if (!spi->bits_per_word)
-+		spi->bits_per_word = 8;
-+
-+	if (spi->bits_per_word > 32)
-+		return -EINVAL;
-+
-+	/*
-+	 * Up to six GPIOs can be connected to the SPI module
-+	 * via GPIO alternate function to control the chip select lines.
-+	 */
-+	gpocon = (1 << (spi->chip_select +
-+			LTQ_SPI_GPOCON_ISCSBN_SHIFT));
-+
-+	if (spi->mode & SPI_CS_HIGH)
-+		gpocon |= (1 << spi->chip_select);
-+
-+	fgpo = (1 << (spi->chip_select + LTQ_SPI_FGPO_SETOUTN_SHIFT));
-+
-+	ltq_spi_reg_setbit(hw, gpocon, LTQ_SPI_GPOCON);
-+	ltq_spi_reg_setbit(hw, fgpo, LTQ_SPI_FGPO);
-+
-+	return 0;
-+}
-+
-+static void ltq_spi_cleanup(struct spi_device *spi)
-+{
-+
-+}
-+
-+static void ltq_spi_txfifo_write(struct ltq_spi *hw)
-+{
-+	u32 fstat, data;
-+	u16 fifo_space;
-+
-+	/* Determine how much FIFOs are free for TX data */
-+	fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
-+	fifo_space = hw->txfs - ((fstat >> LTQ_SPI_FSTAT_TXFFL_SHIFT) &
-+					LTQ_SPI_FSTAT_TXFFL_MASK);
-+
-+	if (!fifo_space)
-+		return;
-+
-+	while (hw->tx_cnt < hw->len && fifo_space) {
-+		data = hw->get_tx(hw);
-+		ltq_spi_reg_write(hw, data, LTQ_SPI_TB);
-+		fifo_space--;
-+	}
-+}
-+
-+static void ltq_spi_rxfifo_read(struct ltq_spi *hw)
-+{
-+	u32 fstat, data, *rx32;
-+	u16 fifo_fill;
-+	u8 rxbv, shift, *rx8;
-+
-+	/* Determine how much FIFOs are filled with RX data */
-+	fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
-+	fifo_fill = ((fstat >> LTQ_SPI_FSTAT_RXFFL_SHIFT)
-+			& LTQ_SPI_FSTAT_RXFFL_MASK);
-+
-+	if (!fifo_fill)
-+		return;
-+
-+	/*
-+	 * The 32 bit FIFO is always used completely independent from the
-+	 * bits_per_word value. Thus four bytes have to be read at once
-+	 * per FIFO.
-+	 */
-+	rx32 = (u32 *) hw->rx;
-+	while (hw->len - hw->rx_cnt >= 4 && fifo_fill) {
-+		*rx32++ = ltq_spi_reg_read(hw, LTQ_SPI_RB);
-+		hw->rx_cnt += 4;
-+		hw->rx += 4;
-+		fifo_fill--;
-+	}
-+
-+	/*
-+	 * If there are remaining bytes, read byte count from STAT.RXBV
-+	 * register and read the data byte-wise.
-+	 */
-+	while (fifo_fill && hw->rx_cnt < hw->len) {
-+		rxbv = (ltq_spi_reg_read(hw, LTQ_SPI_STAT) >>
-+			LTQ_SPI_STAT_RXBV_SHIFT) & LTQ_SPI_STAT_RXBV_MASK;
-+		data = ltq_spi_reg_read(hw, LTQ_SPI_RB);
-+
-+		shift = (rxbv - 1) * 8;
-+		rx8 = hw->rx;
-+
-+		while (rxbv) {
-+			*rx8++ = (data >> shift) & 0xFF;
-+			rxbv--;
-+			shift -= 8;
-+			hw->rx_cnt++;
-+			hw->rx++;
-+		}
-+
-+		fifo_fill--;
-+	}
-+}
-+
-+static void ltq_spi_rxreq_set(struct ltq_spi *hw)
-+{
-+	u32 rxreq, rxreq_max, rxtodo;
-+
-+	rxtodo = ltq_spi_reg_read(hw, LTQ_SPI_RXCNT) & LTQ_SPI_RXCNT_TODO_MASK;
-+
-+	/*
-+	 * In RX-only mode the serial clock is activated only after writing
-+	 * the expected amount of RX bytes into RXREQ register.
-+	 * To avoid receive overflows at high clocks it is better to request
-+	 * only the amount of bytes that fits into all FIFOs. This value
-+	 * depends on the FIFO size implemented in hardware.
-+	 */
-+	rxreq = hw->len - hw->rx_cnt;
-+	rxreq_max = hw->rxfs << 2;
-+	rxreq = min(rxreq_max, rxreq);
-+
-+	if (!rxtodo && rxreq)
-+		ltq_spi_reg_write(hw, rxreq, LTQ_SPI_RXREQ);
-+}
-+
-+static inline void ltq_spi_complete(struct ltq_spi *hw)
-+{
-+	complete(&hw->done);
-+}
-+
-+irqreturn_t ltq_spi_tx_irq(int irq, void *data)
-+{
-+	struct ltq_spi *hw = data;
-+	unsigned long flags;
-+	int completed = 0;
-+
-+	spin_lock_irqsave(&hw->lock, flags);
-+
-+	if (hw->tx_cnt < hw->len)
-+		ltq_spi_txfifo_write(hw);
-+
-+	if (hw->tx_cnt == hw->len)
-+		completed = 1;
-+
-+	spin_unlock_irqrestore(&hw->lock, flags);
-+
-+	if (completed)
-+		ltq_spi_complete(hw);
-+
-+	return IRQ_HANDLED;
-+}
-+
-+irqreturn_t ltq_spi_rx_irq(int irq, void *data)
-+{
-+	struct ltq_spi *hw = data;
-+	unsigned long flags;
-+	int completed = 0;
-+
-+	spin_lock_irqsave(&hw->lock, flags);
-+
-+	if (hw->rx_cnt < hw->len) {
-+		ltq_spi_rxfifo_read(hw);
-+
-+		if (hw->tx && hw->tx_cnt < hw->len)
-+			ltq_spi_txfifo_write(hw);
-+	}
-+
-+	if (hw->rx_cnt == hw->len)
-+		completed = 1;
-+	else if (!hw->tx)
-+		ltq_spi_rxreq_set(hw);
-+
-+	spin_unlock_irqrestore(&hw->lock, flags);
-+
-+	if (completed)
-+		ltq_spi_complete(hw);
-+
-+	return IRQ_HANDLED;
-+}
-+
-+irqreturn_t ltq_spi_err_irq(int irq, void *data)
-+{
-+	struct ltq_spi *hw = data;
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&hw->lock, flags);
-+
-+	/* Disable all interrupts */
-+	ltq_spi_reg_clearbit(hw, LTQ_SPI_IRNEN_ALL, LTQ_SPI_IRNEN);
-+
-+	/* Clear all error flags */
-+	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_CLR_ERRORS, LTQ_SPI_WHBSTATE);
-+
-+	/* Flush FIFOs */
-+	ltq_spi_reg_setbit(hw, LTQ_SPI_RXFCON_RXFLU, LTQ_SPI_RXFCON);
-+	ltq_spi_reg_setbit(hw, LTQ_SPI_TXFCON_TXFLU, LTQ_SPI_TXFCON);
-+
-+	hw->status = -EIO;
-+	spin_unlock_irqrestore(&hw->lock, flags);
-+
-+	ltq_spi_complete(hw);
-+
-+	return IRQ_HANDLED;
-+}
-+
-+static int ltq_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+	u32 irq_flags = 0;
-+
-+	hw->tx = t->tx_buf;
-+	hw->rx = t->rx_buf;
-+	hw->len = t->len;
-+	hw->tx_cnt = 0;
-+	hw->rx_cnt = 0;
-+	hw->status = 0;
-+	init_completion(&hw->done);
-+
-+	ltq_spi_xmit_set(hw, t);
-+
-+	/* Enable error interrupts */
-+	ltq_spi_reg_setbit(hw, LTQ_SPI_IRNEN_E, LTQ_SPI_IRNEN);
-+
-+	if (hw->tx) {
-+		/* Initially fill TX FIFO with as much data as possible */
-+		ltq_spi_txfifo_write(hw);
-+		irq_flags |= LTQ_SPI_IRNEN_T;
-+
-+		/* Always enable RX interrupt in Full Duplex mode */
-+		if (hw->rx)
-+			irq_flags |= LTQ_SPI_IRNEN_R;
-+	} else if (hw->rx) {
-+		/* Start RX clock */
-+		ltq_spi_rxreq_set(hw);
-+
-+		/* Enable RX interrupt to receive data from RX FIFOs */
-+		irq_flags |= LTQ_SPI_IRNEN_R;
-+	}
-+
-+	/* Enable TX or RX interrupts */
-+	ltq_spi_reg_setbit(hw, irq_flags, LTQ_SPI_IRNEN);
-+	wait_for_completion_interruptible(&hw->done);
-+
-+	/* Disable all interrupts */
-+	ltq_spi_reg_clearbit(hw, LTQ_SPI_IRNEN_ALL, LTQ_SPI_IRNEN);
-+
-+	/*
-+	 * Return length of current transfer for bitbang utility code if
-+	 * no errors occured during transmission.
-+	 */
-+	if (!hw->status)
-+		hw->status = hw->len;
-+
-+	return hw->status;
-+}
-+
-+static const struct ltq_spi_irq_map {
-+	char *name;
-+	irq_handler_t handler;
-+} ltq_spi_irqs[] = {
-+	{ "spi_rx", ltq_spi_rx_irq },
-+	{ "spi_tx", ltq_spi_tx_irq },
-+	{ "spi_err", ltq_spi_err_irq },
-+};
-+
-+static int ltq_spi_probe(struct platform_device *pdev)
-+{
-+	struct resource irqres[3];
-+	struct spi_master *master;
-+	struct resource *r;
-+	struct ltq_spi *hw;
-+	int ret, i;
-+	u32 data, id;
-+
-+	if (of_irq_to_resource_table(pdev->dev.of_node, irqres, 3) != 3) {
-+		dev_err(&pdev->dev, "IRQ settings missing in device tree\n");
-+		return -EINVAL;
-+	}
-+
-+	master = spi_alloc_master(&pdev->dev, sizeof(struct ltq_spi));
-+	if (!master) {
-+		dev_err(&pdev->dev, "spi_alloc_master\n");
-+		ret = -ENOMEM;
-+		goto err;
-+	}
-+
-+	hw = spi_master_get_devdata(master);
-+
-+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-+	if (r == NULL) {
-+		dev_err(&pdev->dev, "platform_get_resource\n");
-+		ret = -ENOENT;
-+		goto err_master;
-+	}
-+
-+	r = devm_request_mem_region(&pdev->dev, r->start, resource_size(r),
-+			pdev->name);
-+	if (!r) {
-+		dev_err(&pdev->dev, "failed to request memory region\n");
-+		ret = -ENXIO;
-+		goto err_master;
-+	}
-+
-+	hw->base = devm_ioremap_nocache(&pdev->dev, r->start, resource_size(r));
-+	if (!hw->base) {
-+		dev_err(&pdev->dev, "failed to remap memory region\n");
-+		ret = -ENXIO;
-+		goto err_master;
-+	}
-+
-+	memset(hw->irq, 0, sizeof(hw->irq));
-+	for (i = 0; i < ARRAY_SIZE(ltq_spi_irqs); i++) {
-+		hw->irq[i] = irqres[i].start;
-+		ret = request_irq(hw->irq[i], ltq_spi_irqs[i].handler,
-+				  0, ltq_spi_irqs[i].name, hw);
-+		if (ret) {
-+			dev_err(&pdev->dev, "failed to request %s irq (%d)\n",
-+					ltq_spi_irqs[i].name, hw->irq[i]);
-+			goto err_irq;
-+		}
-+	}
-+
-+	hw->fpiclk = clk_get_fpi();
-+	if (IS_ERR(hw->fpiclk)) {
-+		dev_err(&pdev->dev, "failed to get fpi clock\n");
-+		ret = PTR_ERR(hw->fpiclk);
-+		goto err_clk;
-+	}
-+
-+	hw->spiclk = clk_get(&pdev->dev, NULL);
-+	if (IS_ERR(hw->spiclk)) {
-+		dev_err(&pdev->dev, "failed to get spi clock gate\n");
-+		ret = PTR_ERR(hw->spiclk);
-+		goto err_clk;
-+	}
-+
-+	hw->bitbang.master = spi_master_get(master);
-+	hw->bitbang.chipselect = ltq_spi_chipselect;
-+	hw->bitbang.setup_transfer = ltq_spi_setup_transfer;
-+	hw->bitbang.txrx_bufs = ltq_spi_txrx_bufs;
-+
-+	if (of_machine_is_compatible("lantiq,ase"))
-+		master->num_chipselect = 3;
-+	else
-+		master->num_chipselect = 6;
-+	master->bus_num = pdev->id;
-+	master->setup = ltq_spi_setup;
-+	master->cleanup = ltq_spi_cleanup;
-+	master->dev.of_node = pdev->dev.of_node;
-+
-+	hw->dev = &pdev->dev;
-+	init_completion(&hw->done);
-+	spin_lock_init(&hw->lock);
-+
-+	ltq_spi_hw_enable(hw);
-+
-+	/* Read module capabilities */
-+	id = ltq_spi_reg_read(hw, LTQ_SPI_ID);
-+	hw->txfs = (id >> LTQ_SPI_ID_TXFS_SHIFT) & LTQ_SPI_ID_TXFS_MASK;
-+	hw->rxfs = (id >> LTQ_SPI_ID_TXFS_SHIFT) & LTQ_SPI_ID_TXFS_MASK;
-+	hw->dma_support = (id & LTQ_SPI_ID_CFG) ? 1 : 0;
-+
-+	ltq_spi_config_mode_set(hw);
-+
-+	/* Enable error checking, disable TX/RX, set idle value high */
-+	data = LTQ_SPI_CON_RUEN | LTQ_SPI_CON_AEN |
-+	    LTQ_SPI_CON_TEN | LTQ_SPI_CON_REN |
-+	    LTQ_SPI_CON_TXOFF | LTQ_SPI_CON_RXOFF | LTQ_SPI_CON_IDLE;
-+	ltq_spi_reg_write(hw, data, LTQ_SPI_CON);
-+
-+	/* Enable master mode and clear error flags */
-+	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_SETMS |
-+			  LTQ_SPI_WHBSTATE_CLR_ERRORS, LTQ_SPI_WHBSTATE);
-+
-+	/* Reset GPIO/CS registers */
-+	ltq_spi_reg_write(hw, 0x0, LTQ_SPI_GPOCON);
-+	ltq_spi_reg_write(hw, 0xFF00, LTQ_SPI_FGPO);
-+
-+	/* Enable and flush FIFOs */
-+	ltq_spi_reset_fifos(hw);
-+
-+	ret = spi_bitbang_start(&hw->bitbang);
-+	if (ret) {
-+		dev_err(&pdev->dev, "spi_bitbang_start failed\n");
-+		goto err_bitbang;
-+	}
-+
-+	platform_set_drvdata(pdev, hw);
-+
-+	pr_info("Lantiq SoC SPI controller rev %u (TXFS %u, RXFS %u, DMA %u)\n",
-+		id & LTQ_SPI_ID_REV_MASK, hw->txfs, hw->rxfs, hw->dma_support);
-+
-+	return 0;
-+
-+err_bitbang:
-+	ltq_spi_hw_disable(hw);
-+
-+err_clk:
-+	if (hw->fpiclk)
-+		clk_put(hw->fpiclk);
-+	if (hw->spiclk)
-+		clk_put(hw->spiclk);
-+
-+err_irq:
-+	clk_put(hw->fpiclk);
-+
-+	for (; i > 0; i--)
-+		free_irq(hw->irq[i], hw);
-+
-+err_master:
-+	spi_master_put(master);
-+
-+err:
-+	return ret;
-+}
-+
-+static int ltq_spi_remove(struct platform_device *pdev)
-+{
-+	struct ltq_spi *hw = platform_get_drvdata(pdev);
-+	int i;
-+
-+	spi_bitbang_stop(&hw->bitbang);
-+
-+	platform_set_drvdata(pdev, NULL);
-+
-+	ltq_spi_config_mode_set(hw);
-+	ltq_spi_hw_disable(hw);
-+
-+	for (i = 0; i < ARRAY_SIZE(hw->irq); i++)
-+		if (0 < hw->irq[i])
-+			free_irq(hw->irq[i], hw);
-+
-+	if (hw->fpiclk)
-+		clk_put(hw->fpiclk);
-+	if (hw->spiclk)
-+		clk_put(hw->spiclk);
-+
-+	spi_master_put(hw->bitbang.master);
-+
-+	return 0;
-+}
-+
-+static const struct of_device_id ltq_spi_match[] = {
-+	{ .compatible = "lantiq,spi-xway" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, ltq_spi_match);
-+
-+static struct platform_driver ltq_spi_driver = {
-+	.probe = ltq_spi_probe,
-+	.remove = ltq_spi_remove,
-+	.driver = {
-+		.name = "spi-xway",
-+		.owner = THIS_MODULE,
-+		.of_match_table = ltq_spi_match,
-+	},
-+};
-+
-+module_platform_driver(ltq_spi_driver);
-+
-+MODULE_DESCRIPTION("Lantiq SoC SPI controller driver");
-+MODULE_AUTHOR("Daniel Schwierzeck <daniel.schwierzeck@googlemail.com>");
-+MODULE_LICENSE("GPL");
-+MODULE_ALIAS("platform:spi-xway");
diff --git a/target/linux/lantiq/patches-3.18/0034-reset-Fix-compile-when-reset-RESET_CONTROLLER-is-not.patch b/target/linux/lantiq/patches-3.18/0034-reset-Fix-compile-when-reset-RESET_CONTROLLER-is-not.patch
deleted file mode 100644
index 6590b7b008..0000000000
--- a/target/linux/lantiq/patches-3.18/0034-reset-Fix-compile-when-reset-RESET_CONTROLLER-is-not.patch
+++ /dev/null
@@ -1,45 +0,0 @@
-From b1b9fca8c317afc3f2b78bb54f877e8a830a819d Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Fri, 9 Aug 2013 18:47:27 +0200
-Subject: [PATCH 34/36] reset: Fix compile when reset RESET_CONTROLLER is not
- selected
-
-Drivers need to protect their reset api calls with #ifdef to avoid compile
-errors.
-
-This patch adds dummy wrappers in the same way that linux/of.h does it.
-
-Cc: linux-kernel@vger.kernel.org
-Cc: Philipp Zabel <p.zabel@pengutronix.de>
-Cc: Gabor Juhos <juhosg@openwrt.org>
----
- include/linux/reset-controller.h |   16 ++++++++++++++
- include/linux/reset.h            |   43 ++++++++++++++++++++++++++++++++++++++
- 2 files changed, 59 insertions(+)
-
---- a/include/linux/reset-controller.h
-+++ b/include/linux/reset-controller.h
-@@ -46,7 +46,23 @@ struct reset_controller_dev {
- 	unsigned int nr_resets;
- };
- 
-+#if defined(CONFIG_RESET_CONTROLLER)
-+
- int reset_controller_register(struct reset_controller_dev *rcdev);
- void reset_controller_unregister(struct reset_controller_dev *rcdev);
- 
-+#else
-+
-+static inline int reset_controller_register(struct reset_controller_dev *rcdev)
-+{
-+	return -ENOSYS;
-+}
-+
-+void reset_controller_unregister(struct reset_controller_dev *rcdev)
-+{
-+
-+}
-+
-+#endif
-+
- #endif
diff --git a/target/linux/lantiq/patches-3.18/0035-owrt-lantiq-wifi-and-ethernet-eeprom-handling.patch b/target/linux/lantiq/patches-3.18/0035-owrt-lantiq-wifi-and-ethernet-eeprom-handling.patch
deleted file mode 100644
index 04c2071f32..0000000000
--- a/target/linux/lantiq/patches-3.18/0035-owrt-lantiq-wifi-and-ethernet-eeprom-handling.patch
+++ /dev/null
@@ -1,614 +0,0 @@
-From f8c5db89e793a4bc6c1e87bd7b3a5cec16b75bc3 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Wed, 10 Sep 2014 22:42:14 +0200
-Subject: [PATCH 35/36] owrt: lantiq: wifi and ethernet eeprom handling
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- arch/mips/include/asm/mach-lantiq/pci-ath-fixup.h  |    6 +
- .../mips/include/asm/mach-lantiq/xway/lantiq_soc.h |    3 +
- arch/mips/lantiq/xway/Makefile                     |    3 +
- arch/mips/lantiq/xway/ath_eep.c                    |  282 ++++++++++++++++++++
- arch/mips/lantiq/xway/eth_mac.c                    |   76 ++++++
- arch/mips/lantiq/xway/pci-ath-fixup.c              |  109 ++++++++
- arch/mips/lantiq/xway/rt_eep.c                     |   60 +++++
- 7 files changed, 539 insertions(+)
- create mode 100644 arch/mips/include/asm/mach-lantiq/pci-ath-fixup.h
- create mode 100644 arch/mips/lantiq/xway/ath_eep.c
- create mode 100644 arch/mips/lantiq/xway/eth_mac.c
- create mode 100644 arch/mips/lantiq/xway/pci-ath-fixup.c
- create mode 100644 arch/mips/lantiq/xway/rt_eep.c
-
---- /dev/null
-+++ b/arch/mips/include/asm/mach-lantiq/pci-ath-fixup.h
-@@ -0,0 +1,6 @@
-+#ifndef _PCI_ATH_FIXUP
-+#define _PCI_ATH_FIXUP
-+
-+void ltq_pci_ath_fixup(unsigned slot, u16 *cal_data) __init;
-+
-+#endif /* _PCI_ATH_FIXUP */
---- a/arch/mips/include/asm/mach-lantiq/xway/lantiq_soc.h
-+++ b/arch/mips/include/asm/mach-lantiq/xway/lantiq_soc.h
-@@ -90,5 +90,8 @@ int xrx200_gphy_boot(struct device *dev,
- extern void ltq_pmu_enable(unsigned int module);
- extern void ltq_pmu_disable(unsigned int module);
- 
-+/* allow the ethernet driver to load a flash mapped mac addr */
-+const u8* ltq_get_eth_mac(void);
-+
- #endif /* CONFIG_SOC_TYPE_XWAY */
- #endif /* _LTQ_XWAY_H__ */
---- a/arch/mips/lantiq/xway/Makefile
-+++ b/arch/mips/lantiq/xway/Makefile
-@@ -2,4 +2,7 @@ obj-y := prom.o sysctrl.o clk.o reset.o
- 
- obj-y += vmmc.o tffs.o
- 
-+obj-y += eth_mac.o
-+obj-$(CONFIG_PCI) += ath_eep.o rt_eep.o pci-ath-fixup.o
-+
- obj-$(CONFIG_XRX200_PHY_FW) += xrx200_phy_fw.o
---- /dev/null
-+++ b/arch/mips/lantiq/xway/ath_eep.c
-@@ -0,0 +1,282 @@
-+/*
-+ *  Copyright (C) 2011 Luca Olivetti <luca@ventoso.org>
-+ *  Copyright (C) 2011 John Crispin <blogic@openwrt.org>
-+ *  Copyright (C) 2011 Andrej Vlai <andrej.vlasic0@gmail.com>
-+ *  Copyright (C) 2013 lvaro Fernndez Rojas <noltari@gmail.com>
-+ *  Copyright (C) 2013 Daniel Gimpelevich <daniel@gimpelevich.san-francisco.ca.us>
-+ *
-+ *  This program is free software; you can redistribute it and/or modify it
-+ *  under the terms of the GNU General Public License version 2 as published
-+ *  by the Free Software Foundation.
-+ */
-+
-+#include <linux/init.h>
-+#include <linux/module.h>
-+#include <linux/platform_device.h>
-+#include <linux/etherdevice.h>
-+#include <linux/ath5k_platform.h>
-+#include <linux/ath9k_platform.h>
-+#include <linux/pci.h>
-+#include <linux/err.h>
-+#include <linux/mtd/mtd.h>
-+#include <pci-ath-fixup.h>
-+#include <lantiq_soc.h>
-+
-+extern int (*ltq_pci_plat_dev_init)(struct pci_dev *dev);
-+struct ath5k_platform_data ath5k_pdata;
-+struct ath9k_platform_data ath9k_pdata = {
-+	.led_pin = -1,
-+};
-+static u8 athxk_eeprom_mac[6];
-+
-+static int ath9k_pci_plat_dev_init(struct pci_dev *dev)
-+{
-+	dev->dev.platform_data = &ath9k_pdata;
-+	return 0;
-+}
-+
-+static int ath9k_eep_load;
-+int __init of_ath9k_eeprom_probe(struct platform_device *pdev)
-+{
-+	struct device_node *np = pdev->dev.of_node, *mtd_np;
-+	struct resource *eep_res, *mac_res = NULL;
-+	void __iomem *eep, *mac;
-+	int mac_offset, led_pin;
-+	u32 mac_inc = 0, pci_slot = 0;
-+	int i;
-+	struct mtd_info *the_mtd;
-+	size_t flash_readlen;
-+	const __be32 *list;
-+	const char *part;
-+	phandle phandle;
-+
-+	if ((list = of_get_property(np, "ath,eep-flash", &i)) && i == 2 *
-+			sizeof(*list) && (phandle = be32_to_cpup(list++)) &&
-+			(mtd_np = of_find_node_by_phandle(phandle)) && ((part =
-+			of_get_property(mtd_np, "label", NULL)) || (part =
-+			mtd_np->name)) && (the_mtd = get_mtd_device_nm(part))
-+			!= ERR_PTR(-ENODEV)) {
-+		i = mtd_read(the_mtd, be32_to_cpup(list),
-+				ATH9K_PLAT_EEP_MAX_WORDS << 1, &flash_readlen,
-+				(void *) ath9k_pdata.eeprom_data);
-+		if (!of_property_read_u32(np, "ath,mac-offset", &mac_offset)) {
-+			size_t mac_readlen;
-+			mtd_read(the_mtd, mac_offset, 6, &mac_readlen,
-+				(void *) athxk_eeprom_mac);
-+		}
-+		put_mtd_device(the_mtd);
-+		if ((sizeof(ath9k_pdata.eeprom_data) != flash_readlen) || i) {
-+			dev_err(&pdev->dev, "failed to load eeprom from mtd\n");
-+			return -ENODEV;
-+		}
-+	} else {
-+		eep_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-+		mac_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-+
-+		if (!eep_res) {
-+			dev_err(&pdev->dev, "failed to load eeprom address\n");
-+			return -ENODEV;
-+		}
-+		if (resource_size(eep_res) != ATH9K_PLAT_EEP_MAX_WORDS << 1) {
-+			dev_err(&pdev->dev, "eeprom has an invalid size\n");
-+			return -EINVAL;
-+		}
-+
-+		eep = ioremap(eep_res->start, resource_size(eep_res));
-+		memcpy_fromio(ath9k_pdata.eeprom_data, eep,
-+				ATH9K_PLAT_EEP_MAX_WORDS << 1);
-+	}
-+
-+	if (of_find_property(np, "ath,eep-swap", NULL))
-+		for (i = 0; i < ATH9K_PLAT_EEP_MAX_WORDS; i++)
-+			ath9k_pdata.eeprom_data[i] = swab16(ath9k_pdata.eeprom_data[i]);
-+
-+	if (of_find_property(np, "ath,eep-endian", NULL)) {
-+		ath9k_pdata.endian_check = true;
-+
-+		dev_info(&pdev->dev, "endian check enabled.\n");
-+	}
-+
-+	if (!is_valid_ether_addr(athxk_eeprom_mac)) {
-+		if (mac_res) {
-+			if (resource_size(mac_res) != 6) {
-+				dev_err(&pdev->dev, "mac has an invalid size\n");
-+				return -EINVAL;
-+			}
-+			mac = ioremap(mac_res->start, resource_size(mac_res));
-+			memcpy_fromio(athxk_eeprom_mac, mac, 6);
-+		} else if (ltq_get_eth_mac()) {
-+			memcpy(athxk_eeprom_mac, ltq_get_eth_mac(), 6);
-+		}
-+	}
-+	if (!is_valid_ether_addr(athxk_eeprom_mac)) {
-+		dev_warn(&pdev->dev, "using random mac\n");
-+		random_ether_addr(athxk_eeprom_mac);
-+	}
-+
-+	if (!of_property_read_u32(np, "ath,mac-increment", &mac_inc))
-+		athxk_eeprom_mac[5] += mac_inc;
-+
-+	ath9k_pdata.macaddr = athxk_eeprom_mac;
-+	ltq_pci_plat_dev_init = ath9k_pci_plat_dev_init;
-+
-+	if (!of_property_read_u32(np, "ath,pci-slot", &pci_slot)) {
-+		ltq_pci_ath_fixup(pci_slot, ath9k_pdata.eeprom_data);
-+
-+		dev_info(&pdev->dev, "pci slot: %u\n", pci_slot);
-+                if (ath9k_eep_load) {
-+                        struct pci_dev *d = NULL;
-+                        while ((d = pci_get_device(PCI_VENDOR_ID_ATHEROS,
-+                                        PCI_ANY_ID, d)) != NULL)
-+                                pci_fixup_device(pci_fixup_early, d);
-+                }
-+
-+	}
-+
-+	if (!of_property_read_u32(np, "ath,led-pin", &led_pin)) {
-+		ath9k_pdata.led_pin = led_pin;
-+		dev_info(&pdev->dev, "using led pin %d.\n", led_pin);
-+	}
-+
-+	dev_info(&pdev->dev, "loaded ath9k eeprom\n");
-+
-+	return 0;
-+}
-+
-+static struct of_device_id ath9k_eeprom_ids[] = {
-+	{ .compatible = "ath9k,eeprom" },
-+	{ }
-+};
-+
-+static struct platform_driver ath9k_eeprom_driver = {
-+	.driver		= {
-+		.name		= "ath9k,eeprom",
-+		.owner	= THIS_MODULE,
-+		.of_match_table	= of_match_ptr(ath9k_eeprom_ids),
-+	},
-+};
-+
-+static int __init of_ath9k_eeprom_init(void)
-+{
-+        int ret = platform_driver_probe(&ath9k_eeprom_driver, of_ath9k_eeprom_probe);
-+
-+        if (ret)
-+                ath9k_eep_load = 1;
-+
-+        return ret;
-+}
-+
-+static int __init of_ath9k_eeprom_init_late(void)
-+{
-+        if (!ath9k_eep_load)
-+                return 0;
-+        return platform_driver_probe(&ath9k_eeprom_driver, of_ath9k_eeprom_probe);
-+}
-+late_initcall(of_ath9k_eeprom_init_late);
-+subsys_initcall(of_ath9k_eeprom_init);
-+
-+
-+static int ath5k_pci_plat_dev_init(struct pci_dev *dev)
-+{
-+	dev->dev.platform_data = &ath5k_pdata;
-+	return 0;
-+}
-+
-+int __init of_ath5k_eeprom_probe(struct platform_device *pdev)
-+{
-+	struct device_node *np = pdev->dev.of_node, *mtd_np;
-+	struct resource *eep_res, *mac_res = NULL;
-+	void __iomem *eep, *mac;
-+	int mac_offset;
-+	u32 mac_inc = 0;
-+	int i;
-+	struct mtd_info *the_mtd;
-+	size_t flash_readlen;
-+	const __be32 *list;
-+	const char *part;
-+	phandle phandle;
-+
-+	if ((list = of_get_property(np, "ath,eep-flash", &i)) && i == 2 *
-+			sizeof(*list) && (phandle = be32_to_cpup(list++)) &&
-+			(mtd_np = of_find_node_by_phandle(phandle)) && ((part =
-+			of_get_property(mtd_np, "label", NULL)) || (part =
-+			mtd_np->name)) && (the_mtd = get_mtd_device_nm(part))
-+			!= ERR_PTR(-ENODEV)) {
-+		i = mtd_read(the_mtd, be32_to_cpup(list),
-+				ATH5K_PLAT_EEP_MAX_WORDS << 1, &flash_readlen,
-+				(void *) ath5k_pdata.eeprom_data);
-+		put_mtd_device(the_mtd);
-+		if ((sizeof(ATH5K_PLAT_EEP_MAX_WORDS << 1) != flash_readlen)
-+				|| i) {
-+			dev_err(&pdev->dev, "failed to load eeprom from mtd\n");
-+			return -ENODEV;
-+		}
-+	} else {
-+		eep_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-+		mac_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-+
-+		if (!eep_res) {
-+			dev_err(&pdev->dev, "failed to load eeprom address\n");
-+			return -ENODEV;
-+		}
-+		if (resource_size(eep_res) != ATH5K_PLAT_EEP_MAX_WORDS << 1) {
-+			dev_err(&pdev->dev, "eeprom has an invalid size\n");
-+			return -EINVAL;
-+		}
-+
-+		eep = ioremap(eep_res->start, resource_size(eep_res));
-+		ath5k_pdata.eeprom_data = kmalloc(ATH5K_PLAT_EEP_MAX_WORDS<<1,
-+				GFP_KERNEL);
-+		memcpy_fromio(ath5k_pdata.eeprom_data, eep,
-+				ATH5K_PLAT_EEP_MAX_WORDS << 1);
-+	}
-+
-+	if (of_find_property(np, "ath,eep-swap", NULL))
-+		for (i = 0; i < ATH5K_PLAT_EEP_MAX_WORDS; i++)
-+			ath5k_pdata.eeprom_data[i] = swab16(ath5k_pdata.eeprom_data[i]);
-+
-+	if (!of_property_read_u32(np, "ath,mac-offset", &mac_offset)) {
-+		memcpy_fromio(athxk_eeprom_mac, (void*) ath5k_pdata.eeprom_data + mac_offset, 6);
-+	} else if (mac_res) {
-+		if (resource_size(mac_res) != 6) {
-+			dev_err(&pdev->dev, "mac has an invalid size\n");
-+			return -EINVAL;
-+		}
-+		mac = ioremap(mac_res->start, resource_size(mac_res));
-+		memcpy_fromio(athxk_eeprom_mac, mac, 6);
-+	} else if (ltq_get_eth_mac())
-+		memcpy(athxk_eeprom_mac, ltq_get_eth_mac(), 6);
-+	else {
-+		dev_warn(&pdev->dev, "using random mac\n");
-+		random_ether_addr(athxk_eeprom_mac);
-+	}
-+
-+	if (!of_property_read_u32(np, "ath,mac-increment", &mac_inc))
-+		athxk_eeprom_mac[5] += mac_inc;
-+
-+	ath5k_pdata.macaddr = athxk_eeprom_mac;
-+	ltq_pci_plat_dev_init = ath5k_pci_plat_dev_init;
-+
-+	dev_info(&pdev->dev, "loaded ath5k eeprom\n");
-+
-+	return 0;
-+}
-+
-+static struct of_device_id ath5k_eeprom_ids[] = {
-+	{ .compatible = "ath5k,eeprom" },
-+	{ }
-+};
-+
-+static struct platform_driver ath5k_eeprom_driver = {
-+	.driver		= {
-+		.name		= "ath5k,eeprom",
-+		.owner	= THIS_MODULE,
-+		.of_match_table	= of_match_ptr(ath5k_eeprom_ids),
-+	},
-+};
-+
-+static int __init of_ath5k_eeprom_init(void)
-+{
-+	return platform_driver_probe(&ath5k_eeprom_driver, of_ath5k_eeprom_probe);
-+}
-+device_initcall(of_ath5k_eeprom_init);
---- /dev/null
-+++ b/arch/mips/lantiq/xway/eth_mac.c
-@@ -0,0 +1,76 @@
-+/*
-+ *  Copyright (C) 2012 John Crispin <blogic@openwrt.org>
-+ *
-+ *  This program is free software; you can redistribute it and/or modify it
-+ *  under the terms of the GNU General Public License version 2 as published
-+ *  by the Free Software Foundation.
-+ */
-+
-+#include <linux/init.h>
-+#include <linux/module.h>
-+#include <linux/of_platform.h>
-+#include <linux/if_ether.h>
-+
-+static u8 eth_mac[6];
-+static int eth_mac_set;
-+
-+const u8* ltq_get_eth_mac(void)
-+{
-+	return eth_mac;
-+}
-+
-+static int __init setup_ethaddr(char *str)
-+{
-+	eth_mac_set = mac_pton(str, eth_mac);
-+	return !eth_mac_set;
-+}
-+__setup("ethaddr=", setup_ethaddr);
-+
-+int __init of_eth_mac_probe(struct platform_device *pdev)
-+{
-+	struct device_node *np = pdev->dev.of_node;
-+	struct resource *mac_res;
-+	void __iomem *mac;
-+	u32 mac_inc = 0;
-+
-+	if (eth_mac_set) {
-+		dev_err(&pdev->dev, "mac was already set by bootloader\n");
-+		return -EINVAL;
-+	}
-+	mac_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-+
-+	if (!mac_res) {
-+		dev_err(&pdev->dev, "failed to load mac\n");
-+		return -EINVAL;
-+	}
-+	if (resource_size(mac_res) != 6) {
-+		dev_err(&pdev->dev, "mac has an invalid size\n");
-+		return -EINVAL;
-+	}
-+	mac = ioremap(mac_res->start, resource_size(mac_res));
-+	memcpy_fromio(eth_mac, mac, 6);
-+
-+	if (!of_property_read_u32(np, "mac-increment", &mac_inc))
-+		eth_mac[5] += mac_inc;
-+
-+	return 0;
-+}
-+
-+static struct of_device_id eth_mac_ids[] = {
-+	{ .compatible = "lantiq,eth-mac" },
-+	{ /* sentinel */ }
-+};
-+
-+static struct platform_driver eth_mac_driver = {
-+	.driver		= {
-+		.name		= "lantiq,eth-mac",
-+		.owner	= THIS_MODULE,
-+		.of_match_table	= of_match_ptr(eth_mac_ids),
-+	},
-+};
-+
-+static int __init of_eth_mac_init(void)
-+{
-+	return platform_driver_probe(&eth_mac_driver, of_eth_mac_probe);
-+}
-+device_initcall(of_eth_mac_init);
---- /dev/null
-+++ b/arch/mips/lantiq/xway/pci-ath-fixup.c
-@@ -0,0 +1,109 @@
-+/*
-+ *  Atheros AP94 reference board PCI initialization
-+ *
-+ *  Copyright (C) 2009-2010 Gabor Juhos <juhosg@openwrt.org>
-+ *
-+ *  This program is free software; you can redistribute it and/or modify it
-+ *  under the terms of the GNU General Public License version 2 as published
-+ *  by the Free Software Foundation.
-+ */
-+
-+#include <linux/pci.h>
-+#include <linux/init.h>
-+#include <linux/delay.h>
-+#include <lantiq_soc.h>
-+
-+#define LTQ_PCI_MEM_BASE		0x18000000
-+
-+struct ath_fixup {
-+	u16		*cal_data;
-+	unsigned	slot;
-+};
-+
-+static int ath_num_fixups;
-+static struct ath_fixup ath_fixups[2];
-+
-+static void ath_pci_fixup(struct pci_dev *dev)
-+{
-+	void __iomem *mem;
-+	u16 *cal_data = NULL;
-+	u16 cmd;
-+	u32 bar0;
-+	u32 val;
-+	unsigned i;
-+
-+	for (i = 0; i < ath_num_fixups; i++) {
-+		if (ath_fixups[i].cal_data == NULL)
-+			continue;
-+
-+		if (ath_fixups[i].slot != PCI_SLOT(dev->devfn))
-+			continue;
-+
-+		cal_data = ath_fixups[i].cal_data;
-+		break;
-+	}
-+
-+	if (cal_data == NULL)
-+		return;
-+
-+	if (*cal_data != 0xa55a) {
-+		pr_err("pci %s: invalid calibration data\n", pci_name(dev));
-+		return;
-+	}
-+
-+	pr_info("pci %s: fixup device configuration\n", pci_name(dev));
-+
-+	mem = ioremap(LTQ_PCI_MEM_BASE, 0x10000);
-+	if (!mem) {
-+		pr_err("pci %s: ioremap error\n", pci_name(dev));
-+		return;
-+	}
-+
-+	pci_read_config_dword(dev, PCI_BASE_ADDRESS_0, &bar0);
-+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, LTQ_PCI_MEM_BASE);
-+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-+	cmd |= PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY;
-+	pci_write_config_word(dev, PCI_COMMAND, cmd);
-+
-+	/* set pointer to first reg address */
-+	cal_data += 3;
-+	while (*cal_data != 0xffff) {
-+		u32 reg;
-+		reg = *cal_data++;
-+		val = *cal_data++;
-+		val |= (*cal_data++) << 16;
-+
-+		ltq_w32(swab32(val), mem + reg);
-+		udelay(100);
-+	}
-+
-+	pci_read_config_dword(dev, PCI_VENDOR_ID, &val);
-+	dev->vendor = val & 0xffff;
-+	dev->device = (val >> 16) & 0xffff;
-+
-+	pci_read_config_dword(dev, PCI_CLASS_REVISION, &val);
-+	dev->revision = val & 0xff;
-+	dev->class = val >> 8; /* upper 3 bytes */
-+
-+	pr_info("pci %s: fixup info: [%04x:%04x] revision %02x class %#08x\n", 
-+		pci_name(dev), dev->vendor, dev->device, dev->revision, dev->class);
-+
-+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-+	cmd &= ~(PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);
-+	pci_write_config_word(dev, PCI_COMMAND, cmd);
-+
-+	pci_write_config_dword(dev, PCI_BASE_ADDRESS_0, bar0);
-+
-+	iounmap(mem);
-+}
-+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_ATHEROS, PCI_ANY_ID, ath_pci_fixup);
-+
-+void __init ltq_pci_ath_fixup(unsigned slot, u16 *cal_data)
-+{
-+	if (ath_num_fixups >= ARRAY_SIZE(ath_fixups))
-+		return;
-+
-+	ath_fixups[ath_num_fixups].slot = slot;
-+	ath_fixups[ath_num_fixups].cal_data = cal_data;
-+	ath_num_fixups++;
-+}
---- /dev/null
-+++ b/arch/mips/lantiq/xway/rt_eep.c
-@@ -0,0 +1,60 @@
-+/*
-+ *  Copyright (C) 2011 John Crispin <blogic@openwrt.org>
-+ *
-+ *  This program is free software; you can redistribute it and/or modify it
-+ *  under the terms of the GNU General Public License version 2 as published
-+ *  by the Free Software Foundation.
-+ */
-+
-+#include <linux/init.h>
-+#include <linux/module.h>
-+#include <linux/pci.h>
-+#include <linux/platform_device.h>
-+#include <linux/rt2x00_platform.h>
-+
-+extern int (*ltq_pci_plat_dev_init)(struct pci_dev *dev);
-+static struct rt2x00_platform_data rt2x00_pdata;
-+
-+static int rt2x00_pci_plat_dev_init(struct pci_dev *dev)
-+{
-+	dev->dev.platform_data = &rt2x00_pdata;
-+	return 0;
-+}
-+
-+int __init of_ralink_eeprom_probe(struct platform_device *pdev)
-+{
-+	struct device_node *np = pdev->dev.of_node;
-+	const char *eeprom;
-+
-+	if (of_property_read_string(np, "ralink,eeprom", &eeprom)) {
-+		dev_err(&pdev->dev, "failed to load eeprom filename\n");
-+		return 0;
-+	}
-+
-+	rt2x00_pdata.eeprom_file_name = kstrdup(eeprom, GFP_KERNEL);
-+//	rt2x00_pdata.mac_address = mac;
-+	ltq_pci_plat_dev_init = rt2x00_pci_plat_dev_init;
-+
-+	dev_info(&pdev->dev, "using %s as eeprom\n", eeprom);
-+
-+	return 0;
-+}
-+
-+static struct of_device_id ralink_eeprom_ids[] = {
-+	{ .compatible = "ralink,eeprom" },
-+	{ }
-+};
-+
-+static struct platform_driver ralink_eeprom_driver = {
-+	.driver		= {
-+		.name		= "ralink,eeprom",
-+		.owner	= THIS_MODULE,
-+		.of_match_table	= of_match_ptr(ralink_eeprom_ids),
-+	},
-+};
-+
-+static int __init of_ralink_eeprom_init(void)
-+{
-+	return platform_driver_probe(&ralink_eeprom_driver, of_ralink_eeprom_probe);
-+}
-+device_initcall(of_ralink_eeprom_init);
---- a/drivers/net/ethernet/lantiq_etop.c
-+++ b/drivers/net/ethernet/lantiq_etop.c
-@@ -161,7 +161,7 @@ struct ltq_etop_priv {
- 	int tx_irq;
- 	int rx_irq;
- 
--	const void *mac;
-+	void *mac;
- 	int mii_mode;
- 
- 	spinlock_t lock;
-@@ -840,7 +840,11 @@ ltq_etop_init(struct net_device *dev)
- 	if (err)
- 		goto err_hw;
- 
--	memcpy(&mac, &priv->pldata->mac, sizeof(struct sockaddr));
-+	if (priv->mac)
-+		memcpy(&mac.sa_data, priv->mac, ETH_ALEN);
-+	else
-+		memcpy(&mac.sa_data, ltq_get_eth_mac(), ETH_ALEN);
-+
- 	if (!is_valid_ether_addr(mac.sa_data)) {
- 		pr_warn("etop: invalid MAC, using random\n");
- 		eth_random_addr(mac.sa_data);
diff --git a/target/linux/lantiq/patches-3.18/0036-owrt-generic-dtb-image-hack.patch b/target/linux/lantiq/patches-3.18/0036-owrt-generic-dtb-image-hack.patch
deleted file mode 100644
index 7a306b301e..0000000000
--- a/target/linux/lantiq/patches-3.18/0036-owrt-generic-dtb-image-hack.patch
+++ /dev/null
@@ -1,32 +0,0 @@
-From dba8578e06aedf1e67312ebfc6162e2fadc9448d Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Thu, 7 Aug 2014 18:32:12 +0200
-Subject: [PATCH 36/36] owrt: generic dtb image hack
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- arch/mips/kernel/head.S |    3 +++
- 1 file changed, 3 insertions(+)
-
---- a/arch/mips/kernel/head.S
-+++ b/arch/mips/kernel/head.S
-@@ -86,6 +86,9 @@ EXPORT(__image_cmdline)
- 	.fill	0x400
- #endif /* CONFIG_IMAGE_CMDLINE_HACK */
- 
-+	.ascii  "OWRTDTB:"
-+	EXPORT(__image_dtb)
-+	.fill   0x4000
- 	__REF
- 
- NESTED(kernel_entry, 16, sp)			# kernel entry point
---- a/arch/mips/lantiq/Kconfig
-+++ b/arch/mips/lantiq/Kconfig
-@@ -32,7 +32,6 @@ choice
- config DT_EASY50712
- 	bool "Easy50712"
- 	depends on SOC_XWAY
--	select BUILTIN_DTB
- endchoice
- 
- config PCI_LANTIQ
diff --git a/target/linux/lantiq/patches-3.18/0037-MIPS-lantiq-move-eiu-init-after-irq_domain-register.patch b/target/linux/lantiq/patches-3.18/0037-MIPS-lantiq-move-eiu-init-after-irq_domain-register.patch
deleted file mode 100644
index 32e4ab89d9..0000000000
--- a/target/linux/lantiq/patches-3.18/0037-MIPS-lantiq-move-eiu-init-after-irq_domain-register.patch
+++ /dev/null
@@ -1,74 +0,0 @@
-From baea71233ed1796651cab6ead484a18666a765aa Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Thu, 11 Sep 2014 19:25:25 +0200
-Subject: [PATCH] MIPS: lantiq: move eiu init after irq_domain register
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- arch/mips/lantiq/irq.c |   48 ++++++++++++++++++++++++------------------------
- 1 file changed, 24 insertions(+), 24 deletions(-)
-
---- a/arch/mips/lantiq/irq.c
-+++ b/arch/mips/lantiq/irq.c
-@@ -380,30 +380,6 @@ int __init icu_of_init(struct device_nod
- 			panic("Failed to remap icu memory");
- 	}
- 
--	/* the external interrupts are optional and xway only */
--	eiu_node = of_find_compatible_node(NULL, NULL, "lantiq,eiu-xway");
--	if (eiu_node && !of_address_to_resource(eiu_node, 0, &res)) {
--		/* find out how many external irq sources we have */
--		exin_avail = of_irq_count(eiu_node);
--
--		if (exin_avail > MAX_EIU)
--			exin_avail = MAX_EIU;
--
--		ret = of_irq_to_resource_table(eiu_node,
--						ltq_eiu_irq, exin_avail);
--		if (ret != exin_avail)
--			panic("failed to load external irq resources");
--
--		if (request_mem_region(res.start, resource_size(&res),
--							res.name) < 0)
--			pr_err("Failed to request eiu memory");
--
--		ltq_eiu_membase = ioremap_nocache(res.start,
--							resource_size(&res));
--		if (!ltq_eiu_membase)
--			panic("Failed to remap eiu memory");
--	}
--
- 	/* turn off all irqs by default */
- 	for (i = 0; i < MAX_IM; i++) {
- 		/* make sure all irqs are turned off by default */
-@@ -460,6 +436,30 @@ int __init icu_of_init(struct device_nod
- 	if (MIPS_CPU_TIMER_IRQ != 7)
- 		irq_create_mapping(ltq_domain, MIPS_CPU_TIMER_IRQ);
- 
-+	/* the external interrupts are optional and xway only */
-+	eiu_node = of_find_compatible_node(NULL, NULL, "lantiq,eiu-xway");
-+	if (eiu_node && !of_address_to_resource(eiu_node, 0, &res)) {
-+		/* find out how many external irq sources we have */
-+		exin_avail = of_irq_count(eiu_node);
-+
-+		if (exin_avail > MAX_EIU)
-+			exin_avail = MAX_EIU;
-+
-+		ret = of_irq_to_resource_table(eiu_node,
-+						ltq_eiu_irq, exin_avail);
-+		if (ret != exin_avail)
-+			panic("failed to load external irq resources");
-+
-+		if (request_mem_region(res.start, resource_size(&res),
-+							res.name) < 0)
-+			pr_err("Failed to request eiu memory");
-+
-+		ltq_eiu_membase = ioremap_nocache(res.start,
-+							resource_size(&res));
-+		if (!ltq_eiu_membase)
-+			panic("Failed to remap eiu memory");
-+	}
-+
- 	return 0;
- }
- 
diff --git a/target/linux/lantiq/patches-3.18/0038-MIPS-lantiq-fpi-on-ar9.patch b/target/linux/lantiq/patches-3.18/0038-MIPS-lantiq-fpi-on-ar9.patch
deleted file mode 100644
index 5fbe0a1137..0000000000
--- a/target/linux/lantiq/patches-3.18/0038-MIPS-lantiq-fpi-on-ar9.patch
+++ /dev/null
@@ -1,21 +0,0 @@
-Return correct value for fpi clock on ar9.
-
-Signed-off-by: Ben Mulvihill <ben.mulvihill@gmail.com>
----
- arch/mips/lantiq/xway/clk.c |    5 +++--
- 1 file changed, 3 insertions(+), 2 deletions(-)
-
---- a/arch/mips/lantiq/xway/clk.c
-+++ b/arch/mips/lantiq/xway/clk.c
-@@ -87,8 +87,9 @@ unsigned long ltq_ar9_fpi_hz(void)
- 	unsigned long sys = ltq_ar9_sys_hz();
- 
- 	if (ltq_cgu_r32(CGU_SYS) & BIT(0))
--		return sys;
--	return sys >> 1;
-+		return sys / 3;
-+	else
-+		return sys / 2;
- }
- 
- unsigned long ltq_ar9_cpu_hz(void)
diff --git a/target/linux/lantiq/patches-3.18/0039-MIPS-lantiq-initialize-usb-on-boot.patch b/target/linux/lantiq/patches-3.18/0039-MIPS-lantiq-initialize-usb-on-boot.patch
deleted file mode 100644
index 052e45e91b..0000000000
--- a/target/linux/lantiq/patches-3.18/0039-MIPS-lantiq-initialize-usb-on-boot.patch
+++ /dev/null
@@ -1,96 +0,0 @@
---- a/arch/mips/lantiq/xway/reset.c
-+++ b/arch/mips/lantiq/xway/reset.c
-@@ -44,6 +44,37 @@
- #define RCU_BOOT_SEL(x)		((x >> 18) & 0x7)
- #define RCU_BOOT_SEL_XRX200(x)	(((x >> 17) & 0xf) | ((x >> 8) & 0x10))
- 
-+/* dwc2 USB configuration registers */
-+#define RCU_USB1CFG		0x0018
-+#define RCU_USB2CFG		0x0034
-+
-+/* USB DMA endianness bits */
-+#define RCU_USBCFG_HDSEL_BIT	BIT(11)
-+#define RCU_USBCFG_HOST_END_BIT	BIT(10)
-+#define RCU_USBCFG_SLV_END_BIT	BIT(9)
-+
-+/* USB reset bits */
-+#define RCU_USBRESET		0x0010
-+
-+#define USBRESET_BIT		BIT(4)
-+
-+#define RCU_USBRESET2		0x0048
-+
-+#define USB1RESET_BIT		BIT(4)
-+#define USB2RESET_BIT		BIT(5)
-+
-+#define RCU_CFG1A		0x0038
-+#define RCU_CFG1B		0x003C
-+
-+/* USB PMU devices */
-+#define PMU_AHBM		BIT(15)
-+#define PMU_USB0		BIT(6)
-+#define PMU_USB1		BIT(27)
-+
-+/* USB PHY PMU devices */
-+#define PMU_USB0_P		BIT(0)
-+#define PMU_USB1_P		BIT(26)
-+
- /* remapped base addr of the reset control unit */
- static void __iomem *ltq_rcu_membase;
- static struct device_node *ltq_rcu_np;
-@@ -200,6 +231,45 @@ static void ltq_machine_power_off(void)
- 	unreachable();
- }
- 
-+static void ltq_usb_init(void)
-+{
-+	/* Power for USB cores 1 & 2 */
-+	ltq_pmu_enable(PMU_AHBM);
-+	ltq_pmu_enable(PMU_USB0);
-+	ltq_pmu_enable(PMU_USB1);
-+
-+	ltq_rcu_w32(ltq_rcu_r32(RCU_CFG1A) | BIT(0), RCU_CFG1A);
-+	ltq_rcu_w32(ltq_rcu_r32(RCU_CFG1B) | BIT(0), RCU_CFG1B);
-+
-+	/* Enable USB PHY power for cores 1 & 2 */
-+	ltq_pmu_enable(PMU_USB0_P);
-+	ltq_pmu_enable(PMU_USB1_P);
-+
-+	/* Configure cores to host mode */
-+	ltq_rcu_w32(ltq_rcu_r32(RCU_USB1CFG) & ~RCU_USBCFG_HDSEL_BIT,
-+		RCU_USB1CFG);
-+	ltq_rcu_w32(ltq_rcu_r32(RCU_USB2CFG) & ~RCU_USBCFG_HDSEL_BIT,
-+		RCU_USB2CFG);
-+
-+	/* Select DMA endianness (Host-endian: big-endian) */
-+	ltq_rcu_w32((ltq_rcu_r32(RCU_USB1CFG) & ~RCU_USBCFG_SLV_END_BIT)
-+		| RCU_USBCFG_HOST_END_BIT, RCU_USB1CFG);
-+	ltq_rcu_w32(ltq_rcu_r32((RCU_USB2CFG) & ~RCU_USBCFG_SLV_END_BIT)
-+		| RCU_USBCFG_HOST_END_BIT, RCU_USB2CFG);
-+
-+	/* Hard reset USB state machines */
-+	ltq_rcu_w32(ltq_rcu_r32(RCU_USBRESET) | USBRESET_BIT, RCU_USBRESET);
-+	udelay(50 * 1000);
-+	ltq_rcu_w32(ltq_rcu_r32(RCU_USBRESET) & ~USBRESET_BIT, RCU_USBRESET);
-+
-+	/* Soft reset USB state machines */
-+	ltq_rcu_w32(ltq_rcu_r32(RCU_USBRESET2)
-+		| USB1RESET_BIT | USB2RESET_BIT, RCU_USBRESET2);
-+	udelay(50 * 1000);
-+	ltq_rcu_w32(ltq_rcu_r32(RCU_USBRESET2)
-+		& ~(USB1RESET_BIT | USB2RESET_BIT), RCU_USBRESET2);
-+}
-+
- static int __init mips_reboot_setup(void)
- {
- 	struct resource res;
-@@ -223,6 +293,9 @@ static int __init mips_reboot_setup(void
- 	if (!ltq_rcu_membase)
- 		panic("Failed to remap core memory");
- 
-+	if (of_machine_is_compatible("lantiq,vr9"))
-+		ltq_usb_init();
-+
- 	_machine_restart = ltq_machine_restart;
- 	_machine_halt = ltq_machine_halt;
- 	pm_power_off = ltq_machine_power_off;
diff --git a/target/linux/lantiq/patches-3.18/0040-USB-DWC2-enable-usb-power-gpio.patch b/target/linux/lantiq/patches-3.18/0040-USB-DWC2-enable-usb-power-gpio.patch
deleted file mode 100644
index 76fbb7bac7..0000000000
--- a/target/linux/lantiq/patches-3.18/0040-USB-DWC2-enable-usb-power-gpio.patch
+++ /dev/null
@@ -1,35 +0,0 @@
---- a/drivers/usb/dwc2/platform.c
-+++ b/drivers/usb/dwc2/platform.c
-@@ -40,6 +40,7 @@
- #include <linux/device.h>
- #include <linux/dma-mapping.h>
- #include <linux/of_device.h>
-+#include <linux/of_gpio.h>
- #include <linux/platform_device.h>
- 
- #include <linux/usb/of.h>
-@@ -154,6 +155,7 @@ static int dwc2_driver_probe(struct plat
- 	struct resource *res;
- 	int retval;
- 	int irq;
-+	int gpio_count;
- 
- 	if (usb_disabled())
- 		return -ENODEV;
-@@ -173,6 +175,16 @@ static int dwc2_driver_probe(struct plat
- 		defparams.dma_desc_enable = 0;
- 	}
- 
-+	gpio_count = of_gpio_count(dev->dev.of_node);
-+	while (gpio_count > 0) {
-+		enum of_gpio_flags flags;
-+		int gpio = of_get_gpio_flags(dev->dev.of_node, --gpio_count, &flags);
-+		if (gpio_request(gpio, "usb"))
-+			continue;
-+		dev_info(&dev->dev, "requested GPIO %d\n", gpio);
-+		gpio_direction_output(gpio, (flags & OF_GPIO_ACTIVE_LOW) ? (0) : (1));
-+	}
-+
- 	hsotg = devm_kzalloc(&dev->dev, sizeof(*hsotg), GFP_KERNEL);
- 	if (!hsotg)
- 		return -ENOMEM;
diff --git a/target/linux/lantiq/patches-3.18/0041-USB-DWC2-add-ltq-params.patch b/target/linux/lantiq/patches-3.18/0041-USB-DWC2-add-ltq-params.patch
deleted file mode 100644
index 396aa7d2e8..0000000000
--- a/target/linux/lantiq/patches-3.18/0041-USB-DWC2-add-ltq-params.patch
+++ /dev/null
@@ -1,45 +0,0 @@
---- a/drivers/usb/dwc2/platform.c
-+++ b/drivers/usb/dwc2/platform.c
-@@ -106,6 +106,34 @@ static const struct dwc2_core_params par
- 	.uframe_sched			= -1,
- };
- 
-+static const struct dwc2_core_params params_ltq = {
-+	.otg_cap			= -1,
-+	.otg_ver			= -1,
-+	.dma_enable			= -1,
-+	.dma_desc_enable		= -1,
-+	.speed				= -1,
-+	.enable_dynamic_fifo		= -1,
-+	.en_multiple_tx_fifo		= -1,
-+	.host_rx_fifo_size		= 240,	/* 240 DWORDs */
-+	.host_nperio_tx_fifo_size	= 240,	/* 240 DWORDs */
-+	.host_perio_tx_fifo_size	= 32,	/* 32 DWORDs */
-+	.max_transfer_size		= -1,
-+	.max_packet_count		= -1,
-+	.host_channels			= -1,
-+	.phy_type			= -1,
-+	.phy_utmi_width			= -1,
-+	.phy_ulpi_ddr			= -1,
-+	.phy_ulpi_ext_vbus		= -1,
-+	.i2c_enable			= -1,
-+	.ulpi_fs_ls			= -1,
-+	.host_support_fs_ls_low_power	= -1,
-+	.host_ls_low_power_phy_clk	= -1,
-+	.ts_dline			= -1,
-+	.reload_ctl			= -1,
-+	.ahbcfg				= -1,
-+	.uframe_sched			= -1,
-+};
-+
- /**
-  * dwc2_driver_remove() - Called when the DWC_otg core is unregistered with the
-  * DWC_otg driver
-@@ -129,6 +157,7 @@ static int dwc2_driver_remove(struct pla
- static const struct of_device_id dwc2_of_match_table[] = {
- 	{ .compatible = "brcm,bcm2835-usb", .data = &params_bcm2835 },
- 	{ .compatible = "rockchip,rk3066-usb", .data = &params_rk3066 },
-+	{ .compatible = "lantiq,ifxhcd-xrx200-dwc2", .data = &params_ltq },
- 	{ .compatible = "snps,dwc2", .data = NULL },
- 	{},
- };
diff --git a/target/linux/lantiq/patches-3.18/0042-USB-DWC2-big-endian-support.patch b/target/linux/lantiq/patches-3.18/0042-USB-DWC2-big-endian-support.patch
deleted file mode 100644
index 0455d35514..0000000000
--- a/target/linux/lantiq/patches-3.18/0042-USB-DWC2-big-endian-support.patch
+++ /dev/null
@@ -1,3184 +0,0 @@
---- a/drivers/usb/dwc2/core.c
-+++ b/drivers/usb/dwc2/core.c
-@@ -67,10 +67,10 @@ static void dwc2_enable_common_interrupt
- 	u32 intmsk;
- 
- 	/* Clear any pending OTG Interrupts */
--	writel(0xffffffff, hsotg->regs + GOTGINT);
-+	dwc2_writel(0xffffffff, hsotg->regs + GOTGINT);
- 
- 	/* Clear any pending interrupts */
--	writel(0xffffffff, hsotg->regs + GINTSTS);
-+	dwc2_writel(0xffffffff, hsotg->regs + GINTSTS);
- 
- 	/* Enable the interrupts in the GINTMSK */
- 	intmsk = GINTSTS_MODEMIS | GINTSTS_OTGINT;
-@@ -81,7 +81,7 @@ static void dwc2_enable_common_interrupt
- 	intmsk |= GINTSTS_CONIDSTSCHNG | GINTSTS_WKUPINT | GINTSTS_USBSUSP |
- 		  GINTSTS_SESSREQINT;
- 
--	writel(intmsk, hsotg->regs + GINTMSK);
-+	dwc2_writel(intmsk, hsotg->regs + GINTMSK);
- }
- 
- /*
-@@ -104,10 +104,10 @@ static void dwc2_init_fs_ls_pclk_sel(str
- 	}
- 
- 	dev_dbg(hsotg->dev, "Initializing HCFG.FSLSPClkSel to %08x\n", val);
--	hcfg = readl(hsotg->regs + HCFG);
-+	hcfg = dwc2_readl(hsotg->regs + HCFG);
- 	hcfg &= ~HCFG_FSLSPCLKSEL_MASK;
- 	hcfg |= val << HCFG_FSLSPCLKSEL_SHIFT;
--	writel(hcfg, hsotg->regs + HCFG);
-+	dwc2_writel(hcfg, hsotg->regs + HCFG);
- }
- 
- /*
-@@ -125,7 +125,7 @@ static int dwc2_core_reset(struct dwc2_h
- 	/* Wait for AHB master IDLE state */
- 	do {
- 		usleep_range(20000, 40000);
--		greset = readl(hsotg->regs + GRSTCTL);
-+		greset = dwc2_readl(hsotg->regs + GRSTCTL);
- 		if (++count > 50) {
- 			dev_warn(hsotg->dev,
- 				 "%s() HANG! AHB Idle GRSTCTL=%0x\n",
-@@ -137,10 +137,10 @@ static int dwc2_core_reset(struct dwc2_h
- 	/* Core Soft Reset */
- 	count = 0;
- 	greset |= GRSTCTL_CSFTRST;
--	writel(greset, hsotg->regs + GRSTCTL);
-+	dwc2_writel(greset, hsotg->regs + GRSTCTL);
- 	do {
- 		usleep_range(20000, 40000);
--		greset = readl(hsotg->regs + GRSTCTL);
-+		greset = dwc2_readl(hsotg->regs + GRSTCTL);
- 		if (++count > 50) {
- 			dev_warn(hsotg->dev,
- 				 "%s() HANG! Soft Reset GRSTCTL=%0x\n",
-@@ -150,20 +150,20 @@ static int dwc2_core_reset(struct dwc2_h
- 	} while (greset & GRSTCTL_CSFTRST);
- 
- 	if (hsotg->dr_mode == USB_DR_MODE_HOST) {
--		gusbcfg = readl(hsotg->regs + GUSBCFG);
-+		gusbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
- 		gusbcfg &= ~GUSBCFG_FORCEDEVMODE;
- 		gusbcfg |= GUSBCFG_FORCEHOSTMODE;
--		writel(gusbcfg, hsotg->regs + GUSBCFG);
-+		dwc2_writel(gusbcfg, hsotg->regs + GUSBCFG);
- 	} else if (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL) {
--		gusbcfg = readl(hsotg->regs + GUSBCFG);
-+		gusbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
- 		gusbcfg &= ~GUSBCFG_FORCEHOSTMODE;
- 		gusbcfg |= GUSBCFG_FORCEDEVMODE;
--		writel(gusbcfg, hsotg->regs + GUSBCFG);
-+		dwc2_writel(gusbcfg, hsotg->regs + GUSBCFG);
- 	} else if (hsotg->dr_mode == USB_DR_MODE_OTG) {
--		gusbcfg = readl(hsotg->regs + GUSBCFG);
-+		gusbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
- 		gusbcfg &= ~GUSBCFG_FORCEHOSTMODE;
- 		gusbcfg &= ~GUSBCFG_FORCEDEVMODE;
--		writel(gusbcfg, hsotg->regs + GUSBCFG);
-+		dwc2_writel(gusbcfg, hsotg->regs + GUSBCFG);
- 	}
- 
- 	/*
-@@ -186,9 +186,9 @@ static int dwc2_fs_phy_init(struct dwc2_
- 	 */
- 	if (select_phy) {
- 		dev_dbg(hsotg->dev, "FS PHY selected\n");
--		usbcfg = readl(hsotg->regs + GUSBCFG);
-+		usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
- 		usbcfg |= GUSBCFG_PHYSEL;
--		writel(usbcfg, hsotg->regs + GUSBCFG);
-+		dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
- 
- 		/* Reset after a PHY select */
- 		retval = dwc2_core_reset(hsotg);
-@@ -211,18 +211,18 @@ static int dwc2_fs_phy_init(struct dwc2_
- 		dev_dbg(hsotg->dev, "FS PHY enabling I2C\n");
- 
- 		/* Program GUSBCFG.OtgUtmiFsSel to I2C */
--		usbcfg = readl(hsotg->regs + GUSBCFG);
-+		usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
- 		usbcfg |= GUSBCFG_OTG_UTMI_FS_SEL;
--		writel(usbcfg, hsotg->regs + GUSBCFG);
-+		dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
- 
- 		/* Program GI2CCTL.I2CEn */
--		i2cctl = readl(hsotg->regs + GI2CCTL);
-+		i2cctl = dwc2_readl(hsotg->regs + GI2CCTL);
- 		i2cctl &= ~GI2CCTL_I2CDEVADDR_MASK;
- 		i2cctl |= 1 << GI2CCTL_I2CDEVADDR_SHIFT;
- 		i2cctl &= ~GI2CCTL_I2CEN;
--		writel(i2cctl, hsotg->regs + GI2CCTL);
-+		dwc2_writel(i2cctl, hsotg->regs + GI2CCTL);
- 		i2cctl |= GI2CCTL_I2CEN;
--		writel(i2cctl, hsotg->regs + GI2CCTL);
-+		dwc2_writel(i2cctl, hsotg->regs + GI2CCTL);
- 	}
- 
- 	return retval;
-@@ -236,7 +236,7 @@ static int dwc2_hs_phy_init(struct dwc2_
- 	if (!select_phy)
- 		return 0;
- 
--	usbcfg = readl(hsotg->regs + GUSBCFG);
-+	usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
- 
- 	/*
- 	 * HS PHY parameters. These parameters are preserved during soft reset
-@@ -264,7 +264,7 @@ static int dwc2_hs_phy_init(struct dwc2_
- 		break;
- 	}
- 
--	writel(usbcfg, hsotg->regs + GUSBCFG);
-+	dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
- 
- 	/* Reset after setting the PHY parameters */
- 	retval = dwc2_core_reset(hsotg);
-@@ -299,15 +299,15 @@ static int dwc2_phy_init(struct dwc2_hso
- 	    hsotg->hw_params.fs_phy_type == GHWCFG2_FS_PHY_TYPE_DEDICATED &&
- 	    hsotg->core_params->ulpi_fs_ls > 0) {
- 		dev_dbg(hsotg->dev, "Setting ULPI FSLS\n");
--		usbcfg = readl(hsotg->regs + GUSBCFG);
-+		usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
- 		usbcfg |= GUSBCFG_ULPI_FS_LS;
- 		usbcfg |= GUSBCFG_ULPI_CLK_SUSP_M;
--		writel(usbcfg, hsotg->regs + GUSBCFG);
-+		dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
- 	} else {
--		usbcfg = readl(hsotg->regs + GUSBCFG);
-+		usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
- 		usbcfg &= ~GUSBCFG_ULPI_FS_LS;
- 		usbcfg &= ~GUSBCFG_ULPI_CLK_SUSP_M;
--		writel(usbcfg, hsotg->regs + GUSBCFG);
-+		dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
- 	}
- 
- 	return retval;
-@@ -315,7 +315,7 @@ static int dwc2_phy_init(struct dwc2_hso
- 
- static int dwc2_gahbcfg_init(struct dwc2_hsotg *hsotg)
- {
--	u32 ahbcfg = readl(hsotg->regs + GAHBCFG);
-+	u32 ahbcfg = dwc2_readl(hsotg->regs + GAHBCFG);
- 
- 	switch (hsotg->hw_params.arch) {
- 	case GHWCFG2_EXT_DMA_ARCH:
-@@ -354,7 +354,7 @@ static int dwc2_gahbcfg_init(struct dwc2
- 	if (hsotg->core_params->dma_enable > 0)
- 		ahbcfg |= GAHBCFG_DMA_EN;
- 
--	writel(ahbcfg, hsotg->regs + GAHBCFG);
-+	dwc2_writel(ahbcfg, hsotg->regs + GAHBCFG);
- 
- 	return 0;
- }
-@@ -363,7 +363,7 @@ static void dwc2_gusbcfg_init(struct dwc
- {
- 	u32 usbcfg;
- 
--	usbcfg = readl(hsotg->regs + GUSBCFG);
-+	usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
- 	usbcfg &= ~(GUSBCFG_HNPCAP | GUSBCFG_SRPCAP);
- 
- 	switch (hsotg->hw_params.op_mode) {
-@@ -391,7 +391,7 @@ static void dwc2_gusbcfg_init(struct dwc
- 		break;
- 	}
- 
--	writel(usbcfg, hsotg->regs + GUSBCFG);
-+	dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
- }
- 
- /**
-@@ -409,7 +409,7 @@ int dwc2_core_init(struct dwc2_hsotg *hs
- 
- 	dev_dbg(hsotg->dev, "%s(%p)\n", __func__, hsotg);
- 
--	usbcfg = readl(hsotg->regs + GUSBCFG);
-+	usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
- 
- 	/* Set ULPI External VBUS bit if needed */
- 	usbcfg &= ~GUSBCFG_ULPI_EXT_VBUS_DRV;
-@@ -422,7 +422,7 @@ int dwc2_core_init(struct dwc2_hsotg *hs
- 	if (hsotg->core_params->ts_dline > 0)
- 		usbcfg |= GUSBCFG_TERMSELDLPULSE;
- 
--	writel(usbcfg, hsotg->regs + GUSBCFG);
-+	dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
- 
- 	/* Reset the Controller */
- 	retval = dwc2_core_reset(hsotg);
-@@ -448,11 +448,11 @@ int dwc2_core_init(struct dwc2_hsotg *hs
- 	dwc2_gusbcfg_init(hsotg);
- 
- 	/* Program the GOTGCTL register */
--	otgctl = readl(hsotg->regs + GOTGCTL);
-+	otgctl = dwc2_readl(hsotg->regs + GOTGCTL);
- 	otgctl &= ~GOTGCTL_OTGVER;
- 	if (hsotg->core_params->otg_ver > 0)
- 		otgctl |= GOTGCTL_OTGVER;
--	writel(otgctl, hsotg->regs + GOTGCTL);
-+	dwc2_writel(otgctl, hsotg->regs + GOTGCTL);
- 	dev_dbg(hsotg->dev, "OTG VER PARAM: %d\n", hsotg->core_params->otg_ver);
- 
- 	/* Clear the SRP success bit for FS-I2c */
-@@ -498,16 +498,16 @@ void dwc2_enable_host_interrupts(struct
- 	dev_dbg(hsotg->dev, "%s()\n", __func__);
- 
- 	/* Disable all interrupts */
--	writel(0, hsotg->regs + GINTMSK);
--	writel(0, hsotg->regs + HAINTMSK);
-+	dwc2_writel(0, hsotg->regs + GINTMSK);
-+	dwc2_writel(0, hsotg->regs + HAINTMSK);
- 
- 	/* Enable the common interrupts */
- 	dwc2_enable_common_interrupts(hsotg);
- 
- 	/* Enable host mode interrupts without disturbing common interrupts */
--	intmsk = readl(hsotg->regs + GINTMSK);
-+	intmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 	intmsk |= GINTSTS_DISCONNINT | GINTSTS_PRTINT | GINTSTS_HCHINT;
--	writel(intmsk, hsotg->regs + GINTMSK);
-+	dwc2_writel(intmsk, hsotg->regs + GINTMSK);
- }
- 
- /**
-@@ -517,12 +517,12 @@ void dwc2_enable_host_interrupts(struct
-  */
- void dwc2_disable_host_interrupts(struct dwc2_hsotg *hsotg)
- {
--	u32 intmsk = readl(hsotg->regs + GINTMSK);
-+	u32 intmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 
- 	/* Disable host mode interrupts without disturbing common interrupts */
- 	intmsk &= ~(GINTSTS_SOF | GINTSTS_PRTINT | GINTSTS_HCHINT |
- 		    GINTSTS_PTXFEMP | GINTSTS_NPTXFEMP);
--	writel(intmsk, hsotg->regs + GINTMSK);
-+	dwc2_writel(intmsk, hsotg->regs + GINTMSK);
- }
- 
- /*
-@@ -602,36 +602,36 @@ static void dwc2_config_fifos(struct dwc
- 	dwc2_calculate_dynamic_fifo(hsotg);
- 
- 	/* Rx FIFO */
--	grxfsiz = readl(hsotg->regs + GRXFSIZ);
-+	grxfsiz = dwc2_readl(hsotg->regs + GRXFSIZ);
- 	dev_dbg(hsotg->dev, "initial grxfsiz=%08x\n", grxfsiz);
- 	grxfsiz &= ~GRXFSIZ_DEPTH_MASK;
- 	grxfsiz |= params->host_rx_fifo_size <<
- 		   GRXFSIZ_DEPTH_SHIFT & GRXFSIZ_DEPTH_MASK;
--	writel(grxfsiz, hsotg->regs + GRXFSIZ);
--	dev_dbg(hsotg->dev, "new grxfsiz=%08x\n", readl(hsotg->regs + GRXFSIZ));
-+	dwc2_writel(grxfsiz, hsotg->regs + GRXFSIZ);
-+	dev_dbg(hsotg->dev, "new grxfsiz=%08x\n", dwc2_readl(hsotg->regs + GRXFSIZ));
- 
- 	/* Non-periodic Tx FIFO */
- 	dev_dbg(hsotg->dev, "initial gnptxfsiz=%08x\n",
--		readl(hsotg->regs + GNPTXFSIZ));
-+		dwc2_readl(hsotg->regs + GNPTXFSIZ));
- 	nptxfsiz = params->host_nperio_tx_fifo_size <<
- 		   FIFOSIZE_DEPTH_SHIFT & FIFOSIZE_DEPTH_MASK;
- 	nptxfsiz |= params->host_rx_fifo_size <<
- 		    FIFOSIZE_STARTADDR_SHIFT & FIFOSIZE_STARTADDR_MASK;
--	writel(nptxfsiz, hsotg->regs + GNPTXFSIZ);
-+	dwc2_writel(nptxfsiz, hsotg->regs + GNPTXFSIZ);
- 	dev_dbg(hsotg->dev, "new gnptxfsiz=%08x\n",
--		readl(hsotg->regs + GNPTXFSIZ));
-+		dwc2_readl(hsotg->regs + GNPTXFSIZ));
- 
- 	/* Periodic Tx FIFO */
- 	dev_dbg(hsotg->dev, "initial hptxfsiz=%08x\n",
--		readl(hsotg->regs + HPTXFSIZ));
-+		dwc2_readl(hsotg->regs + HPTXFSIZ));
- 	hptxfsiz = params->host_perio_tx_fifo_size <<
- 		   FIFOSIZE_DEPTH_SHIFT & FIFOSIZE_DEPTH_MASK;
- 	hptxfsiz |= (params->host_rx_fifo_size +
- 		     params->host_nperio_tx_fifo_size) <<
- 		    FIFOSIZE_STARTADDR_SHIFT & FIFOSIZE_STARTADDR_MASK;
--	writel(hptxfsiz, hsotg->regs + HPTXFSIZ);
-+	dwc2_writel(hptxfsiz, hsotg->regs + HPTXFSIZ);
- 	dev_dbg(hsotg->dev, "new hptxfsiz=%08x\n",
--		readl(hsotg->regs + HPTXFSIZ));
-+		dwc2_readl(hsotg->regs + HPTXFSIZ));
- 
- 	if (hsotg->core_params->en_multiple_tx_fifo > 0 &&
- 	    hsotg->hw_params.snpsid <= DWC2_CORE_REV_2_94a) {
-@@ -639,14 +639,14 @@ static void dwc2_config_fifos(struct dwc
- 		 * Global DFIFOCFG calculation for Host mode -
- 		 * include RxFIFO, NPTXFIFO and HPTXFIFO
- 		 */
--		dfifocfg = readl(hsotg->regs + GDFIFOCFG);
-+		dfifocfg = dwc2_readl(hsotg->regs + GDFIFOCFG);
- 		dfifocfg &= ~GDFIFOCFG_EPINFOBASE_MASK;
- 		dfifocfg |= (params->host_rx_fifo_size +
- 			     params->host_nperio_tx_fifo_size +
- 			     params->host_perio_tx_fifo_size) <<
- 			    GDFIFOCFG_EPINFOBASE_SHIFT &
- 			    GDFIFOCFG_EPINFOBASE_MASK;
--		writel(dfifocfg, hsotg->regs + GDFIFOCFG);
-+		dwc2_writel(dfifocfg, hsotg->regs + GDFIFOCFG);
- 	}
- }
- 
-@@ -667,14 +667,14 @@ void dwc2_core_host_init(struct dwc2_hso
- 	dev_dbg(hsotg->dev, "%s(%p)\n", __func__, hsotg);
- 
- 	/* Restart the Phy Clock */
--	writel(0, hsotg->regs + PCGCTL);
-+	dwc2_writel(0, hsotg->regs + PCGCTL);
- 
- 	/* Initialize Host Configuration Register */
- 	dwc2_init_fs_ls_pclk_sel(hsotg);
- 	if (hsotg->core_params->speed == DWC2_SPEED_PARAM_FULL) {
--		hcfg = readl(hsotg->regs + HCFG);
-+		hcfg = dwc2_readl(hsotg->regs + HCFG);
- 		hcfg |= HCFG_FSLSSUPP;
--		writel(hcfg, hsotg->regs + HCFG);
-+		dwc2_writel(hcfg, hsotg->regs + HCFG);
- 	}
- 
- 	/*
-@@ -683,9 +683,9 @@ void dwc2_core_host_init(struct dwc2_hso
- 	 * and its value must not be changed during runtime.
- 	 */
- 	if (hsotg->core_params->reload_ctl > 0) {
--		hfir = readl(hsotg->regs + HFIR);
-+		hfir = dwc2_readl(hsotg->regs + HFIR);
- 		hfir |= HFIR_RLDCTRL;
--		writel(hfir, hsotg->regs + HFIR);
-+		dwc2_writel(hfir, hsotg->regs + HFIR);
- 	}
- 
- 	if (hsotg->core_params->dma_desc_enable > 0) {
-@@ -701,9 +701,9 @@ void dwc2_core_host_init(struct dwc2_hso
- 				"falling back to buffer DMA mode.\n");
- 			hsotg->core_params->dma_desc_enable = 0;
- 		} else {
--			hcfg = readl(hsotg->regs + HCFG);
-+			hcfg = dwc2_readl(hsotg->regs + HCFG);
- 			hcfg |= HCFG_DESCDMA;
--			writel(hcfg, hsotg->regs + HCFG);
-+			dwc2_writel(hcfg, hsotg->regs + HCFG);
- 		}
- 	}
- 
-@@ -712,18 +712,18 @@ void dwc2_core_host_init(struct dwc2_hso
- 
- 	/* TODO - check this */
- 	/* Clear Host Set HNP Enable in the OTG Control Register */
--	otgctl = readl(hsotg->regs + GOTGCTL);
-+	otgctl = dwc2_readl(hsotg->regs + GOTGCTL);
- 	otgctl &= ~GOTGCTL_HSTSETHNPEN;
--	writel(otgctl, hsotg->regs + GOTGCTL);
-+	dwc2_writel(otgctl, hsotg->regs + GOTGCTL);
- 
- 	/* Make sure the FIFOs are flushed */
- 	dwc2_flush_tx_fifo(hsotg, 0x10 /* all TX FIFOs */);
- 	dwc2_flush_rx_fifo(hsotg);
- 
- 	/* Clear Host Set HNP Enable in the OTG Control Register */
--	otgctl = readl(hsotg->regs + GOTGCTL);
-+	otgctl = dwc2_readl(hsotg->regs + GOTGCTL);
- 	otgctl &= ~GOTGCTL_HSTSETHNPEN;
--	writel(otgctl, hsotg->regs + GOTGCTL);
-+	dwc2_writel(otgctl, hsotg->regs + GOTGCTL);
- 
- 	if (hsotg->core_params->dma_desc_enable <= 0) {
- 		int num_channels, i;
-@@ -732,25 +732,25 @@ void dwc2_core_host_init(struct dwc2_hso
- 		/* Flush out any leftover queued requests */
- 		num_channels = hsotg->core_params->host_channels;
- 		for (i = 0; i < num_channels; i++) {
--			hcchar = readl(hsotg->regs + HCCHAR(i));
-+			hcchar = dwc2_readl(hsotg->regs + HCCHAR(i));
- 			hcchar &= ~HCCHAR_CHENA;
- 			hcchar |= HCCHAR_CHDIS;
- 			hcchar &= ~HCCHAR_EPDIR;
--			writel(hcchar, hsotg->regs + HCCHAR(i));
-+			dwc2_writel(hcchar, hsotg->regs + HCCHAR(i));
- 		}
- 
- 		/* Halt all channels to put them into a known state */
- 		for (i = 0; i < num_channels; i++) {
- 			int count = 0;
- 
--			hcchar = readl(hsotg->regs + HCCHAR(i));
-+			hcchar = dwc2_readl(hsotg->regs + HCCHAR(i));
- 			hcchar |= HCCHAR_CHENA | HCCHAR_CHDIS;
- 			hcchar &= ~HCCHAR_EPDIR;
--			writel(hcchar, hsotg->regs + HCCHAR(i));
-+			dwc2_writel(hcchar, hsotg->regs + HCCHAR(i));
- 			dev_dbg(hsotg->dev, "%s: Halt channel %d\n",
- 				__func__, i);
- 			do {
--				hcchar = readl(hsotg->regs + HCCHAR(i));
-+				hcchar = dwc2_readl(hsotg->regs + HCCHAR(i));
- 				if (++count > 1000) {
- 					dev_err(hsotg->dev,
- 						"Unable to clear enable on channel %d\n",
-@@ -771,7 +771,7 @@ void dwc2_core_host_init(struct dwc2_hso
- 			!!(hprt0 & HPRT0_PWR));
- 		if (!(hprt0 & HPRT0_PWR)) {
- 			hprt0 |= HPRT0_PWR;
--			writel(hprt0, hsotg->regs + HPRT0);
-+			dwc2_writel(hprt0, hsotg->regs + HPRT0);
- 		}
- 	}
- 
-@@ -851,7 +851,7 @@ static void dwc2_hc_enable_slave_ints(st
- 		break;
- 	}
- 
--	writel(hcintmsk, hsotg->regs + HCINTMSK(chan->hc_num));
-+	dwc2_writel(hcintmsk, hsotg->regs + HCINTMSK(chan->hc_num));
- 	if (dbg_hc(chan))
- 		dev_vdbg(hsotg->dev, "set HCINTMSK to %08x\n", hcintmsk);
- }
-@@ -888,7 +888,7 @@ static void dwc2_hc_enable_dma_ints(stru
- 		}
- 	}
- 
--	writel(hcintmsk, hsotg->regs + HCINTMSK(chan->hc_num));
-+	dwc2_writel(hcintmsk, hsotg->regs + HCINTMSK(chan->hc_num));
- 	if (dbg_hc(chan))
- 		dev_vdbg(hsotg->dev, "set HCINTMSK to %08x\n", hcintmsk);
- }
-@@ -909,16 +909,16 @@ static void dwc2_hc_enable_ints(struct d
- 	}
- 
- 	/* Enable the top level host channel interrupt */
--	intmsk = readl(hsotg->regs + HAINTMSK);
-+	intmsk = dwc2_readl(hsotg->regs + HAINTMSK);
- 	intmsk |= 1 << chan->hc_num;
--	writel(intmsk, hsotg->regs + HAINTMSK);
-+	dwc2_writel(intmsk, hsotg->regs + HAINTMSK);
- 	if (dbg_hc(chan))
- 		dev_vdbg(hsotg->dev, "set HAINTMSK to %08x\n", intmsk);
- 
- 	/* Make sure host channel interrupts are enabled */
--	intmsk = readl(hsotg->regs + GINTMSK);
-+	intmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 	intmsk |= GINTSTS_HCHINT;
--	writel(intmsk, hsotg->regs + GINTMSK);
-+	dwc2_writel(intmsk, hsotg->regs + GINTMSK);
- 	if (dbg_hc(chan))
- 		dev_vdbg(hsotg->dev, "set GINTMSK to %08x\n", intmsk);
- }
-@@ -947,7 +947,7 @@ void dwc2_hc_init(struct dwc2_hsotg *hso
- 	/* Clear old interrupt conditions for this host channel */
- 	hcintmsk = 0xffffffff;
- 	hcintmsk &= ~HCINTMSK_RESERVED14_31;
--	writel(hcintmsk, hsotg->regs + HCINT(hc_num));
-+	dwc2_writel(hcintmsk, hsotg->regs + HCINT(hc_num));
- 
- 	/* Enable channel interrupts required for this transfer */
- 	dwc2_hc_enable_ints(hsotg, chan);
-@@ -964,7 +964,7 @@ void dwc2_hc_init(struct dwc2_hsotg *hso
- 		hcchar |= HCCHAR_LSPDDEV;
- 	hcchar |= chan->ep_type << HCCHAR_EPTYPE_SHIFT & HCCHAR_EPTYPE_MASK;
- 	hcchar |= chan->max_packet << HCCHAR_MPS_SHIFT & HCCHAR_MPS_MASK;
--	writel(hcchar, hsotg->regs + HCCHAR(hc_num));
-+	dwc2_writel(hcchar, hsotg->regs + HCCHAR(hc_num));
- 	if (dbg_hc(chan)) {
- 		dev_vdbg(hsotg->dev, "set HCCHAR(%d) to %08x\n",
- 			 hc_num, hcchar);
-@@ -1018,7 +1018,7 @@ void dwc2_hc_init(struct dwc2_hsotg *hso
- 		}
- 	}
- 
--	writel(hcsplt, hsotg->regs + HCSPLT(hc_num));
-+	dwc2_writel(hcsplt, hsotg->regs + HCSPLT(hc_num));
- }
- 
- /**
-@@ -1070,14 +1070,14 @@ void dwc2_hc_halt(struct dwc2_hsotg *hso
- 		u32 hcintmsk = HCINTMSK_CHHLTD;
- 
- 		dev_vdbg(hsotg->dev, "dequeue/error\n");
--		writel(hcintmsk, hsotg->regs + HCINTMSK(chan->hc_num));
-+		dwc2_writel(hcintmsk, hsotg->regs + HCINTMSK(chan->hc_num));
- 
- 		/*
- 		 * Make sure no other interrupts besides halt are currently
- 		 * pending. Handling another interrupt could cause a crash due
- 		 * to the QTD and QH state.
- 		 */
--		writel(~hcintmsk, hsotg->regs + HCINT(chan->hc_num));
-+		dwc2_writel(~hcintmsk, hsotg->regs + HCINT(chan->hc_num));
- 
- 		/*
- 		 * Make sure the halt status is set to URB_DEQUEUE or AHB_ERR
-@@ -1086,7 +1086,7 @@ void dwc2_hc_halt(struct dwc2_hsotg *hso
- 		 */
- 		chan->halt_status = halt_status;
- 
--		hcchar = readl(hsotg->regs + HCCHAR(chan->hc_num));
-+		hcchar = dwc2_readl(hsotg->regs + HCCHAR(chan->hc_num));
- 		if (!(hcchar & HCCHAR_CHENA)) {
- 			/*
- 			 * The channel is either already halted or it hasn't
-@@ -1114,7 +1114,7 @@ void dwc2_hc_halt(struct dwc2_hsotg *hso
- 		return;
- 	}
- 
--	hcchar = readl(hsotg->regs + HCCHAR(chan->hc_num));
-+	hcchar = dwc2_readl(hsotg->regs + HCCHAR(chan->hc_num));
- 
- 	/* No need to set the bit in DDMA for disabling the channel */
- 	/* TODO check it everywhere channel is disabled */
-@@ -1137,7 +1137,7 @@ void dwc2_hc_halt(struct dwc2_hsotg *hso
- 		if (chan->ep_type == USB_ENDPOINT_XFER_CONTROL ||
- 		    chan->ep_type == USB_ENDPOINT_XFER_BULK) {
- 			dev_vdbg(hsotg->dev, "control/bulk\n");
--			nptxsts = readl(hsotg->regs + GNPTXSTS);
-+			nptxsts = dwc2_readl(hsotg->regs + GNPTXSTS);
- 			if ((nptxsts & TXSTS_QSPCAVAIL_MASK) == 0) {
- 				dev_vdbg(hsotg->dev, "Disabling channel\n");
- 				hcchar &= ~HCCHAR_CHENA;
-@@ -1145,7 +1145,7 @@ void dwc2_hc_halt(struct dwc2_hsotg *hso
- 		} else {
- 			if (dbg_perio())
- 				dev_vdbg(hsotg->dev, "isoc/intr\n");
--			hptxsts = readl(hsotg->regs + HPTXSTS);
-+			hptxsts = dwc2_readl(hsotg->regs + HPTXSTS);
- 			if ((hptxsts & TXSTS_QSPCAVAIL_MASK) == 0 ||
- 			    hsotg->queuing_high_bandwidth) {
- 				if (dbg_perio())
-@@ -1158,7 +1158,7 @@ void dwc2_hc_halt(struct dwc2_hsotg *hso
- 			dev_vdbg(hsotg->dev, "DMA enabled\n");
- 	}
- 
--	writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
-+	dwc2_writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
- 	chan->halt_status = halt_status;
- 
- 	if (hcchar & HCCHAR_CHENA) {
-@@ -1205,10 +1205,10 @@ void dwc2_hc_cleanup(struct dwc2_hsotg *
- 	 * Clear channel interrupt enables and any unhandled channel interrupt
- 	 * conditions
- 	 */
--	writel(0, hsotg->regs + HCINTMSK(chan->hc_num));
-+	dwc2_writel(0, hsotg->regs + HCINTMSK(chan->hc_num));
- 	hcintmsk = 0xffffffff;
- 	hcintmsk &= ~HCINTMSK_RESERVED14_31;
--	writel(hcintmsk, hsotg->regs + HCINT(chan->hc_num));
-+	dwc2_writel(hcintmsk, hsotg->regs + HCINT(chan->hc_num));
- }
- 
- /**
-@@ -1294,13 +1294,13 @@ static void dwc2_hc_write_packet(struct
- 	if (((unsigned long)data_buf & 0x3) == 0) {
- 		/* xfer_buf is DWORD aligned */
- 		for (i = 0; i < dword_count; i++, data_buf++)
--			writel(*data_buf, data_fifo);
-+			dwc2_writel(*data_buf, data_fifo);
- 	} else {
- 		/* xfer_buf is not DWORD aligned */
- 		for (i = 0; i < dword_count; i++, data_buf++) {
- 			u32 data = data_buf[0] | data_buf[1] << 8 |
- 				   data_buf[2] << 16 | data_buf[3] << 24;
--			writel(data, data_fifo);
-+			dwc2_writel(data, data_fifo);
- 		}
- 	}
- 
-@@ -1453,7 +1453,7 @@ void dwc2_hc_start_transfer(struct dwc2_
- 	hctsiz |= num_packets << TSIZ_PKTCNT_SHIFT & TSIZ_PKTCNT_MASK;
- 	hctsiz |= chan->data_pid_start << TSIZ_SC_MC_PID_SHIFT &
- 		  TSIZ_SC_MC_PID_MASK;
--	writel(hctsiz, hsotg->regs + HCTSIZ(chan->hc_num));
-+	dwc2_writel(hctsiz, hsotg->regs + HCTSIZ(chan->hc_num));
- 	if (dbg_hc(chan)) {
- 		dev_vdbg(hsotg->dev, "Wrote %08x to HCTSIZ(%d)\n",
- 			 hctsiz, chan->hc_num);
-@@ -1481,7 +1481,7 @@ void dwc2_hc_start_transfer(struct dwc2_
- 		} else {
- 			dma_addr = chan->xfer_dma;
- 		}
--		writel((u32)dma_addr, hsotg->regs + HCDMA(chan->hc_num));
-+		dwc2_writel((u32)dma_addr, hsotg->regs + HCDMA(chan->hc_num));
- 		if (dbg_hc(chan))
- 			dev_vdbg(hsotg->dev, "Wrote %08lx to HCDMA(%d)\n",
- 				 (unsigned long)dma_addr, chan->hc_num);
-@@ -1489,13 +1489,13 @@ void dwc2_hc_start_transfer(struct dwc2_
- 
- 	/* Start the split */
- 	if (chan->do_split) {
--		u32 hcsplt = readl(hsotg->regs + HCSPLT(chan->hc_num));
-+		u32 hcsplt = dwc2_readl(hsotg->regs + HCSPLT(chan->hc_num));
- 
- 		hcsplt |= HCSPLT_SPLTENA;
--		writel(hcsplt, hsotg->regs + HCSPLT(chan->hc_num));
-+		dwc2_writel(hcsplt, hsotg->regs + HCSPLT(chan->hc_num));
- 	}
- 
--	hcchar = readl(hsotg->regs + HCCHAR(chan->hc_num));
-+	hcchar = dwc2_readl(hsotg->regs + HCCHAR(chan->hc_num));
- 	hcchar &= ~HCCHAR_MULTICNT_MASK;
- 	hcchar |= chan->multi_count << HCCHAR_MULTICNT_SHIFT &
- 		  HCCHAR_MULTICNT_MASK;
-@@ -1515,7 +1515,7 @@ void dwc2_hc_start_transfer(struct dwc2_
- 			 (hcchar & HCCHAR_MULTICNT_MASK) >>
- 			 HCCHAR_MULTICNT_SHIFT);
- 
--	writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
-+	dwc2_writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
- 	if (dbg_hc(chan))
- 		dev_vdbg(hsotg->dev, "Wrote %08x to HCCHAR(%d)\n", hcchar,
- 			 chan->hc_num);
-@@ -1574,18 +1574,18 @@ void dwc2_hc_start_transfer_ddma(struct
- 		dev_vdbg(hsotg->dev, "	 NTD: %d\n", chan->ntd - 1);
- 	}
- 
--	writel(hctsiz, hsotg->regs + HCTSIZ(chan->hc_num));
-+	dwc2_writel(hctsiz, hsotg->regs + HCTSIZ(chan->hc_num));
- 
- 	hc_dma = (u32)chan->desc_list_addr & HCDMA_DMA_ADDR_MASK;
- 
- 	/* Always start from first descriptor */
- 	hc_dma &= ~HCDMA_CTD_MASK;
--	writel(hc_dma, hsotg->regs + HCDMA(chan->hc_num));
-+	dwc2_writel(hc_dma, hsotg->regs + HCDMA(chan->hc_num));
- 	if (dbg_hc(chan))
- 		dev_vdbg(hsotg->dev, "Wrote %08x to HCDMA(%d)\n",
- 			 hc_dma, chan->hc_num);
- 
--	hcchar = readl(hsotg->regs + HCCHAR(chan->hc_num));
-+	hcchar = dwc2_readl(hsotg->regs + HCCHAR(chan->hc_num));
- 	hcchar &= ~HCCHAR_MULTICNT_MASK;
- 	hcchar |= chan->multi_count << HCCHAR_MULTICNT_SHIFT &
- 		  HCCHAR_MULTICNT_MASK;
-@@ -1604,7 +1604,7 @@ void dwc2_hc_start_transfer_ddma(struct
- 			 (hcchar & HCCHAR_MULTICNT_MASK) >>
- 			 HCCHAR_MULTICNT_SHIFT);
- 
--	writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
-+	dwc2_writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
- 	if (dbg_hc(chan))
- 		dev_vdbg(hsotg->dev, "Wrote %08x to HCCHAR(%d)\n", hcchar,
- 			 chan->hc_num);
-@@ -1661,7 +1661,7 @@ int dwc2_hc_continue_transfer(struct dwc
- 		 * transfer completes, the extra requests for the channel will
- 		 * be flushed.
- 		 */
--		u32 hcchar = readl(hsotg->regs + HCCHAR(chan->hc_num));
-+		u32 hcchar = dwc2_readl(hsotg->regs + HCCHAR(chan->hc_num));
- 
- 		dwc2_hc_set_even_odd_frame(hsotg, chan, &hcchar);
- 		hcchar |= HCCHAR_CHENA;
-@@ -1669,7 +1669,7 @@ int dwc2_hc_continue_transfer(struct dwc
- 		if (dbg_hc(chan))
- 			dev_vdbg(hsotg->dev, "	 IN xfer: hcchar = 0x%08x\n",
- 				 hcchar);
--		writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
-+		dwc2_writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
- 		chan->requests++;
- 		return 1;
- 	}
-@@ -1679,7 +1679,7 @@ int dwc2_hc_continue_transfer(struct dwc
- 	if (chan->xfer_count < chan->xfer_len) {
- 		if (chan->ep_type == USB_ENDPOINT_XFER_INT ||
- 		    chan->ep_type == USB_ENDPOINT_XFER_ISOC) {
--			u32 hcchar = readl(hsotg->regs +
-+			u32 hcchar = dwc2_readl(hsotg->regs +
- 					   HCCHAR(chan->hc_num));
- 
- 			dwc2_hc_set_even_odd_frame(hsotg, chan,
-@@ -1716,12 +1716,12 @@ void dwc2_hc_do_ping(struct dwc2_hsotg *
- 
- 	hctsiz = TSIZ_DOPNG;
- 	hctsiz |= 1 << TSIZ_PKTCNT_SHIFT;
--	writel(hctsiz, hsotg->regs + HCTSIZ(chan->hc_num));
-+	dwc2_writel(hctsiz, hsotg->regs + HCTSIZ(chan->hc_num));
- 
--	hcchar = readl(hsotg->regs + HCCHAR(chan->hc_num));
-+	hcchar = dwc2_readl(hsotg->regs + HCCHAR(chan->hc_num));
- 	hcchar |= HCCHAR_CHENA;
- 	hcchar &= ~HCCHAR_CHDIS;
--	writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
-+	dwc2_writel(hcchar, hsotg->regs + HCCHAR(chan->hc_num));
- }
- 
- /**
-@@ -1740,8 +1740,8 @@ u32 dwc2_calc_frame_interval(struct dwc2
- 	u32 hprt0;
- 	int clock = 60;	/* default value */
- 
--	usbcfg = readl(hsotg->regs + GUSBCFG);
--	hprt0 = readl(hsotg->regs + HPRT0);
-+	usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
-+	hprt0 = dwc2_readl(hsotg->regs + HPRT0);
- 
- 	if (!(usbcfg & GUSBCFG_PHYSEL) && (usbcfg & GUSBCFG_ULPI_UTMI_SEL) &&
- 	    !(usbcfg & GUSBCFG_PHYIF16))
-@@ -1797,7 +1797,7 @@ void dwc2_read_packet(struct dwc2_hsotg
- 	dev_vdbg(hsotg->dev, "%s(%p,%p,%d)\n", __func__, hsotg, dest, bytes);
- 
- 	for (i = 0; i < word_count; i++, data_buf++)
--		*data_buf = readl(fifo);
-+		*data_buf = dwc2_readl(fifo);
- }
- 
- /**
-@@ -1817,56 +1817,56 @@ void dwc2_dump_host_registers(struct dwc
- 	dev_dbg(hsotg->dev, "Host Global Registers\n");
- 	addr = hsotg->regs + HCFG;
- 	dev_dbg(hsotg->dev, "HCFG	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + HFIR;
- 	dev_dbg(hsotg->dev, "HFIR	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + HFNUM;
- 	dev_dbg(hsotg->dev, "HFNUM	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + HPTXSTS;
- 	dev_dbg(hsotg->dev, "HPTXSTS	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + HAINT;
- 	dev_dbg(hsotg->dev, "HAINT	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + HAINTMSK;
- 	dev_dbg(hsotg->dev, "HAINTMSK	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	if (hsotg->core_params->dma_desc_enable > 0) {
- 		addr = hsotg->regs + HFLBADDR;
- 		dev_dbg(hsotg->dev, "HFLBADDR @0x%08lX : 0x%08X\n",
--			(unsigned long)addr, readl(addr));
-+			(unsigned long)addr, dwc2_readl(addr));
- 	}
- 
- 	addr = hsotg->regs + HPRT0;
- 	dev_dbg(hsotg->dev, "HPRT0	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 
- 	for (i = 0; i < hsotg->core_params->host_channels; i++) {
- 		dev_dbg(hsotg->dev, "Host Channel %d Specific Registers\n", i);
- 		addr = hsotg->regs + HCCHAR(i);
- 		dev_dbg(hsotg->dev, "HCCHAR	 @0x%08lX : 0x%08X\n",
--			(unsigned long)addr, readl(addr));
-+			(unsigned long)addr, dwc2_readl(addr));
- 		addr = hsotg->regs + HCSPLT(i);
- 		dev_dbg(hsotg->dev, "HCSPLT	 @0x%08lX : 0x%08X\n",
--			(unsigned long)addr, readl(addr));
-+			(unsigned long)addr, dwc2_readl(addr));
- 		addr = hsotg->regs + HCINT(i);
- 		dev_dbg(hsotg->dev, "HCINT	 @0x%08lX : 0x%08X\n",
--			(unsigned long)addr, readl(addr));
-+			(unsigned long)addr, dwc2_readl(addr));
- 		addr = hsotg->regs + HCINTMSK(i);
- 		dev_dbg(hsotg->dev, "HCINTMSK	 @0x%08lX : 0x%08X\n",
--			(unsigned long)addr, readl(addr));
-+			(unsigned long)addr, dwc2_readl(addr));
- 		addr = hsotg->regs + HCTSIZ(i);
- 		dev_dbg(hsotg->dev, "HCTSIZ	 @0x%08lX : 0x%08X\n",
--			(unsigned long)addr, readl(addr));
-+			(unsigned long)addr, dwc2_readl(addr));
- 		addr = hsotg->regs + HCDMA(i);
- 		dev_dbg(hsotg->dev, "HCDMA	 @0x%08lX : 0x%08X\n",
--			(unsigned long)addr, readl(addr));
-+			(unsigned long)addr, dwc2_readl(addr));
- 		if (hsotg->core_params->dma_desc_enable > 0) {
- 			addr = hsotg->regs + HCDMAB(i);
- 			dev_dbg(hsotg->dev, "HCDMAB	 @0x%08lX : 0x%08X\n",
--				(unsigned long)addr, readl(addr));
-+				(unsigned long)addr, dwc2_readl(addr));
- 		}
- 	}
- #endif
-@@ -1888,80 +1888,80 @@ void dwc2_dump_global_registers(struct d
- 	dev_dbg(hsotg->dev, "Core Global Registers\n");
- 	addr = hsotg->regs + GOTGCTL;
- 	dev_dbg(hsotg->dev, "GOTGCTL	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GOTGINT;
- 	dev_dbg(hsotg->dev, "GOTGINT	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GAHBCFG;
- 	dev_dbg(hsotg->dev, "GAHBCFG	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GUSBCFG;
- 	dev_dbg(hsotg->dev, "GUSBCFG	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GRSTCTL;
- 	dev_dbg(hsotg->dev, "GRSTCTL	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GINTSTS;
- 	dev_dbg(hsotg->dev, "GINTSTS	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GINTMSK;
- 	dev_dbg(hsotg->dev, "GINTMSK	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GRXSTSR;
- 	dev_dbg(hsotg->dev, "GRXSTSR	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GRXFSIZ;
- 	dev_dbg(hsotg->dev, "GRXFSIZ	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GNPTXFSIZ;
- 	dev_dbg(hsotg->dev, "GNPTXFSIZ	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GNPTXSTS;
- 	dev_dbg(hsotg->dev, "GNPTXSTS	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GI2CCTL;
- 	dev_dbg(hsotg->dev, "GI2CCTL	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GPVNDCTL;
- 	dev_dbg(hsotg->dev, "GPVNDCTL	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GGPIO;
- 	dev_dbg(hsotg->dev, "GGPIO	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GUID;
- 	dev_dbg(hsotg->dev, "GUID	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GSNPSID;
- 	dev_dbg(hsotg->dev, "GSNPSID	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GHWCFG1;
- 	dev_dbg(hsotg->dev, "GHWCFG1	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GHWCFG2;
- 	dev_dbg(hsotg->dev, "GHWCFG2	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GHWCFG3;
- 	dev_dbg(hsotg->dev, "GHWCFG3	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GHWCFG4;
- 	dev_dbg(hsotg->dev, "GHWCFG4	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GLPMCFG;
- 	dev_dbg(hsotg->dev, "GLPMCFG	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GPWRDN;
- 	dev_dbg(hsotg->dev, "GPWRDN	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + GDFIFOCFG;
- 	dev_dbg(hsotg->dev, "GDFIFOCFG	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 	addr = hsotg->regs + HPTXFSIZ;
- 	dev_dbg(hsotg->dev, "HPTXFSIZ	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- 
- 	addr = hsotg->regs + PCGCTL;
- 	dev_dbg(hsotg->dev, "PCGCTL	 @0x%08lX : 0x%08X\n",
--		(unsigned long)addr, readl(addr));
-+		(unsigned long)addr, dwc2_readl(addr));
- #endif
- }
- 
-@@ -1980,15 +1980,15 @@ void dwc2_flush_tx_fifo(struct dwc2_hsot
- 
- 	greset = GRSTCTL_TXFFLSH;
- 	greset |= num << GRSTCTL_TXFNUM_SHIFT & GRSTCTL_TXFNUM_MASK;
--	writel(greset, hsotg->regs + GRSTCTL);
-+	dwc2_writel(greset, hsotg->regs + GRSTCTL);
- 
- 	do {
--		greset = readl(hsotg->regs + GRSTCTL);
-+		greset = dwc2_readl(hsotg->regs + GRSTCTL);
- 		if (++count > 10000) {
- 			dev_warn(hsotg->dev,
- 				 "%s() HANG! GRSTCTL=%0x GNPTXSTS=0x%08x\n",
- 				 __func__, greset,
--				 readl(hsotg->regs + GNPTXSTS));
-+				 dwc2_readl(hsotg->regs + GNPTXSTS));
- 			break;
- 		}
- 		udelay(1);
-@@ -2011,10 +2011,10 @@ void dwc2_flush_rx_fifo(struct dwc2_hsot
- 	dev_vdbg(hsotg->dev, "%s()\n", __func__);
- 
- 	greset = GRSTCTL_RXFFLSH;
--	writel(greset, hsotg->regs + GRSTCTL);
-+	dwc2_writel(greset, hsotg->regs + GRSTCTL);
- 
- 	do {
--		greset = readl(hsotg->regs + GRSTCTL);
-+		greset = dwc2_readl(hsotg->regs + GRSTCTL);
- 		if (++count > 10000) {
- 			dev_warn(hsotg->dev, "%s() HANG! GRSTCTL=%0x\n",
- 				 __func__, greset);
-@@ -2676,7 +2676,7 @@ int dwc2_get_hwparams(struct dwc2_hsotg
- 	 * 0x45f42xxx or 0x45f43xxx, which corresponds to either "OT2" or "OT3",
- 	 * as in "OTG version 2.xx" or "OTG version 3.xx".
- 	 */
--	hw->snpsid = readl(hsotg->regs + GSNPSID);
-+	hw->snpsid = dwc2_readl(hsotg->regs + GSNPSID);
- 	if ((hw->snpsid & 0xfffff000) != 0x4f542000 &&
- 	    (hw->snpsid & 0xfffff000) != 0x4f543000) {
- 		dev_err(hsotg->dev, "Bad value for GSNPSID: 0x%08x\n",
-@@ -2688,11 +2688,11 @@ int dwc2_get_hwparams(struct dwc2_hsotg
- 		hw->snpsid >> 12 & 0xf, hw->snpsid >> 8 & 0xf,
- 		hw->snpsid >> 4 & 0xf, hw->snpsid & 0xf, hw->snpsid);
- 
--	hwcfg1 = readl(hsotg->regs + GHWCFG1);
--	hwcfg2 = readl(hsotg->regs + GHWCFG2);
--	hwcfg3 = readl(hsotg->regs + GHWCFG3);
--	hwcfg4 = readl(hsotg->regs + GHWCFG4);
--	grxfsiz = readl(hsotg->regs + GRXFSIZ);
-+	hwcfg1 = dwc2_readl(hsotg->regs + GHWCFG1);
-+	hwcfg2 = dwc2_readl(hsotg->regs + GHWCFG2);
-+	hwcfg3 = dwc2_readl(hsotg->regs + GHWCFG3);
-+	hwcfg4 = dwc2_readl(hsotg->regs + GHWCFG4);
-+	grxfsiz = dwc2_readl(hsotg->regs + GRXFSIZ);
- 
- 	dev_dbg(hsotg->dev, "hwcfg1=%08x\n", hwcfg1);
- 	dev_dbg(hsotg->dev, "hwcfg2=%08x\n", hwcfg2);
-@@ -2701,18 +2701,18 @@ int dwc2_get_hwparams(struct dwc2_hsotg
- 	dev_dbg(hsotg->dev, "grxfsiz=%08x\n", grxfsiz);
- 
- 	/* Force host mode to get HPTXFSIZ / GNPTXFSIZ exact power on value */
--	gusbcfg = readl(hsotg->regs + GUSBCFG);
-+	gusbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
- 	gusbcfg |= GUSBCFG_FORCEHOSTMODE;
--	writel(gusbcfg, hsotg->regs + GUSBCFG);
-+	dwc2_writel(gusbcfg, hsotg->regs + GUSBCFG);
- 	usleep_range(100000, 150000);
- 
--	gnptxfsiz = readl(hsotg->regs + GNPTXFSIZ);
--	hptxfsiz = readl(hsotg->regs + HPTXFSIZ);
-+	gnptxfsiz = dwc2_readl(hsotg->regs + GNPTXFSIZ);
-+	hptxfsiz = dwc2_readl(hsotg->regs + HPTXFSIZ);
- 	dev_dbg(hsotg->dev, "gnptxfsiz=%08x\n", gnptxfsiz);
- 	dev_dbg(hsotg->dev, "hptxfsiz=%08x\n", hptxfsiz);
--	gusbcfg = readl(hsotg->regs + GUSBCFG);
-+	gusbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
- 	gusbcfg &= ~GUSBCFG_FORCEHOSTMODE;
--	writel(gusbcfg, hsotg->regs + GUSBCFG);
-+	dwc2_writel(gusbcfg, hsotg->regs + GUSBCFG);
- 	usleep_range(100000, 150000);
- 
- 	/* hwcfg2 */
-@@ -2831,7 +2831,7 @@ u16 dwc2_get_otg_version(struct dwc2_hso
- 
- bool dwc2_is_controller_alive(struct dwc2_hsotg *hsotg)
- {
--	if (readl(hsotg->regs + GSNPSID) == 0xffffffff)
-+	if (dwc2_readl(hsotg->regs + GSNPSID) == 0xffffffff)
- 		return false;
- 	else
- 		return true;
-@@ -2845,10 +2845,10 @@ bool dwc2_is_controller_alive(struct dwc
-  */
- void dwc2_enable_global_interrupts(struct dwc2_hsotg *hsotg)
- {
--	u32 ahbcfg = readl(hsotg->regs + GAHBCFG);
-+	u32 ahbcfg = dwc2_readl(hsotg->regs + GAHBCFG);
- 
- 	ahbcfg |= GAHBCFG_GLBL_INTR_EN;
--	writel(ahbcfg, hsotg->regs + GAHBCFG);
-+	dwc2_writel(ahbcfg, hsotg->regs + GAHBCFG);
- }
- 
- /**
-@@ -2859,10 +2859,10 @@ void dwc2_enable_global_interrupts(struc
-  */
- void dwc2_disable_global_interrupts(struct dwc2_hsotg *hsotg)
- {
--	u32 ahbcfg = readl(hsotg->regs + GAHBCFG);
-+	u32 ahbcfg = dwc2_readl(hsotg->regs + GAHBCFG);
- 
- 	ahbcfg &= ~GAHBCFG_GLBL_INTR_EN;
--	writel(ahbcfg, hsotg->regs + GAHBCFG);
-+	dwc2_writel(ahbcfg, hsotg->regs + GAHBCFG);
- }
- 
- MODULE_DESCRIPTION("DESIGNWARE HS OTG Core");
---- a/drivers/usb/dwc2/core.h
-+++ b/drivers/usb/dwc2/core.h
-@@ -44,16 +44,28 @@
- #include <linux/usb/phy.h>
- #include "hw.h"
- 
--#ifdef DWC2_LOG_WRITES
--static inline void do_write(u32 value, void *addr)
-+static inline u32 dwc2_readl(const void __iomem *addr)
- {
--	writel(value, addr);
--	pr_info("INFO:: wrote %08x to %p\n", value, addr);
-+	u32 value = __raw_readl(addr);
-+
-+	/* In order to preserve endianness __raw_* operation is used. Therefore
-+	   a barrier is needed to ensure IO access is not re-ordered across
-+	   reads or writes */
-+	mb();
-+	return value;
- }
- 
--#undef writel
--#define writel(v, a)	do_write(v, a)
-+static inline void dwc2_writel(u32 value, void __iomem *addr)
-+{
-+	__raw_writel(value, addr);
-+	/* In order to preserve endianness __raw_* operation is used. Therefore
-+	   a barrier is needed to ensure IO access is not re-ordered across
-+	   reads or writes */
-+	mb();
-+#ifdef DWC2_LOG_WRITES
-+	pr_info("INFO:: wrote %08x to %p\n", value, addr);
- #endif
-+}
- 
- /* Maximum number of Endpoints/HostChannels */
- #define MAX_EPS_CHANNELS	16
---- a/drivers/usb/dwc2/core_intr.c
-+++ b/drivers/usb/dwc2/core_intr.c
-@@ -80,15 +80,15 @@ static const char *dwc2_op_state_str(str
-  */
- static void dwc2_handle_usb_port_intr(struct dwc2_hsotg *hsotg)
- {
--	u32 hprt0 = readl(hsotg->regs + HPRT0);
-+	u32 hprt0 = dwc2_readl(hsotg->regs + HPRT0);
- 
- 	if (hprt0 & HPRT0_ENACHG) {
- 		hprt0 &= ~HPRT0_ENA;
--		writel(hprt0, hsotg->regs + HPRT0);
-+		dwc2_writel(hprt0, hsotg->regs + HPRT0);
- 	}
- 
- 	/* Clear interrupt */
--	writel(GINTSTS_PRTINT, hsotg->regs + GINTSTS);
-+	dwc2_writel(GINTSTS_PRTINT, hsotg->regs + GINTSTS);
- }
- 
- /**
-@@ -102,7 +102,7 @@ static void dwc2_handle_mode_mismatch_in
- 		 dwc2_is_host_mode(hsotg) ? "Host" : "Device");
- 
- 	/* Clear interrupt */
--	writel(GINTSTS_MODEMIS, hsotg->regs + GINTSTS);
-+	dwc2_writel(GINTSTS_MODEMIS, hsotg->regs + GINTSTS);
- }
- 
- /**
-@@ -117,8 +117,8 @@ static void dwc2_handle_otg_intr(struct
- 	u32 gotgctl;
- 	u32 gintmsk;
- 
--	gotgint = readl(hsotg->regs + GOTGINT);
--	gotgctl = readl(hsotg->regs + GOTGCTL);
-+	gotgint = dwc2_readl(hsotg->regs + GOTGINT);
-+	gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
- 	dev_dbg(hsotg->dev, "++OTG Interrupt gotgint=%0x [%s]\n", gotgint,
- 		dwc2_op_state_str(hsotg));
- 
-@@ -126,7 +126,7 @@ static void dwc2_handle_otg_intr(struct
- 		dev_dbg(hsotg->dev,
- 			" ++OTG Interrupt: Session End Detected++ (%s)\n",
- 			dwc2_op_state_str(hsotg));
--		gotgctl = readl(hsotg->regs + GOTGCTL);
-+		gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
- 
- 		if (hsotg->op_state == OTG_STATE_B_HOST) {
- 			hsotg->op_state = OTG_STATE_B_PERIPHERAL;
-@@ -149,15 +149,15 @@ static void dwc2_handle_otg_intr(struct
- 			hsotg->lx_state = DWC2_L0;
- 		}
- 
--		gotgctl = readl(hsotg->regs + GOTGCTL);
-+		gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
- 		gotgctl &= ~GOTGCTL_DEVHNPEN;
--		writel(gotgctl, hsotg->regs + GOTGCTL);
-+		dwc2_writel(gotgctl, hsotg->regs + GOTGCTL);
- 	}
- 
- 	if (gotgint & GOTGINT_SES_REQ_SUC_STS_CHNG) {
- 		dev_dbg(hsotg->dev,
- 			" ++OTG Interrupt: Session Request Success Status Change++\n");
--		gotgctl = readl(hsotg->regs + GOTGCTL);
-+		gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
- 		if (gotgctl & GOTGCTL_SESREQSCS) {
- 			if (hsotg->core_params->phy_type ==
- 					DWC2_PHY_TYPE_PARAM_FS
-@@ -165,9 +165,9 @@ static void dwc2_handle_otg_intr(struct
- 				hsotg->srp_success = 1;
- 			} else {
- 				/* Clear Session Request */
--				gotgctl = readl(hsotg->regs + GOTGCTL);
-+				gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
- 				gotgctl &= ~GOTGCTL_SESREQ;
--				writel(gotgctl, hsotg->regs + GOTGCTL);
-+				dwc2_writel(gotgctl, hsotg->regs + GOTGCTL);
- 			}
- 		}
- 	}
-@@ -177,7 +177,7 @@ static void dwc2_handle_otg_intr(struct
- 		 * Print statements during the HNP interrupt handling
- 		 * can cause it to fail
- 		 */
--		gotgctl = readl(hsotg->regs + GOTGCTL);
-+		gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
- 		/*
- 		 * WA for 3.00a- HW is not setting cur_mode, even sometimes
- 		 * this does not help
-@@ -197,9 +197,9 @@ static void dwc2_handle_otg_intr(struct
- 				 * interrupt does not get handled and Linux
- 				 * complains loudly.
- 				 */
--				gintmsk = readl(hsotg->regs + GINTMSK);
-+				gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 				gintmsk &= ~GINTSTS_SOF;
--				writel(gintmsk, hsotg->regs + GINTMSK);
-+				dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
- 
- 				/*
- 				 * Call callback function with spin lock
-@@ -213,9 +213,9 @@ static void dwc2_handle_otg_intr(struct
- 				hsotg->op_state = OTG_STATE_B_HOST;
- 			}
- 		} else {
--			gotgctl = readl(hsotg->regs + GOTGCTL);
-+			gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
- 			gotgctl &= ~(GOTGCTL_HNPREQ | GOTGCTL_DEVHNPEN);
--			writel(gotgctl, hsotg->regs + GOTGCTL);
-+			dwc2_writel(gotgctl, hsotg->regs + GOTGCTL);
- 			dev_dbg(hsotg->dev, "HNP Failed\n");
- 			dev_err(hsotg->dev,
- 				"Device Not Connected/Responding\n");
-@@ -241,9 +241,9 @@ static void dwc2_handle_otg_intr(struct
- 			hsotg->op_state = OTG_STATE_A_PERIPHERAL;
- 		} else {
- 			/* Need to disable SOF interrupt immediately */
--			gintmsk = readl(hsotg->regs + GINTMSK);
-+			gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 			gintmsk &= ~GINTSTS_SOF;
--			writel(gintmsk, hsotg->regs + GINTMSK);
-+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
- 			spin_unlock(&hsotg->lock);
- 			dwc2_hcd_start(hsotg);
- 			spin_lock(&hsotg->lock);
-@@ -258,7 +258,7 @@ static void dwc2_handle_otg_intr(struct
- 		dev_dbg(hsotg->dev, " ++OTG Interrupt: Debounce Done++\n");
- 
- 	/* Clear GOTGINT */
--	writel(gotgint, hsotg->regs + GOTGINT);
-+	dwc2_writel(gotgint, hsotg->regs + GOTGINT);
- }
- 
- /**
-@@ -273,11 +273,11 @@ static void dwc2_handle_otg_intr(struct
-  */
- static void dwc2_handle_conn_id_status_change_intr(struct dwc2_hsotg *hsotg)
- {
--	u32 gintmsk = readl(hsotg->regs + GINTMSK);
-+	u32 gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 
- 	/* Need to disable SOF interrupt immediately */
- 	gintmsk &= ~GINTSTS_SOF;
--	writel(gintmsk, hsotg->regs + GINTMSK);
-+	dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
- 
- 	dev_dbg(hsotg->dev, " ++Connector ID Status Change Interrupt++  (%s)\n",
- 		dwc2_is_host_mode(hsotg) ? "Host" : "Device");
-@@ -292,7 +292,7 @@ static void dwc2_handle_conn_id_status_c
- 	spin_lock(&hsotg->lock);
- 
- 	/* Clear interrupt */
--	writel(GINTSTS_CONIDSTSCHNG, hsotg->regs + GINTSTS);
-+	dwc2_writel(GINTSTS_CONIDSTSCHNG, hsotg->regs + GINTSTS);
- }
- 
- /**
-@@ -311,7 +311,7 @@ static void dwc2_handle_session_req_intr
- 	dev_dbg(hsotg->dev, "++Session Request Interrupt++\n");
- 
- 	/* Clear interrupt */
--	writel(GINTSTS_SESSREQINT, hsotg->regs + GINTSTS);
-+	dwc2_writel(GINTSTS_SESSREQINT, hsotg->regs + GINTSTS);
- }
- 
- /*
-@@ -327,23 +327,23 @@ static void dwc2_handle_wakeup_detected_
- 	dev_dbg(hsotg->dev, "%s lxstate = %d\n", __func__, hsotg->lx_state);
- 
- 	if (dwc2_is_device_mode(hsotg)) {
--		dev_dbg(hsotg->dev, "DSTS=0x%0x\n", readl(hsotg->regs + DSTS));
-+		dev_dbg(hsotg->dev, "DSTS=0x%0x\n", dwc2_readl(hsotg->regs + DSTS));
- 		if (hsotg->lx_state == DWC2_L2) {
--			u32 dctl = readl(hsotg->regs + DCTL);
-+			u32 dctl = dwc2_readl(hsotg->regs + DCTL);
- 
- 			/* Clear Remote Wakeup Signaling */
- 			dctl &= ~DCTL_RMTWKUPSIG;
--			writel(dctl, hsotg->regs + DCTL);
-+			dwc2_writel(dctl, hsotg->regs + DCTL);
- 		}
- 		/* Change to L0 state */
- 		hsotg->lx_state = DWC2_L0;
- 	} else {
- 		if (hsotg->lx_state != DWC2_L1) {
--			u32 pcgcctl = readl(hsotg->regs + PCGCTL);
-+			u32 pcgcctl = dwc2_readl(hsotg->regs + PCGCTL);
- 
- 			/* Restart the Phy Clock */
- 			pcgcctl &= ~PCGCTL_STOPPCLK;
--			writel(pcgcctl, hsotg->regs + PCGCTL);
-+			dwc2_writel(pcgcctl, hsotg->regs + PCGCTL);
- 			mod_timer(&hsotg->wkp_timer,
- 				  jiffies + msecs_to_jiffies(71));
- 		} else {
-@@ -353,7 +353,7 @@ static void dwc2_handle_wakeup_detected_
- 	}
- 
- 	/* Clear interrupt */
--	writel(GINTSTS_WKUPINT, hsotg->regs + GINTSTS);
-+	dwc2_writel(GINTSTS_WKUPINT, hsotg->regs + GINTSTS);
- }
- 
- /*
-@@ -369,7 +369,7 @@ static void dwc2_handle_disconnect_intr(
- 	/* Change to L3 (OFF) state */
- 	hsotg->lx_state = DWC2_L3;
- 
--	writel(GINTSTS_DISCONNINT, hsotg->regs + GINTSTS);
-+	dwc2_writel(GINTSTS_DISCONNINT, hsotg->regs + GINTSTS);
- }
- 
- /*
-@@ -391,7 +391,7 @@ static void dwc2_handle_usb_suspend_intr
- 		 * Check the Device status register to determine if the Suspend
- 		 * state is active
- 		 */
--		dsts = readl(hsotg->regs + DSTS);
-+		dsts = dwc2_readl(hsotg->regs + DSTS);
- 		dev_dbg(hsotg->dev, "DSTS=0x%0x\n", dsts);
- 		dev_dbg(hsotg->dev,
- 			"DSTS.Suspend Status=%d HWCFG4.Power Optimize=%d\n",
-@@ -413,7 +413,7 @@ static void dwc2_handle_usb_suspend_intr
- 	hsotg->lx_state = DWC2_L2;
- 
- 	/* Clear interrupt */
--	writel(GINTSTS_USBSUSP, hsotg->regs + GINTSTS);
-+	dwc2_writel(GINTSTS_USBSUSP, hsotg->regs + GINTSTS);
- }
- 
- #define GINTMSK_COMMON	(GINTSTS_WKUPINT | GINTSTS_SESSREQINT |		\
-@@ -431,9 +431,9 @@ static u32 dwc2_read_common_intr(struct
- 	u32 gahbcfg;
- 	u32 gintmsk_common = GINTMSK_COMMON;
- 
--	gintsts = readl(hsotg->regs + GINTSTS);
--	gintmsk = readl(hsotg->regs + GINTMSK);
--	gahbcfg = readl(hsotg->regs + GAHBCFG);
-+	gintsts = dwc2_readl(hsotg->regs + GINTSTS);
-+	gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
-+	gahbcfg = dwc2_readl(hsotg->regs + GAHBCFG);
- 
- 	/* If any common interrupts set */
- 	if (gintsts & gintmsk_common)
---- a/drivers/usb/dwc2/gadget.c
-+++ b/drivers/usb/dwc2/gadget.c
-@@ -55,12 +55,12 @@ static inline struct s3c_hsotg *to_hsotg
- 
- static inline void __orr32(void __iomem *ptr, u32 val)
- {
--	writel(readl(ptr) | val, ptr);
-+	dwc2_writel(dwc2_readl(ptr) | val, ptr);
- }
- 
- static inline void __bic32(void __iomem *ptr, u32 val)
- {
--	writel(readl(ptr) & ~val, ptr);
-+	dwc2_writel(dwc2_readl(ptr) & ~val, ptr);
- }
- 
- /* forward decleration of functions */
-@@ -97,14 +97,14 @@ static inline bool using_dma(struct s3c_
-  */
- static void s3c_hsotg_en_gsint(struct s3c_hsotg *hsotg, u32 ints)
- {
--	u32 gsintmsk = readl(hsotg->regs + GINTMSK);
-+	u32 gsintmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 	u32 new_gsintmsk;
- 
- 	new_gsintmsk = gsintmsk | ints;
- 
- 	if (new_gsintmsk != gsintmsk) {
- 		dev_dbg(hsotg->dev, "gsintmsk now 0x%08x\n", new_gsintmsk);
--		writel(new_gsintmsk, hsotg->regs + GINTMSK);
-+		dwc2_writel(new_gsintmsk, hsotg->regs + GINTMSK);
- 	}
- }
- 
-@@ -115,13 +115,13 @@ static void s3c_hsotg_en_gsint(struct s3
-  */
- static void s3c_hsotg_disable_gsint(struct s3c_hsotg *hsotg, u32 ints)
- {
--	u32 gsintmsk = readl(hsotg->regs + GINTMSK);
-+	u32 gsintmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 	u32 new_gsintmsk;
- 
- 	new_gsintmsk = gsintmsk & ~ints;
- 
- 	if (new_gsintmsk != gsintmsk)
--		writel(new_gsintmsk, hsotg->regs + GINTMSK);
-+		dwc2_writel(new_gsintmsk, hsotg->regs + GINTMSK);
- }
- 
- /**
-@@ -146,12 +146,12 @@ static void s3c_hsotg_ctrl_epint(struct
- 		bit <<= 16;
- 
- 	local_irq_save(flags);
--	daint = readl(hsotg->regs + DAINTMSK);
-+	daint = dwc2_readl(hsotg->regs + DAINTMSK);
- 	if (en)
- 		daint |= bit;
- 	else
- 		daint &= ~bit;
--	writel(daint, hsotg->regs + DAINTMSK);
-+	dwc2_writel(daint, hsotg->regs + DAINTMSK);
- 	local_irq_restore(flags);
- }
- 
-@@ -169,8 +169,8 @@ static void s3c_hsotg_init_fifo(struct s
- 
- 	/* set FIFO sizes to 2048/1024 */
- 
--	writel(2048, hsotg->regs + GRXFSIZ);
--	writel((2048 << FIFOSIZE_STARTADDR_SHIFT) |
-+	dwc2_writel(2048, hsotg->regs + GRXFSIZ);
-+	dwc2_writel((2048 << FIFOSIZE_STARTADDR_SHIFT) |
- 		(1024 << FIFOSIZE_DEPTH_SHIFT), hsotg->regs + GNPTXFSIZ);
- 
- 	/*
-@@ -200,7 +200,7 @@ static void s3c_hsotg_init_fifo(struct s
- 			  "insufficient fifo memory");
- 		addr += size;
- 
--		writel(val, hsotg->regs + DPTXFSIZN(ep));
-+		dwc2_writel(val, hsotg->regs + DPTXFSIZN(ep));
- 	}
- 	/* 768*4=3072 bytes FIFO length */
- 	size = 768;
-@@ -211,7 +211,7 @@ static void s3c_hsotg_init_fifo(struct s
- 			  "insufficient fifo memory");
- 		addr += size;
- 
--		writel(val, hsotg->regs + DPTXFSIZN(ep));
-+		dwc2_writel(val, hsotg->regs + DPTXFSIZN(ep));
- 	}
- 
- 	/*
-@@ -219,13 +219,13 @@ static void s3c_hsotg_init_fifo(struct s
- 	 * all fifos are flushed before continuing
- 	 */
- 
--	writel(GRSTCTL_TXFNUM(0x10) | GRSTCTL_TXFFLSH |
-+	dwc2_writel(GRSTCTL_TXFNUM(0x10) | GRSTCTL_TXFFLSH |
- 	       GRSTCTL_RXFFLSH, hsotg->regs + GRSTCTL);
- 
- 	/* wait until the fifos are both flushed */
- 	timeout = 100;
- 	while (1) {
--		val = readl(hsotg->regs + GRSTCTL);
-+		val = dwc2_readl(hsotg->regs + GRSTCTL);
- 
- 		if ((val & (GRSTCTL_TXFFLSH | GRSTCTL_RXFFLSH)) == 0)
- 			break;
-@@ -317,7 +317,7 @@ static int s3c_hsotg_write_fifo(struct s
- 				struct s3c_hsotg_req *hs_req)
- {
- 	bool periodic = is_ep_periodic(hs_ep);
--	u32 gnptxsts = readl(hsotg->regs + GNPTXSTS);
-+	u32 gnptxsts = dwc2_readl(hsotg->regs + GNPTXSTS);
- 	int buf_pos = hs_req->req.actual;
- 	int to_write = hs_ep->size_loaded;
- 	void *data;
-@@ -332,7 +332,7 @@ static int s3c_hsotg_write_fifo(struct s
- 		return 0;
- 
- 	if (periodic && !hsotg->dedicated_fifos) {
--		u32 epsize = readl(hsotg->regs + DIEPTSIZ(hs_ep->index));
-+		u32 epsize = dwc2_readl(hsotg->regs + DIEPTSIZ(hs_ep->index));
- 		int size_left;
- 		int size_done;
- 
-@@ -373,7 +373,7 @@ static int s3c_hsotg_write_fifo(struct s
- 			return -ENOSPC;
- 		}
- 	} else if (hsotg->dedicated_fifos && hs_ep->index != 0) {
--		can_write = readl(hsotg->regs + DTXFSTS(hs_ep->index));
-+		can_write = dwc2_readl(hsotg->regs + DTXFSTS(hs_ep->index));
- 
- 		can_write &= 0xffff;
- 		can_write *= 4;
-@@ -550,11 +550,11 @@ static void s3c_hsotg_start_req(struct s
- 	epsize_reg = dir_in ? DIEPTSIZ(index) : DOEPTSIZ(index);
- 
- 	dev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x, ep %d, dir %s\n",
--		__func__, readl(hsotg->regs + epctrl_reg), index,
-+		__func__, dwc2_readl(hsotg->regs + epctrl_reg), index,
- 		hs_ep->dir_in ? "in" : "out");
- 
- 	/* If endpoint is stalled, we will restart request later */
--	ctrl = readl(hsotg->regs + epctrl_reg);
-+	ctrl = dwc2_readl(hsotg->regs + epctrl_reg);
- 
- 	if (ctrl & DXEPCTL_STALL) {
- 		dev_warn(hsotg->dev, "%s: ep%d is stalled\n", __func__, index);
-@@ -622,7 +622,7 @@ static void s3c_hsotg_start_req(struct s
- 	hs_ep->req = hs_req;
- 
- 	/* write size / packets */
--	writel(epsize, hsotg->regs + epsize_reg);
-+	dwc2_writel(epsize, hsotg->regs + epsize_reg);
- 
- 	if (using_dma(hsotg) && !continuing) {
- 		unsigned int dma_reg;
-@@ -633,7 +633,7 @@ static void s3c_hsotg_start_req(struct s
- 		 */
- 
- 		dma_reg = dir_in ? DIEPDMA(index) : DOEPDMA(index);
--		writel(ureq->dma, hsotg->regs + dma_reg);
-+		dwc2_writel(ureq->dma, hsotg->regs + dma_reg);
- 
- 		dev_dbg(hsotg->dev, "%s: %pad => 0x%08x\n",
- 			__func__, &ureq->dma, dma_reg);
-@@ -652,7 +652,7 @@ static void s3c_hsotg_start_req(struct s
- 
- 
- 	dev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n", __func__, ctrl);
--	writel(ctrl, hsotg->regs + epctrl_reg);
-+	dwc2_writel(ctrl, hsotg->regs + epctrl_reg);
- 
- 	/*
- 	 * set these, it seems that DMA support increments past the end
-@@ -674,7 +674,7 @@ static void s3c_hsotg_start_req(struct s
- 	 * to debugging to see what is going on.
- 	 */
- 	if (dir_in)
--		writel(DIEPMSK_INTKNTXFEMPMSK,
-+		dwc2_writel(DIEPMSK_INTKNTXFEMPMSK,
- 		       hsotg->regs + DIEPINT(index));
- 
- 	/*
-@@ -683,13 +683,13 @@ static void s3c_hsotg_start_req(struct s
- 	 */
- 
- 	/* check ep is enabled */
--	if (!(readl(hsotg->regs + epctrl_reg) & DXEPCTL_EPENA))
-+	if (!(dwc2_readl(hsotg->regs + epctrl_reg) & DXEPCTL_EPENA))
- 		dev_warn(hsotg->dev,
- 			 "ep%d: failed to become enabled (DXEPCTL=0x%08x)?\n",
--			 index, readl(hsotg->regs + epctrl_reg));
-+			 index, dwc2_readl(hsotg->regs + epctrl_reg));
- 
- 	dev_dbg(hsotg->dev, "%s: DXEPCTL=0x%08x\n",
--		__func__, readl(hsotg->regs + epctrl_reg));
-+		__func__, dwc2_readl(hsotg->regs + epctrl_reg));
- 
- 	/* enable ep interrupts */
- 	s3c_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 1);
-@@ -1051,14 +1051,14 @@ static void s3c_hsotg_stall_ep0(struct s
- 	 * taken effect, so no need to clear later.
- 	 */
- 
--	ctrl = readl(hsotg->regs + reg);
-+	ctrl = dwc2_readl(hsotg->regs + reg);
- 	ctrl |= DXEPCTL_STALL;
- 	ctrl |= DXEPCTL_CNAK;
--	writel(ctrl, hsotg->regs + reg);
-+	dwc2_writel(ctrl, hsotg->regs + reg);
- 
- 	dev_dbg(hsotg->dev,
- 		"written DXEPCTL=0x%08x to %08x (DXEPCTL=0x%08x)\n",
--		ctrl, reg, readl(hsotg->regs + reg));
-+		ctrl, reg, dwc2_readl(hsotg->regs + reg));
- 
- 	 /*
- 	  * complete won't be called, so we enqueue
-@@ -1108,11 +1108,11 @@ static void s3c_hsotg_process_control(st
- 		switch (ctrl->bRequest) {
- 		case USB_REQ_SET_ADDRESS:
- 			s3c_hsotg_disconnect(hsotg);
--			dcfg = readl(hsotg->regs + DCFG);
-+			dcfg = dwc2_readl(hsotg->regs + DCFG);
- 			dcfg &= ~DCFG_DEVADDR_MASK;
- 			dcfg |= (le16_to_cpu(ctrl->wValue) <<
- 				 DCFG_DEVADDR_SHIFT) & DCFG_DEVADDR_MASK;
--			writel(dcfg, hsotg->regs + DCFG);
-+			dwc2_writel(dcfg, hsotg->regs + DCFG);
- 
- 			dev_info(hsotg->dev, "new address %d\n", ctrl->wValue);
- 
-@@ -1302,7 +1302,7 @@ static void s3c_hsotg_rx_data(struct s3c
- 
- 
- 	if (!hs_req) {
--		u32 epctl = readl(hsotg->regs + DOEPCTL(ep_idx));
-+		u32 epctl = dwc2_readl(hsotg->regs + DOEPCTL(ep_idx));
- 		int ptr;
- 
- 		dev_warn(hsotg->dev,
-@@ -1311,7 +1311,7 @@ static void s3c_hsotg_rx_data(struct s3c
- 
- 		/* dump the data from the FIFO, we've nothing we can do */
- 		for (ptr = 0; ptr < size; ptr += 4)
--			(void)readl(fifo);
-+			(void)dwc2_readl(fifo);
- 
- 		return;
- 	}
-@@ -1378,14 +1378,14 @@ static void s3c_hsotg_send_zlp(struct s3
- 	dev_dbg(hsotg->dev, "sending zero-length packet\n");
- 
- 	/* issue a zero-sized packet to terminate this */
--	writel(DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |
-+	dwc2_writel(DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |
- 	       DXEPTSIZ_XFERSIZE(0), hsotg->regs + DIEPTSIZ(0));
- 
--	ctrl = readl(hsotg->regs + DIEPCTL0);
-+	ctrl = dwc2_readl(hsotg->regs + DIEPCTL0);
- 	ctrl |= DXEPCTL_CNAK;  /* clear NAK set by core */
- 	ctrl |= DXEPCTL_EPENA; /* ensure ep enabled */
- 	ctrl |= DXEPCTL_USBACTEP;
--	writel(ctrl, hsotg->regs + DIEPCTL0);
-+	dwc2_writel(ctrl, hsotg->regs + DIEPCTL0);
- }
- 
- /**
-@@ -1401,7 +1401,7 @@ static void s3c_hsotg_send_zlp(struct s3
- static void s3c_hsotg_handle_outdone(struct s3c_hsotg *hsotg,
- 				     int epnum, bool was_setup)
- {
--	u32 epsize = readl(hsotg->regs + DOEPTSIZ(epnum));
-+	u32 epsize = dwc2_readl(hsotg->regs + DOEPTSIZ(epnum));
- 	struct s3c_hsotg_ep *hs_ep = &hsotg->eps[epnum];
- 	struct s3c_hsotg_req *hs_req = hs_ep->req;
- 	struct usb_request *req = &hs_req->req;
-@@ -1475,7 +1475,7 @@ static u32 s3c_hsotg_read_frameno(struct
- {
- 	u32 dsts;
- 
--	dsts = readl(hsotg->regs + DSTS);
-+	dsts = dwc2_readl(hsotg->regs + DSTS);
- 	dsts &= DSTS_SOFFN_MASK;
- 	dsts >>= DSTS_SOFFN_SHIFT;
- 
-@@ -1500,7 +1500,7 @@ static u32 s3c_hsotg_read_frameno(struct
-  */
- static void s3c_hsotg_handle_rx(struct s3c_hsotg *hsotg)
- {
--	u32 grxstsr = readl(hsotg->regs + GRXSTSP);
-+	u32 grxstsr = dwc2_readl(hsotg->regs + GRXSTSP);
- 	u32 epnum, status, size;
- 
- 	WARN_ON(using_dma(hsotg));
-@@ -1532,7 +1532,7 @@ static void s3c_hsotg_handle_rx(struct s
- 		dev_dbg(hsotg->dev,
- 			"SetupDone (Frame=0x%08x, DOPEPCTL=0x%08x)\n",
- 			s3c_hsotg_read_frameno(hsotg),
--			readl(hsotg->regs + DOEPCTL(0)));
-+			dwc2_readl(hsotg->regs + DOEPCTL(0)));
- 
- 		s3c_hsotg_handle_outdone(hsotg, epnum, true);
- 		break;
-@@ -1545,7 +1545,7 @@ static void s3c_hsotg_handle_rx(struct s
- 		dev_dbg(hsotg->dev,
- 			"SetupRX (Frame=0x%08x, DOPEPCTL=0x%08x)\n",
- 			s3c_hsotg_read_frameno(hsotg),
--			readl(hsotg->regs + DOEPCTL(0)));
-+			dwc2_readl(hsotg->regs + DOEPCTL(0)));
- 
- 		s3c_hsotg_rx_data(hsotg, epnum, size);
- 		break;
-@@ -1622,16 +1622,16 @@ static void s3c_hsotg_set_ep_maxpacket(s
- 	 * if one of the directions may not be in use.
- 	 */
- 
--	reg = readl(regs + DIEPCTL(ep));
-+	reg = dwc2_readl(regs + DIEPCTL(ep));
- 	reg &= ~DXEPCTL_MPS_MASK;
- 	reg |= mpsval;
--	writel(reg, regs + DIEPCTL(ep));
-+	dwc2_writel(reg, regs + DIEPCTL(ep));
- 
- 	if (ep) {
--		reg = readl(regs + DOEPCTL(ep));
-+		reg = dwc2_readl(regs + DOEPCTL(ep));
- 		reg &= ~DXEPCTL_MPS_MASK;
- 		reg |= mpsval;
--		writel(reg, regs + DOEPCTL(ep));
-+		dwc2_writel(reg, regs + DOEPCTL(ep));
- 	}
- 
- 	return;
-@@ -1650,14 +1650,14 @@ static void s3c_hsotg_txfifo_flush(struc
- 	int timeout;
- 	int val;
- 
--	writel(GRSTCTL_TXFNUM(idx) | GRSTCTL_TXFFLSH,
-+	dwc2_writel(GRSTCTL_TXFNUM(idx) | GRSTCTL_TXFFLSH,
- 		hsotg->regs + GRSTCTL);
- 
- 	/* wait until the fifo is flushed */
- 	timeout = 100;
- 
- 	while (1) {
--		val = readl(hsotg->regs + GRSTCTL);
-+		val = dwc2_readl(hsotg->regs + GRSTCTL);
- 
- 		if ((val & (GRSTCTL_TXFFLSH)) == 0)
- 			break;
-@@ -1718,7 +1718,7 @@ static void s3c_hsotg_complete_in(struct
- 				  struct s3c_hsotg_ep *hs_ep)
- {
- 	struct s3c_hsotg_req *hs_req = hs_ep->req;
--	u32 epsize = readl(hsotg->regs + DIEPTSIZ(hs_ep->index));
-+	u32 epsize = dwc2_readl(hsotg->regs + DIEPTSIZ(hs_ep->index));
- 	int size_left, size_done;
- 
- 	if (!hs_req) {
-@@ -1801,11 +1801,11 @@ static void s3c_hsotg_epint(struct s3c_h
- 	u32 ints;
- 	u32 ctrl;
- 
--	ints = readl(hsotg->regs + epint_reg);
--	ctrl = readl(hsotg->regs + epctl_reg);
-+	ints = dwc2_readl(hsotg->regs + epint_reg);
-+	ctrl = dwc2_readl(hsotg->regs + epctl_reg);
- 
- 	/* Clear endpoint interrupts */
--	writel(ints, hsotg->regs + epint_reg);
-+	dwc2_writel(ints, hsotg->regs + epint_reg);
- 
- 	dev_dbg(hsotg->dev, "%s: ep%d(%s) DxEPINT=0x%08x\n",
- 		__func__, idx, dir_in ? "in" : "out", ints);
-@@ -1816,13 +1816,13 @@ static void s3c_hsotg_epint(struct s3c_h
- 				ctrl |= DXEPCTL_SETEVENFR;
- 			else
- 				ctrl |= DXEPCTL_SETODDFR;
--			writel(ctrl, hsotg->regs + epctl_reg);
-+			dwc2_writel(ctrl, hsotg->regs + epctl_reg);
- 		}
- 
- 		dev_dbg(hsotg->dev,
- 			"%s: XferCompl: DxEPCTL=0x%08x, DXEPTSIZ=%08x\n",
--			__func__, readl(hsotg->regs + epctl_reg),
--			readl(hsotg->regs + epsiz_reg));
-+			__func__, dwc2_readl(hsotg->regs + epctl_reg),
-+			dwc2_readl(hsotg->regs + epsiz_reg));
- 
- 		/*
- 		 * we get OutDone from the FIFO, so we only need to look
-@@ -1847,16 +1847,16 @@ static void s3c_hsotg_epint(struct s3c_h
- 		dev_dbg(hsotg->dev, "%s: EPDisbld\n", __func__);
- 
- 		if (dir_in) {
--			int epctl = readl(hsotg->regs + epctl_reg);
-+			int epctl = dwc2_readl(hsotg->regs + epctl_reg);
- 
- 			s3c_hsotg_txfifo_flush(hsotg, hs_ep->fifo_index);
- 
- 			if ((epctl & DXEPCTL_STALL) &&
- 				(epctl & DXEPCTL_EPTYPE_BULK)) {
--				int dctl = readl(hsotg->regs + DCTL);
-+				int dctl = dwc2_readl(hsotg->regs + DCTL);
- 
- 				dctl |= DCTL_CGNPINNAK;
--				writel(dctl, hsotg->regs + DCTL);
-+				dwc2_writel(dctl, hsotg->regs + DCTL);
- 			}
- 		}
- 	}
-@@ -1918,7 +1918,7 @@ static void s3c_hsotg_epint(struct s3c_h
-  */
- static void s3c_hsotg_irq_enumdone(struct s3c_hsotg *hsotg)
- {
--	u32 dsts = readl(hsotg->regs + DSTS);
-+	u32 dsts = dwc2_readl(hsotg->regs + DSTS);
- 	int ep0_mps = 0, ep_mps = 8;
- 
- 	/*
-@@ -1979,8 +1979,8 @@ static void s3c_hsotg_irq_enumdone(struc
- 	s3c_hsotg_enqueue_setup(hsotg);
- 
- 	dev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
--		readl(hsotg->regs + DIEPCTL0),
--		readl(hsotg->regs + DOEPCTL0));
-+		dwc2_readl(hsotg->regs + DIEPCTL0),
-+		dwc2_readl(hsotg->regs + DOEPCTL0));
- }
- 
- /**
-@@ -2014,7 +2014,7 @@ static void kill_all_requests(struct s3c
- 	}
- 	if (!hsotg->dedicated_fifos)
- 		return;
--	size = (readl(hsotg->regs + DTXFSTS(ep->index)) & 0xffff) * 4;
-+	size = (dwc2_readl(hsotg->regs + DTXFSTS(ep->index)) & 0xffff) * 4;
- 	if (size < ep->fifo_size)
- 		s3c_hsotg_txfifo_flush(hsotg, ep->fifo_index);
- }
-@@ -2084,11 +2084,11 @@ static int s3c_hsotg_corereset(struct s3
- 	dev_dbg(hsotg->dev, "resetting core\n");
- 
- 	/* issue soft reset */
--	writel(GRSTCTL_CSFTRST, hsotg->regs + GRSTCTL);
-+	dwc2_writel(GRSTCTL_CSFTRST, hsotg->regs + GRSTCTL);
- 
- 	timeout = 10000;
- 	do {
--		grstctl = readl(hsotg->regs + GRSTCTL);
-+		grstctl = dwc2_readl(hsotg->regs + GRSTCTL);
- 	} while ((grstctl & GRSTCTL_CSFTRST) && timeout-- > 0);
- 
- 	if (grstctl & GRSTCTL_CSFTRST) {
-@@ -2099,7 +2099,7 @@ static int s3c_hsotg_corereset(struct s3
- 	timeout = 10000;
- 
- 	while (1) {
--		u32 grstctl = readl(hsotg->regs + GRSTCTL);
-+		u32 grstctl = dwc2_readl(hsotg->regs + GRSTCTL);
- 
- 		if (timeout-- < 0) {
- 			dev_info(hsotg->dev,
-@@ -2134,22 +2134,22 @@ static void s3c_hsotg_core_init(struct s
- 	 */
- 
- 	/* set the PLL on, remove the HNP/SRP and set the PHY */
--	writel(hsotg->phyif | GUSBCFG_TOUTCAL(7) |
-+	dwc2_writel(hsotg->phyif | GUSBCFG_TOUTCAL(7) |
- 	       (0x5 << 10), hsotg->regs + GUSBCFG);
- 
- 	s3c_hsotg_init_fifo(hsotg);
- 
- 	__orr32(hsotg->regs + DCTL, DCTL_SFTDISCON);
- 
--	writel(1 << 18 | DCFG_DEVSPD_HS,  hsotg->regs + DCFG);
-+	dwc2_writel(1 << 18 | DCFG_DEVSPD_HS,  hsotg->regs + DCFG);
- 
- 	/* Clear any pending OTG interrupts */
--	writel(0xffffffff, hsotg->regs + GOTGINT);
-+	dwc2_writel(0xffffffff, hsotg->regs + GOTGINT);
- 
- 	/* Clear any pending interrupts */
--	writel(0xffffffff, hsotg->regs + GINTSTS);
-+	dwc2_writel(0xffffffff, hsotg->regs + GINTSTS);
- 
--	writel(GINTSTS_ERLYSUSP | GINTSTS_SESSREQINT |
-+	dwc2_writel(GINTSTS_ERLYSUSP | GINTSTS_SESSREQINT |
- 		GINTSTS_GOUTNAKEFF | GINTSTS_GINNAKEFF |
- 		GINTSTS_CONIDSTSCHNG | GINTSTS_USBRST |
- 		GINTSTS_ENUMDONE | GINTSTS_OTGINT |
-@@ -2157,11 +2157,11 @@ static void s3c_hsotg_core_init(struct s
- 		hsotg->regs + GINTMSK);
- 
- 	if (using_dma(hsotg))
--		writel(GAHBCFG_GLBL_INTR_EN | GAHBCFG_DMA_EN |
-+		dwc2_writel(GAHBCFG_GLBL_INTR_EN | GAHBCFG_DMA_EN |
- 		       GAHBCFG_HBSTLEN_INCR4,
- 		       hsotg->regs + GAHBCFG);
- 	else
--		writel(((hsotg->dedicated_fifos) ? (GAHBCFG_NP_TXF_EMP_LVL |
-+		dwc2_writel(((hsotg->dedicated_fifos) ? (GAHBCFG_NP_TXF_EMP_LVL |
- 						    GAHBCFG_P_TXF_EMP_LVL) : 0) |
- 		       GAHBCFG_GLBL_INTR_EN,
- 		       hsotg->regs + GAHBCFG);
-@@ -2172,7 +2172,7 @@ static void s3c_hsotg_core_init(struct s
- 	 * interrupts.
- 	 */
- 
--	writel(((hsotg->dedicated_fifos) ? DIEPMSK_TXFIFOEMPTY |
-+	dwc2_writel(((hsotg->dedicated_fifos) ? DIEPMSK_TXFIFOEMPTY |
- 		DIEPMSK_INTKNTXFEMPMSK : 0) |
- 		DIEPMSK_EPDISBLDMSK | DIEPMSK_XFERCOMPLMSK |
- 		DIEPMSK_TIMEOUTMSK | DIEPMSK_AHBERRMSK |
-@@ -2183,17 +2183,17 @@ static void s3c_hsotg_core_init(struct s
- 	 * don't need XferCompl, we get that from RXFIFO in slave mode. In
- 	 * DMA mode we may need this.
- 	 */
--	writel((using_dma(hsotg) ? (DIEPMSK_XFERCOMPLMSK |
-+	dwc2_writel((using_dma(hsotg) ? (DIEPMSK_XFERCOMPLMSK |
- 				    DIEPMSK_TIMEOUTMSK) : 0) |
- 		DOEPMSK_EPDISBLDMSK | DOEPMSK_AHBERRMSK |
- 		DOEPMSK_SETUPMSK,
- 		hsotg->regs + DOEPMSK);
- 
--	writel(0, hsotg->regs + DAINTMSK);
-+	dwc2_writel(0, hsotg->regs + DAINTMSK);
- 
- 	dev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
--		readl(hsotg->regs + DIEPCTL0),
--		readl(hsotg->regs + DOEPCTL0));
-+		dwc2_readl(hsotg->regs + DIEPCTL0),
-+		dwc2_readl(hsotg->regs + DOEPCTL0));
- 
- 	/* enable in and out endpoint interrupts */
- 	s3c_hsotg_en_gsint(hsotg, GINTSTS_OEPINT | GINTSTS_IEPINT);
-@@ -2214,7 +2214,7 @@ static void s3c_hsotg_core_init(struct s
- 	udelay(10);  /* see openiboot */
- 	__bic32(hsotg->regs + DCTL, DCTL_PWRONPRGDONE);
- 
--	dev_dbg(hsotg->dev, "DCTL=0x%08x\n", readl(hsotg->regs + DCTL));
-+	dev_dbg(hsotg->dev, "DCTL=0x%08x\n", dwc2_readl(hsotg->regs + DCTL));
- 
- 	/*
- 	 * DxEPCTL_USBActEp says RO in manual, but seems to be set by
-@@ -2222,26 +2222,26 @@ static void s3c_hsotg_core_init(struct s
- 	 */
- 
- 	/* set to read 1 8byte packet */
--	writel(DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |
-+	dwc2_writel(DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |
- 	       DXEPTSIZ_XFERSIZE(8), hsotg->regs + DOEPTSIZ0);
- 
--	writel(s3c_hsotg_ep0_mps(hsotg->eps[0].ep.maxpacket) |
-+	dwc2_writel(s3c_hsotg_ep0_mps(hsotg->eps[0].ep.maxpacket) |
- 	       DXEPCTL_CNAK | DXEPCTL_EPENA |
- 	       DXEPCTL_USBACTEP,
- 	       hsotg->regs + DOEPCTL0);
- 
- 	/* enable, but don't activate EP0in */
--	writel(s3c_hsotg_ep0_mps(hsotg->eps[0].ep.maxpacket) |
-+	dwc2_writel(s3c_hsotg_ep0_mps(hsotg->eps[0].ep.maxpacket) |
- 	       DXEPCTL_USBACTEP, hsotg->regs + DIEPCTL0);
- 
- 	s3c_hsotg_enqueue_setup(hsotg);
- 
- 	dev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
--		readl(hsotg->regs + DIEPCTL0),
--		readl(hsotg->regs + DOEPCTL0));
-+		dwc2_readl(hsotg->regs + DIEPCTL0),
-+		dwc2_readl(hsotg->regs + DOEPCTL0));
- 
- 	/* clear global NAKs */
--	writel(DCTL_CGOUTNAK | DCTL_CGNPINNAK,
-+	dwc2_writel(DCTL_CGOUTNAK | DCTL_CGNPINNAK,
- 	       hsotg->regs + DCTL);
- 
- 	/* must be at-least 3ms to allow bus to see disconnect */
-@@ -2265,8 +2265,8 @@ static irqreturn_t s3c_hsotg_irq(int irq
- 
- 	spin_lock(&hsotg->lock);
- irq_retry:
--	gintsts = readl(hsotg->regs + GINTSTS);
--	gintmsk = readl(hsotg->regs + GINTMSK);
-+	gintsts = dwc2_readl(hsotg->regs + GINTSTS);
-+	gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 
- 	dev_dbg(hsotg->dev, "%s: %08x %08x (%08x) retry %d\n",
- 		__func__, gintsts, gintsts & gintmsk, gintmsk, retry_count);
-@@ -2274,35 +2274,35 @@ irq_retry:
- 	gintsts &= gintmsk;
- 
- 	if (gintsts & GINTSTS_OTGINT) {
--		u32 otgint = readl(hsotg->regs + GOTGINT);
-+		u32 otgint = dwc2_readl(hsotg->regs + GOTGINT);
- 
- 		dev_info(hsotg->dev, "OTGInt: %08x\n", otgint);
- 
--		writel(otgint, hsotg->regs + GOTGINT);
-+		dwc2_writel(otgint, hsotg->regs + GOTGINT);
- 	}
- 
- 	if (gintsts & GINTSTS_SESSREQINT) {
- 		dev_dbg(hsotg->dev, "%s: SessReqInt\n", __func__);
--		writel(GINTSTS_SESSREQINT, hsotg->regs + GINTSTS);
-+		dwc2_writel(GINTSTS_SESSREQINT, hsotg->regs + GINTSTS);
- 	}
- 
- 	if (gintsts & GINTSTS_ENUMDONE) {
--		writel(GINTSTS_ENUMDONE, hsotg->regs + GINTSTS);
-+		dwc2_writel(GINTSTS_ENUMDONE, hsotg->regs + GINTSTS);
- 
- 		s3c_hsotg_irq_enumdone(hsotg);
- 	}
- 
- 	if (gintsts & GINTSTS_CONIDSTSCHNG) {
- 		dev_dbg(hsotg->dev, "ConIDStsChg (DSTS=0x%08x, GOTCTL=%08x)\n",
--			readl(hsotg->regs + DSTS),
--			readl(hsotg->regs + GOTGCTL));
-+			dwc2_readl(hsotg->regs + DSTS),
-+			dwc2_readl(hsotg->regs + GOTGCTL));
- 
--		writel(GINTSTS_CONIDSTSCHNG, hsotg->regs + GINTSTS);
-+		dwc2_writel(GINTSTS_CONIDSTSCHNG, hsotg->regs + GINTSTS);
- 	}
- 
- 	if (gintsts & (GINTSTS_OEPINT | GINTSTS_IEPINT)) {
--		u32 daint = readl(hsotg->regs + DAINT);
--		u32 daintmsk = readl(hsotg->regs + DAINTMSK);
-+		u32 daint = dwc2_readl(hsotg->regs + DAINT);
-+		u32 daintmsk = dwc2_readl(hsotg->regs + DAINTMSK);
- 		u32 daint_out, daint_in;
- 		int ep;
- 
-@@ -2325,13 +2325,13 @@ irq_retry:
- 
- 	if (gintsts & GINTSTS_USBRST) {
- 
--		u32 usb_status = readl(hsotg->regs + GOTGCTL);
-+		u32 usb_status = dwc2_readl(hsotg->regs + GOTGCTL);
- 
- 		dev_dbg(hsotg->dev, "%s: USBRst\n", __func__);
- 		dev_dbg(hsotg->dev, "GNPTXSTS=%08x\n",
--			readl(hsotg->regs + GNPTXSTS));
-+			dwc2_readl(hsotg->regs + GNPTXSTS));
- 
--		writel(GINTSTS_USBRST, hsotg->regs + GINTSTS);
-+		dwc2_writel(GINTSTS_USBRST, hsotg->regs + GINTSTS);
- 
- 		if (usb_status & GOTGCTL_BSESVLD) {
- 			if (time_after(jiffies, hsotg->last_rst +
-@@ -2382,26 +2382,26 @@ irq_retry:
- 
- 	if (gintsts & GINTSTS_MODEMIS) {
- 		dev_warn(hsotg->dev, "warning, mode mismatch triggered\n");
--		writel(GINTSTS_MODEMIS, hsotg->regs + GINTSTS);
-+		dwc2_writel(GINTSTS_MODEMIS, hsotg->regs + GINTSTS);
- 	}
- 
- 	if (gintsts & GINTSTS_USBSUSP) {
- 		dev_info(hsotg->dev, "GINTSTS_USBSusp\n");
--		writel(GINTSTS_USBSUSP, hsotg->regs + GINTSTS);
-+		dwc2_writel(GINTSTS_USBSUSP, hsotg->regs + GINTSTS);
- 
- 		call_gadget(hsotg, suspend);
- 	}
- 
- 	if (gintsts & GINTSTS_WKUPINT) {
- 		dev_info(hsotg->dev, "GINTSTS_WkUpIn\n");
--		writel(GINTSTS_WKUPINT, hsotg->regs + GINTSTS);
-+		dwc2_writel(GINTSTS_WKUPINT, hsotg->regs + GINTSTS);
- 
- 		call_gadget(hsotg, resume);
- 	}
- 
- 	if (gintsts & GINTSTS_ERLYSUSP) {
- 		dev_dbg(hsotg->dev, "GINTSTS_ErlySusp\n");
--		writel(GINTSTS_ERLYSUSP, hsotg->regs + GINTSTS);
-+		dwc2_writel(GINTSTS_ERLYSUSP, hsotg->regs + GINTSTS);
- 	}
- 
- 	/*
-@@ -2413,7 +2413,7 @@ irq_retry:
- 	if (gintsts & GINTSTS_GOUTNAKEFF) {
- 		dev_info(hsotg->dev, "GOUTNakEff triggered\n");
- 
--		writel(DCTL_CGOUTNAK, hsotg->regs + DCTL);
-+		dwc2_writel(DCTL_CGOUTNAK, hsotg->regs + DCTL);
- 
- 		s3c_hsotg_dump(hsotg);
- 	}
-@@ -2421,7 +2421,7 @@ irq_retry:
- 	if (gintsts & GINTSTS_GINNAKEFF) {
- 		dev_info(hsotg->dev, "GINNakEff triggered\n");
- 
--		writel(DCTL_CGNPINNAK, hsotg->regs + DCTL);
-+		dwc2_writel(DCTL_CGNPINNAK, hsotg->regs + DCTL);
- 
- 		s3c_hsotg_dump(hsotg);
- 	}
-@@ -2479,7 +2479,7 @@ static int s3c_hsotg_ep_enable(struct us
- 	/* note, we handle this here instead of s3c_hsotg_set_ep_maxpacket */
- 
- 	epctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);
--	epctrl = readl(hsotg->regs + epctrl_reg);
-+	epctrl = dwc2_readl(hsotg->regs + epctrl_reg);
- 
- 	dev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x from 0x%08x\n",
- 		__func__, epctrl, epctrl_reg);
-@@ -2550,7 +2550,7 @@ static int s3c_hsotg_ep_enable(struct us
- 		for (i = 1; i <= 8; ++i) {
- 			if (hsotg->fifo_map & (1<<i))
- 				continue;
--			val = readl(hsotg->regs + DPTXFSIZN(i));
-+			val = dwc2_readl(hsotg->regs + DPTXFSIZN(i));
- 			val = (val >> FIFOSIZE_DEPTH_SHIFT)*4;
- 			if (val < size)
- 				continue;
-@@ -2574,9 +2574,9 @@ static int s3c_hsotg_ep_enable(struct us
- 	dev_dbg(hsotg->dev, "%s: write DxEPCTL=0x%08x\n",
- 		__func__, epctrl);
- 
--	writel(epctrl, hsotg->regs + epctrl_reg);
-+	dwc2_writel(epctrl, hsotg->regs + epctrl_reg);
- 	dev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x\n",
--		__func__, readl(hsotg->regs + epctrl_reg));
-+		__func__, dwc2_readl(hsotg->regs + epctrl_reg));
- 
- 	/* enable the endpoint interrupt */
- 	s3c_hsotg_ctrl_epint(hsotg, index, dir_in, 1);
-@@ -2617,13 +2617,13 @@ static int s3c_hsotg_ep_disable(struct u
- 	hs_ep->fifo_index = 0;
- 	hs_ep->fifo_size = 0;
- 
--	ctrl = readl(hsotg->regs + epctrl_reg);
-+	ctrl = dwc2_readl(hsotg->regs + epctrl_reg);
- 	ctrl &= ~DXEPCTL_EPENA;
- 	ctrl &= ~DXEPCTL_USBACTEP;
- 	ctrl |= DXEPCTL_SNAK;
- 
- 	dev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n", __func__, ctrl);
--	writel(ctrl, hsotg->regs + epctrl_reg);
-+	dwc2_writel(ctrl, hsotg->regs + epctrl_reg);
- 
- 	/* disable endpoint interrupts */
- 	s3c_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 0);
-@@ -2704,7 +2704,7 @@ static int s3c_hsotg_ep_sethalt(struct u
- 	/* write both IN and OUT control registers */
- 
- 	epreg = DIEPCTL(index);
--	epctl = readl(hs->regs + epreg);
-+	epctl = dwc2_readl(hs->regs + epreg);
- 
- 	if (value) {
- 		epctl |= DXEPCTL_STALL + DXEPCTL_SNAK;
-@@ -2718,10 +2718,10 @@ static int s3c_hsotg_ep_sethalt(struct u
- 				epctl |= DXEPCTL_SETD0PID;
- 	}
- 
--	writel(epctl, hs->regs + epreg);
-+	dwc2_writel(epctl, hs->regs + epreg);
- 
- 	epreg = DOEPCTL(index);
--	epctl = readl(hs->regs + epreg);
-+	epctl = dwc2_readl(hs->regs + epreg);
- 
- 	if (value)
- 		epctl |= DXEPCTL_STALL;
-@@ -2733,7 +2733,7 @@ static int s3c_hsotg_ep_sethalt(struct u
- 				epctl |= DXEPCTL_SETD0PID;
- 	}
- 
--	writel(epctl, hs->regs + epreg);
-+	dwc2_writel(epctl, hs->regs + epreg);
- 
- 	hs_ep->halted = value;
- 
-@@ -2822,38 +2822,38 @@ static void s3c_hsotg_init(struct s3c_hs
- {
- 	/* unmask subset of endpoint interrupts */
- 
--	writel(DIEPMSK_TIMEOUTMSK | DIEPMSK_AHBERRMSK |
-+	dwc2_writel(DIEPMSK_TIMEOUTMSK | DIEPMSK_AHBERRMSK |
- 		DIEPMSK_EPDISBLDMSK | DIEPMSK_XFERCOMPLMSK,
- 		hsotg->regs + DIEPMSK);
- 
--	writel(DOEPMSK_SETUPMSK | DOEPMSK_AHBERRMSK |
-+	dwc2_writel(DOEPMSK_SETUPMSK | DOEPMSK_AHBERRMSK |
- 		DOEPMSK_EPDISBLDMSK | DOEPMSK_XFERCOMPLMSK,
- 		hsotg->regs + DOEPMSK);
- 
--	writel(0, hsotg->regs + DAINTMSK);
-+	dwc2_writel(0, hsotg->regs + DAINTMSK);
- 
- 	/* Be in disconnected state until gadget is registered */
- 	__orr32(hsotg->regs + DCTL, DCTL_SFTDISCON);
- 
- 	if (0) {
- 		/* post global nak until we're ready */
--		writel(DCTL_SGNPINNAK | DCTL_SGOUTNAK,
-+		dwc2_writel(DCTL_SGNPINNAK | DCTL_SGOUTNAK,
- 		       hsotg->regs + DCTL);
- 	}
- 
- 	/* setup fifos */
- 
- 	dev_dbg(hsotg->dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",
--		readl(hsotg->regs + GRXFSIZ),
--		readl(hsotg->regs + GNPTXFSIZ));
-+		dwc2_readl(hsotg->regs + GRXFSIZ),
-+		dwc2_readl(hsotg->regs + GNPTXFSIZ));
- 
- 	s3c_hsotg_init_fifo(hsotg);
- 
- 	/* set the PLL on, remove the HNP/SRP and set the PHY */
--	writel(GUSBCFG_PHYIF16 | GUSBCFG_TOUTCAL(7) | (0x5 << 10),
-+	dwc2_writel(GUSBCFG_PHYIF16 | GUSBCFG_TOUTCAL(7) | (0x5 << 10),
- 	       hsotg->regs + GUSBCFG);
- 
--	writel(using_dma(hsotg) ? GAHBCFG_DMA_EN : 0x0,
-+	dwc2_writel(using_dma(hsotg) ? GAHBCFG_DMA_EN : 0x0,
- 	       hsotg->regs + GAHBCFG);
- }
- 
-@@ -3045,8 +3045,8 @@ static void s3c_hsotg_initep(struct s3c_
- 
- 	if (using_dma(hsotg)) {
- 		u32 next = DXEPCTL_NEXTEP((epnum + 1) % 15);
--		writel(next, hsotg->regs + DIEPCTL(epnum));
--		writel(next, hsotg->regs + DOEPCTL(epnum));
-+		dwc2_writel(next, hsotg->regs + DIEPCTL(epnum));
-+		dwc2_writel(next, hsotg->regs + DOEPCTL(epnum));
- 	}
- }
- 
-@@ -3061,13 +3061,13 @@ static void s3c_hsotg_hw_cfg(struct s3c_
- 	u32 cfg2, cfg3, cfg4;
- 	/* check hardware configuration */
- 
--	cfg2 = readl(hsotg->regs + 0x48);
-+	cfg2 = dwc2_readl(hsotg->regs + 0x48);
- 	hsotg->num_of_eps = (cfg2 >> 10) & 0xF;
- 
--	cfg3 = readl(hsotg->regs + 0x4C);
-+	cfg3 = dwc2_readl(hsotg->regs + 0x4C);
- 	hsotg->fifo_mem = (cfg3 >> 16);
- 
--	cfg4 = readl(hsotg->regs + 0x50);
-+	cfg4 = dwc2_readl(hsotg->regs + 0x50);
- 	hsotg->dedicated_fifos = (cfg4 >> 25) & 1;
- 
- 	dev_info(hsotg->dev, "EPs: %d, %s fifos, %d entries in SPRAM\n",
-@@ -3089,19 +3089,19 @@ static void s3c_hsotg_dump(struct s3c_hs
- 	int idx;
- 
- 	dev_info(dev, "DCFG=0x%08x, DCTL=0x%08x, DIEPMSK=%08x\n",
--		 readl(regs + DCFG), readl(regs + DCTL),
--		 readl(regs + DIEPMSK));
-+		 dwc2_readl(regs + DCFG), dwc2_readl(regs + DCTL),
-+		 dwc2_readl(regs + DIEPMSK));
- 
- 	dev_info(dev, "GAHBCFG=0x%08x, 0x44=0x%08x\n",
--		 readl(regs + GAHBCFG), readl(regs + 0x44));
-+		 dwc2_readl(regs + GAHBCFG), dwc2_readl(regs + 0x44));
- 
- 	dev_info(dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",
--		 readl(regs + GRXFSIZ), readl(regs + GNPTXFSIZ));
-+		 dwc2_readl(regs + GRXFSIZ), dwc2_readl(regs + GNPTXFSIZ));
- 
- 	/* show periodic fifo settings */
- 
- 	for (idx = 1; idx <= 15; idx++) {
--		val = readl(regs + DPTXFSIZN(idx));
-+		val = dwc2_readl(regs + DPTXFSIZN(idx));
- 		dev_info(dev, "DPTx[%d] FSize=%d, StAddr=0x%08x\n", idx,
- 			 val >> FIFOSIZE_DEPTH_SHIFT,
- 			 val & FIFOSIZE_STARTADDR_MASK);
-@@ -3110,21 +3110,21 @@ static void s3c_hsotg_dump(struct s3c_hs
- 	for (idx = 0; idx < 15; idx++) {
- 		dev_info(dev,
- 			 "ep%d-in: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n", idx,
--			 readl(regs + DIEPCTL(idx)),
--			 readl(regs + DIEPTSIZ(idx)),
--			 readl(regs + DIEPDMA(idx)));
-+			 dwc2_readl(regs + DIEPCTL(idx)),
-+			 dwc2_readl(regs + DIEPTSIZ(idx)),
-+			 dwc2_readl(regs + DIEPDMA(idx)));
- 
--		val = readl(regs + DOEPCTL(idx));
-+		val = dwc2_readl(regs + DOEPCTL(idx));
- 		dev_info(dev,
- 			 "ep%d-out: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n",
--			 idx, readl(regs + DOEPCTL(idx)),
--			 readl(regs + DOEPTSIZ(idx)),
--			 readl(regs + DOEPDMA(idx)));
-+			 idx, dwc2_readl(regs + DOEPCTL(idx)),
-+			 dwc2_readl(regs + DOEPTSIZ(idx)),
-+			 dwc2_readl(regs + DOEPDMA(idx)));
- 
- 	}
- 
- 	dev_info(dev, "DVBUSDIS=0x%08x, DVBUSPULSE=%08x\n",
--		 readl(regs + DVBUSDIS), readl(regs + DVBUSPULSE));
-+		 dwc2_readl(regs + DVBUSDIS), dwc2_readl(regs + DVBUSPULSE));
- #endif
- }
- 
-@@ -3144,38 +3144,38 @@ static int state_show(struct seq_file *s
- 	int idx;
- 
- 	seq_printf(seq, "DCFG=0x%08x, DCTL=0x%08x, DSTS=0x%08x\n",
--		 readl(regs + DCFG),
--		 readl(regs + DCTL),
--		 readl(regs + DSTS));
-+		 dwc2_readl(regs + DCFG),
-+		 dwc2_readl(regs + DCTL),
-+		 dwc2_readl(regs + DSTS));
- 
- 	seq_printf(seq, "DIEPMSK=0x%08x, DOEPMASK=0x%08x\n",
--		   readl(regs + DIEPMSK), readl(regs + DOEPMSK));
-+		   dwc2_readl(regs + DIEPMSK), dwc2_readl(regs + DOEPMSK));
- 
- 	seq_printf(seq, "GINTMSK=0x%08x, GINTSTS=0x%08x\n",
--		   readl(regs + GINTMSK),
--		   readl(regs + GINTSTS));
-+		   dwc2_readl(regs + GINTMSK),
-+		   dwc2_readl(regs + GINTSTS));
- 
- 	seq_printf(seq, "DAINTMSK=0x%08x, DAINT=0x%08x\n",
--		   readl(regs + DAINTMSK),
--		   readl(regs + DAINT));
-+		   dwc2_readl(regs + DAINTMSK),
-+		   dwc2_readl(regs + DAINT));
- 
- 	seq_printf(seq, "GNPTXSTS=0x%08x, GRXSTSR=%08x\n",
--		   readl(regs + GNPTXSTS),
--		   readl(regs + GRXSTSR));
-+		   dwc2_readl(regs + GNPTXSTS),
-+		   dwc2_readl(regs + GRXSTSR));
- 
- 	seq_puts(seq, "\nEndpoint status:\n");
- 
- 	for (idx = 0; idx < 15; idx++) {
- 		u32 in, out;
- 
--		in = readl(regs + DIEPCTL(idx));
--		out = readl(regs + DOEPCTL(idx));
-+		in = dwc2_readl(regs + DIEPCTL(idx));
-+		out = dwc2_readl(regs + DOEPCTL(idx));
- 
- 		seq_printf(seq, "ep%d: DIEPCTL=0x%08x, DOEPCTL=0x%08x",
- 			   idx, in, out);
- 
--		in = readl(regs + DIEPTSIZ(idx));
--		out = readl(regs + DOEPTSIZ(idx));
-+		in = dwc2_readl(regs + DIEPTSIZ(idx));
-+		out = dwc2_readl(regs + DOEPTSIZ(idx));
- 
- 		seq_printf(seq, ", DIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x",
- 			   in, out);
-@@ -3215,9 +3215,9 @@ static int fifo_show(struct seq_file *se
- 	int idx;
- 
- 	seq_puts(seq, "Non-periodic FIFOs:\n");
--	seq_printf(seq, "RXFIFO: Size %d\n", readl(regs + GRXFSIZ));
-+	seq_printf(seq, "RXFIFO: Size %d\n", dwc2_readl(regs + GRXFSIZ));
- 
--	val = readl(regs + GNPTXFSIZ);
-+	val = dwc2_readl(regs + GNPTXFSIZ);
- 	seq_printf(seq, "NPTXFIFO: Size %d, Start 0x%08x\n",
- 		   val >> FIFOSIZE_DEPTH_SHIFT,
- 		   val & FIFOSIZE_DEPTH_MASK);
-@@ -3225,7 +3225,7 @@ static int fifo_show(struct seq_file *se
- 	seq_puts(seq, "\nPeriodic TXFIFOs:\n");
- 
- 	for (idx = 1; idx <= 15; idx++) {
--		val = readl(regs + DPTXFSIZN(idx));
-+		val = dwc2_readl(regs + DPTXFSIZN(idx));
- 
- 		seq_printf(seq, "\tDPTXFIFO%2d: Size %d, Start 0x%08x\n", idx,
- 			   val >> FIFOSIZE_DEPTH_SHIFT,
-@@ -3278,20 +3278,20 @@ static int ep_show(struct seq_file *seq,
- 	/* first show the register state */
- 
- 	seq_printf(seq, "\tDIEPCTL=0x%08x, DOEPCTL=0x%08x\n",
--		   readl(regs + DIEPCTL(index)),
--		   readl(regs + DOEPCTL(index)));
-+		   dwc2_readl(regs + DIEPCTL(index)),
-+		   dwc2_readl(regs + DOEPCTL(index)));
- 
- 	seq_printf(seq, "\tDIEPDMA=0x%08x, DOEPDMA=0x%08x\n",
--		   readl(regs + DIEPDMA(index)),
--		   readl(regs + DOEPDMA(index)));
-+		   dwc2_readl(regs + DIEPDMA(index)),
-+		   dwc2_readl(regs + DOEPDMA(index)));
- 
- 	seq_printf(seq, "\tDIEPINT=0x%08x, DOEPINT=0x%08x\n",
--		   readl(regs + DIEPINT(index)),
--		   readl(regs + DOEPINT(index)));
-+		   dwc2_readl(regs + DIEPINT(index)),
-+		   dwc2_readl(regs + DOEPINT(index)));
- 
- 	seq_printf(seq, "\tDIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x\n",
--		   readl(regs + DIEPTSIZ(index)),
--		   readl(regs + DOEPTSIZ(index)));
-+		   dwc2_readl(regs + DIEPTSIZ(index)),
-+		   dwc2_readl(regs + DOEPTSIZ(index)));
- 
- 	seq_puts(seq, "\n");
- 	seq_printf(seq, "mps %d\n", ep->ep.maxpacket);
---- a/drivers/usb/dwc2/hcd.c
-+++ b/drivers/usb/dwc2/hcd.c
-@@ -80,10 +80,10 @@ static void dwc2_dump_channel_info(struc
- 	if (chan == NULL)
- 		return;
- 
--	hcchar = readl(hsotg->regs + HCCHAR(chan->hc_num));
--	hcsplt = readl(hsotg->regs + HCSPLT(chan->hc_num));
--	hctsiz = readl(hsotg->regs + HCTSIZ(chan->hc_num));
--	hc_dma = readl(hsotg->regs + HCDMA(chan->hc_num));
-+	hcchar = dwc2_readl(hsotg->regs + HCCHAR(chan->hc_num));
-+	hcsplt = dwc2_readl(hsotg->regs + HCSPLT(chan->hc_num));
-+	hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chan->hc_num));
-+	hc_dma = dwc2_readl(hsotg->regs + HCDMA(chan->hc_num));
- 
- 	dev_dbg(hsotg->dev, "  Assigned to channel %p:\n", chan);
- 	dev_dbg(hsotg->dev, "    hcchar 0x%08x, hcsplt 0x%08x\n",
-@@ -207,7 +207,7 @@ void dwc2_hcd_start(struct dwc2_hsotg *h
- 		 */
- 		hprt0 = dwc2_read_hprt0(hsotg);
- 		hprt0 |= HPRT0_RST;
--		writel(hprt0, hsotg->regs + HPRT0);
-+		dwc2_writel(hprt0, hsotg->regs + HPRT0);
- 	}
- 
- 	queue_delayed_work(hsotg->wq_otg, &hsotg->start_work,
-@@ -228,11 +228,11 @@ static void dwc2_hcd_cleanup_channels(st
- 			channel = hsotg->hc_ptr_array[i];
- 			if (!list_empty(&channel->hc_list_entry))
- 				continue;
--			hcchar = readl(hsotg->regs + HCCHAR(i));
-+			hcchar = dwc2_readl(hsotg->regs + HCCHAR(i));
- 			if (hcchar & HCCHAR_CHENA) {
- 				hcchar &= ~(HCCHAR_CHENA | HCCHAR_EPDIR);
- 				hcchar |= HCCHAR_CHDIS;
--				writel(hcchar, hsotg->regs + HCCHAR(i));
-+				dwc2_writel(hcchar, hsotg->regs + HCCHAR(i));
- 			}
- 		}
- 	}
-@@ -241,11 +241,11 @@ static void dwc2_hcd_cleanup_channels(st
- 		channel = hsotg->hc_ptr_array[i];
- 		if (!list_empty(&channel->hc_list_entry))
- 			continue;
--		hcchar = readl(hsotg->regs + HCCHAR(i));
-+		hcchar = dwc2_readl(hsotg->regs + HCCHAR(i));
- 		if (hcchar & HCCHAR_CHENA) {
- 			/* Halt the channel */
- 			hcchar |= HCCHAR_CHDIS;
--			writel(hcchar, hsotg->regs + HCCHAR(i));
-+			dwc2_writel(hcchar, hsotg->regs + HCCHAR(i));
- 		}
- 
- 		dwc2_hc_cleanup(hsotg, channel);
-@@ -279,11 +279,11 @@ void dwc2_hcd_disconnect(struct dwc2_hso
- 	 * interrupt mask and status bits and disabling subsequent host
- 	 * channel interrupts.
- 	 */
--	intr = readl(hsotg->regs + GINTMSK);
-+	intr = dwc2_readl(hsotg->regs + GINTMSK);
- 	intr &= ~(GINTSTS_NPTXFEMP | GINTSTS_PTXFEMP | GINTSTS_HCHINT);
--	writel(intr, hsotg->regs + GINTMSK);
-+	dwc2_writel(intr, hsotg->regs + GINTMSK);
- 	intr = GINTSTS_NPTXFEMP | GINTSTS_PTXFEMP | GINTSTS_HCHINT;
--	writel(intr, hsotg->regs + GINTSTS);
-+	dwc2_writel(intr, hsotg->regs + GINTSTS);
- 
- 	/*
- 	 * Turn off the vbus power only if the core has transitioned to device
-@@ -293,7 +293,7 @@ void dwc2_hcd_disconnect(struct dwc2_hso
- 	if (dwc2_is_device_mode(hsotg)) {
- 		if (hsotg->op_state != OTG_STATE_A_SUSPEND) {
- 			dev_dbg(hsotg->dev, "Disconnect: PortPower off\n");
--			writel(0, hsotg->regs + HPRT0);
-+			dwc2_writel(0, hsotg->regs + HPRT0);
- 		}
- 
- 		dwc2_disable_host_interrupts(hsotg);
-@@ -344,7 +344,7 @@ void dwc2_hcd_stop(struct dwc2_hsotg *hs
- 
- 	/* Turn off the vbus power */
- 	dev_dbg(hsotg->dev, "PortPower off\n");
--	writel(0, hsotg->regs + HPRT0);
-+	dwc2_writel(0, hsotg->regs + HPRT0);
- }
- 
- static int dwc2_hcd_urb_enqueue(struct dwc2_hsotg *hsotg,
-@@ -369,7 +369,7 @@ static int dwc2_hcd_urb_enqueue(struct d
- 	if ((dev_speed == USB_SPEED_LOW) &&
- 	    (hsotg->hw_params.fs_phy_type == GHWCFG2_FS_PHY_TYPE_DEDICATED) &&
- 	    (hsotg->hw_params.hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI)) {
--		u32 hprt0 = readl(hsotg->regs + HPRT0);
-+		u32 hprt0 = dwc2_readl(hsotg->regs + HPRT0);
- 		u32 prtspd = (hprt0 & HPRT0_SPD_MASK) >> HPRT0_SPD_SHIFT;
- 
- 		if (prtspd == HPRT0_SPD_FULL_SPEED)
-@@ -391,7 +391,7 @@ static int dwc2_hcd_urb_enqueue(struct d
- 		return retval;
- 	}
- 
--	intr_mask = readl(hsotg->regs + GINTMSK);
-+	intr_mask = dwc2_readl(hsotg->regs + GINTMSK);
- 	if (!(intr_mask & GINTSTS_SOF)) {
- 		enum dwc2_transaction_type tr_type;
- 
-@@ -1059,7 +1059,7 @@ static void dwc2_process_periodic_channe
- 	if (dbg_perio())
- 		dev_vdbg(hsotg->dev, "Queue periodic transactions\n");
- 
--	tx_status = readl(hsotg->regs + HPTXSTS);
-+	tx_status = dwc2_readl(hsotg->regs + HPTXSTS);
- 	qspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>
- 		    TXSTS_QSPCAVAIL_SHIFT;
- 	fspcavail = (tx_status & TXSTS_FSPCAVAIL_MASK) >>
-@@ -1074,7 +1074,7 @@ static void dwc2_process_periodic_channe
- 
- 	qh_ptr = hsotg->periodic_sched_assigned.next;
- 	while (qh_ptr != &hsotg->periodic_sched_assigned) {
--		tx_status = readl(hsotg->regs + HPTXSTS);
-+		tx_status = dwc2_readl(hsotg->regs + HPTXSTS);
- 		qspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>
- 			    TXSTS_QSPCAVAIL_SHIFT;
- 		if (qspcavail == 0) {
-@@ -1134,7 +1134,7 @@ static void dwc2_process_periodic_channe
- 	}
- 
- 	if (hsotg->core_params->dma_enable <= 0) {
--		tx_status = readl(hsotg->regs + HPTXSTS);
-+		tx_status = dwc2_readl(hsotg->regs + HPTXSTS);
- 		qspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>
- 			    TXSTS_QSPCAVAIL_SHIFT;
- 		fspcavail = (tx_status & TXSTS_FSPCAVAIL_MASK) >>
-@@ -1157,9 +1157,9 @@ static void dwc2_process_periodic_channe
- 			 * level to ensure that new requests are loaded as
- 			 * soon as possible.)
- 			 */
--			gintmsk = readl(hsotg->regs + GINTMSK);
-+			gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 			gintmsk |= GINTSTS_PTXFEMP;
--			writel(gintmsk, hsotg->regs + GINTMSK);
-+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
- 		} else {
- 			/*
- 			 * Disable the Tx FIFO empty interrupt since there are
-@@ -1168,9 +1168,9 @@ static void dwc2_process_periodic_channe
- 			 * handlers to queue more transactions as transfer
- 			 * states change.
- 			 */
--			gintmsk = readl(hsotg->regs + GINTMSK);
-+			gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 			gintmsk &= ~GINTSTS_PTXFEMP;
--			writel(gintmsk, hsotg->regs + GINTMSK);
-+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
- 		}
- 	}
- }
-@@ -1199,7 +1199,7 @@ static void dwc2_process_non_periodic_ch
- 
- 	dev_vdbg(hsotg->dev, "Queue non-periodic transactions\n");
- 
--	tx_status = readl(hsotg->regs + GNPTXSTS);
-+	tx_status = dwc2_readl(hsotg->regs + GNPTXSTS);
- 	qspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>
- 		    TXSTS_QSPCAVAIL_SHIFT;
- 	fspcavail = (tx_status & TXSTS_FSPCAVAIL_MASK) >>
-@@ -1222,7 +1222,7 @@ static void dwc2_process_non_periodic_ch
- 	 * available in the request queue or the Tx FIFO
- 	 */
- 	do {
--		tx_status = readl(hsotg->regs + GNPTXSTS);
-+		tx_status = dwc2_readl(hsotg->regs + GNPTXSTS);
- 		qspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>
- 			    TXSTS_QSPCAVAIL_SHIFT;
- 		if (hsotg->core_params->dma_enable <= 0 && qspcavail == 0) {
-@@ -1259,7 +1259,7 @@ next:
- 	} while (hsotg->non_periodic_qh_ptr != orig_qh_ptr);
- 
- 	if (hsotg->core_params->dma_enable <= 0) {
--		tx_status = readl(hsotg->regs + GNPTXSTS);
-+		tx_status = dwc2_readl(hsotg->regs + GNPTXSTS);
- 		qspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>
- 			    TXSTS_QSPCAVAIL_SHIFT;
- 		fspcavail = (tx_status & TXSTS_FSPCAVAIL_MASK) >>
-@@ -1279,9 +1279,9 @@ next:
- 			 * level to ensure that new requests are loaded as
- 			 * soon as possible.)
- 			 */
--			gintmsk = readl(hsotg->regs + GINTMSK);
-+			gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 			gintmsk |= GINTSTS_NPTXFEMP;
--			writel(gintmsk, hsotg->regs + GINTMSK);
-+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
- 		} else {
- 			/*
- 			 * Disable the Tx FIFO empty interrupt since there are
-@@ -1290,9 +1290,9 @@ next:
- 			 * handlers to queue more transactions as transfer
- 			 * states change.
- 			 */
--			gintmsk = readl(hsotg->regs + GINTMSK);
-+			gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 			gintmsk &= ~GINTSTS_NPTXFEMP;
--			writel(gintmsk, hsotg->regs + GINTMSK);
-+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
- 		}
- 	}
- }
-@@ -1330,10 +1330,10 @@ void dwc2_hcd_queue_transactions(struct
- 			 * Ensure NP Tx FIFO empty interrupt is disabled when
- 			 * there are no non-periodic transfers to process
- 			 */
--			u32 gintmsk = readl(hsotg->regs + GINTMSK);
-+			u32 gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 
- 			gintmsk &= ~GINTSTS_NPTXFEMP;
--			writel(gintmsk, hsotg->regs + GINTMSK);
-+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
- 		}
- 	}
- }
-@@ -1347,7 +1347,7 @@ static void dwc2_conn_id_status_change(s
- 
- 	dev_dbg(hsotg->dev, "%s()\n", __func__);
- 
--	gotgctl = readl(hsotg->regs + GOTGCTL);
-+	gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
- 	dev_dbg(hsotg->dev, "gotgctl=%0x\n", gotgctl);
- 	dev_dbg(hsotg->dev, "gotgctl.b.conidsts=%d\n",
- 		!!(gotgctl & GOTGCTL_CONID_B));
-@@ -1408,9 +1408,9 @@ static void dwc2_wakeup_detected(unsigne
- 	hprt0 = dwc2_read_hprt0(hsotg);
- 	dev_dbg(hsotg->dev, "Resume: HPRT0=%0x\n", hprt0);
- 	hprt0 &= ~HPRT0_RES;
--	writel(hprt0, hsotg->regs + HPRT0);
-+	dwc2_writel(hprt0, hsotg->regs + HPRT0);
- 	dev_dbg(hsotg->dev, "Clear Resume: HPRT0=%0x\n",
--		readl(hsotg->regs + HPRT0));
-+		dwc2_readl(hsotg->regs + HPRT0));
- 
- 	dwc2_hcd_rem_wakeup(hsotg);
- 
-@@ -1438,30 +1438,30 @@ static void dwc2_port_suspend(struct dwc
- 	spin_lock_irqsave(&hsotg->lock, flags);
- 
- 	if (windex == hsotg->otg_port && dwc2_host_is_b_hnp_enabled(hsotg)) {
--		gotgctl = readl(hsotg->regs + GOTGCTL);
-+		gotgctl = dwc2_readl(hsotg->regs + GOTGCTL);
- 		gotgctl |= GOTGCTL_HSTSETHNPEN;
--		writel(gotgctl, hsotg->regs + GOTGCTL);
-+		dwc2_writel(gotgctl, hsotg->regs + GOTGCTL);
- 		hsotg->op_state = OTG_STATE_A_SUSPEND;
- 	}
- 
- 	hprt0 = dwc2_read_hprt0(hsotg);
- 	hprt0 |= HPRT0_SUSP;
--	writel(hprt0, hsotg->regs + HPRT0);
-+	dwc2_writel(hprt0, hsotg->regs + HPRT0);
- 
- 	/* Update lx_state */
- 	hsotg->lx_state = DWC2_L2;
- 
- 	/* Suspend the Phy Clock */
--	pcgctl = readl(hsotg->regs + PCGCTL);
-+	pcgctl = dwc2_readl(hsotg->regs + PCGCTL);
- 	pcgctl |= PCGCTL_STOPPCLK;
--	writel(pcgctl, hsotg->regs + PCGCTL);
-+	dwc2_writel(pcgctl, hsotg->regs + PCGCTL);
- 	udelay(10);
- 
- 	/* For HNP the bus must be suspended for at least 200ms */
- 	if (dwc2_host_is_b_hnp_enabled(hsotg)) {
--		pcgctl = readl(hsotg->regs + PCGCTL);
-+		pcgctl = dwc2_readl(hsotg->regs + PCGCTL);
- 		pcgctl &= ~PCGCTL_STOPPCLK;
--		writel(pcgctl, hsotg->regs + PCGCTL);
-+		dwc2_writel(pcgctl, hsotg->regs + PCGCTL);
- 
- 		spin_unlock_irqrestore(&hsotg->lock, flags);
- 
-@@ -1510,23 +1510,23 @@ static int dwc2_hcd_hub_control(struct d
- 				"ClearPortFeature USB_PORT_FEAT_ENABLE\n");
- 			hprt0 = dwc2_read_hprt0(hsotg);
- 			hprt0 |= HPRT0_ENA;
--			writel(hprt0, hsotg->regs + HPRT0);
-+			dwc2_writel(hprt0, hsotg->regs + HPRT0);
- 			break;
- 
- 		case USB_PORT_FEAT_SUSPEND:
- 			dev_dbg(hsotg->dev,
- 				"ClearPortFeature USB_PORT_FEAT_SUSPEND\n");
--			writel(0, hsotg->regs + PCGCTL);
-+			dwc2_writel(0, hsotg->regs + PCGCTL);
- 			msleep(USB_RESUME_TIMEOUT);
- 
- 			hprt0 = dwc2_read_hprt0(hsotg);
- 			hprt0 |= HPRT0_RES;
--			writel(hprt0, hsotg->regs + HPRT0);
-+			dwc2_writel(hprt0, hsotg->regs + HPRT0);
- 			hprt0 &= ~HPRT0_SUSP;
- 			usleep_range(100000, 150000);
- 
- 			hprt0 &= ~HPRT0_RES;
--			writel(hprt0, hsotg->regs + HPRT0);
-+			dwc2_writel(hprt0, hsotg->regs + HPRT0);
- 			break;
- 
- 		case USB_PORT_FEAT_POWER:
-@@ -1534,7 +1534,7 @@ static int dwc2_hcd_hub_control(struct d
- 				"ClearPortFeature USB_PORT_FEAT_POWER\n");
- 			hprt0 = dwc2_read_hprt0(hsotg);
- 			hprt0 &= ~HPRT0_PWR;
--			writel(hprt0, hsotg->regs + HPRT0);
-+			dwc2_writel(hprt0, hsotg->regs + HPRT0);
- 			break;
- 
- 		case USB_PORT_FEAT_INDICATOR:
-@@ -1653,7 +1653,7 @@ static int dwc2_hcd_hub_control(struct d
- 			break;
- 		}
- 
--		hprt0 = readl(hsotg->regs + HPRT0);
-+		hprt0 = dwc2_readl(hsotg->regs + HPRT0);
- 		dev_vdbg(hsotg->dev, "  HPRT0: 0x%08x\n", hprt0);
- 
- 		if (hprt0 & HPRT0_CONNSTS)
-@@ -1718,18 +1718,18 @@ static int dwc2_hcd_hub_control(struct d
- 				"SetPortFeature - USB_PORT_FEAT_POWER\n");
- 			hprt0 = dwc2_read_hprt0(hsotg);
- 			hprt0 |= HPRT0_PWR;
--			writel(hprt0, hsotg->regs + HPRT0);
-+			dwc2_writel(hprt0, hsotg->regs + HPRT0);
- 			break;
- 
- 		case USB_PORT_FEAT_RESET:
- 			hprt0 = dwc2_read_hprt0(hsotg);
- 			dev_dbg(hsotg->dev,
- 				"SetPortFeature - USB_PORT_FEAT_RESET\n");
--			pcgctl = readl(hsotg->regs + PCGCTL);
-+			pcgctl = dwc2_readl(hsotg->regs + PCGCTL);
- 			pcgctl &= ~(PCGCTL_ENBL_SLEEP_GATING | PCGCTL_STOPPCLK);
--			writel(pcgctl, hsotg->regs + PCGCTL);
-+			dwc2_writel(pcgctl, hsotg->regs + PCGCTL);
- 			/* ??? Original driver does this */
--			writel(0, hsotg->regs + PCGCTL);
-+			dwc2_writel(0, hsotg->regs + PCGCTL);
- 
- 			hprt0 = dwc2_read_hprt0(hsotg);
- 			/* Clear suspend bit if resetting from suspend state */
-@@ -1744,13 +1744,13 @@ static int dwc2_hcd_hub_control(struct d
- 				hprt0 |= HPRT0_PWR | HPRT0_RST;
- 				dev_dbg(hsotg->dev,
- 					"In host mode, hprt0=%08x\n", hprt0);
--				writel(hprt0, hsotg->regs + HPRT0);
-+				dwc2_writel(hprt0, hsotg->regs + HPRT0);
- 			}
- 
- 			/* Clear reset bit in 10ms (FS/LS) or 50ms (HS) */
- 			usleep_range(50000, 70000);
- 			hprt0 &= ~HPRT0_RST;
--			writel(hprt0, hsotg->regs + HPRT0);
-+			dwc2_writel(hprt0, hsotg->regs + HPRT0);
- 			hsotg->lx_state = DWC2_L0; /* Now back to On state */
- 			break;
- 
-@@ -1814,7 +1814,7 @@ static int dwc2_hcd_is_status_changed(st
- 
- int dwc2_hcd_get_frame_number(struct dwc2_hsotg *hsotg)
- {
--	u32 hfnum = readl(hsotg->regs + HFNUM);
-+	u32 hfnum = dwc2_readl(hsotg->regs + HFNUM);
- 
- #ifdef DWC2_DEBUG_SOF
- 	dev_vdbg(hsotg->dev, "DWC OTG HCD GET FRAME NUMBER %d\n",
-@@ -1917,11 +1917,11 @@ void dwc2_hcd_dump_state(struct dwc2_hso
- 		if (chan->xfer_started) {
- 			u32 hfnum, hcchar, hctsiz, hcint, hcintmsk;
- 
--			hfnum = readl(hsotg->regs + HFNUM);
--			hcchar = readl(hsotg->regs + HCCHAR(i));
--			hctsiz = readl(hsotg->regs + HCTSIZ(i));
--			hcint = readl(hsotg->regs + HCINT(i));
--			hcintmsk = readl(hsotg->regs + HCINTMSK(i));
-+			hfnum = dwc2_readl(hsotg->regs + HFNUM);
-+			hcchar = dwc2_readl(hsotg->regs + HCCHAR(i));
-+			hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(i));
-+			hcint = dwc2_readl(hsotg->regs + HCINT(i));
-+			hcintmsk = dwc2_readl(hsotg->regs + HCINTMSK(i));
- 			dev_dbg(hsotg->dev, "    hfnum: 0x%08x\n", hfnum);
- 			dev_dbg(hsotg->dev, "    hcchar: 0x%08x\n", hcchar);
- 			dev_dbg(hsotg->dev, "    hctsiz: 0x%08x\n", hctsiz);
-@@ -1969,12 +1969,12 @@ void dwc2_hcd_dump_state(struct dwc2_hso
- 	dev_dbg(hsotg->dev, "  periodic_channels: %d\n",
- 		hsotg->periodic_channels);
- 	dev_dbg(hsotg->dev, "  periodic_usecs: %d\n", hsotg->periodic_usecs);
--	np_tx_status = readl(hsotg->regs + GNPTXSTS);
-+	np_tx_status = dwc2_readl(hsotg->regs + GNPTXSTS);
- 	dev_dbg(hsotg->dev, "  NP Tx Req Queue Space Avail: %d\n",
- 		(np_tx_status & TXSTS_QSPCAVAIL_MASK) >> TXSTS_QSPCAVAIL_SHIFT);
- 	dev_dbg(hsotg->dev, "  NP Tx FIFO Space Avail: %d\n",
- 		(np_tx_status & TXSTS_FSPCAVAIL_MASK) >> TXSTS_FSPCAVAIL_SHIFT);
--	p_tx_status = readl(hsotg->regs + HPTXSTS);
-+	p_tx_status = dwc2_readl(hsotg->regs + HPTXSTS);
- 	dev_dbg(hsotg->dev, "  P Tx Req Queue Space Avail: %d\n",
- 		(p_tx_status & TXSTS_QSPCAVAIL_MASK) >> TXSTS_QSPCAVAIL_SHIFT);
- 	dev_dbg(hsotg->dev, "  P Tx FIFO Space Avail: %d\n",
-@@ -2238,7 +2238,7 @@ static void dwc2_hcd_reset_func(struct w
- 	dev_dbg(hsotg->dev, "USB RESET function called\n");
- 	hprt0 = dwc2_read_hprt0(hsotg);
- 	hprt0 &= ~HPRT0_RST;
--	writel(hprt0, hsotg->regs + HPRT0);
-+	dwc2_writel(hprt0, hsotg->regs + HPRT0);
- 	hsotg->flags.b.port_reset_change = 1;
- }
- 
-@@ -2715,17 +2715,17 @@ static void dwc2_hcd_free(struct dwc2_hs
- 		hsotg->status_buf = NULL;
- 	}
- 
--	ahbcfg = readl(hsotg->regs + GAHBCFG);
-+	ahbcfg = dwc2_readl(hsotg->regs + GAHBCFG);
- 
- 	/* Disable all interrupts */
- 	ahbcfg &= ~GAHBCFG_GLBL_INTR_EN;
--	writel(ahbcfg, hsotg->regs + GAHBCFG);
--	writel(0, hsotg->regs + GINTMSK);
-+	dwc2_writel(ahbcfg, hsotg->regs + GAHBCFG);
-+	dwc2_writel(0, hsotg->regs + GINTMSK);
- 
- 	if (hsotg->hw_params.snpsid >= DWC2_CORE_REV_3_00a) {
--		dctl = readl(hsotg->regs + DCTL);
-+		dctl = dwc2_readl(hsotg->regs + DCTL);
- 		dctl |= DCTL_SFTDISCON;
--		writel(dctl, hsotg->regs + DCTL);
-+		dwc2_writel(dctl, hsotg->regs + DCTL);
- 	}
- 
- 	if (hsotg->wq_otg) {
-@@ -2788,7 +2788,7 @@ int dwc2_hcd_init(struct dwc2_hsotg *hso
- 
- 	retval = -ENOMEM;
- 
--	hcfg = readl(hsotg->regs + HCFG);
-+	hcfg = dwc2_readl(hsotg->regs + HCFG);
- 	dev_dbg(hsotg->dev, "hcfg=%08x\n", hcfg);
- 
- #ifdef CONFIG_USB_DWC2_TRACK_MISSED_SOFS
---- a/drivers/usb/dwc2/hcd_ddma.c
-+++ b/drivers/usb/dwc2/hcd_ddma.c
-@@ -169,19 +169,19 @@ static void dwc2_per_sched_enable(struct
- 
- 	spin_lock_irqsave(&hsotg->lock, flags);
- 
--	hcfg = readl(hsotg->regs + HCFG);
-+	hcfg = dwc2_readl(hsotg->regs + HCFG);
- 	if (hcfg & HCFG_PERSCHEDENA) {
- 		/* already enabled */
- 		spin_unlock_irqrestore(&hsotg->lock, flags);
- 		return;
- 	}
- 
--	writel(hsotg->frame_list_dma, hsotg->regs + HFLBADDR);
-+	dwc2_writel(hsotg->frame_list_dma, hsotg->regs + HFLBADDR);
- 
- 	hcfg &= ~HCFG_FRLISTEN_MASK;
- 	hcfg |= fr_list_en | HCFG_PERSCHEDENA;
- 	dev_vdbg(hsotg->dev, "Enabling Periodic schedule\n");
--	writel(hcfg, hsotg->regs + HCFG);
-+	dwc2_writel(hcfg, hsotg->regs + HCFG);
- 
- 	spin_unlock_irqrestore(&hsotg->lock, flags);
- }
-@@ -193,7 +193,7 @@ static void dwc2_per_sched_disable(struc
- 
- 	spin_lock_irqsave(&hsotg->lock, flags);
- 
--	hcfg = readl(hsotg->regs + HCFG);
-+	hcfg = dwc2_readl(hsotg->regs + HCFG);
- 	if (!(hcfg & HCFG_PERSCHEDENA)) {
- 		/* already disabled */
- 		spin_unlock_irqrestore(&hsotg->lock, flags);
-@@ -202,7 +202,7 @@ static void dwc2_per_sched_disable(struc
- 
- 	hcfg &= ~HCFG_PERSCHEDENA;
- 	dev_vdbg(hsotg->dev, "Disabling Periodic schedule\n");
--	writel(hcfg, hsotg->regs + HCFG);
-+	dwc2_writel(hcfg, hsotg->regs + HCFG);
- 
- 	spin_unlock_irqrestore(&hsotg->lock, flags);
- }
---- a/drivers/usb/dwc2/hcd.h
-+++ b/drivers/usb/dwc2/hcd.h
-@@ -371,10 +371,10 @@ static inline struct usb_hcd *dwc2_hsotg
-  */
- static inline void disable_hc_int(struct dwc2_hsotg *hsotg, int chnum, u32 intr)
- {
--	u32 mask = readl(hsotg->regs + HCINTMSK(chnum));
-+	u32 mask = dwc2_readl(hsotg->regs + HCINTMSK(chnum));
- 
- 	mask &= ~intr;
--	writel(mask, hsotg->regs + HCINTMSK(chnum));
-+	dwc2_writel(mask, hsotg->regs + HCINTMSK(chnum));
- }
- 
- /*
-@@ -382,11 +382,11 @@ static inline void disable_hc_int(struct
-  */
- static inline int dwc2_is_host_mode(struct dwc2_hsotg *hsotg)
- {
--	return (readl(hsotg->regs + GINTSTS) & GINTSTS_CURMODE_HOST) != 0;
-+	return (dwc2_readl(hsotg->regs + GINTSTS) & GINTSTS_CURMODE_HOST) != 0;
- }
- static inline int dwc2_is_device_mode(struct dwc2_hsotg *hsotg)
- {
--	return (readl(hsotg->regs + GINTSTS) & GINTSTS_CURMODE_HOST) == 0;
-+	return (dwc2_readl(hsotg->regs + GINTSTS) & GINTSTS_CURMODE_HOST) == 0;
- }
- 
- /*
-@@ -395,7 +395,7 @@ static inline int dwc2_is_device_mode(st
-  */
- static inline u32 dwc2_read_hprt0(struct dwc2_hsotg *hsotg)
- {
--	u32 hprt0 = readl(hsotg->regs + HPRT0);
-+	u32 hprt0 = dwc2_readl(hsotg->regs + HPRT0);
- 
- 	hprt0 &= ~(HPRT0_ENA | HPRT0_CONNDET | HPRT0_ENACHG | HPRT0_OVRCURRCHG);
- 	return hprt0;
-@@ -582,7 +582,7 @@ static inline u16 dwc2_micro_frame_num(u
-  */
- static inline u32 dwc2_read_core_intr(struct dwc2_hsotg *hsotg)
- {
--	return readl(hsotg->regs + GINTSTS) & readl(hsotg->regs + GINTMSK);
-+	return dwc2_readl(hsotg->regs + GINTSTS) & dwc2_readl(hsotg->regs + GINTMSK);
- }
- 
- static inline u32 dwc2_hcd_urb_get_status(struct dwc2_hcd_urb *dwc2_urb)
-@@ -744,7 +744,7 @@ do {									\
- 			   qtd_list_entry);				\
- 	if (usb_pipeint(_qtd_->urb->pipe) &&				\
- 	    (_qh_)->start_split_frame != 0 && !_qtd_->complete_split) {	\
--		_hfnum_.d32 = readl((_hcd_)->regs + HFNUM);		\
-+		_hfnum_.d32 = dwc2_readl((_hcd_)->regs + HFNUM);		\
- 		switch (_hfnum_.b.frnum & 0x7) {			\
- 		case 7:							\
- 			(_hcd_)->hfnum_7_samples_##_letter_++;		\
---- a/drivers/usb/dwc2/hcd_intr.c
-+++ b/drivers/usb/dwc2/hcd_intr.c
-@@ -148,7 +148,7 @@ static void dwc2_sof_intr(struct dwc2_hs
- 		dwc2_hcd_queue_transactions(hsotg, tr_type);
- 
- 	/* Clear interrupt */
--	writel(GINTSTS_SOF, hsotg->regs + GINTSTS);
-+	dwc2_writel(GINTSTS_SOF, hsotg->regs + GINTSTS);
- }
- 
- /*
-@@ -164,7 +164,7 @@ static void dwc2_rx_fifo_level_intr(stru
- 	if (dbg_perio())
- 		dev_vdbg(hsotg->dev, "--RxFIFO Level Interrupt--\n");
- 
--	grxsts = readl(hsotg->regs + GRXSTSP);
-+	grxsts = dwc2_readl(hsotg->regs + GRXSTSP);
- 	chnum = (grxsts & GRXSTS_HCHNUM_MASK) >> GRXSTS_HCHNUM_SHIFT;
- 	chan = hsotg->hc_ptr_array[chnum];
- 	if (!chan) {
-@@ -247,11 +247,11 @@ static void dwc2_hprt0_enable(struct dwc
- 	dev_vdbg(hsotg->dev, "%s(%p)\n", __func__, hsotg);
- 
- 	/* Every time when port enables calculate HFIR.FrInterval */
--	hfir = readl(hsotg->regs + HFIR);
-+	hfir = dwc2_readl(hsotg->regs + HFIR);
- 	hfir &= ~HFIR_FRINT_MASK;
- 	hfir |= dwc2_calc_frame_interval(hsotg) << HFIR_FRINT_SHIFT &
- 		HFIR_FRINT_MASK;
--	writel(hfir, hsotg->regs + HFIR);
-+	dwc2_writel(hfir, hsotg->regs + HFIR);
- 
- 	/* Check if we need to adjust the PHY clock speed for low power */
- 	if (!params->host_support_fs_ls_low_power) {
-@@ -260,7 +260,7 @@ static void dwc2_hprt0_enable(struct dwc
- 		return;
- 	}
- 
--	usbcfg = readl(hsotg->regs + GUSBCFG);
-+	usbcfg = dwc2_readl(hsotg->regs + GUSBCFG);
- 	prtspd = (hprt0 & HPRT0_SPD_MASK) >> HPRT0_SPD_SHIFT;
- 
- 	if (prtspd == HPRT0_SPD_LOW_SPEED || prtspd == HPRT0_SPD_FULL_SPEED) {
-@@ -268,11 +268,11 @@ static void dwc2_hprt0_enable(struct dwc
- 		if (!(usbcfg & GUSBCFG_PHY_LP_CLK_SEL)) {
- 			/* Set PHY low power clock select for FS/LS devices */
- 			usbcfg |= GUSBCFG_PHY_LP_CLK_SEL;
--			writel(usbcfg, hsotg->regs + GUSBCFG);
-+			dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
- 			do_reset = 1;
- 		}
- 
--		hcfg = readl(hsotg->regs + HCFG);
-+		hcfg = dwc2_readl(hsotg->regs + HCFG);
- 		fslspclksel = (hcfg & HCFG_FSLSPCLKSEL_MASK) >>
- 			      HCFG_FSLSPCLKSEL_SHIFT;
- 
-@@ -286,7 +286,7 @@ static void dwc2_hprt0_enable(struct dwc
- 				fslspclksel = HCFG_FSLSPCLKSEL_6_MHZ;
- 				hcfg &= ~HCFG_FSLSPCLKSEL_MASK;
- 				hcfg |= fslspclksel << HCFG_FSLSPCLKSEL_SHIFT;
--				writel(hcfg, hsotg->regs + HCFG);
-+				dwc2_writel(hcfg, hsotg->regs + HCFG);
- 				do_reset = 1;
- 			}
- 		} else {
-@@ -297,7 +297,7 @@ static void dwc2_hprt0_enable(struct dwc
- 				fslspclksel = HCFG_FSLSPCLKSEL_48_MHZ;
- 				hcfg &= ~HCFG_FSLSPCLKSEL_MASK;
- 				hcfg |= fslspclksel << HCFG_FSLSPCLKSEL_SHIFT;
--				writel(hcfg, hsotg->regs + HCFG);
-+				dwc2_writel(hcfg, hsotg->regs + HCFG);
- 				do_reset = 1;
- 			}
- 		}
-@@ -305,7 +305,7 @@ static void dwc2_hprt0_enable(struct dwc
- 		/* Not low power */
- 		if (usbcfg & GUSBCFG_PHY_LP_CLK_SEL) {
- 			usbcfg &= ~GUSBCFG_PHY_LP_CLK_SEL;
--			writel(usbcfg, hsotg->regs + GUSBCFG);
-+			dwc2_writel(usbcfg, hsotg->regs + GUSBCFG);
- 			do_reset = 1;
- 		}
- 	}
-@@ -332,7 +332,7 @@ static void dwc2_port_intr(struct dwc2_h
- 
- 	dev_vdbg(hsotg->dev, "--Port Interrupt--\n");
- 
--	hprt0 = readl(hsotg->regs + HPRT0);
-+	hprt0 = dwc2_readl(hsotg->regs + HPRT0);
- 	hprt0_modify = hprt0;
- 
- 	/*
-@@ -385,7 +385,7 @@ static void dwc2_port_intr(struct dwc2_h
- 	}
- 
- 	/* Clear Port Interrupts */
--	writel(hprt0_modify, hsotg->regs + HPRT0);
-+	dwc2_writel(hprt0_modify, hsotg->regs + HPRT0);
- }
- 
- /*
-@@ -405,7 +405,7 @@ static u32 dwc2_get_actual_xfer_length(s
- {
- 	u32 hctsiz, count, length;
- 
--	hctsiz = readl(hsotg->regs + HCTSIZ(chnum));
-+	hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));
- 
- 	if (halt_status == DWC2_HC_XFER_COMPLETE) {
- 		if (chan->ep_is_in) {
-@@ -483,7 +483,7 @@ static int dwc2_update_urb_state(struct
- 		urb->status = 0;
- 	}
- 
--	hctsiz = readl(hsotg->regs + HCTSIZ(chnum));
-+	hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));
- 	dev_vdbg(hsotg->dev, "DWC_otg: %s: %s, channel %d\n",
- 		 __func__, (chan->ep_is_in ? "IN" : "OUT"), chnum);
- 	dev_vdbg(hsotg->dev, "  chan->xfer_len %d\n", chan->xfer_len);
-@@ -506,7 +506,7 @@ void dwc2_hcd_save_data_toggle(struct dw
- 			       struct dwc2_host_chan *chan, int chnum,
- 			       struct dwc2_qtd *qtd)
- {
--	u32 hctsiz = readl(hsotg->regs + HCTSIZ(chnum));
-+	u32 hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));
- 	u32 pid = (hctsiz & TSIZ_SC_MC_PID_MASK) >> TSIZ_SC_MC_PID_SHIFT;
- 
- 	if (chan->ep_type != USB_ENDPOINT_XFER_CONTROL) {
-@@ -753,9 +753,9 @@ cleanup:
- 		}
- 	}
- 
--	haintmsk = readl(hsotg->regs + HAINTMSK);
-+	haintmsk = dwc2_readl(hsotg->regs + HAINTMSK);
- 	haintmsk &= ~(1 << chan->hc_num);
--	writel(haintmsk, hsotg->regs + HAINTMSK);
-+	dwc2_writel(haintmsk, hsotg->regs + HAINTMSK);
- 
- 	/* Try to queue more transfers now that there's a free channel */
- 	tr_type = dwc2_hcd_select_transactions(hsotg);
-@@ -802,9 +802,9 @@ static void dwc2_halt_channel(struct dwc
- 			 * is enabled so that the non-periodic schedule will
- 			 * be processed
- 			 */
--			gintmsk = readl(hsotg->regs + GINTMSK);
-+			gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 			gintmsk |= GINTSTS_NPTXFEMP;
--			writel(gintmsk, hsotg->regs + GINTMSK);
-+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
- 		} else {
- 			dev_vdbg(hsotg->dev, "isoc/intr\n");
- 			/*
-@@ -821,9 +821,9 @@ static void dwc2_halt_channel(struct dwc
- 			 * enabled so that the periodic schedule will be
- 			 * processed
- 			 */
--			gintmsk = readl(hsotg->regs + GINTMSK);
-+			gintmsk = dwc2_readl(hsotg->regs + GINTMSK);
- 			gintmsk |= GINTSTS_PTXFEMP;
--			writel(gintmsk, hsotg->regs + GINTMSK);
-+			dwc2_writel(gintmsk, hsotg->regs + GINTMSK);
- 		}
- 	}
- }
-@@ -888,7 +888,7 @@ static void dwc2_complete_periodic_xfer(
- 					struct dwc2_qtd *qtd,
- 					enum dwc2_halt_status halt_status)
- {
--	u32 hctsiz = readl(hsotg->regs + HCTSIZ(chnum));
-+	u32 hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));
- 
- 	qtd->error_count = 0;
- 
-@@ -1158,7 +1158,7 @@ static void dwc2_update_urb_state_abn(st
- 
- 	urb->actual_length += xfer_length;
- 
--	hctsiz = readl(hsotg->regs + HCTSIZ(chnum));
-+	hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));
- 	dev_vdbg(hsotg->dev, "DWC_otg: %s: %s, channel %d\n",
- 		 __func__, (chan->ep_is_in ? "IN" : "OUT"), chnum);
- 	dev_vdbg(hsotg->dev, "  chan->start_pkt_count %d\n",
-@@ -1469,10 +1469,10 @@ static void dwc2_hc_ahberr_intr(struct d
- 
- 	dwc2_hc_handle_tt_clear(hsotg, chan, qtd);
- 
--	hcchar = readl(hsotg->regs + HCCHAR(chnum));
--	hcsplt = readl(hsotg->regs + HCSPLT(chnum));
--	hctsiz = readl(hsotg->regs + HCTSIZ(chnum));
--	hc_dma = readl(hsotg->regs + HCDMA(chnum));
-+	hcchar = dwc2_readl(hsotg->regs + HCCHAR(chnum));
-+	hcsplt = dwc2_readl(hsotg->regs + HCSPLT(chnum));
-+	hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));
-+	hc_dma = dwc2_readl(hsotg->regs + HCDMA(chnum));
- 
- 	dev_err(hsotg->dev, "AHB ERROR, Channel %d\n", chnum);
- 	dev_err(hsotg->dev, "  hcchar 0x%08x, hcsplt 0x%08x\n", hcchar, hcsplt);
-@@ -1685,10 +1685,10 @@ static bool dwc2_halt_status_ok(struct d
- 		 * This code is here only as a check. This condition should
- 		 * never happen. Ignore the halt if it does occur.
- 		 */
--		hcchar = readl(hsotg->regs + HCCHAR(chnum));
--		hctsiz = readl(hsotg->regs + HCTSIZ(chnum));
--		hcintmsk = readl(hsotg->regs + HCINTMSK(chnum));
--		hcsplt = readl(hsotg->regs + HCSPLT(chnum));
-+		hcchar = dwc2_readl(hsotg->regs + HCCHAR(chnum));
-+		hctsiz = dwc2_readl(hsotg->regs + HCTSIZ(chnum));
-+		hcintmsk = dwc2_readl(hsotg->regs + HCINTMSK(chnum));
-+		hcsplt = dwc2_readl(hsotg->regs + HCSPLT(chnum));
- 		dev_dbg(hsotg->dev,
- 			"%s: chan->halt_status DWC2_HC_XFER_NO_HALT_STATUS,\n",
- 			 __func__);
-@@ -1712,7 +1712,7 @@ static bool dwc2_halt_status_ok(struct d
- 	 * when the halt interrupt occurs. Halt the channel again if it does
- 	 * occur.
- 	 */
--	hcchar = readl(hsotg->regs + HCCHAR(chnum));
-+	hcchar = dwc2_readl(hsotg->regs + HCCHAR(chnum));
- 	if (hcchar & HCCHAR_CHDIS) {
- 		dev_warn(hsotg->dev,
- 			 "%s: hcchar.chdis set unexpectedly, hcchar 0x%08x, trying to halt again\n",
-@@ -1772,7 +1772,7 @@ static void dwc2_hc_chhltd_intr_dma(stru
- 		return;
- 	}
- 
--	hcintmsk = readl(hsotg->regs + HCINTMSK(chnum));
-+	hcintmsk = dwc2_readl(hsotg->regs + HCINTMSK(chnum));
- 
- 	if (chan->hcint & HCINTMSK_XFERCOMPL) {
- 		/*
-@@ -1867,7 +1867,7 @@ static void dwc2_hc_chhltd_intr_dma(stru
- 				dev_err(hsotg->dev,
- 					"hcint 0x%08x, intsts 0x%08x\n",
- 					chan->hcint,
--					readl(hsotg->regs + GINTSTS));
-+					dwc2_readl(hsotg->regs + GINTSTS));
- 				goto error;
- 			}
- 		}
-@@ -1922,11 +1922,11 @@ static void dwc2_hc_n_intr(struct dwc2_h
- 
- 	chan = hsotg->hc_ptr_array[chnum];
- 
--	hcint = readl(hsotg->regs + HCINT(chnum));
--	hcintmsk = readl(hsotg->regs + HCINTMSK(chnum));
-+	hcint = dwc2_readl(hsotg->regs + HCINT(chnum));
-+	hcintmsk = dwc2_readl(hsotg->regs + HCINTMSK(chnum));
- 	if (!chan) {
- 		dev_err(hsotg->dev, "## hc_ptr_array for channel is NULL ##\n");
--		writel(hcint, hsotg->regs + HCINT(chnum));
-+		dwc2_writel(hcint, hsotg->regs + HCINT(chnum));
- 		return;
- 	}
- 
-@@ -1938,7 +1938,7 @@ static void dwc2_hc_n_intr(struct dwc2_h
- 			 hcint, hcintmsk, hcint & hcintmsk);
- 	}
- 
--	writel(hcint, hsotg->regs + HCINT(chnum));
-+	dwc2_writel(hcint, hsotg->regs + HCINT(chnum));
- 	chan->hcint = hcint;
- 	hcint &= hcintmsk;
- 
-@@ -2030,7 +2030,7 @@ static void dwc2_hc_intr(struct dwc2_hso
- 	u32 haint;
- 	int i;
- 
--	haint = readl(hsotg->regs + HAINT);
-+	haint = dwc2_readl(hsotg->regs + HAINT);
- 	if (dbg_perio()) {
- 		dev_vdbg(hsotg->dev, "%s()\n", __func__);
- 
-@@ -2098,8 +2098,8 @@ irqreturn_t dwc2_handle_hcd_intr(struct
- 				 "DWC OTG HCD Finished Servicing Interrupts\n");
- 			dev_vdbg(hsotg->dev,
- 				 "DWC OTG HCD gintsts=0x%08x gintmsk=0x%08x\n",
--				 readl(hsotg->regs + GINTSTS),
--				 readl(hsotg->regs + GINTMSK));
-+				 dwc2_readl(hsotg->regs + GINTSTS),
-+				 dwc2_readl(hsotg->regs + GINTMSK));
- 		}
- 	}
- 
---- a/drivers/usb/dwc2/hcd_queue.c
-+++ b/drivers/usb/dwc2/hcd_queue.c
-@@ -115,7 +115,7 @@ static void dwc2_qh_init(struct dwc2_hso
- 		if (qh->ep_type == USB_ENDPOINT_XFER_INT)
- 			qh->interval = 8;
- #endif
--		hprt = readl(hsotg->regs + HPRT0);
-+		hprt = dwc2_readl(hsotg->regs + HPRT0);
- 		prtspd = (hprt & HPRT0_SPD_MASK) >> HPRT0_SPD_SHIFT;
- 		if (prtspd == HPRT0_SPD_HIGH_SPEED &&
- 		    (dev_speed == USB_SPEED_LOW ||
-@@ -593,9 +593,9 @@ int dwc2_hcd_qh_add(struct dwc2_hsotg *h
- 	if (status)
- 		return status;
- 	if (!hsotg->periodic_qh_count) {
--		intr_mask = readl(hsotg->regs + GINTMSK);
-+		intr_mask = dwc2_readl(hsotg->regs + GINTMSK);
- 		intr_mask |= GINTSTS_SOF;
--		writel(intr_mask, hsotg->regs + GINTMSK);
-+		dwc2_writel(intr_mask, hsotg->regs + GINTMSK);
- 	}
- 	hsotg->periodic_qh_count++;
- 
-@@ -630,9 +630,9 @@ void dwc2_hcd_qh_unlink(struct dwc2_hsot
- 	dwc2_deschedule_periodic(hsotg, qh);
- 	hsotg->periodic_qh_count--;
- 	if (!hsotg->periodic_qh_count) {
--		intr_mask = readl(hsotg->regs + GINTMSK);
-+		intr_mask = dwc2_readl(hsotg->regs + GINTMSK);
- 		intr_mask &= ~GINTSTS_SOF;
--		writel(intr_mask, hsotg->regs + GINTMSK);
-+		dwc2_writel(intr_mask, hsotg->regs + GINTMSK);
- 	}
- }
- 
diff --git a/target/linux/lantiq/patches-3.18/0043-gpio-stp-xway-fix-phy-mask.patch b/target/linux/lantiq/patches-3.18/0043-gpio-stp-xway-fix-phy-mask.patch
deleted file mode 100644
index d43cdf3d54..0000000000
--- a/target/linux/lantiq/patches-3.18/0043-gpio-stp-xway-fix-phy-mask.patch
+++ /dev/null
@@ -1,23 +0,0 @@
-From 08b085a07efe12568d86dff064e6f089e2971744 Mon Sep 17 00:00:00 2001
-From: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
-Date: Mon, 25 May 2015 22:39:50 +0200
-Subject: gpio-stp-xway: Fix enabling the highest bit of the PHY LEDs
-
-0x3 only masks two bits, but three bits have to be allowed. This fixes
-GPHY0 LED2 (which is the highest bit of phy2) on my board.
-
-Signed-off-by: Martin Blumenstingl <martin.blumenstingl@googlemail.com>
-Acked-by: John Crispin <blogic@openwrt.org>
-Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
-
---- a/drivers/gpio/gpio-stp-xway.c
-+++ b/drivers/gpio/gpio-stp-xway.c
-@@ -58,7 +58,7 @@
- #define XWAY_STP_ADSL_MASK	0x3
- 
- /* 2 groups of 3 bits can be driven by the phys */
--#define XWAY_STP_PHY_MASK	0x3
-+#define XWAY_STP_PHY_MASK	0x7
- #define XWAY_STP_PHY1_SHIFT	27
- #define XWAY_STP_PHY2_SHIFT	15
- 
diff --git a/target/linux/lantiq/patches-3.18/0100-lantiq-xrx200-enable-remove-crc.patch b/target/linux/lantiq/patches-3.18/0100-lantiq-xrx200-enable-remove-crc.patch
deleted file mode 100644
index 60a1937568..0000000000
--- a/target/linux/lantiq/patches-3.18/0100-lantiq-xrx200-enable-remove-crc.patch
+++ /dev/null
@@ -1,25 +0,0 @@
---- a/drivers/net/ethernet/lantiq_xrx200.c
-+++ b/drivers/net/ethernet/lantiq_xrx200.c
-@@ -143,6 +143,7 @@
- #define PMAC_IPG_MASK		0xf
- #define PMAC_HD_CTL_AS		0x0008
- #define PMAC_HD_CTL_AC		0x0004
-+#define PMAC_HD_CTL_RC		0x0010
- #define PMAC_HD_CTL_RXSH	0x0040
- #define PMAC_HD_CTL_AST		0x0080
- #define PMAC_HD_CTL_RST		0x0100
-@@ -1502,12 +1503,12 @@ static void xrx200_hw_init(struct xrx200
- #ifdef SW_ROUTING
- 	/* enable status header, enable CRC */
- 	ltq_pmac_w32_mask(0,
--		PMAC_HD_CTL_RST | PMAC_HD_CTL_AST | PMAC_HD_CTL_RXSH | PMAC_HD_CTL_AS | PMAC_HD_CTL_AC,
-+		PMAC_HD_CTL_RST | PMAC_HD_CTL_AST | PMAC_HD_CTL_RXSH | PMAC_HD_CTL_AS | PMAC_HD_CTL_AC | PMAC_HD_CTL_RC,
- 		PMAC_HD_CTL);
- #else
- 	/* disable status header, enable CRC */
- 	ltq_pmac_w32_mask(PMAC_HD_CTL_AST | PMAC_HD_CTL_RXSH | PMAC_HD_CTL_AS,
--		PMAC_HD_CTL_AC,
-+		PMAC_HD_CTL_AC | PMAC_HD_CTL_RC,
- 		PMAC_HD_CTL);
- #endif
- 
diff --git a/target/linux/lantiq/patches-3.18/0101-mtd-split.patch b/target/linux/lantiq/patches-3.18/0101-mtd-split.patch
deleted file mode 100644
index 6753a2156c..0000000000
--- a/target/linux/lantiq/patches-3.18/0101-mtd-split.patch
+++ /dev/null
@@ -1,192 +0,0 @@
---- a/arch/mips/lantiq/xway/Makefile
-+++ b/arch/mips/lantiq/xway/Makefile
-@@ -1,6 +1,6 @@
- obj-y := prom.o sysctrl.o clk.o reset.o dma.o timer.o dcdc.o
- 
--obj-y += vmmc.o tffs.o
-+obj-y += vmmc.o tffs.o mtd_split.o
- 
- obj-y += eth_mac.o
- obj-$(CONFIG_PCI) += ath_eep.o rt_eep.o pci-ath-fixup.o
---- /dev/null
-+++ b/arch/mips/lantiq/xway/mtd_split.c
-@@ -0,0 +1,129 @@
-+#include <linux/magic.h>
-+#include <linux/root_dev.h>
-+#include <linux/mtd/mtd.h>
-+#include <linux/mtd/partitions.h>
-+
-+#define ROOTFS_SPLIT_NAME "rootfs_data"
-+
-+struct squashfs_super_block {
-+	__le32 s_magic;
-+	__le32 pad0[9];
-+	__le64 bytes_used;
-+};
-+
-+static void split_brnimage_kernel(struct mtd_info *master, const char *name,
-+                                       int offset, int size)
-+{
-+	unsigned long buf[4];
-+	// Assume at most 2MB of kernel image
-+	unsigned long end = offset + (2 << 20);
-+	unsigned long part_size = offset + 0x400 - 12;
-+	size_t len;
-+	int ret;
-+
-+	if (strcmp(name, "firmware") != 0)
-+		return;
-+	while (part_size < end) {
-+		long size_min = part_size - 0x400 - 12 - offset;
-+		long size_max = part_size + 12 - offset;
-+		ret = mtd_read(master, part_size, 16, &len, (void *)buf);
-+		if (ret || len != 16)
-+			return;
-+
-+		if (le32_to_cpu(buf[0]) < size_min ||
-+				le32_to_cpu(buf[0]) > size_max) {
-+			part_size += 0x400;
-+			continue;
-+		}
-+
-+		if (le32_to_cpu(buf[3]) == SQUASHFS_MAGIC) {
-+			part_size += 12 - offset;
-+			__mtd_add_partition(master, "rootfs", offset + part_size,
-+			                            size - part_size, false);
-+			return;
-+		}
-+		part_size += 0x400;
-+	}
-+}
-+
-+static void split_eva_kernel(struct mtd_info *master, const char *name,
-+				int offset, int size)
-+{
-+#define EVA_MAGIC   0xfeed1281
-+	unsigned long magic = 0;
-+	unsigned long part_size = 0, p;
-+	size_t len;
-+	int ret;
-+
-+	if (strcmp(name, CONFIG_MTD_SPLIT_FIRMWARE_NAME) != 0)
-+		return;
-+
-+	ret = mtd_read(master, offset, 4, &len, (void *)&magic);
-+	if (ret || len != sizeof(magic))
-+		return;
-+
-+	if (le32_to_cpu(magic) != EVA_MAGIC)
-+		return;
-+
-+	ret = mtd_read(master, offset + 4, 4, &len, (void *)&part_size);
-+	if (ret || len != sizeof(part_size))
-+		return;
-+
-+	p = part_size = le32_to_cpu(part_size) + 0x18;
-+	p &= ~0xffff;
-+	p += 0x10000;
-+
-+	ret = mtd_read(master, offset + p, 4, &len, (void *)&magic);
-+	if (ret || len != sizeof(magic))
-+		return;
-+
-+	if (magic == SQUASHFS_MAGIC)
-+		part_size = p + 0x100;
-+	else
-+	        part_size = mtd_pad_erasesize(master, offset, len);
-+
-+	if (part_size + master->erasesize > size)
-+		return;
-+
-+	__mtd_add_partition(master, "rootfs", offset + part_size,
-+			    size - part_size, false);
-+}
-+
-+static void split_tplink_kernel(struct mtd_info *master, const char *name,
-+				int offset, int size)
-+{
-+#define TPLINK_MAGIC   0x00000002
-+	unsigned long magic = 0;
-+	unsigned long part_size = 0;
-+	size_t len;
-+	int ret;
-+
-+	if (strcmp(name, CONFIG_MTD_SPLIT_FIRMWARE_NAME) != 0)
-+		return;
-+
-+	ret = mtd_read(master, offset, 4, &len, (void *)&magic);
-+	if (ret || len != sizeof(magic))
-+		return;
-+
-+	if (le32_to_cpu(magic) != TPLINK_MAGIC)
-+		return;
-+
-+	ret = mtd_read(master, offset + 0x78, 4, &len, (void *)&part_size);
-+	if (ret || len != sizeof(part_size))
-+		return;
-+
-+	part_size = be32_to_cpu(part_size) + 0x200;
-+	if (part_size + master->erasesize > size)
-+		return;
-+
-+	__mtd_add_partition(master, "rootfs", offset + part_size,
-+			    size - part_size, false);
-+}
-+
-+void arch_split_mtd_part(struct mtd_info *master, const char *name,
-+				int offset, int size)
-+{
-+	split_tplink_kernel(master, name, offset, size);
-+	split_eva_kernel(master, name, offset, size);
-+	split_brnimage_kernel(master, name, offset, size);
-+}
---- a/include/linux/mtd/partitions.h
-+++ b/include/linux/mtd/partitions.h
-@@ -89,12 +89,17 @@ extern void deregister_mtd_parser(struct
- int mtd_is_partition(const struct mtd_info *mtd);
- int mtd_add_partition(struct mtd_info *master, const char *name,
- 		      long long offset, long long length);
-+int __mtd_add_partition(struct mtd_info *master, const char *name,
-+		    long long offset, long long length, bool dup_check);
-+
- int mtd_del_partition(struct mtd_info *master, int partno);
- struct mtd_info *mtdpart_get_master(const struct mtd_info *mtd);
- uint64_t mtdpart_get_offset(const struct mtd_info *mtd);
- uint64_t mtd_get_device_size(const struct mtd_info *mtd);
--extern void __weak arch_split_mtd_part(struct mtd_info *master,
--				       const char *name, int offset, int size);
-+void __weak arch_split_mtd_part(struct mtd_info *master,
-+ 				       const char *name, int offset, int size);
-+unsigned long
-+mtd_pad_erasesize(struct mtd_info *mtd, int offset, int len);
- 
- int parse_mtd_partitions_by_type(struct mtd_info *master,
- 				 enum mtd_parser_type type,
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -627,7 +627,7 @@ out_register:
- }
- 
- 
--static int
-+int
- __mtd_add_partition(struct mtd_info *master, const char *name,
- 		    long long offset, long long length, bool dup_check)
- {
-@@ -748,7 +748,7 @@ run_parsers_by_type(struct mtd_part *sla
- 	return nr_parts;
- }
- 
--static inline unsigned long
-+unsigned long
- mtd_pad_erasesize(struct mtd_info *mtd, int offset, int len)
- {
- 	unsigned long mask = mtd->erasesize - 1;
-@@ -818,7 +818,6 @@ static void split_uimage(struct mtd_info
- 		return;
- 
- 	len = be32_to_cpu(hdr.size) + 0x40;
--	len = mtd_pad_erasesize(master, part->offset, len);
- 	if (len + master->erasesize > part->mtd.size)
- 		return;
- 
diff --git a/target/linux/lantiq/patches-3.18/0150-lantiq-pinctrl-xway.patch b/target/linux/lantiq/patches-3.18/0150-lantiq-pinctrl-xway.patch
deleted file mode 100644
index 84adbe661f..0000000000
--- a/target/linux/lantiq/patches-3.18/0150-lantiq-pinctrl-xway.patch
+++ /dev/null
@@ -1,15 +0,0 @@
---- a/drivers/pinctrl/pinctrl-xway.c
-+++ b/drivers/pinctrl/pinctrl-xway.c
-@@ -152,10 +152,10 @@ static const struct ltq_mfp_pin xway_mfp
- 	MFP_XWAY(GPIO41, GPIO,	NONE,	NONE,	NONE),
- 	MFP_XWAY(GPIO42, GPIO,	MDIO,	NONE,	NONE),
- 	MFP_XWAY(GPIO43, GPIO,	MDIO,	NONE,	NONE),
--	MFP_XWAY(GPIO44, GPIO,	NONE,	GPHY,	SIN),
-+	MFP_XWAY(GPIO44, GPIO,	MII,	SIN,	GPHY),
- 	MFP_XWAY(GPIO45, GPIO,	NONE,	GPHY,	SIN),
- 	MFP_XWAY(GPIO46, GPIO,	NONE,	NONE,	EXIN),
--	MFP_XWAY(GPIO47, GPIO,	NONE,	GPHY,	SIN),
-+	MFP_XWAY(GPIO47, GPIO,	MII,	GPHY,	SIN),
- 	MFP_XWAY(GPIO48, GPIO,	EBU,	NONE,	NONE),
- 	MFP_XWAY(GPIO49, GPIO,	EBU,	NONE,	NONE),
- 	MFP_XWAY(GPIO50, GPIO,	NONE,	NONE,	NONE),
diff --git a/target/linux/lantiq/patches-3.18/0151-lantiq-ifxmips_pcie-use-of.patch b/target/linux/lantiq/patches-3.18/0151-lantiq-ifxmips_pcie-use-of.patch
deleted file mode 100644
index 26a3a65142..0000000000
--- a/target/linux/lantiq/patches-3.18/0151-lantiq-ifxmips_pcie-use-of.patch
+++ /dev/null
@@ -1,51 +0,0 @@
---- a/arch/mips/pci/ifxmips_pcie.c
-+++ b/arch/mips/pci/ifxmips_pcie.c
-@@ -18,6 +18,8 @@
- #include <linux/pci_regs.h>
- #include <linux/module.h>
- 
-+#include <linux/of_platform.h>
-+
- #include "ifxmips_pcie.h"
- #include "ifxmips_pcie_reg.h"
- 
-@@ -1045,7 +1047,7 @@ pcie_rc_initialize(int pcie_port)
- 	return 0;
- }
- 
--static int __init ifx_pcie_bios_init(void)
-+static int __init ifx_pcie_bios_probe(struct platform_device *pdev)
- {
-     void __iomem *io_map_base;
-     int pcie_port;
-@@ -1083,6 +1085,30 @@ static int __init ifx_pcie_bios_init(voi
- 
-     return 0;
- }
-+
-+static const struct of_device_id ifxmips_pcie_match[] = {
-+        { .compatible = "lantiq,pcie-xrx200" },
-+        {},
-+};
-+MODULE_DEVICE_TABLE(of, ifxmips_pcie_match);
-+
-+static struct platform_driver ltq_pci_driver = {
-+        .probe = ifx_pcie_bios_probe,
-+        .driver = {
-+                .name = "pcie-xrx200",
-+                .owner = THIS_MODULE,
-+                .of_match_table = ifxmips_pcie_match,
-+        },
-+};
-+
-+int __init ifx_pcie_bios_init(void)
-+{
-+        int ret = platform_driver_register(&ltq_pci_driver);
-+        if (ret)
-+                pr_info("pcie-xrx200: Error registering platform driver!");
-+        return ret;
-+}
-+
- arch_initcall(ifx_pcie_bios_init);
- 
- MODULE_LICENSE("GPL");
diff --git a/target/linux/lantiq/patches-3.18/0160-owrt-lantiq-multiple-flash.patch b/target/linux/lantiq/patches-3.18/0160-owrt-lantiq-multiple-flash.patch
deleted file mode 100644
index c09323104d..0000000000
--- a/target/linux/lantiq/patches-3.18/0160-owrt-lantiq-multiple-flash.patch
+++ /dev/null
@@ -1,217 +0,0 @@
---- a/drivers/mtd/maps/lantiq-flash.c
-+++ b/drivers/mtd/maps/lantiq-flash.c
-@@ -19,6 +19,7 @@
- #include <linux/mtd/cfi.h>
- #include <linux/platform_device.h>
- #include <linux/mtd/physmap.h>
-+#include <linux/mtd/concat.h>
- #include <linux/of.h>
- 
- #include <lantiq_soc.h>
-@@ -38,10 +39,12 @@ enum {
- 	LTQ_NOR_NORMAL
- };
- 
-+#define MAX_RESOURCES		4
-+
- struct ltq_mtd {
--	struct resource *res;
--	struct mtd_info *mtd;
--	struct map_info *map;
-+	struct mtd_info *mtd[MAX_RESOURCES];
-+	struct mtd_info	*cmtd;
-+	struct map_info map[MAX_RESOURCES];
- };
- 
- static const char ltq_map_name[] = "ltq_nor";
-@@ -109,12 +112,44 @@ ltq_copy_to(struct map_info *map, unsign
- }
- 
- static int
-+ltq_mtd_remove(struct platform_device *pdev)
-+{
-+	struct ltq_mtd *ltq_mtd = platform_get_drvdata(pdev);
-+	int i;
-+
-+	if (ltq_mtd == NULL)
-+		return 0;
-+
-+	if (ltq_mtd->cmtd) {
-+		mtd_device_unregister(ltq_mtd->cmtd);
-+		if (ltq_mtd->cmtd != ltq_mtd->mtd[0])
-+			mtd_concat_destroy(ltq_mtd->cmtd);
-+	}
-+
-+	for (i = 0; i < MAX_RESOURCES; i++) {
-+		if (ltq_mtd->mtd[i] != NULL)
-+			map_destroy(ltq_mtd->mtd[i]);
-+	}
-+
-+	kfree(ltq_mtd);
-+
-+	return 0;
-+}
-+
-+static int
- ltq_mtd_probe(struct platform_device *pdev)
- {
- 	struct mtd_part_parser_data ppdata;
- 	struct ltq_mtd *ltq_mtd;
- 	struct cfi_private *cfi;
--	int err;
-+	int err = 0;
-+	int i;
-+	int devices_found = 0;
-+
-+	static const char *rom_probe_types[] = {
-+		"cfi_probe", "jedec_probe", NULL
-+	};
-+	const char **type;
- 
- 	if (of_machine_is_compatible("lantiq,falcon") &&
- 			(ltq_boot_select() != BS_FLASH)) {
-@@ -128,76 +163,88 @@ ltq_mtd_probe(struct platform_device *pd
- 
- 	platform_set_drvdata(pdev, ltq_mtd);
- 
--	ltq_mtd->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
--	if (!ltq_mtd->res) {
--		dev_err(&pdev->dev, "failed to get memory resource\n");
--		return -ENOENT;
-+	for (i = 0; i < pdev->num_resources; i++) {
-+		printk(KERN_NOTICE "lantiq nor flash device: %.8llx at %.8llx\n",
-+		       (unsigned long long)resource_size(&pdev->resource[i]),
-+		       (unsigned long long)pdev->resource[i].start);
-+	
-+		if (!devm_request_mem_region(&pdev->dev,
-+			pdev->resource[i].start,
-+			resource_size(&pdev->resource[i]),
-+			dev_name(&pdev->dev))) {
-+			dev_err(&pdev->dev, "Could not reserve memory region\n");
-+			return -ENOMEM;
-+		}
-+
-+		ltq_mtd->map[i].name = ltq_map_name;
-+		ltq_mtd->map[i].bankwidth = 2;
-+		ltq_mtd->map[i].read = ltq_read16;
-+		ltq_mtd->map[i].write = ltq_write16;
-+		ltq_mtd->map[i].copy_from = ltq_copy_from;
-+		ltq_mtd->map[i].copy_to = ltq_copy_to;
-+
-+		if (of_find_property(pdev->dev.of_node, "lantiq,noxip", NULL))
-+			ltq_mtd->map[i].phys = NO_XIP;
-+		else
-+			ltq_mtd->map[i].phys = pdev->resource[i].start;
-+		ltq_mtd->map[i].size = resource_size(&pdev->resource[i]);
-+		ltq_mtd->map[i].virt = devm_ioremap(&pdev->dev, pdev->resource[i].start,
-+						 ltq_mtd->map[i].size);
-+		if (IS_ERR(ltq_mtd->map[i].virt))
-+			return PTR_ERR(ltq_mtd->map[i].virt);
-+
-+		if (ltq_mtd->map[i].virt == NULL) {
-+			dev_err(&pdev->dev, "Failed to ioremap flash region\n");
-+			err = PTR_ERR(ltq_mtd->map[i].virt);
-+			goto err_out;
-+		}
-+
-+		ltq_mtd->map[i].map_priv_1 = LTQ_NOR_PROBING;
-+		for (type = rom_probe_types; !ltq_mtd->mtd[i] && *type; type++)
-+			ltq_mtd->mtd[i] = do_map_probe(*type, &ltq_mtd->map[i]);
-+		ltq_mtd->map[i].map_priv_1 = LTQ_NOR_NORMAL;
-+
-+		if (!ltq_mtd->mtd[i]) {
-+			dev_err(&pdev->dev, "probing failed\n");
-+			return -ENXIO;
-+		} else {
-+			devices_found++;
-+		}
-+
-+		ltq_mtd->mtd[i]->owner = THIS_MODULE;
-+		ltq_mtd->mtd[i]->dev.parent = &pdev->dev;
-+
-+		cfi = ltq_mtd->map[i].fldrv_priv;
-+		cfi->addr_unlock1 ^= 1;
-+		cfi->addr_unlock2 ^= 1;
- 	}
- 
--	ltq_mtd->map = devm_kzalloc(&pdev->dev, sizeof(struct map_info),
--				    GFP_KERNEL);
--	if (!ltq_mtd->map)
--		return -ENOMEM;
--
--	if (of_find_property(pdev->dev.of_node, "lantiq,noxip", NULL))
--		ltq_mtd->map->phys = NO_XIP;
--	else
--		ltq_mtd->map->phys = ltq_mtd->res->start;
--	ltq_mtd->res->start;
--	ltq_mtd->map->size = resource_size(ltq_mtd->res);
--	ltq_mtd->map->virt = devm_ioremap_resource(&pdev->dev, ltq_mtd->res);
--	if (IS_ERR(ltq_mtd->map->virt))
--		return PTR_ERR(ltq_mtd->map->virt);
--
--	ltq_mtd->map->name = ltq_map_name;
--	ltq_mtd->map->bankwidth = 2;
--	ltq_mtd->map->read = ltq_read16;
--	ltq_mtd->map->write = ltq_write16;
--	ltq_mtd->map->copy_from = ltq_copy_from;
--	ltq_mtd->map->copy_to = ltq_copy_to;
--
--	ltq_mtd->map->map_priv_1 = LTQ_NOR_PROBING;
--	ltq_mtd->mtd = do_map_probe("cfi_probe", ltq_mtd->map);
--	ltq_mtd->map->map_priv_1 = LTQ_NOR_NORMAL;
--
--	if (!ltq_mtd->mtd) {
--		dev_err(&pdev->dev, "probing failed\n");
--		return -ENXIO;
--	}
--
--	ltq_mtd->mtd->owner = THIS_MODULE;
--
--	cfi = ltq_mtd->map->fldrv_priv;
--	cfi->addr_unlock1 ^= 1;
--	cfi->addr_unlock2 ^= 1;
-+	if (devices_found == 1) {
-+		ltq_mtd->cmtd = ltq_mtd->mtd[0];
-+	} else if (devices_found > 1) {
-+		/*
-+		 * We detected multiple devices. Concatenate them together.
-+		 */
-+		ltq_mtd->cmtd = mtd_concat_create(ltq_mtd->mtd, devices_found, dev_name(&pdev->dev));
-+		if (ltq_mtd->cmtd == NULL)
-+			err = -ENXIO;
-+	}
- 
- 	ppdata.of_node = pdev->dev.of_node;
--	err = mtd_device_parse_register(ltq_mtd->mtd, ltq_probe_types,
-+	err = mtd_device_parse_register(ltq_mtd->cmtd, ltq_probe_types,
- 					&ppdata, NULL, 0);
- 	if (err) {
- 		dev_err(&pdev->dev, "failed to add partitions\n");
--		goto err_destroy;
-+		goto err_out;
- 	}
- 
- 	return 0;
- 
--err_destroy:
--	map_destroy(ltq_mtd->mtd);
-+err_out:
-+	ltq_mtd_remove(pdev);
- 	return err;
- }
- 
--static int
--ltq_mtd_remove(struct platform_device *pdev)
--{
--	struct ltq_mtd *ltq_mtd = platform_get_drvdata(pdev);
--
--	if (ltq_mtd && ltq_mtd->mtd) {
--		mtd_device_unregister(ltq_mtd->mtd);
--		map_destroy(ltq_mtd->mtd);
--	}
--	return 0;
--}
--
- static const struct of_device_id ltq_mtd_match[] = {
- 	{ .compatible = "lantiq,nor" },
- 	{},
diff --git a/target/linux/lantiq/patches-3.18/0300-MTD-cfi-cmdset-0001-disable-buffered-writes.patch b/target/linux/lantiq/patches-3.18/0300-MTD-cfi-cmdset-0001-disable-buffered-writes.patch
deleted file mode 100644
index d153c521d3..0000000000
--- a/target/linux/lantiq/patches-3.18/0300-MTD-cfi-cmdset-0001-disable-buffered-writes.patch
+++ /dev/null
@@ -1,11 +0,0 @@
---- a/drivers/mtd/chips/cfi_cmdset_0001.c
-+++ b/drivers/mtd/chips/cfi_cmdset_0001.c
-@@ -39,7 +39,7 @@
- /* #define CMDSET0001_DISABLE_WRITE_SUSPEND */
- 
- // debugging, turns off buffer write mode if set to 1
--#define FORCE_WORD_WRITE 0
-+#define FORCE_WORD_WRITE 1
- 
- /* Intel chips */
- #define I82802AB	0x00ad
diff --git a/target/linux/lantiq/patches-3.18/0340-falcon-easy98000-cpld.patch b/target/linux/lantiq/patches-3.18/0340-falcon-easy98000-cpld.patch
deleted file mode 100644
index f4d9dd3ffe..0000000000
--- a/target/linux/lantiq/patches-3.18/0340-falcon-easy98000-cpld.patch
+++ /dev/null
@@ -1,439 +0,0 @@
-simple driver to access the cpld registers on easy98000 incl. LED support
-
-diff --git a/arch/mips/lantiq/falcon/Makefile b/arch/mips/lantiq/falcon/Makefile
---- a/arch/mips/lantiq/falcon/Makefile
-+++ b/arch/mips/lantiq/falcon/Makefile
-@@ -1,1 +1,2 @@
- obj-y := prom.o reset.o sysctrl.o
-+obj-y += addon-easy98000.o dev-leds-easy98000-cpld.o
-diff --git a/arch/mips/lantiq/falcon/addon-easy98000.c b/arch/mips/lantiq/falcon/addon-easy98000.c
-new file mode 100644
---- /dev/null
-+++ b/arch/mips/lantiq/falcon/addon-easy98000.c
-@@ -0,0 +1,247 @@
-+/*
-+ *  EASY98000 CPLD Addon driver
-+ *
-+ *  Copyright (C) 2011 Thomas Langer <thomas.langer@lantiq.com>
-+ *
-+ *  This program is free software; you can redistribute it and/or modify it
-+ *  under the terms of the GNU General Public License version 2  as published
-+ *  by the Free Software Foundation.
-+ *
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/module.h>
-+#include <linux/version.h>
-+#include <linux/types.h>
-+#include <linux/init.h>
-+#include <linux/platform_device.h>
-+#include <linux/of_platform.h>
-+#include <linux/errno.h>
-+#include <linux/slab.h>
-+#include <linux/proc_fs.h>
-+#include <linux/seq_file.h>
-+
-+struct easy98000_reg_cpld {
-+	u16 cmdreg1;		/* 0x1 */
-+	u16 cmdreg0;		/* 0x0 */
-+	u16 idreg0;		/* 0x3 */
-+	u16 resreg;		/* 0x2 */
-+	u16 intreg;		/* 0x5 */
-+	u16 idreg1;		/* 0x4 */
-+	u16 ledreg;		/* 0x7 */
-+	u16 pcmconconfig;	/* 0x6 */
-+	u16 res0;		/* 0x9 */
-+	u16 ethledreg;		/* 0x8 */
-+	u16 res1[4];		/* 0xa-0xd */
-+	u16 cpld1v;		/* 0xf */
-+	u16 cpld2v;		/* 0xe */
-+};
-+static struct easy98000_reg_cpld * const cpld =
-+	(struct easy98000_reg_cpld *)(KSEG1 | 0x17c00000);
-+#define cpld_r8(reg) (__raw_readw(&cpld->reg) & 0xFF)
-+#define cpld_w8(val, reg) __raw_writew((val) & 0xFF, &cpld->reg)
-+
-+int easy98000_addon_has_dm9000(void)
-+{
-+	if ((cpld_r8(idreg0) & 0xF) == 1)
-+		return 1;
-+	return 0;
-+}
-+
-+#if defined(CONFIG_PROC_FS)
-+typedef void (*cpld_dump) (struct seq_file *s);
-+struct proc_entry {
-+	char *name;
-+	void *callback;
-+};
-+
-+static int cpld_proc_show ( struct seq_file *s, void *p )
-+{
-+	cpld_dump dump = s->private;
-+
-+	if ( dump != NULL )
-+		dump(s);
-+
-+	return 0;
-+}
-+
-+static int cpld_proc_open ( struct inode *inode, struct file *file )
-+{
-+	return single_open ( file, cpld_proc_show, PDE_DATA(inode) );
-+}
-+
-+static void cpld_versions_get ( struct seq_file *s )
-+{
-+	seq_printf(s, "CPLD1: V%d\n", cpld_r8(cpld1v));
-+	seq_printf(s, "CPLD2: V%d\n", cpld_r8(cpld2v));
-+}
-+
-+static void cpld_ebu_module_get ( struct seq_file *s )
-+{
-+	u8 addon_id;
-+
-+	addon_id = cpld_r8(idreg0) & 0xF;
-+	switch (addon_id) {
-+	case 0xF: /* nothing connected */
-+		break;
-+	case 1:
-+		seq_printf(s, "Ethernet Controller module (dm9000)\n");
-+		break;
-+	default:
-+		seq_printf(s, "Unknown EBU module (EBU_ID=0x%02X)\n", addon_id);
-+		break;
-+	}
-+}
-+
-+static void cpld_xmii_module_get ( struct seq_file *s )
-+{
-+	u8 addon_id;
-+	char *mod = NULL;
-+
-+	addon_id = cpld_r8(idreg1) & 0xF;
-+	switch (addon_id) {
-+	case 0xF:
-+		mod = "no module";
-+		break;
-+	case 0x1:
-+		mod = "RGMII module";
-+		break;
-+	case 0x4:
-+		mod = "GMII MAC Mode (XWAY TANTOS-3G)";
-+		break;
-+	case 0x5:
-+		mod = "MII MAC Mode (XWAY TANTOS-3G)";
-+		break;
-+	case 0x6:
-+		mod = "TMII MAC Mode (XWAY TANTOS-3G)";
-+		break;
-+	case 0x8:
-+		mod = "GMII PHY module";
-+		break;
-+	case 0x9:
-+		mod = "MII PHY module";
-+		break;
-+	case 0xA:
-+		mod = "RMII PHY module";
-+		break;
-+	default:
-+		break;
-+	}
-+	if (mod)
-+		seq_printf(s, "%s\n", mod);
-+	else
-+		seq_printf(s, "unknown xMII module (xMII_ID=0x%02X)\n", addon_id);
-+}
-+
-+static void cpld_sgmii_module_get ( struct seq_file *s )
-+{
-+	u8 addon_id;
-+	char *mod = NULL;
-+
-+	addon_id = cpld_r8(idreg1)>>4 & 0xF;
-+	switch (addon_id) {
-+	case 0xF:
-+		mod = "no module";
-+		break;
-+	case 0x1:
-+		mod = "SGMII module";
-+		break;
-+	default:
-+		mod = NULL;
-+		break;
-+	}
-+	if (mod)
-+		seq_printf(s, "%s\n", mod);
-+	else
-+		seq_printf(s, "unknown module (SGMII_ID=0x%02X) found\n", addon_id);
-+}
-+
-+static struct proc_entry proc_entries[] = {
-+	{"versions",	cpld_versions_get},
-+	{"ebu",		cpld_ebu_module_get},
-+	{"xmii",	cpld_xmii_module_get},
-+	{"sgmii",	cpld_sgmii_module_get},
-+};
-+
-+static struct file_operations ops = {
-+	.owner   = THIS_MODULE,
-+	.open    = cpld_proc_open,
-+	.read    = seq_read,
-+	.llseek  = seq_lseek,
-+	.release = single_release,
-+};
-+
-+static void cpld_proc_entry_create(struct proc_dir_entry *parent_node,
-+				   struct proc_entry *proc_entry)
-+{
-+	proc_create_data ( proc_entry->name, (S_IFREG | S_IRUGO), parent_node,
-+			   &ops, proc_entry->callback);
-+}
-+
-+static int cpld_proc_install(void)
-+{
-+	struct proc_dir_entry *driver_proc_node;
-+
-+	driver_proc_node = proc_mkdir("cpld", NULL);
-+	if (driver_proc_node != NULL) {
-+		int i;
-+		for (i = 0; i < ARRAY_SIZE(proc_entries); i++)
-+			cpld_proc_entry_create(driver_proc_node,
-+					      &proc_entries[i]);
-+	} else {
-+		printk("cannot create proc entry");
-+		return -1;
-+	}
-+	return 0;
-+}
-+#else
-+static inline int cpld_proc_install(void) {}
-+#endif
-+
-+static int easy98000_addon_probe(struct platform_device *pdev)
-+{
-+	return cpld_proc_install();
-+}
-+
-+static int easy98000_addon_remove(struct platform_device *pdev)
-+{
-+#if defined(CONFIG_PROC_FS)
-+	char buf[64];
-+	int i;
-+
-+	for (i = 0; i < sizeof(proc_entries) / sizeof(proc_entries[0]); i++) {
-+		sprintf(buf, "cpld/%s", proc_entries[i].name);
-+		remove_proc_entry(buf, 0);
-+	}
-+	remove_proc_entry("cpld", 0);
-+#endif
-+	return 0;
-+}
-+
-+static const struct of_device_id easy98000_addon_match[] = {
-+	{.compatible = "lantiq,easy98000_addon" },
-+	{},
-+};
-+
-+static struct platform_driver easy98000_addon_driver = {
-+	.probe = easy98000_addon_probe,
-+	.remove = easy98000_addon_remove,
-+	.driver = {
-+		.name = "easy98000_addon",
-+		.owner = THIS_MODULE,
-+		.of_match_table = easy98000_addon_match,
-+	},
-+};
-+
-+int __init easy98000_addon_init(void)
-+{
-+	return platform_driver_register(&easy98000_addon_driver);
-+}
-+
-+void __exit easy98000_addon_exit(void)
-+{
-+	platform_driver_unregister(&easy98000_addon_driver);
-+}
-+
-+module_init(easy98000_addon_init);
-+module_exit(easy98000_addon_exit);
-diff --git a/arch/mips/lantiq/falcon/dev-leds-easy98000-cpld.c b/arch/mips/lantiq/falcon/dev-leds-easy98000-cpld.c
-new file mode 100644
---- /dev/null
-+++ b/arch/mips/lantiq/falcon/dev-leds-easy98000-cpld.c
-@@ -0,0 +1,174 @@
-+/*
-+ *  EASY98000 CPLD LED driver
-+ *
-+ *  Copyright (C) 2013 Ralph Hempel <ralph.hempel@lantiq.com>
-+ *
-+ *  This program is free software; you can redistribute it and/or modify it
-+ *  under the terms of the GNU General Public License version 2  as published
-+ *  by the Free Software Foundation.
-+ *
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/module.h>
-+#include <linux/version.h>
-+#include <linux/types.h>
-+#include <linux/init.h>
-+#include <linux/platform_device.h>
-+#include <linux/of_platform.h>
-+#include <linux/errno.h>
-+#include <linux/leds.h>
-+#include <linux/slab.h>
-+
-+#ifdef CONFIG_LEDS_CLASS
-+
-+#define LED_NAME	"easy98000_cpld_led"
-+#define LED_DESC	"EASY98000 LED driver"
-+#define LED_VERSION	"1.0.1"
-+
-+#define MAX_LED		16
-+
-+const char *led_name[8] = {
-+	"ge0_act",
-+	"ge0_link",
-+	"ge1_act",
-+	"ge1_link",
-+	"fe2_act",
-+	"fe2_link",
-+	"fe3_act",
-+	"fe3_link"
-+};
-+
-+#define cpld_base7			((u16 *)(KSEG1 | 0x17c0000c))
-+#define cpld_base8			((u16 *)(KSEG1 | 0x17c00012))
-+
-+#define ltq_r16(reg)			__raw_readw(reg)
-+#define ltq_w16(val, reg)		__raw_writew(val, reg)
-+
-+struct cpld_led_dev {
-+	struct led_classdev	cdev;
-+	u8			mask;
-+	u16			*base;
-+};
-+
-+struct cpld_led_drvdata {
-+	struct cpld_led_dev	*led_devs;
-+	int			num_leds;
-+};
-+
-+void led_set(u8 mask, u16 *base)
-+{
-+	ltq_w16(ltq_r16(base) | mask, base);
-+}
-+
-+void led_clear(u8 mask, u16 *base)
-+{
-+	ltq_w16(ltq_r16(base) & (~mask), base);
-+}
-+
-+void led_blink_clear(u8 mask, u16 *base)
-+{
-+	led_clear(mask, base);
-+}
-+
-+static void led_brightness(struct led_classdev *led_cdev,
-+			       enum led_brightness value)
-+{
-+	struct cpld_led_dev *led_dev =
-+	    container_of(led_cdev, struct cpld_led_dev, cdev);
-+
-+	if (value)
-+		led_set(led_dev->mask, led_dev->base);
-+	else
-+		led_clear(led_dev->mask, led_dev->base);
-+}
-+
-+static int led_probe(struct platform_device *pdev)
-+{
-+	int i;
-+	char name[32];
-+	struct cpld_led_drvdata *drvdata;
-+	int ret = 0;
-+
-+	drvdata = kzalloc(sizeof(struct cpld_led_drvdata) +
-+			  sizeof(struct cpld_led_dev) * MAX_LED,
-+			  GFP_KERNEL);
-+	if (!drvdata)
-+		return -ENOMEM;
-+
-+	drvdata->led_devs = (struct cpld_led_dev *) &drvdata[1];
-+
-+	for (i = 0; i < MAX_LED; i++) {
-+		struct cpld_led_dev *led_dev = &drvdata->led_devs[i];
-+		led_dev->cdev.brightness_set = led_brightness;
-+		led_dev->cdev.default_trigger = NULL;
-+		led_dev->mask = 1 << (i % 8);
-+		if(i < 8) {
-+			sprintf(name, "easy98000-cpld:%s", led_name[i]);
-+			led_dev->base = cpld_base8;
-+		} else {
-+			sprintf(name, "easy98000-cpld:red:%d", i-8);
-+			led_dev->base = cpld_base7;
-+		}
-+		led_dev->cdev.name = name;
-+		ret = led_classdev_register(&pdev->dev, &led_dev->cdev);
-+		if (ret)
-+			goto err;
-+	}
-+	platform_set_drvdata(pdev, drvdata);
-+	return 0;
-+
-+err:
-+	for (i = i - 1; i >= 0; i--)
-+		led_classdev_unregister(&drvdata->led_devs[i].cdev);
-+
-+	kfree(drvdata);
-+	return ret;
-+}
-+
-+static int led_remove(struct platform_device *pdev)
-+{
-+	int i;
-+	struct cpld_led_drvdata *drvdata = platform_get_drvdata(pdev);
-+	for (i = 0; i < MAX_LED; i++)
-+		led_classdev_unregister(&drvdata->led_devs[i].cdev);
-+	kfree(drvdata);
-+	return 0;
-+}
-+
-+static const struct of_device_id led_driver_match[] = {
-+	{.compatible = "lantiq,easy98000_cpld_led" },
-+	{},
-+};
-+
-+static struct platform_driver led_driver = {
-+	.probe = led_probe,
-+	.remove = led_remove,
-+	.driver = {
-+		.name = LED_NAME,
-+		.owner = THIS_MODULE,
-+		.of_match_table = led_driver_match,
-+		},
-+};
-+
-+int __init easy98000_cpld_led_init(void)
-+{
-+	pr_info(LED_DESC ", Version " LED_VERSION
-+		" (c) Copyright 2013, Lantiq Deutschland GmbH\n");
-+	return platform_driver_register(&led_driver);
-+}
-+
-+void __exit easy98000_cpld_led_exit(void)
-+{
-+	platform_driver_unregister(&led_driver);
-+}
-+
-+module_init(easy98000_cpld_led_init);
-+module_exit(easy98000_cpld_led_exit);
-+
-+MODULE_DESCRIPTION(LED_NAME);
-+MODULE_DESCRIPTION(LED_DESC);
-+MODULE_AUTHOR("Ralph Hempel <ralph.hempel@lantiq.com>");
-+MODULE_LICENSE("GPL v2");
-+
-+#endif /* CONFIG_LEDS_CLASS */
diff --git a/target/linux/lantiq/patches-3.18/0500-MIPS-lantiq-VPE-extensions.patch b/target/linux/lantiq/patches-3.18/0500-MIPS-lantiq-VPE-extensions.patch
deleted file mode 100644
index 0df0fa0279..0000000000
--- a/target/linux/lantiq/patches-3.18/0500-MIPS-lantiq-VPE-extensions.patch
+++ /dev/null
@@ -1,983 +0,0 @@
-From: John Crispin <blogic@openwrt.org>
-Date: Thu, 29 Sep 2011 20:30:40 +0200
-
-[PATCH 15/25] VPE extensions
-
-From 1a3548545403c8f7cc02317643b616db6d0c9a4b Mon Sep 17 00:00:00 2001
----
- arch/mips/Kconfig                  |   22 +++
- arch/mips/include/asm/mipsmtregs.h |   54 +++++++
- arch/mips/kernel/Makefile          |    3 +-
- arch/mips/kernel/mips-mt.c         |   97 +++++++++++--
- arch/mips/kernel/mtsched_proc.c    |  279 ++++++++++++++++++++++++++++++++++++
- arch/mips/kernel/perf_proc.c       |  191 ++++++++++++++++++++++++
- arch/mips/kernel/proc.c            |   17 +++
- arch/mips/kernel/smtc.c            |    7 +
- arch/mips/kernel/vpe.c             |  250 ++++++++++++++++++++++++++++++++-
- 9 files changed, 905 insertions(+), 15 deletions(-)
- create mode 100644 arch/mips/kernel/mtsched_proc.c
- create mode 100644 arch/mips/kernel/perf_proc.c
-
-diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
---- a/arch/mips/Kconfig
-+++ b/arch/mips/Kconfig
-@@ -1999,6 +1999,28 @@ config MIPS_VPE_LOADER
- 	  Includes a loader for loading an elf relocatable object
- 	  onto another VPE and running it.
- 
-+config IFX_VPE_EXT
-+	bool "IFX APRP Extensions"
-+	depends on MIPS_VPE_LOADER
-+	default y
-+	help
-+	  IFX included extensions in APRP
-+
-+config PERFCTRS
-+	bool "34K Performance counters"
-+	depends on MIPS_MT && PROC_FS
-+	default n
-+	help
-+	  34K Performance counter through /proc
-+
-+config MTSCHED
-+	bool "Support mtsched priority configuration for TCs"
-+	depends on MIPS_MT && PROC_FS
-+	default y
-+	help
-+	  Support for mtsched priority configuration for TCs through
-+	  /proc/mips/mtsched
-+
- config MIPS_VPE_LOADER_CMP
- 	bool
- 	default "y"
-diff --git a/arch/mips/include/asm/mipsmtregs.h b/arch/mips/include/asm/mipsmtregs.h
---- a/arch/mips/include/asm/mipsmtregs.h
-+++ b/arch/mips/include/asm/mipsmtregs.h
-@@ -31,16 +31,32 @@
- #define read_c0_vpeconf1()		__read_32bit_c0_register($1, 3)
- #define write_c0_vpeconf1(val)		__write_32bit_c0_register($1, 3, val)
- 
-+#define read_c0_vpeschedule()           __read_32bit_c0_register($1, 5)
-+#define write_c0_vpeschedule(val)       __write_32bit_c0_register($1, 5, val)
-+
-+#define read_c0_vpeschefback()      	__read_32bit_c0_register($1, 6)
-+#define write_c0_vpeschefback(val)  	__write_32bit_c0_register($1, 6, val)
-+
-+#define read_c0_vpeopt()              __read_32bit_c0_register($1, 7)
-+#define write_c0_vpeopt(val)          __write_32bit_c0_register($1, 7, val)
-+
- #define read_c0_tcstatus()		__read_32bit_c0_register($2, 1)
- #define write_c0_tcstatus(val)		__write_32bit_c0_register($2, 1, val)
- 
- #define read_c0_tcbind()		__read_32bit_c0_register($2, 2)
-+#define write_c0_tcbind(val)		__write_32bit_c0_register($2, 2, val)
- 
- #define write_c0_tchalt(val)		__write_32bit_c0_register($2, 4, val)
- 
- #define read_c0_tccontext()		__read_32bit_c0_register($2, 5)
- #define write_c0_tccontext(val)		__write_32bit_c0_register($2, 5, val)
- 
-+#define read_c0_tcschedule()		__read_32bit_c0_register($2, 6)
-+#define write_c0_tcschedule(val)	__write_32bit_c0_register($2, 6, val)
-+
-+#define read_c0_tcschefback()		__read_32bit_c0_register($2, 7)
-+#define write_c0_tcschefback(val)	__write_32bit_c0_register($2, 7, val)
-+
- #else /* Assembly */
- /*
-  * Macros for use in assembly language code
-@@ -79,6 +95,8 @@
- #define MVPCONTROL_STLB_SHIFT	2
- #define MVPCONTROL_STLB		(_ULCAST_(1) << MVPCONTROL_STLB_SHIFT)
- 
-+#define MVPCONTROL_CPA_SHIFT	3
-+#define MVPCONTROL_CPA		(_ULCAST_(1) << MVPCONTROL_CPA_SHIFT)
- 
- /* MVPConf0 fields */
- #define MVPCONF0_PTC_SHIFT	0
-@@ -89,6 +107,8 @@
- #define MVPCONF0_TCA		( _ULCAST_(1) << MVPCONF0_TCA_SHIFT)
- #define MVPCONF0_PTLBE_SHIFT	16
- #define MVPCONF0_PTLBE		(_ULCAST_(0x3ff) << MVPCONF0_PTLBE_SHIFT)
-+#define MVPCONF0_PCP_SHIFT	27
-+#define MVPCONF0_PCP		(_ULCAST_(1) << MVPCONF0_PCP_SHIFT)
- #define MVPCONF0_TLBS_SHIFT	29
- #define MVPCONF0_TLBS		(_ULCAST_(1) << MVPCONF0_TLBS_SHIFT)
- #define MVPCONF0_M_SHIFT	31
-@@ -126,9 +146,25 @@
- #define VPECONF0_VPA		(_ULCAST_(1) << VPECONF0_VPA_SHIFT)
- #define VPECONF0_MVP_SHIFT	1
- #define VPECONF0_MVP		(_ULCAST_(1) << VPECONF0_MVP_SHIFT)
-+#define VPECONF0_ICS_SHIFT	16
-+#define VPECONF0_ICS		(_ULCAST_(1) << VPECONF0_ICS_SHIFT)
-+#define VPECONF0_DCS_SHIFT	17
-+#define VPECONF0_DCS		(_ULCAST_(1) << VPECONF0_DCS_SHIFT)
- #define VPECONF0_XTC_SHIFT	21
- #define VPECONF0_XTC		(_ULCAST_(0xff) << VPECONF0_XTC_SHIFT)
- 
-+/* VPEOpt fields */
-+#define VPEOPT_DWX_SHIFT	0
-+#define VPEOPT_IWX_SHIFT	8
-+#define VPEOPT_IWX0		( _ULCAST_(0x1) << VPEOPT_IWX_SHIFT)
-+#define VPEOPT_IWX1		( _ULCAST_(0x2) << VPEOPT_IWX_SHIFT)
-+#define VPEOPT_IWX2		( _ULCAST_(0x4) << VPEOPT_IWX_SHIFT)
-+#define VPEOPT_IWX3		( _ULCAST_(0x8) << VPEOPT_IWX_SHIFT)
-+#define VPEOPT_DWX0		( _ULCAST_(0x1) << VPEOPT_DWX_SHIFT)
-+#define VPEOPT_DWX1		( _ULCAST_(0x2) << VPEOPT_DWX_SHIFT)
-+#define VPEOPT_DWX2		( _ULCAST_(0x4) << VPEOPT_DWX_SHIFT)
-+#define VPEOPT_DWX3		( _ULCAST_(0x8) << VPEOPT_DWX_SHIFT)
-+
- /* VPEConf1 fields (per VPE) */
- #define VPECONF1_NCP1_SHIFT	0
- #define VPECONF1_NCP1		(_ULCAST_(0xff) << VPECONF1_NCP1_SHIFT)
-@@ -376,6 +412,14 @@ do {									\
- #define write_vpe_c0_vpeconf0(val)	mttc0(1, 2, val)
- #define read_vpe_c0_vpeconf1()		mftc0(1, 3)
- #define write_vpe_c0_vpeconf1(val)	mttc0(1, 3, val)
-+#define read_vpe_c0_vpeschedule()	mftc0(1, 5)
-+#define write_vpe_c0_vpeschedule(val)	mttc0(1, 5, val)
-+#define read_vpe_c0_vpeschefback()	mftc0(1, 6)
-+#define write_vpe_c0_vpeschefback(val)	mttc0(1, 6, val)
-+#define read_vpe_c0_vpeopt()		mftc0(1, 7)
-+#define write_vpe_c0_vpeopt(val)	mttc0(1, 7, val)
-+#define read_vpe_c0_wired()		mftc0(6, 0)
-+#define write_vpe_c0_wired(val)		mttc0(6, 0, val)
- #define read_vpe_c0_count()		mftc0(9, 0)
- #define write_vpe_c0_count(val)		mttc0(9, 0, val)
- #define read_vpe_c0_status()		mftc0(12, 0)
-@@ -407,6 +451,12 @@ do {									\
- #define write_tc_c0_tchalt(val)		mttc0(2, 4, val)
- #define read_tc_c0_tccontext()		mftc0(2, 5)
- #define write_tc_c0_tccontext(val)	mttc0(2, 5, val)
-+#define read_tc_c0_tcschedule()		mftc0(2, 6)
-+#define write_tc_c0_tcschedule(val)	mttc0(2, 6, val)
-+#define read_tc_c0_tcschefback()	mftc0(2, 7)
-+#define write_tc_c0_tcschefback(val)	mttc0(2, 7, val)
-+#define read_tc_c0_entryhi()            mftc0(10, 0)
-+#define write_tc_c0_entryhi(val)        mttc0(10, 0, val)
- 
- /* GPR */
- #define read_tc_gpr_sp()		mftgpr(29)
-diff --git a/arch/mips/include/asm/vpe.h b/arch/mips/include/asm/vpe.h
---- a/arch/mips/include/asm/vpe.h
-+++ b/arch/mips/include/asm/vpe.h
-@@ -38,6 +38,17 @@ static inline int aprp_cpu_index(void)
- #endif
- }
- 
-+/* For the explanation of the APIs please refer the section "MT APRP Kernel
-+ * Programming" in AR9 SW Architecture Specification
-+ */
-+int32_t vpe1_sw_start(void* sw_start_addr, uint32_t tcmask, uint32_t flags);
-+int32_t vpe1_sw_stop(uint32_t flags);
-+uint32_t vpe1_get_load_addr(uint32_t flags);
-+uint32_t vpe1_get_max_mem(uint32_t flags);
-+
-+int32_t vpe1_set_boot_param(char *field, char *value, char flags);
-+int32_t vpe1_get_boot_param(char *field, char **value, char flags);
-+
- enum vpe_state {
- 	VPE_STATE_UNUSED = 0,
- 	VPE_STATE_INUSE,
-diff --git a/arch/mips/kernel/Makefile b/arch/mips/kernel/Makefile
---- a/arch/mips/kernel/Makefile
-+++ b/arch/mips/kernel/Makefile
-@@ -79,7 +79,8 @@ obj-$(CONFIG_MIPS32_O32)	+= binfmt_elfo3
- 
- obj-$(CONFIG_KGDB)		+= kgdb.o
- obj-$(CONFIG_PROC_FS)		+= proc.o
--
-+obj-$(CONFIG_MTSCHED)		+= mtsched_proc.o
-+obj-$(CONFIG_PERFCTRS)		+= perf_proc.o
- obj-$(CONFIG_64BIT)		+= cpu-bugs64.o
- 
- obj-$(CONFIG_I8253)		+= i8253.o
-diff --git a/arch/mips/kernel/mips-mt.c b/arch/mips/kernel/mips-mt.c
---- a/arch/mips/kernel/mips-mt.c
-+++ b/arch/mips/kernel/mips-mt.c
-@@ -20,26 +20,96 @@
- #include <asm/cacheflush.h>
- 
- int vpelimit;
--
- static int __init maxvpes(char *str)
- {
- 	get_option(&str, &vpelimit);
--
- 	return 1;
- }
--
- __setup("maxvpes=", maxvpes);
- 
- int tclimit;
--
- static int __init maxtcs(char *str)
- {
- 	get_option(&str, &tclimit);
--
- 	return 1;
- }
-+__setup("maxtcs=", maxtcs);
- 
--__setup("maxtcs=", maxtcs);
-+#ifdef CONFIG_IFX_VPE_EXT
-+int stlb;
-+static int __init istlbshared(char *str)
-+{
-+	get_option(&str, &stlb);
-+	return 1;
-+}
-+__setup("vpe_tlb_shared=", istlbshared);
-+
-+int vpe0_wired;
-+static int __init vpe0wired(char *str)
-+{
-+	get_option(&str, &vpe0_wired);
-+	return 1;
-+}
-+__setup("vpe0_wired_tlb_entries=", vpe0wired);
-+
-+int vpe1_wired;
-+static int __init vpe1wired(char *str)
-+{
-+	get_option(&str, &vpe1_wired);
-+	return 1;
-+}
-+__setup("vpe1_wired_tlb_entries=", vpe1wired);
-+
-+#ifdef CONFIG_MIPS_MT_SMTC
-+extern int nostlb;
-+#endif
-+void configure_tlb(void)
-+{
-+	int vpeflags, tcflags, tlbsiz;
-+	unsigned int config1val;
-+	vpeflags = dvpe();
-+	tcflags = dmt();
-+	write_c0_vpeconf0((read_c0_vpeconf0() | VPECONF0_MVP));
-+	write_c0_mvpcontrol((read_c0_mvpcontrol() | MVPCONTROL_VPC));
-+	mips_ihb();
-+	//printk("stlb = %d, vpe0_wired = %d vpe1_wired=%d\n", stlb,vpe0_wired, vpe1_wired);
-+	if (stlb) {
-+		if (!(read_c0_mvpconf0() & MVPCONF0_TLBS)) {
-+			emt(tcflags);
-+			evpe(vpeflags);
-+			return;
-+		}
-+
-+		write_c0_mvpcontrol(read_c0_mvpcontrol() | MVPCONTROL_STLB);
-+		write_c0_wired(vpe0_wired + vpe1_wired);
-+		if (((read_vpe_c0_config() & MIPS_CONF_MT) >> 7) == 1) {
-+			config1val = read_vpe_c0_config1();
-+			tlbsiz = (((config1val >> 25) & 0x3f) + 1);
-+			if (tlbsiz > 64)
-+				tlbsiz = 64;
-+			cpu_data[0].tlbsize = tlbsiz;
-+			current_cpu_data.tlbsize = tlbsiz;
-+		}
-+
-+	}
-+	else {
-+		write_c0_mvpcontrol(read_c0_mvpcontrol() & ~MVPCONTROL_STLB);
-+		write_c0_wired(vpe0_wired);
-+	}
-+
-+	ehb();
-+	write_c0_mvpcontrol((read_c0_mvpcontrol() & ~MVPCONTROL_VPC));
-+	ehb();
-+	local_flush_tlb_all();
-+
-+	printk("Wired TLB entries for Linux read_c0_wired() = %d\n", read_c0_wired());
-+#ifdef CONFIG_MIPS_MT_SMTC
-+	nostlb = !stlb;
-+#endif
-+	emt(tcflags);
-+	evpe(vpeflags);
-+}
-+#endif
- 
- /*
-  * Dump new MIPS MT state for the core. Does not leave TCs halted.
-@@ -74,18 +144,18 @@ void mips_mt_regdump(unsigned long mvpct
- 			if ((read_tc_c0_tcbind() & TCBIND_CURVPE) == i) {
- 				printk("  VPE %d\n", i);
- 				printk("   VPEControl : %08lx\n",
--				       read_vpe_c0_vpecontrol());
-+					read_vpe_c0_vpecontrol());
- 				printk("   VPEConf0 : %08lx\n",
--				       read_vpe_c0_vpeconf0());
-+					read_vpe_c0_vpeconf0());
- 				printk("   VPE%d.Status : %08lx\n",
--				       i, read_vpe_c0_status());
-+					i, read_vpe_c0_status());
- 				printk("   VPE%d.EPC : %08lx %pS\n",
--				       i, read_vpe_c0_epc(),
--				       (void *) read_vpe_c0_epc());
-+					i, read_vpe_c0_epc(),
-+					(void *) read_vpe_c0_epc());
- 				printk("   VPE%d.Cause : %08lx\n",
--				       i, read_vpe_c0_cause());
-+					i, read_vpe_c0_cause());
- 				printk("   VPE%d.Config7 : %08lx\n",
--				       i, read_vpe_c0_config7());
-+					i, read_vpe_c0_config7());
- 				break; /* Next VPE */
- 			}
- 		}
-@@ -280,6 +350,9 @@ void mips_mt_set_cpuoptions(void)
- 		printk("Mapped %ld ITC cells starting at 0x%08x\n",
- 			((itcblkgrn & 0x7fe00000) >> 20), itc_base);
- 	}
-+#ifdef CONFIG_IFX_VPE_EXT
-+	configure_tlb();
-+#endif
- }
- 
- /*
-diff --git a/arch/mips/kernel/mtsched_proc.c b/arch/mips/kernel/mtsched_proc.c
-new file mode 100644
---- /dev/null
-+++ b/arch/mips/kernel/mtsched_proc.c
-@@ -0,0 +1,282 @@
-+/*
-+ * /proc hooks for MIPS MT scheduling policy management for 34K cores
-+ *
-+ *  This program is free software; you can distribute it and/or modify it
-+ *  under the terms of the GNU General Public License (Version 2) as
-+ *  published by the Free Software Foundation.
-+ *
-+ *  This program is distributed in the hope it will be useful, but WITHOUT
-+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-+ *  for more details.
-+ *
-+ *  You should have received a copy of the GNU General Public License along
-+ *  with this program; if not, write to the Free Software Foundation, Inc.,
-+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
-+ *
-+ * Copyright (C) 2006 Mips Technologies, Inc
-+ */
-+
-+#include <linux/kernel.h>
-+
-+#include <asm/cpu.h>
-+#include <asm/processor.h>
-+#include <asm/setup.h>
-+#include <asm/mipsregs.h>
-+#include <asm/mipsmtregs.h>
-+#include <asm/uaccess.h>
-+#include <linux/proc_fs.h>
-+#include <linux/seq_file.h>
-+
-+/*static struct proc_dir_entry *mtsched_proc;*/
-+
-+#ifndef CONFIG_MIPS_MT_SMTC
-+#define NTCS 2
-+#else
-+#define NTCS NR_CPUS
-+#endif
-+#define NVPES 2
-+
-+int lastvpe = 1;
-+int lasttc = 8;
-+
-+static int proc_read_mtsched (struct seq_file *s)
-+{
-+	int i;
-+	int vpe;
-+	int mytc;
-+	unsigned long flags;
-+	unsigned int mtflags;
-+	unsigned int haltstate;
-+	unsigned int vpes_checked[NVPES];
-+	unsigned int vpeschedule[NVPES];
-+	unsigned int vpeschefback[NVPES];
-+	unsigned int tcschedule[NTCS];
-+	unsigned int tcschefback[NTCS];
-+
-+	/* Dump the state of the MIPS MT scheduling policy manager */
-+	/* Inititalize control state */
-+	for(i = 0; i < NVPES; i++) {
-+		vpes_checked[i] = 0;
-+		vpeschedule[i] = 0;
-+		vpeschefback[i] = 0;
-+	}
-+	for(i = 0; i < NTCS; i++) {
-+		tcschedule[i] = 0;
-+		tcschefback[i] = 0;
-+	}
-+	
-+	/* Disable interrupts and multithreaded issue */
-+	local_irq_save(flags);
-+	mtflags = dvpe();
-+
-+	/* Then go through the TCs, halt 'em, and extract the values */
-+	mytc = (read_c0_tcbind() & TCBIND_CURTC) >> TCBIND_CURTC_SHIFT;
-+	for(i = 0; i < NTCS; i++) {
-+		if(i == mytc) {
-+			/* No need to halt ourselves! */
-+			tcschedule[i] = read_c0_tcschedule();
-+			tcschefback[i] = read_c0_tcschefback();
-+			/* If VPE bound to TC hasn't been checked, do it */
-+			vpe = read_c0_tcbind() & TCBIND_CURVPE;
-+			if(!vpes_checked[vpe]) {
-+				vpeschedule[vpe] = read_c0_vpeschedule();
-+				vpeschefback[vpe] = read_c0_vpeschefback();
-+				vpes_checked[vpe] = 1;
-+			}
-+		} else {
-+			settc(i);
-+			haltstate = read_tc_c0_tchalt();
-+			write_tc_c0_tchalt(TCHALT_H);
-+			mips_ihb();
-+			tcschedule[i] = read_tc_c0_tcschedule();
-+			tcschefback[i] = read_tc_c0_tcschefback();
-+			/* If VPE bound to TC hasn't been checked, do it */
-+			vpe = read_tc_c0_tcbind() & TCBIND_CURVPE;
-+			if(!vpes_checked[vpe]) {
-+			    vpeschedule[vpe] = read_vpe_c0_vpeschedule();
-+			    vpeschefback[vpe] = read_vpe_c0_vpeschefback();
-+			    vpes_checked[vpe] = 1;
-+			}
-+			if(!haltstate) write_tc_c0_tchalt(0);
-+		}
-+	}
-+	/* Re-enable MT and interrupts */
-+	evpe(mtflags);
-+	local_irq_restore(flags);
-+	for(vpe=0; vpe < NVPES; vpe++) {
-+		seq_printf(s, "VPE[%d].VPEschedule  = 0x%08x\n",
-+			vpe, vpeschedule[vpe]);
-+		seq_printf(s, "VPE[%d].VPEschefback = 0x%08x\n",
-+			vpe, vpeschefback[vpe]);
-+	}
-+	for(i=0; i < NTCS; i++) {
-+		seq_printf(s, "TC[%d].TCschedule    = 0x%08x\n",
-+			i, tcschedule[i]);
-+		seq_printf(s, "TC[%d].TCschefback   = 0x%08x\n",
-+			i, tcschefback[i]);
-+	}
-+
-+	return 0;
-+}
-+
-+/*
-+ * Write to perf counter registers based on text input
-+ */
-+
-+#define TXTBUFSZ 100
-+static int proc_write_mtsched(struct file *file, const __user char *buffer,
-+				size_t count, loff_t *offset)
-+{
-+	int len = 0;
-+	char mybuf[TXTBUFSZ];
-+	/* At most, we will set up 9 TCs and 2 VPEs, 11 entries in all */
-+	char entity[1];   //, entity1[1];
-+	int number[1];
-+	unsigned long value[1];
-+	int nparsed = 0 , index = 0;
-+	unsigned long flags;
-+	unsigned int mtflags;
-+	unsigned int haltstate;
-+	unsigned int tcbindval;
-+
-+	if(count >= TXTBUFSZ) len = TXTBUFSZ-1;
-+	else len = count;
-+	memset(mybuf,0,TXTBUFSZ);
-+	if(copy_from_user(mybuf, buffer, len)) return -EFAULT;
-+
-+	nparsed = sscanf(mybuf, "%c%d %lx",
-+		 &entity[0] ,&number[0], &value[0]);
-+
-+	/*
-+	 * Having acquired the inputs, which might have
-+	 * generated exceptions and preemptions,
-+	 * program the registers.
-+	 */
-+	/* Disable interrupts and multithreaded issue */
-+	local_irq_save(flags);
-+	mtflags = dvpe();
-+
-+	if(entity[index] == 't' ) {
-+		/* Set TCSchedule or TCScheFBack of specified TC */
-+		if(number[index] > NTCS) goto skip;
-+		/* If it's our own TC, do it direct */
-+		if(number[index] ==
-+				((read_c0_tcbind() & TCBIND_CURTC)
-+				>> TCBIND_CURTC_SHIFT)) {
-+			if(entity[index] == 't')
-+				 write_c0_tcschedule(value[index]);
-+			else
-+				write_c0_tcschefback(value[index]);
-+		} else {
-+		/* Otherwise, we do it via MTTR */
-+			settc(number[index]);
-+			haltstate = read_tc_c0_tchalt();
-+			write_tc_c0_tchalt(TCHALT_H);
-+			mips_ihb();
-+			if(entity[index] == 't')
-+				 write_tc_c0_tcschedule(value[index]);
-+			else
-+				write_tc_c0_tcschefback(value[index]);
-+			mips_ihb();
-+			if(!haltstate) write_tc_c0_tchalt(0);
-+		}
-+	} else if(entity[index] == 'v') {
-+		/* Set VPESchedule of specified VPE */
-+		if(number[index] > NVPES) goto skip;
-+		tcbindval = read_c0_tcbind();
-+		/* Are we doing this to our current VPE? */
-+		if((tcbindval & TCBIND_CURVPE) == number[index]) {
-+			/* Then life is simple */
-+			write_c0_vpeschedule(value[index]);
-+		} else {
-+			/*
-+			 * Bind ourselves to the other VPE long enough
-+			 * to program the bind value.
-+			 */
-+			write_c0_tcbind((tcbindval & ~TCBIND_CURVPE)
-+					   | number[index]);
-+			mips_ihb();
-+			write_c0_vpeschedule(value[index]);
-+			mips_ihb();
-+			/* Restore previous binding */
-+			write_c0_tcbind(tcbindval);
-+			mips_ihb();
-+		}
-+	}
-+
-+	else if(entity[index] == 'r') {
-+		unsigned int vpes_checked[2], vpe ,i , mytc;
-+		vpes_checked[0] = vpes_checked[1] = 0;
-+
-+		/* Then go through the TCs, halt 'em, and extract the values */
-+		mytc = (read_c0_tcbind() & TCBIND_CURTC) >> TCBIND_CURTC_SHIFT;
-+
-+		for(i = 0; i < NTCS; i++) {
-+			if(i == mytc) {
-+				/* No need to halt ourselves! */
-+				write_c0_vpeschefback(0);
-+				write_c0_tcschefback(0);
-+			} else {
-+				settc(i);
-+				haltstate = read_tc_c0_tchalt();
-+				write_tc_c0_tchalt(TCHALT_H);
-+				mips_ihb();
-+				write_tc_c0_tcschefback(0);
-+				/* If VPE bound to TC hasn't been checked, do it */
-+				vpe = read_tc_c0_tcbind() & TCBIND_CURVPE;
-+				if(!vpes_checked[vpe]) {
-+				    write_vpe_c0_vpeschefback(0);
-+				    vpes_checked[vpe] = 1;
-+				}
-+				if(!haltstate) write_tc_c0_tchalt(0);
-+			}
-+		}
-+	}
-+	else {
-+		printk ("\n Usage : <t/v><0/1> <Hex Value>\n Example : t0 0x01\n");
-+	}
-+
-+skip:
-+	/* Re-enable MT and interrupts */
-+	evpe(mtflags);
-+	local_irq_restore(flags);
-+	return (len);
-+}
-+
-+static int mtsched_proc_show (struct seq_file *s, void *p)
-+{
-+	seq_printf(s, "mtsched_proc_show\n");
-+	return proc_read_mtsched (s);
-+}
-+
-+static int mtsched_proc_open (struct inode *inode, struct file *file)
-+{
-+	return single_open (file, mtsched_proc_show, NULL);
-+}
-+
-+
-+static const struct file_operations mtsched_proc_fops = {
-+  .owner = THIS_MODULE,
-+  .open = mtsched_proc_open,
-+  .read = seq_read,
-+  .write = proc_write_mtsched,
-+  .llseek = seq_lseek,
-+  .release = single_release,
-+};
-+
-+static int __init init_mtsched_proc(void)
-+{
-+	extern struct proc_dir_entry *get_mips_proc_dir(void);
-+
-+	if (!cpu_has_mipsmt) {
-+		printk("mtsched: not a MIPS MT capable processor\n");
-+		return -ENODEV;
-+	}
-+	proc_create ("mtsched", 0, get_mips_proc_dir(), &mtsched_proc_fops);
-+
-+	return 0;
-+}
-+
-+/* Automagically create the entry */
-+module_init(init_mtsched_proc);
-diff --git a/arch/mips/kernel/perf_proc.c b/arch/mips/kernel/perf_proc.c
-new file mode 100644
---- /dev/null
-+++ b/arch/mips/kernel/perf_proc.c
-@@ -0,0 +1,191 @@
-+/*
-+ * /proc hooks for CPU performance counter support for SMTC kernel
-+ * (and ultimately others)
-+ * Copyright (C) 2006 Mips Technologies, Inc
-+ */
-+
-+#include <linux/kernel.h>
-+
-+#include <asm/cpu.h>
-+#include <asm/processor.h>
-+#include <asm/setup.h>
-+#include <asm/mipsregs.h>
-+#include <asm/uaccess.h>
-+#include <linux/proc_fs.h>
-+
-+/*
-+ * /proc diagnostic and statistics hooks
-+ */
-+
-+
-+/* Internal software-extended event counters */
-+
-+static unsigned long long extencount[4] = {0,0,0,0};
-+
-+static struct proc_dir_entry *perf_proc;
-+
-+static int proc_read_perf(char *page, char **start, off_t off,
-+				int count, int *eof, void *data)
-+{
-+	int totalen = 0;
-+	int len;
-+
-+	len = sprintf(page, "PerfCnt[0].Ctl : 0x%08x\n", read_c0_perfctrl0());
-+	totalen += len;
-+	page += len;
-+	len = sprintf(page, "PerfCnt[0].Cnt : %Lu\n",
-+		extencount[0] + (unsigned long long)((unsigned)read_c0_perfcntr0()));
-+	totalen += len;
-+	page += len;
-+	len = sprintf(page, "PerfCnt[1].Ctl : 0x%08x\n", read_c0_perfctrl1());
-+	totalen += len;
-+	page += len;
-+	len = sprintf(page, "PerfCnt[1].Cnt : %Lu\n",
-+		extencount[1] + (unsigned long long)((unsigned)read_c0_perfcntr1()));
-+	totalen += len;
-+	page += len;
-+	len = sprintf(page, "PerfCnt[2].Ctl : 0x%08x\n", read_c0_perfctrl2());
-+	totalen += len;
-+	page += len;
-+	len = sprintf(page, "PerfCnt[2].Cnt : %Lu\n",
-+		extencount[2] + (unsigned long long)((unsigned)read_c0_perfcntr2()));
-+	totalen += len;
-+	page += len;
-+	len = sprintf(page, "PerfCnt[3].Ctl : 0x%08x\n", read_c0_perfctrl3());
-+	totalen += len;
-+	page += len;
-+	len = sprintf(page, "PerfCnt[3].Cnt : %Lu\n",
-+		extencount[3] + (unsigned long long)((unsigned)read_c0_perfcntr3()));
-+	totalen += len;
-+	page += len;
-+
-+	return totalen;
-+}
-+
-+/*
-+ * Write to perf counter registers based on text input
-+ */
-+
-+#define TXTBUFSZ 100
-+
-+static int proc_write_perf(struct file *file, const char *buffer,
-+				unsigned long count, void *data)
-+{
-+	int len;
-+	int nparsed;
-+	int index;
-+	char mybuf[TXTBUFSZ];
-+
-+	int which[4];
-+	unsigned long control[4];
-+	long long ctrdata[4];
-+
-+	if(count >= TXTBUFSZ) len = TXTBUFSZ-1;
-+	else len = count;
-+	memset(mybuf,0,TXTBUFSZ);
-+	if(copy_from_user(mybuf, buffer, len)) return -EFAULT;
-+
-+	nparsed = sscanf(mybuf,
-+			"%d %lx %Ld %d %lx %Ld %d %lx %Ld %d %lx %Ld",
-+				&which[0], &control[0], &ctrdata[0],
-+				&which[1], &control[1], &ctrdata[1],
-+				&which[2], &control[2], &ctrdata[2],
-+				&which[3], &control[3], &ctrdata[3]);
-+
-+	for(index = 0; nparsed >= 3; index++) {
-+		switch (which[index]) {
-+		case 0:
-+			write_c0_perfctrl0(control[index]);
-+			if(ctrdata[index] != -1) {
-+			    extencount[0] = (unsigned long long)ctrdata[index];
-+			    write_c0_perfcntr0((unsigned long)0);
-+			}
-+			break;
-+		case 1:
-+			write_c0_perfctrl1(control[index]);
-+			if(ctrdata[index] != -1) {
-+			    extencount[1] = (unsigned long long)ctrdata[index];
-+			    write_c0_perfcntr1((unsigned long)0);
-+			}
-+			break;
-+		case 2:
-+			write_c0_perfctrl2(control[index]);
-+			if(ctrdata[index] != -1) {
-+			    extencount[2] = (unsigned long long)ctrdata[index];
-+			    write_c0_perfcntr2((unsigned long)0);
-+			}
-+			break;
-+		case 3:
-+			write_c0_perfctrl3(control[index]);
-+			if(ctrdata[index] != -1) {
-+			    extencount[3] = (unsigned long long)ctrdata[index];
-+			    write_c0_perfcntr3((unsigned long)0);
-+			}
-+			break;
-+		}
-+		nparsed -= 3;
-+	}
-+	return (len);
-+}
-+
-+extern int (*perf_irq)(void);
-+
-+/*
-+ * Invoked when timer interrupt vector picks up a perf counter overflow
-+ */
-+
-+static int perf_proc_irq(void)
-+{
-+	unsigned long snapshot;
-+
-+	/*
-+	 * It would be nice to do this as a loop, but we don't have
-+	 * indirect access to CP0 registers.
-+	 */
-+	snapshot = read_c0_perfcntr0();
-+	if ((long)snapshot < 0) {
-+		extencount[0] +=
-+			(unsigned long long)((unsigned)read_c0_perfcntr0());
-+		write_c0_perfcntr0(0);
-+	}
-+	snapshot = read_c0_perfcntr1();
-+	if ((long)snapshot < 0) {
-+		extencount[1] +=
-+			(unsigned long long)((unsigned)read_c0_perfcntr1());
-+		write_c0_perfcntr1(0);
-+	}
-+	snapshot = read_c0_perfcntr2();
-+	if ((long)snapshot < 0) {
-+		extencount[2] +=
-+			(unsigned long long)((unsigned)read_c0_perfcntr2());
-+		write_c0_perfcntr2(0);
-+	}
-+	snapshot = read_c0_perfcntr3();
-+	if ((long)snapshot < 0) {
-+		extencount[3] +=
-+			(unsigned long long)((unsigned)read_c0_perfcntr3());
-+		write_c0_perfcntr3(0);
-+	}
-+	return 0;
-+}
-+
-+static int __init init_perf_proc(void)
-+{
-+	extern struct proc_dir_entry *get_mips_proc_dir(void);
-+
-+	struct proc_dir_entry *mips_proc_dir = get_mips_proc_dir();
-+
-+	write_c0_perfcntr0(0);
-+	write_c0_perfcntr1(0);
-+	write_c0_perfcntr2(0);
-+	write_c0_perfcntr3(0);
-+	perf_proc = create_proc_entry("perf", 0644, mips_proc_dir);
-+	perf_proc->read_proc = proc_read_perf;
-+	perf_proc->write_proc = proc_write_perf;
-+	perf_irq = perf_proc_irq;
-+
-+	return 0;
-+}
-+
-+/* Automagically create the entry */
-+module_init(init_perf_proc);
-diff --git a/arch/mips/kernel/proc.c b/arch/mips/kernel/proc.c
---- a/arch/mips/kernel/proc.c
-+++ b/arch/mips/kernel/proc.c
-@@ -7,6 +7,7 @@
- #include <linux/kernel.h>
- #include <linux/sched.h>
- #include <linux/seq_file.h>
-+#include <linux/proc_fs.h>
- #include <asm/bootinfo.h>
- #include <asm/cpu.h>
- #include <asm/cpu-features.h>
-@@ -166,3 +167,19 @@ const struct seq_operations cpuinfo_op =
- 	.stop	= c_stop,
- 	.show	= show_cpuinfo,
- };
-+
-+/*
-+ * Support for MIPS/local /proc hooks in /proc/mips/
-+ */
-+
-+static struct proc_dir_entry *mips_proc = NULL;
-+
-+struct proc_dir_entry *get_mips_proc_dir(void)
-+{
-+       /*
-+        * This ought not to be preemptable.
-+        */
-+       if(mips_proc == NULL)
-+               mips_proc = proc_mkdir("mips", NULL);
-+       return(mips_proc);
-+}
-diff --git a/arch/mips/kernel/vpe.c b/arch/mips/kernel/vpe.c
---- a/arch/mips/kernel/vpe.c
-+++ b/arch/mips/kernel/vpe.c
-@@ -138,12 +138,39 @@ void release_vpe(struct vpe *v)
- 	kfree(v);
- }
- 
-+static void __maybe_unused dump_mtregs(void)
-+{
-+	unsigned long val;
-+
-+	val = read_c0_config3();
-+	printk("config3 0x%lx MT %ld\n", val,
-+	       (val & CONFIG3_MT) >> CONFIG3_MT_SHIFT);
-+
-+	val = read_c0_mvpcontrol();
-+	printk("MVPControl 0x%lx, STLB %ld VPC %ld EVP %ld\n", val,
-+	       (val & MVPCONTROL_STLB) >> MVPCONTROL_STLB_SHIFT,
-+	       (val & MVPCONTROL_VPC) >> MVPCONTROL_VPC_SHIFT,
-+	       (val & MVPCONTROL_EVP));
-+
-+	val = read_c0_mvpconf0();
-+	printk("mvpconf0 0x%lx, PVPE %ld PTC %ld M %ld\n", val,
-+	       (val & MVPCONF0_PVPE) >> MVPCONF0_PVPE_SHIFT,
-+	       val & MVPCONF0_PTC, (val & MVPCONF0_M) >> MVPCONF0_M_SHIFT);
-+}
-+
- /* Find some VPE program space */
- void *alloc_progmem(unsigned long len)
- {
- 	void *addr;
- 
- #ifdef CONFIG_MIPS_VPE_LOADER_TOM
-+#ifdef CONFIG_IFX_VPE_EXT
-+	if (vpe1_load_addr) {
-+		memset((void *)vpe1_load_addr, 0, len);
-+		return (void *)vpe1_load_addr;
-+	}
-+#endif
-+
- 	/*
- 	 * This means you must tell Linux to use less memory than you
- 	 * physically have, for example by passing a mem= boot argument.
-@@ -381,6 +408,20 @@ static int apply_r_mips_lo16(struct modu
- 		mips_hi16_list = NULL;
- 	}
- 
-+#if defined(CONFIG_IFX_VPE_EXT) && 0
-+	/*
-+	 * $a2 & $a3 are used to pass command line parameters to VPE1. $a2
-+	 * points to the start of the command line string and $a3 points to
-+	 * the end of the string. This convention is identical to the Linux
-+	 * kernel boot parameter passing mechanism. Please note that $a3 is
-+	 * used to pass physical memory size or 0 in SDE tool kit. So, if you
-+	 * are passing comand line parameters through $a2 & $a3 SDE programs
-+	 * don't work as desired.
-+	 */
-+	mttgpr(6, command_line);
-+	mttgpr(7, (command_line + strlen(command_line)));
-+	if (is_sdepgm)
-+#endif
- 	/*
- 	 * Ok, we're done with the HI16 relocs.	 Now deal with the LO16.
- 	 */
-@@ -565,6 +606,9 @@ static int find_vpe_symbols(struct vpe *
- 	if ((v->__start == 0) || (v->shared_ptr == NULL))
- 		return -1;
- 
-+#ifdef CONFIG_IFX_VPE_EXT
-+	is_sdepgm = 1;
-+#endif
- 	return 0;
- }
- 
-@@ -732,6 +776,15 @@ static int vpe_elfload(struct vpe *v)
- 			   (unsigned long)v->load_addr + v->len);
- 
- 	if ((find_vpe_symbols(v, sechdrs, symindex, strtab, &mod)) < 0) {
-+#ifdef CONFIG_IFX_VPE_EXT
-+		if (vpe1_load_addr) {
-+			/* Conversion to KSEG1 is required ??? */
-+			v->__start = KSEG1ADDR(vpe1_load_addr);
-+			is_sdepgm = 0;
-+			return 0;
-+		}
-+#endif
-+
- 		if (v->__start == 0) {
- 			pr_warn("VPE loader: program does not contain a __start symbol\n");
- 			return -ENOEXEC;
-@@ -768,6 +821,9 @@ static int vpe_open(struct inode *inode,
- 	struct vpe_notifications *notifier;
- 	struct vpe *v;
- 	int ret;
-+#ifdef CONFIG_IFX_VPE_EXT
-+   int progsize;
-+#endif
- 
- 	if (VPE_MODULE_MINOR != iminor(inode)) {
- 		/* assume only 1 device at the moment. */
-@@ -793,7 +849,12 @@ static int vpe_open(struct inode *inode,
- 		release_progmem(v->load_addr);
- 		cleanup_tc(get_tc(aprp_cpu_index()));
- 	}
--
-+#ifdef CONFIG_IFX_VPE_EXT
-+	progsize = (vpe1_mem  != 0) ? vpe1_mem : P_SIZE;
-+	//printk("progsize = %x\n", progsize);
-+	v->pbuffer = vmalloc(progsize);
-+	v->plen = progsize;
-+#else
- 	/* this of-course trashes what was there before... */
- 	v->pbuffer = vmalloc(P_SIZE);
- 	if (!v->pbuffer) {
-@@ -870,6 +931,18 @@ static ssize_t vpe_write(struct file *fi
- 		pr_warn("VPE loader: elf size too big. Perhaps strip uneeded symbols\n");
- 		return -ENOMEM;
- 	}
-+#ifdef CONFIG_IFX_VPE_EXT
-+#ifndef CONFIG_MIPS_MT_SMTC
-+	configure_tlb();
-+#endif
-+#endif
-+
-+#ifndef CONFIG_MIPS_MT_SMTC
-+	if (!vpelimit)
-+		vpelimit = 1;
-+	if (!tclimit)
-+		tclimit = 1;
-+#endif
- 
- 	count -= copy_from_user(v->pbuffer + v->len, buffer, count);
- 	if (!count)
diff --git a/target/linux/lantiq/patches-3.18/0501-MIPS-lantiq-VPE-softdog.patch b/target/linux/lantiq/patches-3.18/0501-MIPS-lantiq-VPE-softdog.patch
deleted file mode 100644
index 42693bf467..0000000000
--- a/target/linux/lantiq/patches-3.18/0501-MIPS-lantiq-VPE-softdog.patch
+++ /dev/null
@@ -1,178 +0,0 @@
-From 79bbd1bfeb1dd9c66dd81605611d8d1db3e81822 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Thu, 29 Sep 2011 21:29:14 +0200
-Subject: [PATCH 16/25] VPE softdog
-
---- /dev/null
-+++ b/arch/mips/include/asm/mach-lantiq/softdog_vpe.h
-@@ -0,0 +1,40 @@
-+/*
-+ *   This program is free software; you can redistribute it and/or modify
-+ *   it under the terms of the GNU General Public License as published by
-+ *   the Free Software Foundation; either version 2 of the License, or
-+ *   (at your option) any later version.
-+ *
-+ *   This program is distributed in the hope that it will be useful,
-+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ *   GNU General Public License for more details.
-+ *
-+ *   You should have received a copy of the GNU General Public License
-+ *   along with this program; if not, write to the Free Software
-+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
-+ *
-+ *   Copyright (C) 2005 infineon
-+ *   Copyright (C) 2007 John Crispin <blogic@openwrt.org>
-+ *
-+ */
-+#ifndef _SOFTDOG_VPE_H__
-+#define _SOFTDOG_VPE_H__
-+
-+typedef int (*VPE_SW_WDOG_RESET)(unsigned long wdog_cleared_ok_count);
-+
-+#ifdef CONFIG_VPE_SOFTDOG
-+extern unsigned long vpe1_wdog_ctr;
-+extern unsigned long vpe1_wdog_timeout;
-+
-+unsigned long vpe1_sw_wdog_start(unsigned long);
-+unsigned long vpe1_sw_wdog_stop(unsigned long);
-+
-+int32_t vpe1_sw_wdog_register_reset_handler(VPE_SW_WDOG_RESET reset_fn);
-+#else
-+static inline unsigned long vpe1_sw_wdog_start(unsigned long flags) { return 0; }
-+static inline unsigned long vpe1_sw_wdog_stop(unsigned long flags) { return 0; }
-+
-+static inline int32_t vpe1_sw_wdog_register_reset_handler(VPE_SW_WDOG_RESET reset_fn) { return 0; }
-+#endif
-+
-+#endif
---- a/arch/mips/lantiq/Kconfig
-+++ b/arch/mips/lantiq/Kconfig
-@@ -51,4 +51,8 @@ config XRX200_PHY_FW
- 	bool "XRX200 PHY firmware loader"
- 	depends on SOC_XWAY
- 
-+config VPE_SOFTDOG
-+	bool "VPE1 watchdog"
-+	depends on MIPS_VPE_LOADER
-+
- endif
---- a/arch/mips/lantiq/Makefile
-+++ b/arch/mips/lantiq/Makefile
-@@ -7,6 +7,7 @@
- obj-y := irq.o clk.o prom.o
- 
- obj-$(CONFIG_EARLY_PRINTK) += early_printk.o
-+obj-$(CONFIG_VPE_SOFTDOG) += softdog_vpe.o
- 
- obj-$(CONFIG_SOC_TYPE_XWAY) += xway/
- obj-$(CONFIG_SOC_FALCON) += falcon/
---- /dev/null
-+++ b/arch/mips/lantiq/softdog_vpe.c
-@@ -0,0 +1,106 @@
-+/*
-+** =============================================================================
-+** FILE NAME     : softdog_vpe.c
-+** MODULES       : LXDB
-+** DATE          : 24-03-2008
-+** AUTHOR        : LXDB Team
-+** DESCRIPTION   : This header file contains the code for the watchdog
-+**                 implementation on vpe1 side.
-+** REFERENCES    :
-+** COPYRIGHT     : Copyright (c) 2008
-+**                 Am Campeon 1-12, 85579 Neubiberg, Germany
-+**
-+** HISTORY       :
-+** $Date   $Author    $Comment
-+** 24-03-2008   LXDB    Initial version
-+** ============================================================================
-+*/
-+
-+#include <linux/module.h>
-+#include <linux/moduleparam.h>
-+#include <linux/types.h>
-+#include <linux/timer.h>
-+#include <linux/reboot.h>
-+#include <linux/init.h>
-+#include <linux/jiffies.h>
-+
-+#include <asm/softdog_vpe.h>
-+
-+static unsigned long last_wdog_value;
-+static unsigned long vpe1_wdog_cleared;
-+
-+static unsigned long vpe1_wdog_dead;
-+static void watchdog_vpe0_fire(unsigned long); /* Called when vpe0 timer expires */
-+static void keep_alive_vpe0(unsigned long);
-+VPE_SW_WDOG_RESET reset_local_fn;
-+
-+
-+static struct timer_list watchdog_vpe0_ticktock =
-+                TIMER_INITIALIZER(watchdog_vpe0_fire, 0, 0);
-+
-+static void watchdog_vpe0_fire (unsigned long flags)
-+{
-+	volatile unsigned long *wdog_ctr_value;
-+	wdog_ctr_value = (void*)vpe1_wdog_ctr;
-+	if (*wdog_ctr_value == last_wdog_value) { /* VPE1 watchdog expiry handling */
-+		vpe1_sw_wdog_stop(flags);
-+		vpe1_wdog_dead++;
-+		printk(KERN_DEBUG "VPE1 watchdog reset handler called\n");
-+	/* Call the reset handler function */
-+		reset_local_fn(flags);
-+	} else { /* Everything is OK on vpe1 side. Continue. */
-+		last_wdog_value = *wdog_ctr_value;
-+		vpe1_wdog_cleared++;
-+		keep_alive_vpe0(flags);
-+	}
-+}
-+
-+int32_t vpe1_sw_wdog_register_reset_handler (VPE_SW_WDOG_RESET reset_fn)
-+{
-+	reset_local_fn = (VPE_SW_WDOG_RESET)reset_fn;
-+	return 0;
-+}
-+
-+static void keep_alive_vpe0(unsigned long flags)
-+{
-+	mod_timer(&watchdog_vpe0_ticktock, jiffies+ vpe1_wdog_timeout );
-+}
-+
-+unsigned long vpe1_sw_wdog_start(unsigned long flags)
-+{
-+	volatile unsigned long *wdog_ctr_value;
-+	wdog_ctr_value = (void*)vpe1_wdog_ctr;
-+	*wdog_ctr_value = 0;
-+	last_wdog_value = 0;
-+	keep_alive_vpe0(flags);
-+	return 0;
-+}
-+
-+unsigned long vpe1_sw_wdog_stop(unsigned long flags)
-+{
-+	del_timer(&watchdog_vpe0_ticktock);
-+	return 0;
-+}
-+
-+static int __init watchdog_vpe1_init(void)
-+{
-+	/* Nothing to be done here */
-+	return 0;
-+}
-+
-+static void __exit watchdog_vpe1_exit(void)
-+{
-+	unsigned long flags=0;
-+	vpe1_sw_wdog_stop(flags);
-+}
-+
-+module_init(watchdog_vpe1_init);
-+module_exit(watchdog_vpe1_exit);
-+
-+EXPORT_SYMBOL(vpe1_sw_wdog_register_reset_handler);
-+EXPORT_SYMBOL(vpe1_sw_wdog_start);
-+EXPORT_SYMBOL(vpe1_sw_wdog_stop);
-+
-+MODULE_AUTHOR("LXDB");
-+MODULE_DESCRIPTION("Software Watchdog For VPE1");
-+MODULE_LICENSE("GPL");
diff --git a/target/linux/lantiq/patches-3.18/0502-MIPS-lantiq-add-physical_memsize.patch b/target/linux/lantiq/patches-3.18/0502-MIPS-lantiq-add-physical_memsize.patch
deleted file mode 100644
index 90a919bf17..0000000000
--- a/target/linux/lantiq/patches-3.18/0502-MIPS-lantiq-add-physical_memsize.patch
+++ /dev/null
@@ -1,44 +0,0 @@
-CONFIG_MIPS_VPE_LOADER requires us to provide physical_memsize for VPE1
-
-diff --git a/arch/mips/lantiq/prom.c b/arch/mips/lantiq/prom.c
---- a/arch/mips/lantiq/prom.c
-+++ b/arch/mips/lantiq/prom.c
-@@ -25,6 +25,8 @@
- DEFINE_SPINLOCK(ebu_lock);
- EXPORT_SYMBOL_GPL(ebu_lock);
- 
-+unsigned long physical_memsize = 0L;
-+
- /*
-  * this struct is filled by the soc specific detection code and holds
-  * information about the specific soc type, revision and name
-@@ -67,6 +69,10 @@ extern struct boot_param_header __image_
- 
- void __init plat_mem_setup(void)
- {
-+	/* assume 16M as default incase uboot fails to pass proper ramsize */
-+	unsigned long memsize = 16;
-+	char **envp = (char **) KSEG1ADDR(fw_arg2);
-+
- 	ioport_resource.start = IOPORT_RESOURCE_START;
- 	ioport_resource.end = IOPORT_RESOURCE_END;
- 	iomem_resource.start = IOMEM_RESOURCE_START;
-@@ -80,6 +86,18 @@ void __init plat_mem_setup(void)
- 	 */
- 	__dt_setup_arch(&__image_dtb);
- 
-+	while (*envp) {
-+		char *e = (char *)KSEG1ADDR(*envp); printk("e=%s\n", e);
-+		if (!strncmp(e, "memsize=", 8)) {
-+			e += 8;
-+			if (kstrtoul(e, 0, &memsize))
-+				pr_warning("bad memsize specified\n");
-+		}
-+		envp++;
-+	}
-+	memsize *= 1024 * 1024;
-+	physical_memsize = memsize; printk("MEMSIZE = %lu\n", physical_memsize);
-+
- 	strlcpy(arcs_cmdline, boot_command_line, COMMAND_LINE_SIZE);
- }
- 
diff --git a/target/linux/lantiq/patches-3.18/0520-sdk-add-irq-defines.patch b/target/linux/lantiq/patches-3.18/0520-sdk-add-irq-defines.patch
deleted file mode 100644
index 7fb3384c23..0000000000
--- a/target/linux/lantiq/patches-3.18/0520-sdk-add-irq-defines.patch
+++ /dev/null
@@ -1,254 +0,0 @@
-add interrupt definitions for external drivers (SDK)
-
---- a/arch/mips/include/asm/mach-lantiq/falcon/falcon_irq.h
-+++ b/arch/mips/include/asm/mach-lantiq/falcon/falcon_irq.h
-@@ -22,4 +22,249 @@
- 
- #define MAX_IM			5
- 
-+/* HOST IF Event Interrupt */
-+#define FALCON_IRQ_HOST				(INT_NUM_IM0_IRL0 + 0)
-+/* HOST IF Mailbox0 Receive Interrupt */
-+#define FALCON_IRQ_HOST_MB0_RX			(INT_NUM_IM0_IRL0 + 1)
-+/* HOST IF Mailbox0 Transmit Interrupt */
-+#define FALCON_IRQ_HOST_MB0_TX			(INT_NUM_IM0_IRL0 + 2)
-+/* HOST IF Mailbox1 Receive Interrupt */
-+#define FALCON_IRQ_HOST_MB1_RX			(INT_NUM_IM0_IRL0 + 3)
-+/* HOST IF Mailbox1 Transmit Interrupt */
-+#define FALCON_IRQ_HOST_MB1_TX			(INT_NUM_IM0_IRL0 + 4)
-+/* I2C Last Single Data Transfer Request */
-+#define FALCON_IRQ_I2C_LSREQ			(INT_NUM_IM0_IRL0 + 8)
-+/* I2C Single Data Transfer Request */
-+#define FALCON_IRQ_I2C_SREQ			(INT_NUM_IM0_IRL0 + 9)
-+/* I2C Last Burst Data Transfer Request */
-+#define FALCON_IRQ_I2C_LBREQ			(INT_NUM_IM0_IRL0 + 10)
-+/* I2C Burst Data Transfer Request */
-+#define FALCON_IRQ_I2C_BREQ			(INT_NUM_IM0_IRL0 + 11)
-+/* I2C Error Interrupt */
-+#define FALCON_IRQ_I2C_I2C_ERR			(INT_NUM_IM0_IRL0 + 12)
-+/* I2C Protocol Interrupt */
-+#define FALCON_IRQ_I2C_I2C_P			(INT_NUM_IM0_IRL0 + 13)
-+/* SSC Transmit Interrupt */
-+#define FALCON_IRQ_SSC_T			(INT_NUM_IM0_IRL0 + 14)
-+/* SSC Receive Interrupt */
-+#define FALCON_IRQ_SSC_R			(INT_NUM_IM0_IRL0 + 15)
-+/* SSC Error Interrupt */
-+#define FALCON_IRQ_SSC_E			(INT_NUM_IM0_IRL0 + 16)
-+/* SSC Frame Interrupt */
-+#define FALCON_IRQ_SSC_F			(INT_NUM_IM0_IRL0 + 17)
-+/* Advanced Encryption Standard Interrupt */
-+#define FALCON_IRQ_AES_AES			(INT_NUM_IM0_IRL0 + 27)
-+/* Secure Hash Algorithm Interrupt */
-+#define FALCON_IRQ_SHA_HASH			(INT_NUM_IM0_IRL0 + 28)
-+/* PCM Receive Interrupt */
-+#define FALCON_IRQ_PCM_RX			(INT_NUM_IM0_IRL0 + 29)
-+/* PCM Transmit Interrupt */
-+#define FALCON_IRQ_PCM_TX			(INT_NUM_IM0_IRL0 + 30)
-+/* PCM Transmit Crash Interrupt */
-+#define FALCON_IRQ_PCM_HW2_CRASH		(INT_NUM_IM0_IRL0 + 31)
-+
-+/* EBU Serial Flash Command Error */
-+#define FALCON_IRQ_EBU_SF_CMDERR		(INT_NUM_IM1_IRL0 + 0)
-+/* EBU Serial Flash Command Overwrite Error */
-+#define FALCON_IRQ_EBU_SF_COVERR		(INT_NUM_IM1_IRL0 + 1)
-+/* EBU Serial Flash Busy */
-+#define FALCON_IRQ_EBU_SF_BUSY			(INT_NUM_IM1_IRL0 + 2)
-+/* External Interrupt from GPIO P0 */
-+#define FALCON_IRQ_GPIO_P0			(INT_NUM_IM1_IRL0 + 4)
-+/* External Interrupt from GPIO P1 */
-+#define FALCON_IRQ_GPIO_P1			(INT_NUM_IM1_IRL0 + 5)
-+/* External Interrupt from GPIO P2 */
-+#define FALCON_IRQ_GPIO_P2			(INT_NUM_IM1_IRL0 + 6)
-+/* External Interrupt from GPIO P3 */
-+#define FALCON_IRQ_GPIO_P3			(INT_NUM_IM1_IRL0 + 7)
-+/* External Interrupt from GPIO P4 */
-+#define FALCON_IRQ_GPIO_P4			(INT_NUM_IM1_IRL0 + 8)
-+/* 8kHz backup interrupt derived from core-PLL */
-+#define FALCON_IRQ_FSC_BKP			(INT_NUM_IM1_IRL0 + 10)
-+/* FSC Timer Interrupt 0 */
-+#define FALCON_IRQ_FSCT_CMP0			(INT_NUM_IM1_IRL0 + 11)
-+/* FSC Timer Interrupt 1 */
-+#define FALCON_IRQ_FSCT_CMP1			(INT_NUM_IM1_IRL0 + 12)
-+/* 8kHz root interrupt derived from GPON interface */
-+#define FALCON_IRQ_FSC_ROOT			(INT_NUM_IM1_IRL0 + 13)
-+/* Time of Day */
-+#define FALCON_IRQ_TOD				(INT_NUM_IM1_IRL0 + 14)
-+/* PMA Interrupt from IntNode of the 200MHz Domain */
-+#define FALCON_IRQ_PMA_200M			(INT_NUM_IM1_IRL0 + 15)
-+/* PMA Interrupt from IntNode of the TX Clk Domain */
-+#define FALCON_IRQ_PMA_TX			(INT_NUM_IM1_IRL0 + 16)
-+/* PMA Interrupt from IntNode of the RX Clk Domain */
-+#define FALCON_IRQ_PMA_RX			(INT_NUM_IM1_IRL0 + 17)
-+/* SYS1 Interrupt */
-+#define FALCON_IRQ_SYS1				(INT_NUM_IM1_IRL0 + 20)
-+/* SYS GPE Interrupt */
-+#define FALCON_IRQ_SYS_GPE			(INT_NUM_IM1_IRL0 + 21)
-+/* Watchdog Access Error Interrupt */
-+#define FALCON_IRQ_WDT_AEIR			(INT_NUM_IM1_IRL0 + 24)
-+/* Watchdog Prewarning Interrupt */
-+#define FALCON_IRQ_WDT_PIR			(INT_NUM_IM1_IRL0 + 25)
-+/* SBIU interrupt */
-+#define FALCON_IRQ_SBIU0			(INT_NUM_IM1_IRL0 + 27)
-+/* FPI Bus Control Unit Interrupt */
-+#define FALCON_IRQ_BCU0				(INT_NUM_IM1_IRL0 + 29)
-+/* DDR Controller Interrupt */
-+#define FALCON_IRQ_DDR				(INT_NUM_IM1_IRL0 + 30)
-+/* Crossbar Error Interrupt */
-+#define FALCON_IRQ_XBAR_ERROR			(INT_NUM_IM1_IRL0 + 31)
-+
-+/* ICTRLL 0 Interrupt */
-+#define FALCON_IRQ_ICTRLL0			(INT_NUM_IM2_IRL0 + 0)
-+/* ICTRLL 1 Interrupt */
-+#define FALCON_IRQ_ICTRLL1			(INT_NUM_IM2_IRL0 + 1)
-+/* ICTRLL 2 Interrupt */
-+#define FALCON_IRQ_ICTRLL2			(INT_NUM_IM2_IRL0 + 2)
-+/* ICTRLL 3 Interrupt */
-+#define FALCON_IRQ_ICTRLL3			(INT_NUM_IM2_IRL0 + 3)
-+/* OCTRLL 0 Interrupt */
-+#define FALCON_IRQ_OCTRLL0			(INT_NUM_IM2_IRL0 + 4)
-+/* OCTRLL 1 Interrupt */
-+#define FALCON_IRQ_OCTRLL1			(INT_NUM_IM2_IRL0 + 5)
-+/* OCTRLL 2 Interrupt */
-+#define FALCON_IRQ_OCTRLL2			(INT_NUM_IM2_IRL0 + 6)
-+/* OCTRLL 3 Interrupt */
-+#define FALCON_IRQ_OCTRLL3			(INT_NUM_IM2_IRL0 + 7)
-+/* OCTRLG Interrupt */
-+#define FALCON_IRQ_OCTRLG			(INT_NUM_IM2_IRL0 + 9)
-+/* IQM Interrupt */
-+#define FALCON_IRQ_IQM				(INT_NUM_IM2_IRL0 + 10)
-+/* FSQM Interrupt */
-+#define FALCON_IRQ_FSQM				(INT_NUM_IM2_IRL0 + 11)
-+/* TMU Interrupt */
-+#define FALCON_IRQ_TMU				(INT_NUM_IM2_IRL0 + 12)
-+/* LINK1 Interrupt */
-+#define FALCON_IRQ_LINK1			(INT_NUM_IM2_IRL0 + 14)
-+/* ICTRLC 0 Interrupt */
-+#define FALCON_IRQ_ICTRLC0			(INT_NUM_IM2_IRL0 + 16)
-+/* ICTRLC 1 Interrupt */
-+#define FALCON_IRQ_ICTRLC1			(INT_NUM_IM2_IRL0 + 17)
-+/* OCTRLC Interrupt */
-+#define FALCON_IRQ_OCTRLC			(INT_NUM_IM2_IRL0 + 18)
-+/* CONFIG Break Interrupt */
-+#define FALCON_IRQ_CONFIG_BREAK			(INT_NUM_IM2_IRL0 + 19)
-+/* CONFIG Interrupt */
-+#define FALCON_IRQ_CONFIG			(INT_NUM_IM2_IRL0 + 20)
-+/* Dispatcher Interrupt */
-+#define FALCON_IRQ_DISP				(INT_NUM_IM2_IRL0 + 21)
-+/* TBM Interrupt */
-+#define FALCON_IRQ_TBM				(INT_NUM_IM2_IRL0 + 22)
-+/* GTC Downstream Interrupt */
-+#define FALCON_IRQ_GTC_DS			(INT_NUM_IM2_IRL0 + 29)
-+/* GTC Upstream Interrupt */
-+#define FALCON_IRQ_GTC_US			(INT_NUM_IM2_IRL0 + 30)
-+/* EIM Interrupt */
-+#define FALCON_IRQ_EIM				(INT_NUM_IM2_IRL0 + 31)
-+
-+/* ASC0 Transmit Interrupt */
-+#define FALCON_IRQ_ASC0_T			(INT_NUM_IM3_IRL0 + 0)
-+/* ASC0 Receive Interrupt */
-+#define FALCON_IRQ_ASC0_R			(INT_NUM_IM3_IRL0 + 1)
-+/* ASC0 Error Interrupt */
-+#define FALCON_IRQ_ASC0_E			(INT_NUM_IM3_IRL0 + 2)
-+/* ASC0 Transmit Buffer Interrupt */
-+#define FALCON_IRQ_ASC0_TB			(INT_NUM_IM3_IRL0 + 3)
-+/* ASC0 Autobaud Start Interrupt */
-+#define FALCON_IRQ_ASC0_ABST			(INT_NUM_IM3_IRL0 + 4)
-+/* ASC0 Autobaud Detection Interrupt */
-+#define FALCON_IRQ_ASC0_ABDET			(INT_NUM_IM3_IRL0 + 5)
-+/* ASC1 Modem Status Interrupt */
-+#define FALCON_IRQ_ASC0_MS			(INT_NUM_IM3_IRL0 + 6)
-+/* ASC0 Soft Flow Control Interrupt */
-+#define FALCON_IRQ_ASC0_SFC			(INT_NUM_IM3_IRL0 + 7)
-+/* ASC1 Transmit Interrupt */
-+#define FALCON_IRQ_ASC1_T			(INT_NUM_IM3_IRL0 + 8)
-+/* ASC1 Receive Interrupt */
-+#define FALCON_IRQ_ASC1_R			(INT_NUM_IM3_IRL0 + 9)
-+/* ASC1 Error Interrupt */
-+#define FALCON_IRQ_ASC1_E			(INT_NUM_IM3_IRL0 + 10)
-+/* ASC1 Transmit Buffer Interrupt */
-+#define FALCON_IRQ_ASC1_TB			(INT_NUM_IM3_IRL0 + 11)
-+/* ASC1 Autobaud Start Interrupt */
-+#define FALCON_IRQ_ASC1_ABST			(INT_NUM_IM3_IRL0 + 12)
-+/* ASC1 Autobaud Detection Interrupt */
-+#define FALCON_IRQ_ASC1_ABDET			(INT_NUM_IM3_IRL0 + 13)
-+/* ASC1 Modem Status Interrupt */
-+#define FALCON_IRQ_ASC1_MS			(INT_NUM_IM3_IRL0 + 14)
-+/* ASC1 Soft Flow Control Interrupt */
-+#define FALCON_IRQ_ASC1_SFC			(INT_NUM_IM3_IRL0 + 15)
-+/* GPTC Timer/Counter 1A Interrupt */
-+#define FALCON_IRQ_GPTC_TC1A			(INT_NUM_IM3_IRL0 + 16)
-+/* GPTC Timer/Counter 1B Interrupt */
-+#define FALCON_IRQ_GPTC_TC1B			(INT_NUM_IM3_IRL0 + 17)
-+/* GPTC Timer/Counter 2A Interrupt */
-+#define FALCON_IRQ_GPTC_TC2A			(INT_NUM_IM3_IRL0 + 18)
-+/* GPTC Timer/Counter 2B Interrupt */
-+#define FALCON_IRQ_GPTC_TC2B			(INT_NUM_IM3_IRL0 + 19)
-+/* GPTC Timer/Counter 3A Interrupt */
-+#define FALCON_IRQ_GPTC_TC3A			(INT_NUM_IM3_IRL0 + 20)
-+/* GPTC Timer/Counter 3B Interrupt */
-+#define FALCON_IRQ_GPTC_TC3B			(INT_NUM_IM3_IRL0 + 21)
-+/* DFEV0, Channel 1 Transmit Interrupt */
-+#define FALCON_IRQ_DFEV0_2TX			(INT_NUM_IM3_IRL0 + 26)
-+/* DFEV0, Channel 1 Receive Interrupt */
-+#define FALCON_IRQ_DFEV0_2RX			(INT_NUM_IM3_IRL0 + 27)
-+/* DFEV0, Channel 1 General Purpose Interrupt */
-+#define FALCON_IRQ_DFEV0_2GP			(INT_NUM_IM3_IRL0 + 28)
-+/* DFEV0, Channel 0 Transmit Interrupt */
-+#define FALCON_IRQ_DFEV0_1TX			(INT_NUM_IM3_IRL0 + 29)
-+/* DFEV0, Channel 0 Receive Interrupt */
-+#define FALCON_IRQ_DFEV0_1RX			(INT_NUM_IM3_IRL0 + 30)
-+/* DFEV0, Channel 0 General Purpose Interrupt */
-+#define FALCON_IRQ_DFEV0_1GP			(INT_NUM_IM3_IRL0 + 31)
-+
-+/* ICTRLL 0 Error */
-+#define FALCON_IRQ_ICTRLL0_ERR			(INT_NUM_IM4_IRL0 + 0)
-+/* ICTRLL 1 Error */
-+#define FALCON_IRQ_ICTRLL1_ERR			(INT_NUM_IM4_IRL0 + 1)
-+/* ICTRLL 2 Error */
-+#define FALCON_IRQ_ICTRLL2_ERR			(INT_NUM_IM4_IRL0 + 2)
-+/* ICTRLL 3 Error */
-+#define FALCON_IRQ_ICTRLL3_ERR			(INT_NUM_IM4_IRL0 + 3)
-+/* OCTRLL 0 Error */
-+#define FALCON_IRQ_OCTRLL0_ERR			(INT_NUM_IM4_IRL0 + 4)
-+/* OCTRLL 1 Error */
-+#define FALCON_IRQ_OCTRLL1_ERR			(INT_NUM_IM4_IRL0 + 5)
-+/* OCTRLL 2 Error */
-+#define FALCON_IRQ_OCTRLL2_ERR			(INT_NUM_IM4_IRL0 + 6)
-+/* OCTRLL 3 Error */
-+#define FALCON_IRQ_OCTRLL3_ERR			(INT_NUM_IM4_IRL0 + 7)
-+/* ICTRLG Error */
-+#define FALCON_IRQ_ICTRLG_ERR			(INT_NUM_IM4_IRL0 + 8)
-+/* OCTRLG Error */
-+#define FALCON_IRQ_OCTRLG_ERR			(INT_NUM_IM4_IRL0 + 9)
-+/* IQM Error */
-+#define FALCON_IRQ_IQM_ERR			(INT_NUM_IM4_IRL0 + 10)
-+/* FSQM Error */
-+#define FALCON_IRQ_FSQM_ERR			(INT_NUM_IM4_IRL0 + 11)
-+/* TMU Error */
-+#define FALCON_IRQ_TMU_ERR			(INT_NUM_IM4_IRL0 + 12)
-+/* MPS Status Interrupt #0 (VPE1 to VPE0) */
-+#define FALCON_IRQ_MPS_IR0			(INT_NUM_IM4_IRL0 + 14)
-+/* MPS Status Interrupt #1 (VPE1 to VPE0) */
-+#define FALCON_IRQ_MPS_IR1			(INT_NUM_IM4_IRL0 + 15)
-+/* MPS Status Interrupt #2 (VPE1 to VPE0) */
-+#define FALCON_IRQ_MPS_IR2			(INT_NUM_IM4_IRL0 + 16)
-+/* MPS Status Interrupt #3 (VPE1 to VPE0) */
-+#define FALCON_IRQ_MPS_IR3			(INT_NUM_IM4_IRL0 + 17)
-+/* MPS Status Interrupt #4 (VPE1 to VPE0) */
-+#define FALCON_IRQ_MPS_IR4			(INT_NUM_IM4_IRL0 + 18)
-+/* MPS Status Interrupt #5 (VPE1 to VPE0) */
-+#define FALCON_IRQ_MPS_IR5			(INT_NUM_IM4_IRL0 + 19)
-+/* MPS Status Interrupt #6 (VPE1 to VPE0) */
-+#define FALCON_IRQ_MPS_IR6			(INT_NUM_IM4_IRL0 + 20)
-+/* MPS Status Interrupt #7 (VPE1 to VPE0) */
-+#define FALCON_IRQ_MPS_IR7			(INT_NUM_IM4_IRL0 + 21)
-+/* MPS Status Interrupt #8 (VPE1 to VPE0) */
-+#define FALCON_IRQ_MPS_IR8			(INT_NUM_IM4_IRL0 + 22)
-+/* VPE0 Exception Level Flag Interrupt */
-+#define FALCON_IRQ_VPE0_EXL			(INT_NUM_IM4_IRL0 + 29)
-+/* VPE0 Error Level Flag Interrupt */
-+#define FALCON_IRQ_VPE0_ERL			(INT_NUM_IM4_IRL0 + 30)
-+/* VPE0 Performance Monitoring Counter Interrupt */
-+#define FALCON_IRQ_VPE0_PMCIR			(INT_NUM_IM4_IRL0 + 31)
-+
- #endif /* _FALCON_IRQ__ */
diff --git a/target/linux/lantiq/patches-3.18/1012-lantiq-irq_set_default_host.patch b/target/linux/lantiq/patches-3.18/1012-lantiq-irq_set_default_host.patch
deleted file mode 100644
index 6b9ecaf50f..0000000000
--- a/target/linux/lantiq/patches-3.18/1012-lantiq-irq_set_default_host.patch
+++ /dev/null
@@ -1,14 +0,0 @@
-set the default irq domain for lantiq
-
-diff --git a/arch/mips/lantiq/irq.c b/arch/mips/lantiq/irq.c
---- a/arch/mips/lantiq/irq.c
-+++ b/arch/mips/lantiq/irq.c
-@@ -431,6 +431,8 @@ int __init icu_of_init(struct device_nod
- 		(MAX_IM * INT_NUM_IM_OFFSET) + MIPS_CPU_IRQ_CASCADE,
- 		&irq_domain_ops, 0);
- 
-+	irq_set_default_host(ltq_domain);
-+
- #if defined(CONFIG_MIPS_MT_SMP)
- 	if (cpu_has_vint) {
- 		pr_info("Setting up IPI vectored interrupts\n");
diff --git a/target/linux/lantiq/patches-3.18/1015-sdk-compat.patch b/target/linux/lantiq/patches-3.18/1015-sdk-compat.patch
deleted file mode 100644
index a3d7a22e6f..0000000000
--- a/target/linux/lantiq/patches-3.18/1015-sdk-compat.patch
+++ /dev/null
@@ -1,130 +0,0 @@
-add some compatibility functions to access sysctrl from external (SDK) drivers
-
-diff --git a/arch/mips/include/asm/mach-lantiq/falcon/lantiq_soc.h b/arch/mips/include/asm/mach-lantiq/falcon/lantiq_soc.h
---- a/arch/mips/include/asm/mach-lantiq/falcon/lantiq_soc.h
-+++ b/arch/mips/include/asm/mach-lantiq/falcon/lantiq_soc.h
-@@ -41,6 +41,11 @@
- #define SYSCTL_SYS1		0
- #define SYSCTL_SYSETH		1
- #define SYSCTL_SYSGPE		2
-+extern void ltq_sysctl_activate(int module, unsigned int mask);
-+extern void ltq_sysctl_deactivate(int module, unsigned int mask);
-+extern void ltq_sysctl_clken(int module, unsigned int mask);
-+extern void ltq_sysctl_clkdis(int module, unsigned int mask);
-+extern void ltq_sysctl_reboot(int module, unsigned int mask);
- 
- /* BOOT_SEL - find what boot media we have */
- #define BS_FLASH		0x1
-diff --git a/arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h b/arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h
-new file mode 100644
---- /dev/null
-+++ b/arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h
-@@ -0,0 +1,60 @@
-+/*
-+ * This program is free software; you can redistribute it and/or
-+ * modify it under the terms of the GNU General Public License as
-+ * published by the Free Software Foundation; either version 2 of
-+ * the License, or (at your option) any later version.
-+ *
-+ * This program is distributed in the hope that it will be useful,
-+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
-+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+ * GNU General Public License for more details.
-+ *
-+ * You should have received a copy of the GNU General Public License
-+ * along with this program; if not, write to the Free Software
-+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-+ * MA 02111-1307 USA
-+ *
-+ * Copyright (C) 2010 Thomas Langer, Lantiq Deutschland
-+ */
-+
-+#ifndef __FALCON_SYSCTRL_H
-+#define __FALCON_SYSCTRL_H
-+
-+#include <falcon/lantiq_soc.h>
-+
-+static inline void sys1_hw_activate(u32 mask)
-+{ ltq_sysctl_activate(SYSCTL_SYS1, mask); }
-+static inline void sys1_hw_deactivate(u32 mask)
-+{ ltq_sysctl_deactivate(SYSCTL_SYS1, mask); }
-+static inline void sys1_hw_clk_enable(u32 mask)
-+{ ltq_sysctl_clken(SYSCTL_SYS1, mask); }
-+static inline void sys1_hw_clk_disable(u32 mask)
-+{ ltq_sysctl_clkdis(SYSCTL_SYS1, mask); }
-+static inline void sys1_hw_activate_or_reboot(u32 mask)
-+{ ltq_sysctl_reboot(SYSCTL_SYS1, mask); }
-+
-+static inline void sys_eth_hw_activate(u32 mask)
-+{ ltq_sysctl_activate(SYSCTL_SYSETH, mask); }
-+static inline void sys_eth_hw_deactivate(u32 mask)
-+{ ltq_sysctl_deactivate(SYSCTL_SYSETH, mask); }
-+static inline void sys_eth_hw_clk_enable(u32 mask)
-+{ ltq_sysctl_clken(SYSCTL_SYSETH, mask); }
-+static inline void sys_eth_hw_clk_disable(u32 mask)
-+{ ltq_sysctl_clkdis(SYSCTL_SYSETH, mask); }
-+static inline void sys_eth_hw_activate_or_reboot(u32 mask)
-+{ ltq_sysctl_reboot(SYSCTL_SYSETH, mask); }
-+
-+static inline void sys_gpe_hw_activate(u32 mask)
-+{ ltq_sysctl_activate(SYSCTL_SYSGPE, mask); }
-+static inline void sys_gpe_hw_deactivate(u32 mask)
-+{ ltq_sysctl_deactivate(SYSCTL_SYSGPE, mask); }
-+static inline void sys_gpe_hw_clk_enable(u32 mask)
-+{ ltq_sysctl_clken(SYSCTL_SYSGPE, mask); }
-+static inline void sys_gpe_hw_clk_disable(u32 mask)
-+{ ltq_sysctl_clkdis(SYSCTL_SYSGPE, mask); }
-+static inline void sys_gpe_hw_activate_or_reboot(u32 mask)
-+{ ltq_sysctl_reboot(SYSCTL_SYSGPE, mask); }
-+static inline int sys_gpe_hw_is_activated(u32 mask)
-+{ return 1; }
-+
-+#endif /* __FALCON_SYSCTRL_H */
-diff --git a/arch/mips/lantiq/falcon/sysctrl.c b/arch/mips/lantiq/falcon/sysctrl.c
---- a/arch/mips/lantiq/falcon/sysctrl.c
-+++ b/arch/mips/lantiq/falcon/sysctrl.c
-@@ -262,3 +262,44 @@ void __init ltq_soc_init(void)
- 	clkdev_add_sys("1e100c00.serial", SYSCTL_SYS1, ACTS_ASC0_ACT);
- 	clkdev_add_sys("1e200000.i2c", SYSCTL_SYS1, ACTS_I2C_ACT);
- }
-+
-+
-+/*
-+ * for compatibility to external drivers from Lantiq
-+ * see arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h
-+ */
-+
-+void ltq_sysctl_activate(int module, unsigned int mask)
-+{
-+	struct clk clk = { .module = module, .bits = mask };
-+	sysctl_activate(&clk);
-+}
-+EXPORT_SYMBOL(ltq_sysctl_activate);
-+
-+void ltq_sysctl_deactivate(int module, unsigned int mask)
-+{
-+	struct clk clk = { .module = module, .bits = mask };
-+	sysctl_deactivate(&clk);
-+}
-+EXPORT_SYMBOL(ltq_sysctl_deactivate);
-+
-+void ltq_sysctl_clken(int module, unsigned int mask)
-+{
-+	struct clk clk = { .module = module, .bits = mask };
-+	sysctl_clken(&clk);
-+}
-+EXPORT_SYMBOL(ltq_sysctl_clken);
-+
-+void ltq_sysctl_clkdis(int module, unsigned int mask)
-+{
-+	struct clk clk = { .module = module, .bits = mask };
-+	sysctl_clkdis(&clk);
-+}
-+EXPORT_SYMBOL(ltq_sysctl_clkdis);
-+
-+void ltq_sysctl_reboot(int module, unsigned int mask)
-+{
-+	struct clk clk = { .module = module, .bits = mask };
-+	sysctl_reboot(&clk);
-+}
-+EXPORT_SYMBOL(ltq_sysctl_reboot);
diff --git a/target/linux/lantiq/patches-3.18/1017-udp-in-kernel-redirect.patch b/target/linux/lantiq/patches-3.18/1017-udp-in-kernel-redirect.patch
deleted file mode 100644
index 327463d880..0000000000
--- a/target/linux/lantiq/patches-3.18/1017-udp-in-kernel-redirect.patch
+++ /dev/null
@@ -1,376 +0,0 @@
-From: John Crispin <blogic@openwrt.org>
-Date: Thu, 29 Sep 2011 20:29:54 +0200
-
-[PATCH 17/25] udp in-kernel redirect
-
----
- include/linux/udp_redirect.h |   57 +++++++++++++
- net/Kconfig                  |    6 ++
- net/ipv4/Makefile            |    3 +
- net/ipv4/udp.c               |   28 ++++++-
- net/ipv4/udp_redirect_symb.c |  186 ++++++++++++++++++++++++++++++++++++++++++
- 5 files changed, 276 insertions(+), 4 deletions(-)
- create mode 100644 include/linux/udp_redirect.h
- create mode 100644 net/ipv4/udp_redirect_symb.c
-
-diff --git a/include/linux/udp_redirect.h b/include/linux/udp_redirect.h
-new file mode 100644
---- /dev/null
-+++ b/include/linux/udp_redirect.h
-@@ -0,0 +1,57 @@
-+#ifndef _UDP_REDIRECT_H
-+#define _UDP_REDIRECT_H
-+
-+/******************************************************************************
-+
-+                               Copyright (c) 2006
-+                            Infineon Technologies AG
-+                     Am Campeon 1-12; 81726 Munich, Germany
-+
-+  THE DELIVERY OF THIS SOFTWARE AS WELL AS THE HEREBY GRANTED NON-EXCLUSIVE,
-+  WORLDWIDE LICENSE TO USE, COPY, MODIFY, DISTRIBUTE AND SUBLICENSE THIS
-+  SOFTWARE IS FREE OF CHARGE.
-+
-+  THE LICENSED SOFTWARE IS PROVIDED "AS IS" AND INFINEON EXPRESSLY DISCLAIMS
-+  ALL REPRESENTATIONS AND WARRANTIES, WHETHER EXPRESS OR IMPLIED, INCLUDING
-+  WITHOUT LIMITATION, WARRANTIES OR REPRESENTATIONS OF WORKMANSHIP,
-+  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, DURABILITY, THAT THE
-+  OPERATING OF THE LICENSED SOFTWARE WILL BE ERROR FREE OR FREE OF ANY THIRD
-+  PARTY CLAIMS, INCLUDING WITHOUT LIMITATION CLAIMS OF THIRD PARTY INTELLECTUAL
-+  PROPERTY INFRINGEMENT.
-+
-+  EXCEPT FOR ANY LIABILITY DUE TO WILFUL ACTS OR GROSS NEGLIGENCE AND EXCEPT
-+  FOR ANY PERSONAL INJURY INFINEON SHALL IN NO EVENT BE LIABLE FOR ANY CLAIM
-+  OR DAMAGES OF ANY KIND, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-+  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-+  DEALINGS IN THE SOFTWARE.
-+
-+******************************************************************************/
-+
-+/* ============================= */
-+/* Includes                      */
-+/* ============================= */
-+#ifndef _LINUX_TYPES_H
-+#include <linux/types.h>
-+#endif
-+
-+
-+/* ============================= */
-+/* Definitions                   */
-+/* ============================= */
-+#define UDP_REDIRECT_MAGIC (void*)0x55445052L
-+
-+
-+/* ============================= */
-+/* Global variable declaration   */
-+/* ============================= */
-+extern int (*udp_do_redirect_fn)(struct sock *sk, struct sk_buff *skb);
-+extern int (*udpredirect_getfrag_fn)(void *p, char * to,
-+                                     int offset, int fraglen, int odd,
-+                                     struct sk_buff *skb);
-+/* ============================= */
-+/* Global function declaration   */
-+/* ============================= */
-+
-+extern int udpredirect_getfrag(void *p, char * to, int offset,
-+                               int fraglen, int odd, struct sk_buff *skb);
-+#endif
-diff --git a/net/Kconfig b/net/Kconfig
---- a/net/Kconfig
-+++ b/net/Kconfig
-@@ -82,6 +82,12 @@ config INET
- 
- 	  Short answer: say Y.
- 
-+config IFX_UDP_REDIRECT
-+	bool "IFX Kernel Packet Interface for UDP redirection"
-+	help
-+	  You can say Y here if you want to use hooks from kernel for
-+	  UDP redirection.
-+
- if INET
- source "net/ipv4/Kconfig"
- source "net/ipv6/Kconfig"
-diff --git a/net/ipv4/Makefile b/net/ipv4/Makefile
---- a/net/ipv4/Makefile
-+++ b/net/ipv4/Makefile
-@@ -15,6 +15,9 @@ obj-y     := route.o inetpeer.o protocol
- 
- obj-$(CONFIG_NET_IP_TUNNEL) += ip_tunnel.o
- obj-$(CONFIG_SYSCTL) += sysctl_net_ipv4.o
-+ifneq ($(CONFIG_IFX_UDP_REDIRECT),)
-+obj-$(CONFIG_IFX_UDP_REDIRECT) += udp_redirect_symb.o
-+endif
- obj-$(CONFIG_PROC_FS) += proc.o
- obj-$(CONFIG_IP_MULTIPLE_TABLES) += fib_rules.o
- obj-$(CONFIG_IP_MROUTE) += ipmr.o
-diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
---- a/net/ipv4/udp.c
-+++ b/net/ipv4/udp.c
-@@ -114,6 +114,10 @@
- #include <net/busy_poll.h>
- #include "udp_impl.h"
- 
-+#if defined(CONFIG_IFX_UDP_REDIRECT) || defined(CONFIG_IFX_UDP_REDIRECT_MODULE)
-+#include <linux/udp_redirect.h>
-+#endif
-+
- struct udp_table udp_table __read_mostly;
- EXPORT_SYMBOL(udp_table);
- 
-@@ -877,7 +881,7 @@ int udp_sendmsg(struct kiocb *iocb, stru
- 	u8  tos;
- 	int err, is_udplite = IS_UDPLITE(sk);
- 	int corkreq = up->corkflag || msg->msg_flags&MSG_MORE;
--	int (*getfrag)(void *, char *, int, int, int, struct sk_buff *);
-+	int (*getfrag)(void *, char *, int, int, int, struct sk_buff *) = NULL;
- 	struct sk_buff *skb;
- 	struct ip_options_data opt_copy;
- 
-@@ -896,7 +900,13 @@ int udp_sendmsg(struct kiocb *iocb, stru
- 	ipc.ttl = 0;
- 	ipc.tos = -1;
- 
--	getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag;
-+/* UDPREDIRECT */
-+#if defined(CONFIG_IFX_UDP_REDIRECT) || defined(CONFIG_IFX_UDP_REDIRECT_MODULE)
-+	if(udpredirect_getfrag_fn && sk->sk_user_data == UDP_REDIRECT_MAGIC)
-+		getfrag = udpredirect_getfrag_fn;
-+	else
-+#endif /* IFX_UDP_REDIRECT */
-+		getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag;
- 
- 	fl4 = &inet->cork.fl.u.ip4;
- 	if (up->pending) {
-@@ -1736,6 +1746,7 @@ int __udp4_lib_rcv(struct sk_buff *skb, 
- 	struct rtable *rt = skb_rtable(skb);
- 	__be32 saddr, daddr;
- 	struct net *net = dev_net(skb->dev);
-+	int ret = 0;
- 
- 	/*
- 	 *  Validate the packet.
-@@ -1769,6 +1780,7 @@ int __udp4_lib_rcv(struct sk_buff *skb, 
- 		if (unlikely(sk->sk_rx_dst != dst))
- 			udp_sk_rx_dst_set(sk, dst);
- 
-+
- 		ret = udp_queue_rcv_skb(sk, skb);
- 		sock_put(sk);
- 		/* a return value > 0 means to resubmit the input, but
-@@ -1792,6 +1804,15 @@ int __udp4_lib_rcv(struct sk_buff *skb, 
- 			skb_checksum_try_convert(skb, IPPROTO_UDP, uh->check,
- 						 inet_compute_pseudo);
- 
-+		/* UDPREDIRECT */
-+#if defined(CONFIG_IFX_UDP_REDIRECT) || defined(CONFIG_IFX_UDP_REDIRECT_MODULE)
-+		if(udp_do_redirect_fn && sk->sk_user_data == UDP_REDIRECT_MAGIC)
-+		{
-+			udp_do_redirect_fn(sk,skb);
-+			kfree_skb(skb);
-+			return(0);
-+		}
-+#endif
- 		ret = udp_queue_rcv_skb(sk, skb);
- 		sock_put(sk);
- 
-@@ -2249,7 +2270,7 @@ struct proto udp_prot = {
- 	.clear_sk	   = sk_prot_clear_portaddr_nulls,
- };
- EXPORT_SYMBOL(udp_prot);
--
-+EXPORT_SYMBOL(udp_rcv);
- /* ------------------------------------------------------------------------ */
- #ifdef CONFIG_PROC_FS
- 
-diff --git a/net/ipv4/udp_redirect_symb.c b/net/ipv4/udp_redirect_symb.c
-new file mode 100644
---- /dev/null
-+++ b/net/ipv4/udp_redirect_symb.c
-@@ -0,0 +1,186 @@
-+/******************************************************************************
-+
-+                               Copyright (c) 2006
-+                            Infineon Technologies AG
-+                     Am Campeon 1-12; 81726 Munich, Germany
-+
-+  THE DELIVERY OF THIS SOFTWARE AS WELL AS THE HEREBY GRANTED NON-EXCLUSIVE,
-+  WORLDWIDE LICENSE TO USE, COPY, MODIFY, DISTRIBUTE AND SUBLICENSE THIS
-+  SOFTWARE IS FREE OF CHARGE.
-+
-+  THE LICENSED SOFTWARE IS PROVIDED "AS IS" AND INFINEON EXPRESSLY DISCLAIMS
-+  ALL REPRESENTATIONS AND WARRANTIES, WHETHER EXPRESS OR IMPLIED, INCLUDING
-+  WITHOUT LIMITATION, WARRANTIES OR REPRESENTATIONS OF WORKMANSHIP,
-+  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, DURABILITY, THAT THE
-+  OPERATING OF THE LICENSED SOFTWARE WILL BE ERROR FREE OR FREE OF ANY THIRD
-+  PARTY CLAIMS, INCLUDING WITHOUT LIMITATION CLAIMS OF THIRD PARTY INTELLECTUAL
-+  PROPERTY INFRINGEMENT.
-+
-+  EXCEPT FOR ANY LIABILITY DUE TO WILFUL ACTS OR GROSS NEGLIGENCE AND EXCEPT
-+  FOR ANY PERSONAL INJURY INFINEON SHALL IN NO EVENT BE LIABLE FOR ANY CLAIM
-+  OR DAMAGES OF ANY KIND, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-+  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-+  DEALINGS IN THE SOFTWARE.
-+
-+******************************************************************************/
-+#if defined(CONFIG_IFX_UDP_REDIRECT) || defined(CONFIG_IFX_UDP_REDIRECT_MODULE)
-+/* ============================= */
-+/* Includes                      */
-+/* ============================= */
-+#include <net/checksum.h>
-+#include <net/udp.h>
-+#include <linux/module.h>
-+#include <linux/skbuff.h>
-+#include <linux/udp_redirect.h>
-+
-+/* ============================= */
-+/* Global variable definition    */
-+/* ============================= */
-+int (*udpredirect_getfrag_fn) (void *p, char * to, int offset,
-+                               int fraglen, int odd, struct sk_buff *skb) = NULL;
-+int (*udp_do_redirect_fn)(struct sock *sk, struct sk_buff *skb) = NULL;
-+
-+/* ============================= */
-+/* Local type definitions        */
-+/* ============================= */
-+struct udpfakehdr
-+{
-+  struct udphdr uh;
-+  u32 saddr;
-+  u32 daddr;
-+  struct iovec *iov;
-+  u32 wcheck;
-+};
-+
-+/* ============================= */
-+/* Local function declaration    */
-+/* ============================= */
-+static int udpredirect_csum_partial_copy_fromiovecend(unsigned char *kdata,
-+              struct iovec *iov, int offset, unsigned int len, __wsum *csump);
-+
-+static int udpredirect_memcpy_fromiovecend(unsigned char *kdata, struct iovec *iov, int offset,
-+                        int len);
-+
-+/* ============================= */
-+/* Global function definition    */
-+/* ============================= */
-+
-+/*
-+   Copy of udp_getfrag() from udp.c
-+   This function exists because no copy_from_user() is needed for udpredirect.
-+*/
-+
-+int
-+udpredirect_getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb)
-+{
-+   struct iovec *iov = from;
-+
-+        if (skb->ip_summed == CHECKSUM_PARTIAL) {
-+                if (udpredirect_memcpy_fromiovecend(to, iov, offset, len) < 0)
-+                        return -EFAULT;
-+        } else {
-+                __wsum csum = 0;
-+                if (udpredirect_csum_partial_copy_fromiovecend(to, iov, offset, len, &csum) < 0)
-+                        return -EFAULT;
-+                skb->csum = csum_block_add(skb->csum, csum, odd);
-+        }
-+        return 0;
-+}
-+
-+static int udpredirect_memcpy_fromiovecend(unsigned char *kdata, struct iovec *iov, int offset,
-+                        int len)
-+{
-+        /* Skip over the finished iovecs */
-+        while (offset >= iov->iov_len) {
-+                offset -= iov->iov_len;
-+                iov++;
-+        }
-+
-+        while (len > 0) {
-+                u8 __user *base = iov->iov_base + offset;
-+                int copy = min_t(unsigned int, len, iov->iov_len - offset);
-+
-+                offset = 0;
-+                memcpy(kdata, base, copy);
-+                len -= copy;
-+                kdata += copy;
-+                iov++;
-+        }
-+
-+        return 0;
-+}
-+
-+/*
-+   Copy of csum_partial_copy_fromiovecend() from iovec.c
-+   This function exists because no copy_from_user() is needed for udpredirect.
-+*/
-+
-+int udpredirect_csum_partial_copy_fromiovecend(unsigned char *kdata, struct iovec *iov,
-+				 int offset, unsigned int len, __wsum *csump)
-+{
-+	__wsum csum = *csump;
-+	int partial_cnt = 0, err = 0;
-+
-+	/* Skip over the finished iovecs */
-+	while (offset >= iov->iov_len) {
-+		offset -= iov->iov_len;
-+		iov++;
-+	}
-+
-+	while (len > 0) {
-+		u8 __user *base = iov->iov_base + offset;
-+		int copy = min_t(unsigned int, len, iov->iov_len - offset);
-+
-+		offset = 0;
-+
-+		/* There is a remnant from previous iov. */
-+		if (partial_cnt) {
-+			int par_len = 4 - partial_cnt;
-+
-+			/* iov component is too short ... */
-+			if (par_len > copy) {
-+				memcpy(kdata, base, copy);
-+				kdata += copy;
-+				base  += copy;
-+				partial_cnt += copy;
-+				len   -= copy;
-+				iov++;
-+				if (len)
-+					continue;
-+				*csump = csum_partial(kdata - partial_cnt,
-+							 partial_cnt, csum);
-+				goto out;
-+			}
-+			memcpy(kdata, base, par_len);
-+			csum = csum_partial(kdata - partial_cnt, 4, csum);
-+			kdata += par_len;
-+			base  += par_len;
-+			copy  -= par_len;
-+			len   -= par_len;
-+			partial_cnt = 0;
-+		}
-+
-+		if (len > copy) {
-+			partial_cnt = copy % 4;
-+			if (partial_cnt) {
-+				copy -= partial_cnt;
-+				memcpy(kdata + copy, base + copy, partial_cnt);
-+			}
-+		}
-+
-+		if (copy) {
-+			csum = csum_partial_copy_nocheck(base, kdata, copy, csum);
-+		}
-+		len   -= copy + partial_cnt;
-+		kdata += copy + partial_cnt;
-+		iov++;
-+	}
-+        *csump = csum;
-+out:
-+	return err;
-+}
-+
-+EXPORT_SYMBOL(udpredirect_getfrag);
-+EXPORT_SYMBOL(udp_do_redirect_fn);
-+EXPORT_SYMBOL(udpredirect_getfrag_fn);
-+#endif /* CONFIG_IFX_UDP_REDIRECT* */
diff --git a/target/linux/lantiq/patches-3.18/1100-lantiq-irq-icu_map-number.patch b/target/linux/lantiq/patches-3.18/1100-lantiq-irq-icu_map-number.patch
deleted file mode 100644
index 1faae4f336..0000000000
--- a/target/linux/lantiq/patches-3.18/1100-lantiq-irq-icu_map-number.patch
+++ /dev/null
@@ -1,14 +0,0 @@
-in icu_map the virtual irq should be used instead of the hw_irq
-
-diff --git a/arch/mips/lantiq/irq.c b/arch/mips/lantiq/irq.c
---- a/arch/mips/lantiq/irq.c
-+++ b/arch/mips/lantiq/irq.c
-@@ -345,7 +345,7 @@ static int icu_map(struct irq_domain *d,
- 		if (hw == ltq_eiu_irq[i].start)
- 			chip = &ltq_eiu_type;
- 
--	irq_set_chip_and_handler(hw, chip, handle_level_irq);
-+	irq_set_chip_and_handler(irq, chip, handle_level_irq);
- 
- 	return 0;
- }
diff --git a/target/linux/lantiq/patches-3.18/2000-falcon-fix-reboot.patch b/target/linux/lantiq/patches-3.18/2000-falcon-fix-reboot.patch
deleted file mode 100644
index cf93ebe78d..0000000000
--- a/target/linux/lantiq/patches-3.18/2000-falcon-fix-reboot.patch
+++ /dev/null
@@ -1,15 +0,0 @@
-Falcon: avoid problems with the gcc "__builtin_unreachable", replace with endless loop
-
---- a/arch/mips/lantiq/falcon/reset.c
-+++ b/arch/mips/lantiq/falcon/reset.c
-@@ -47,6 +47,10 @@ EXPORT_SYMBOL_GPL(ltq_reset_cause);
- #define WDT_PW1		0x00BE0000
- #define WDT_PW2		0x00DC0000
- 
-+/* to avoid problems with the gcc "__builtin_unreachable", change definition here! */
-+#undef unreachable
-+#define unreachable()	do { } while(1)
-+
- static void machine_restart(char *command)
- {
- 	local_irq_disable();
diff --git a/target/linux/lantiq/patches-3.18/2002-falcon-fix-gpefreq.patch b/target/linux/lantiq/patches-3.18/2002-falcon-fix-gpefreq.patch
deleted file mode 100644
index 537effd530..0000000000
--- a/target/linux/lantiq/patches-3.18/2002-falcon-fix-gpefreq.patch
+++ /dev/null
@@ -1,21 +0,0 @@
-fix detection of invalid gpe clock setting
-
---- a/arch/mips/lantiq/falcon/sysctrl.c
-+++ b/arch/mips/lantiq/falcon/sysctrl.c
-@@ -147,12 +147,11 @@ static void falcon_gpe_enable(void)
- 	if (status & (1 << (GPPC_OFFSET + 1)))
- 		return;
- 
--	if (status_r32(STATUS_CONFIG) == 0)
-+	freq = (status_r32(STATUS_CONFIG) &
-+		GPEFREQ_MASK) >>
-+		GPEFREQ_OFFSET;
-+	if (freq == 0)
- 		freq = 1; /* use 625MHz on unfused chip */
--	else
--		freq = (status_r32(STATUS_CONFIG) &
--			GPEFREQ_MASK) >>
--			GPEFREQ_OFFSET;
- 
- 	/* apply new frequency */
- 	sysctl_w32_mask(SYSCTL_SYS1, 7 << (GPPC_OFFSET + 1),
diff --git a/target/linux/lantiq/patches-3.18/2005-falcon-sysctrl-refactor.patch b/target/linux/lantiq/patches-3.18/2005-falcon-sysctrl-refactor.patch
deleted file mode 100644
index fb89dfe35d..0000000000
--- a/target/linux/lantiq/patches-3.18/2005-falcon-sysctrl-refactor.patch
+++ /dev/null
@@ -1,127 +0,0 @@
-falcon: refactor 'sysctrl_init' from common code in 'ltq_soc_init'
-
-diff --git a/arch/mips/lantiq/falcon/sysctrl.c b/arch/mips/lantiq/falcon/sysctrl.c
---- a/arch/mips/lantiq/falcon/sysctrl.c
-+++ b/arch/mips/lantiq/falcon/sysctrl.c
-@@ -62,17 +62,26 @@
- #define ACTS_PADCTRL3	0x00200000
- #define ACTS_PADCTRL4	0x00400000
- 
--#define sysctl_w32(m, x, y)	ltq_w32((x), sysctl_membase[m] + (y))
--#define sysctl_r32(m, x)	ltq_r32(sysctl_membase[m] + (x))
--#define sysctl_w32_mask(m, clear, set, reg)	\
-+#define sysctl_w32(m,val,reg)	ltq_w32((val), sysctl_membase[m] + (reg))
-+#define sysctl_r32(m,reg)	ltq_r32(sysctl_membase[m] + (reg))
-+#define sysctl_w32_mask(m,clear,set,reg)	\
- 		sysctl_w32(m, (sysctl_r32(m, reg) & ~(clear)) | (set), reg)
- 
--#define status_w32(x, y)	ltq_w32((x), status_membase + (y))
--#define status_r32(x)		ltq_r32(status_membase + (x))
-+#define status_w32(val,reg)	sysctl_w32(3, val, reg)
-+#define status_r32(reg)		sysctl_r32(3, reg)
- 
--static void __iomem *sysctl_membase[3], *status_membase;
-+static const char *sysctrl_compatible[] = {
-+	"lantiq,sys1-falcon",
-+	"lantiq,syseth-falcon",
-+	"lantiq,sysgpe-falcon",
-+	"lantiq,status-falcon",
-+	"lantiq,ebu-falcon"
-+};
-+
-+static void __iomem *sysctl_membase[ARRAY_SIZE(sysctrl_compatible)];
- void __iomem *ltq_sys1_membase, *ltq_ebu_membase;
- 
-+
- void falcon_trigger_hrst(int level)
- {
- 	sysctl_w32(SYSCTL_SYS1, level & 1, SYS1_HRSTOUTC);
-@@ -181,62 +190,38 @@ static inline void clkdev_add_sys(const 
- 	clkdev_add(&clk->cl);
- }
- 
-+void __iomem * __init sysctrl_init(const char *compatible)
-+{
-+	struct device_node *np;
-+	struct resource res;
-+	void __iomem *base;
-+
-+	np = of_find_compatible_node(NULL, NULL, compatible);
-+	if (!np)
-+		panic("Failed to load node '%s'", compatible);
-+
-+	if (of_address_to_resource(np, 0, &res))
-+		panic("Failed to get '%s' resources", compatible);
-+
-+	if (request_mem_region(res.start, resource_size(&res), res.name) < 0)
-+		pr_err("Failed to request '%s' mem-region\n", compatible);
-+
-+	base = ioremap_nocache(res.start, resource_size(&res));
-+	if (!base)
-+		panic("Failed to remap '%s' resources", compatible);
-+
-+	return base;
-+}
-+
- void __init ltq_soc_init(void)
- {
--	struct device_node *np_status =
--		of_find_compatible_node(NULL, NULL, "lantiq,status-falcon");
--	struct device_node *np_ebu =
--		of_find_compatible_node(NULL, NULL, "lantiq,ebu-falcon");
--	struct device_node *np_sys1 =
--		of_find_compatible_node(NULL, NULL, "lantiq,sys1-falcon");
--	struct device_node *np_syseth =
--		of_find_compatible_node(NULL, NULL, "lantiq,syseth-falcon");
--	struct device_node *np_sysgpe =
--		of_find_compatible_node(NULL, NULL, "lantiq,sysgpe-falcon");
--	struct resource res_status, res_ebu, res_sys[3];
- 	int i;
- 
--	/* check if all the core register ranges are available */
--	if (!np_status || !np_ebu || !np_sys1 || !np_syseth || !np_sysgpe)
--		panic("Failed to load core nodes from devicetree");
-+	for (i = 0; i < ARRAY_SIZE(sysctrl_compatible); i++)
-+		sysctl_membase[i] = sysctrl_init(sysctrl_compatible[i]);
- 
--	if (of_address_to_resource(np_status, 0, &res_status) ||
--			of_address_to_resource(np_ebu, 0, &res_ebu) ||
--			of_address_to_resource(np_sys1, 0, &res_sys[0]) ||
--			of_address_to_resource(np_syseth, 0, &res_sys[1]) ||
--			of_address_to_resource(np_sysgpe, 0, &res_sys[2]))
--		panic("Failed to get core resources");
--
--	if ((request_mem_region(res_status.start, resource_size(&res_status),
--				res_status.name) < 0) ||
--		(request_mem_region(res_ebu.start, resource_size(&res_ebu),
--				res_ebu.name) < 0) ||
--		(request_mem_region(res_sys[0].start,
--				resource_size(&res_sys[0]),
--				res_sys[0].name) < 0) ||
--		(request_mem_region(res_sys[1].start,
--				resource_size(&res_sys[1]),
--				res_sys[1].name) < 0) ||
--		(request_mem_region(res_sys[2].start,
--				resource_size(&res_sys[2]),
--				res_sys[2].name) < 0))
--		pr_err("Failed to request core resources");
--
--	status_membase = ioremap_nocache(res_status.start,
--					resource_size(&res_status));
--	ltq_ebu_membase = ioremap_nocache(res_ebu.start,
--					resource_size(&res_ebu));
--
--	if (!status_membase || !ltq_ebu_membase)
--		panic("Failed to remap core resources");
--
--	for (i = 0; i < 3; i++) {
--		sysctl_membase[i] = ioremap_nocache(res_sys[i].start,
--						resource_size(&res_sys[i]));
--		if (!sysctl_membase[i])
--			panic("Failed to remap sysctrl resources");
--	}
- 	ltq_sys1_membase = sysctl_membase[0];
-+	ltq_ebu_membase = sysctl_membase[4];
- 
- 	falcon_gpe_enable();
- 
diff --git a/target/linux/lantiq/patches-3.18/2009-GPIO-MIPS-lantiq-add-gpio-driver-for-falcon-SoC.patch b/target/linux/lantiq/patches-3.18/2009-GPIO-MIPS-lantiq-add-gpio-driver-for-falcon-SoC.patch
deleted file mode 100644
index 61cc1b43bb..0000000000
--- a/target/linux/lantiq/patches-3.18/2009-GPIO-MIPS-lantiq-add-gpio-driver-for-falcon-SoC.patch
+++ /dev/null
@@ -1,399 +0,0 @@
-From: Thomas Langer <thomas.langer@lantiq.com>
-Date: Thu, 8 Aug 2013 16:19:15 +0200
-
-[PATCH 24/34] GPIO: MIPS: lantiq: add gpio driver for falcon SoC
-
-Add driver for GPIO blocks found on Lantiq FALCON SoC. The SoC has 5 banks of
-up to 32 pads. The GPIO blocks have a per pin IRQs.
-
-Signed-off-by: Thomas Langer <thomas.langer@lantiq.com>
-Acked-by: John Crispin <blogic@openwrt.org>
-Cc: linux-mips@linux-mips.org
-Cc: linux-gpio@vger.kernel.org
----
- drivers/gpio/Kconfig       |    5 +
- drivers/gpio/Makefile      |    1 +
- drivers/gpio/gpio-falcon.c |  348 ++++++++++++++++++++++++++++++++++++++++++++
- 3 files changed, 354 insertions(+)
- create mode 100644 drivers/gpio/gpio-falcon.c
-
-diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
---- a/drivers/gpio/Kconfig
-+++ b/drivers/gpio/Kconfig
-@@ -163,6 +163,11 @@ config GPIO_ZEVIO
- 	help
- 	  Say yes here to support the GPIO controller in LSI ZEVIO SoCs.
- 
-+config GPIO_FALCON
-+	def_bool y
-+	depends on MIPS && SOC_FALCON
-+	select GPIO_GENERIC
-+
- config GPIO_MM_LANTIQ
- 	bool "Lantiq Memory mapped GPIOs"
- 	depends on LANTIQ && SOC_XWAY
-diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
---- a/drivers/gpio/Makefile
-+++ b/drivers/gpio/Makefile
-@@ -30,6 +30,7 @@ obj-$(CONFIG_GPIO_DWAPB)	+= gpio-dwapb.o
- obj-$(CONFIG_GPIO_EM)		+= gpio-em.o
- obj-$(CONFIG_GPIO_EP93XX)	+= gpio-ep93xx.o
- obj-$(CONFIG_GPIO_F7188X)	+= gpio-f7188x.o
-+obj-$(CONFIG_GPIO_FALCON)	+= gpio-falcon.o
- obj-$(CONFIG_GPIO_GE_FPGA)	+= gpio-ge.o
- obj-$(CONFIG_GPIO_GRGPIO)	+= gpio-grgpio.o
- obj-$(CONFIG_GPIO_ICH)		+= gpio-ich.o
-diff --git a/drivers/gpio/gpio-falcon.c b/drivers/gpio/gpio-falcon.c
-new file mode 100644
---- /dev/null
-+++ b/drivers/gpio/gpio-falcon.c
-@@ -0,0 +1,349 @@
-+/*
-+ *  This program is free software; you can redistribute it and/or modify it
-+ *  under the terms of the GNU General Public License version 2 as published
-+ *  by the Free Software Foundation.
-+ *
-+ *  Copyright (C) 2012 Thomas Langer <thomas.langer@lantiq.com>
-+ *  Copyright (C) 2012 John Crispin <blogic@openwrt.org>
-+ */
-+
-+#include <linux/gpio.h>
-+#include <linux/interrupt.h>
-+#include <linux/slab.h>
-+#include <linux/export.h>
-+#include <linux/err.h>
-+#include <linux/module.h>
-+#include <linux/of.h>
-+#include <linux/of_irq.h>
-+#include <linux/pinctrl/pinctrl.h>
-+#include <linux/pinctrl/consumer.h>
-+#include <linux/platform_device.h>
-+
-+#include <lantiq_soc.h>
-+
-+/* Data Output Register */
-+#define GPIO_OUT            0x00000000
-+/* Data Input Register */
-+#define GPIO_IN             0x00000004
-+/* Direction Register */
-+#define GPIO_DIR            0x00000008
-+/* External Interrupt Control Register 0 */
-+#define GPIO_EXINTCR0       0x00000018
-+/* External Interrupt Control Register 1 */
-+#define GPIO_EXINTCR1       0x0000001C
-+/* IRN Capture Register */
-+#define GPIO_IRNCR          0x00000020
-+/* IRN Interrupt Configuration Register */
-+#define GPIO_IRNCFG		0x0000002C
-+/* IRN Interrupt Enable Set Register */
-+#define GPIO_IRNRNSET       0x00000030
-+/* IRN Interrupt Enable Clear Register */
-+#define GPIO_IRNENCLR       0x00000034
-+/* Output Set Register */
-+#define GPIO_OUTSET         0x00000040
-+/* Output Cler Register */
-+#define GPIO_OUTCLR         0x00000044
-+/* Direction Clear Register */
-+#define GPIO_DIRSET         0x00000048
-+/* Direction Set Register */
-+#define GPIO_DIRCLR         0x0000004C
-+
-+/* turn a gpio_chip into a falcon_gpio_port */
-+#define ctop(c)		container_of(c, struct falcon_gpio_port, gpio_chip)
-+/* turn a irq_data into a falcon_gpio_port */
-+#define itop(i)		((struct falcon_gpio_port *) irq_get_chip_data(i->irq))
-+
-+#define port_r32(p, reg)	ltq_r32(p->port + reg)
-+#define port_w32(p, val, reg)	ltq_w32(val, p->port + reg)
-+#define port_w32_mask(p, clear, set, reg) \
-+		port_w32(p, (port_r32(p, reg) & ~(clear)) | (set), reg)
-+
-+#define MAX_BANKS		5
-+#define PINS_PER_PORT		32
-+
-+struct falcon_gpio_port {
-+	struct gpio_chip gpio_chip;
-+	void __iomem *port;
-+	unsigned int irq_base;
-+	unsigned int chained_irq;
-+	struct clk *clk;
-+	char name[6];
-+};
-+
-+static struct irq_chip falcon_gpio_irq_chip;
-+
-+static int falcon_gpio_direction_input(struct gpio_chip *chip,
-+					unsigned int offset)
-+{
-+	port_w32(ctop(chip), 1 << offset, GPIO_DIRCLR);
-+
-+	return 0;
-+}
-+
-+static void falcon_gpio_set(struct gpio_chip *chip, unsigned int offset,
-+					int value)
-+{
-+	if (value)
-+		port_w32(ctop(chip), 1 << offset, GPIO_OUTSET);
-+	else
-+		port_w32(ctop(chip), 1 << offset, GPIO_OUTCLR);
-+}
-+
-+static int falcon_gpio_direction_output(struct gpio_chip *chip,
-+					unsigned int offset, int value)
-+{
-+	falcon_gpio_set(chip, offset, value);
-+	port_w32(ctop(chip), 1 << offset, GPIO_DIRSET);
-+
-+	return 0;
-+}
-+
-+static int falcon_gpio_get(struct gpio_chip *chip, unsigned int offset)
-+{
-+	if ((port_r32(ctop(chip), GPIO_DIR) >> offset) & 1)
-+		return (port_r32(ctop(chip), GPIO_OUT) >> offset) & 1;
-+	else
-+		return (port_r32(ctop(chip), GPIO_IN) >> offset) & 1;
-+}
-+
-+static int falcon_gpio_request(struct gpio_chip *chip, unsigned offset)
-+{
-+	int gpio = chip->base + offset;
-+
-+	return pinctrl_request_gpio(gpio);
-+}
-+
-+static void falcon_gpio_free(struct gpio_chip *chip, unsigned offset)
-+{
-+	int gpio = chip->base + offset;
-+
-+	pinctrl_free_gpio(gpio);
-+}
-+
-+static int falcon_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
-+{
-+	return ctop(chip)->irq_base + offset;
-+}
-+
-+static void falcon_gpio_disable_irq(struct irq_data *d)
-+{
-+	unsigned int offset = d->irq - itop(d)->irq_base;
-+
-+	port_w32(itop(d), 1 << offset, GPIO_IRNENCLR);
-+}
-+
-+static void falcon_gpio_enable_irq(struct irq_data *d)
-+{
-+	unsigned int offset = d->irq - itop(d)->irq_base;
-+
-+	port_w32(itop(d), 1 << offset, GPIO_IRNRNSET);
-+}
-+
-+static void falcon_gpio_ack_irq(struct irq_data *d)
-+{
-+	unsigned int offset = d->irq - itop(d)->irq_base;
-+
-+	port_w32(itop(d), 1 << offset, GPIO_IRNCR);
-+}
-+
-+static void falcon_gpio_mask_and_ack_irq(struct irq_data *d)
-+{
-+	unsigned int offset = d->irq - itop(d)->irq_base;
-+
-+	port_w32(itop(d), 1 << offset, GPIO_IRNENCLR);
-+	port_w32(itop(d), 1 << offset, GPIO_IRNCR);
-+}
-+
-+static int falcon_gpio_irq_type(struct irq_data *d, unsigned int type)
-+{
-+	unsigned int offset = d->irq - itop(d)->irq_base;
-+	unsigned int mask = 1 << offset;
-+
-+	if ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_NONE)
-+		return 0;
-+
-+	if ((type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) != 0) {
-+		/* level triggered */
-+		port_w32_mask(itop(d), 0, mask, GPIO_IRNCFG);
-+		irq_set_chip_and_handler_name(d->irq,
-+			&falcon_gpio_irq_chip, handle_level_irq, "mux");
-+	} else {
-+		/* edge triggered */
-+		port_w32_mask(itop(d), mask, 0, GPIO_IRNCFG);
-+		irq_set_chip_and_handler_name(d->irq,
-+			&falcon_gpio_irq_chip, handle_simple_irq, "mux");
-+	}
-+
-+	if ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {
-+		port_w32_mask(itop(d), mask, 0, GPIO_EXINTCR0);
-+		port_w32_mask(itop(d), 0, mask, GPIO_EXINTCR1);
-+	} else {
-+		if ((type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_LEVEL_HIGH)) != 0)
-+			/* positive logic: rising edge, high level */
-+			port_w32_mask(itop(d), mask, 0, GPIO_EXINTCR0);
-+		else
-+			/* negative logic: falling edge, low level */
-+			port_w32_mask(itop(d), 0, mask, GPIO_EXINTCR0);
-+		port_w32_mask(itop(d), mask, 0, GPIO_EXINTCR1);
-+	}
-+
-+	return gpio_direction_input(itop(d)->gpio_chip.base + offset);
-+}
-+
-+static void falcon_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
-+{
-+	struct falcon_gpio_port *gpio_port = irq_desc_get_handler_data(desc);
-+	unsigned long irncr;
-+	int offset;
-+
-+	/* acknowledge interrupt */
-+	irncr = port_r32(gpio_port, GPIO_IRNCR);
-+	port_w32(gpio_port, irncr, GPIO_IRNCR);
-+
-+	desc->irq_data.chip->irq_ack(&desc->irq_data);
-+
-+	for_each_set_bit(offset, &irncr, gpio_port->gpio_chip.ngpio)
-+		generic_handle_irq(gpio_port->irq_base + offset);
-+}
-+
-+static int falcon_gpio_irq_map(struct irq_domain *d, unsigned int irq,
-+				irq_hw_number_t hw)
-+{
-+	struct falcon_gpio_port *port = d->host_data;
-+
-+	irq_set_chip_and_handler_name(irq, &falcon_gpio_irq_chip,
-+			handle_simple_irq, "mux");
-+	irq_set_chip_data(irq, port);
-+
-+	/* set to negative logic (falling edge, low level) */
-+	port_w32_mask(port, 0, 1 << hw, GPIO_EXINTCR0);
-+	return 0;
-+}
-+
-+static struct irq_chip falcon_gpio_irq_chip = {
-+	.name = "gpio_irq_mux",
-+	.irq_mask = falcon_gpio_disable_irq,
-+	.irq_unmask = falcon_gpio_enable_irq,
-+	.irq_ack = falcon_gpio_ack_irq,
-+	.irq_mask_ack = falcon_gpio_mask_and_ack_irq,
-+	.irq_set_type = falcon_gpio_irq_type,
-+};
-+
-+static const struct irq_domain_ops irq_domain_ops = {
-+	.xlate = irq_domain_xlate_onetwocell,
-+	.map = falcon_gpio_irq_map,
-+};
-+
-+static struct irqaction gpio_cascade = {
-+	.handler = no_action,
-+	.flags = IRQF_DISABLED,
-+	.name = "gpio_cascade",
-+};
-+
-+static int falcon_gpio_probe(struct platform_device *pdev)
-+{
-+	struct pinctrl_gpio_range *gpio_range;
-+	struct device_node *node = pdev->dev.of_node;
-+	const __be32 *bank = of_get_property(node, "lantiq,bank", NULL);
-+	struct falcon_gpio_port *gpio_port;
-+	struct resource *gpiores, irqres;
-+	int ret, size;
-+
-+	if (!bank || *bank >= MAX_BANKS)
-+		return -ENODEV;
-+
-+	size = pinctrl_falcon_get_range_size(*bank);
-+	if (size < 1) {
-+		dev_err(&pdev->dev, "pad not loaded for bank %d\n", *bank);
-+		return size;
-+	}
-+
-+	gpio_range = devm_kzalloc(&pdev->dev, sizeof(struct pinctrl_gpio_range),
-+				GFP_KERNEL);
-+	if (!gpio_range)
-+		return -ENOMEM;
-+
-+	gpio_port = devm_kzalloc(&pdev->dev, sizeof(struct falcon_gpio_port),
-+				GFP_KERNEL);
-+	if (!gpio_port)
-+		return -ENOMEM;
-+
-+	snprintf(gpio_port->name, 6, "gpio%d", *bank);
-+	gpio_port->gpio_chip.label = gpio_port->name;
-+	gpio_port->gpio_chip.direction_input = falcon_gpio_direction_input;
-+	gpio_port->gpio_chip.direction_output = falcon_gpio_direction_output;
-+	gpio_port->gpio_chip.get = falcon_gpio_get;
-+	gpio_port->gpio_chip.set = falcon_gpio_set;
-+	gpio_port->gpio_chip.request = falcon_gpio_request;
-+	gpio_port->gpio_chip.free = falcon_gpio_free;
-+	gpio_port->gpio_chip.base = *bank * PINS_PER_PORT;
-+	gpio_port->gpio_chip.ngpio = size;
-+	gpio_port->gpio_chip.dev = &pdev->dev;
-+
-+	gpiores = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-+	gpio_port->port = devm_ioremap_resource(&pdev->dev, gpiores);
-+	if (IS_ERR(gpio_port->port))
-+		return PTR_ERR(gpio_port->port);
-+
-+	gpio_port->clk = devm_clk_get(&pdev->dev, NULL);
-+	if (IS_ERR(gpio_port->clk))
-+		return PTR_ERR(gpio_port->clk);
-+	clk_activate(gpio_port->clk);
-+
-+	if (of_irq_to_resource_table(node, &irqres, 1) == 1) {
-+		gpio_port->irq_base = INT_NUM_EXTRA_START + (32 * *bank);
-+		gpio_port->gpio_chip.to_irq = falcon_gpio_to_irq;
-+		gpio_port->chained_irq = irqres.start;
-+		irq_domain_add_legacy(node, size, gpio_port->irq_base, 0,
-+					&irq_domain_ops, gpio_port);
-+		setup_irq(irqres.start, &gpio_cascade);
-+		irq_set_handler_data(irqres.start, gpio_port);
-+		irq_set_chained_handler(irqres.start, falcon_gpio_irq_handler);
-+	}
-+
-+	ret = gpiochip_add(&gpio_port->gpio_chip);
-+	if (ret)
-+		return ret;
-+
-+	platform_set_drvdata(pdev, gpio_port);
-+
-+	gpio_range->name = "FALCON GPIO";
-+	gpio_range->id = *bank;
-+	gpio_range->base = gpio_port->gpio_chip.base;
-+	gpio_range->pin_base = gpio_port->gpio_chip.base;
-+	gpio_range->npins = gpio_port->gpio_chip.ngpio;
-+	gpio_range->gc = &gpio_port->gpio_chip;
-+
-+	pinctrl_falcon_add_gpio_range(gpio_range);
-+
-+	return 0;
-+}
-+
-+static const struct of_device_id falcon_gpio_match[] = {
-+	{ .compatible = "lantiq,falcon-gpio" },
-+	{ .compatible = "lantiq,gpio-falcon" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, falcon_gpio_match);
-+
-+static struct platform_driver falcon_gpio_driver = {
-+	.probe = falcon_gpio_probe,
-+	.driver = {
-+		.name = "gpio-falcon",
-+		.owner = THIS_MODULE,
-+		.of_match_table = falcon_gpio_match,
-+	},
-+};
-+
-+int __init falcon_gpio_init(void)
-+{
-+	int ret;
-+
-+	pr_info("FALC(tm) ON GPIO Driver, (C) 2012 Lantiq Deutschland Gmbh\n");
-+	ret = platform_driver_register(&falcon_gpio_driver);
-+	if (ret)
-+		pr_err("falcon_gpio: Error registering platform driver!");
-+	return ret;
-+}
-+
-+subsys_initcall(falcon_gpio_init);
diff --git a/target/linux/lantiq/patches-3.18/2010-falcon-gpio-use-local-function-in-falcon_gpio_irq_type.patch b/target/linux/lantiq/patches-3.18/2010-falcon-gpio-use-local-function-in-falcon_gpio_irq_type.patch
deleted file mode 100644
index 10f49ffbe4..0000000000
--- a/target/linux/lantiq/patches-3.18/2010-falcon-gpio-use-local-function-in-falcon_gpio_irq_type.patch
+++ /dev/null
@@ -1,15 +0,0 @@
-use driver internal function in falcon_gpio_irq_type (instead gpio_direction_input)
-to avoid dump in gpio_ensure_requested()
-
-diff --git a/drivers/gpio/gpio-falcon.c b/drivers/gpio/gpio-falcon.c
---- a/drivers/gpio/gpio-falcon.c
-+++ b/drivers/gpio/gpio-falcon.c
-@@ -187,7 +187,7 @@ static int falcon_gpio_irq_type(struct i
- 		port_w32_mask(itop(d), mask, 0, GPIO_EXINTCR1);
- 	}
- 
--	return gpio_direction_input(itop(d)->gpio_chip.base + offset);
-+	return falcon_gpio_direction_input(&itop(d)->gpio_chip, offset);
- }
- 
- static void falcon_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
diff --git a/target/linux/lantiq/patches-3.18/2012-falcon-gpio-remove-irq_base.patch b/target/linux/lantiq/patches-3.18/2012-falcon-gpio-remove-irq_base.patch
deleted file mode 100644
index c38a4f9930..0000000000
--- a/target/linux/lantiq/patches-3.18/2012-falcon-gpio-remove-irq_base.patch
+++ /dev/null
@@ -1,130 +0,0 @@
-gpio-falcon: don't use a fixed irq_base, use dynamic number assignment
-
-diff --git a/drivers/gpio/gpio-falcon.c b/drivers/gpio/gpio-falcon.c
---- a/drivers/gpio/gpio-falcon.c
-+++ b/drivers/gpio/gpio-falcon.c
-@@ -64,7 +64,7 @@
- struct falcon_gpio_port {
- 	struct gpio_chip gpio_chip;
- 	void __iomem *port;
--	unsigned int irq_base;
-+	struct irq_domain *domain;
- 	unsigned int chained_irq;
- 	struct clk *clk;
- 	char name[6];
-@@ -122,33 +122,33 @@ static void falcon_gpio_free(struct gpio
- 
- static int falcon_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
- {
--	return ctop(chip)->irq_base + offset;
-+	return irq_create_mapping(ctop(chip)->domain, offset);
- }
- 
- static void falcon_gpio_disable_irq(struct irq_data *d)
- {
--	unsigned int offset = d->irq - itop(d)->irq_base;
-+	unsigned int offset = d->hwirq;
- 
- 	port_w32(itop(d), 1 << offset, GPIO_IRNENCLR);
- }
- 
- static void falcon_gpio_enable_irq(struct irq_data *d)
- {
--	unsigned int offset = d->irq - itop(d)->irq_base;
-+	unsigned int offset = d->hwirq;
- 
- 	port_w32(itop(d), 1 << offset, GPIO_IRNRNSET);
- }
- 
- static void falcon_gpio_ack_irq(struct irq_data *d)
- {
--	unsigned int offset = d->irq - itop(d)->irq_base;
-+	unsigned int offset = d->hwirq;
- 
- 	port_w32(itop(d), 1 << offset, GPIO_IRNCR);
- }
- 
- static void falcon_gpio_mask_and_ack_irq(struct irq_data *d)
- {
--	unsigned int offset = d->irq - itop(d)->irq_base;
-+	unsigned int offset = d->hwirq;
- 
- 	port_w32(itop(d), 1 << offset, GPIO_IRNENCLR);
- 	port_w32(itop(d), 1 << offset, GPIO_IRNCR);
-@@ -156,7 +156,7 @@ static void falcon_gpio_mask_and_ack_irq
- 
- static int falcon_gpio_irq_type(struct irq_data *d, unsigned int type)
- {
--	unsigned int offset = d->irq - itop(d)->irq_base;
-+	unsigned int offset = d->hwirq;
- 	unsigned int mask = 1 << offset;
- 
- 	if ((type & IRQ_TYPE_SENSE_MASK) == IRQ_TYPE_NONE)
-@@ -166,12 +166,12 @@ static int falcon_gpio_irq_type(struct i
- 		/* level triggered */
- 		port_w32_mask(itop(d), 0, mask, GPIO_IRNCFG);
- 		irq_set_chip_and_handler_name(d->irq,
--			&falcon_gpio_irq_chip, handle_level_irq, "mux");
-+			&falcon_gpio_irq_chip, handle_level_irq, "level");
- 	} else {
- 		/* edge triggered */
- 		port_w32_mask(itop(d), mask, 0, GPIO_IRNCFG);
- 		irq_set_chip_and_handler_name(d->irq,
--			&falcon_gpio_irq_chip, handle_simple_irq, "mux");
-+			&falcon_gpio_irq_chip, handle_simple_irq, "edge");
- 	}
- 
- 	if ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {
-@@ -194,7 +194,7 @@ static void falcon_gpio_irq_handler(unsi
- {
- 	struct falcon_gpio_port *gpio_port = irq_desc_get_handler_data(desc);
- 	unsigned long irncr;
--	int offset;
-+	int offset, child_irq;
- 
- 	/* acknowledge interrupt */
- 	irncr = port_r32(gpio_port, GPIO_IRNCR);
-@@ -202,8 +202,11 @@ static void falcon_gpio_irq_handler(unsi
- 
- 	desc->irq_data.chip->irq_ack(&desc->irq_data);
- 
--	for_each_set_bit(offset, &irncr, gpio_port->gpio_chip.ngpio)
--		generic_handle_irq(gpio_port->irq_base + offset);
-+	for_each_set_bit(offset, &irncr, gpio_port->gpio_chip.ngpio) {
-+		child_irq = irq_find_mapping(gpio_port->domain, offset);
-+		if (child_irq)
-+			generic_handle_irq(child_irq);
-+	}
- }
- 
- static int falcon_gpio_irq_map(struct irq_domain *d, unsigned int irq,
-@@ -212,7 +215,7 @@ static int falcon_gpio_irq_map(struct ir
- 	struct falcon_gpio_port *port = d->host_data;
- 
- 	irq_set_chip_and_handler_name(irq, &falcon_gpio_irq_chip,
--			handle_simple_irq, "mux");
-+				      handle_simple_irq, port->name);
- 	irq_set_chip_data(irq, port);
- 
- 	/* set to negative logic (falling edge, low level) */
-@@ -221,7 +224,7 @@ static int falcon_gpio_irq_map(struct ir
- }
- 
- static struct irq_chip falcon_gpio_irq_chip = {
--	.name = "gpio_irq_mux",
-+	.name = "gpio-falcon",
- 	.irq_mask = falcon_gpio_disable_irq,
- 	.irq_unmask = falcon_gpio_enable_irq,
- 	.irq_ack = falcon_gpio_ack_irq,
-@@ -291,10 +294,9 @@ static int falcon_gpio_probe(struct plat
- 	clk_activate(gpio_port->clk);
- 
- 	if (of_irq_to_resource_table(node, &irqres, 1) == 1) {
--		gpio_port->irq_base = INT_NUM_EXTRA_START + (32 * *bank);
- 		gpio_port->gpio_chip.to_irq = falcon_gpio_to_irq;
- 		gpio_port->chained_irq = irqres.start;
--		irq_domain_add_legacy(node, size, gpio_port->irq_base, 0,
-+		gpio_port->domain = irq_domain_add_simple(node, size, 0,
- 					&irq_domain_ops, gpio_port);
- 		setup_irq(irqres.start, &gpio_cascade);
- 		irq_set_handler_data(irqres.start, gpio_port);
diff --git a/target/linux/lantiq/patches-3.18/2013-falcon-gpio-fix-locking.patch b/target/linux/lantiq/patches-3.18/2013-falcon-gpio-fix-locking.patch
deleted file mode 100644
index b6f2ad3476..0000000000
--- a/target/linux/lantiq/patches-3.18/2013-falcon-gpio-fix-locking.patch
+++ /dev/null
@@ -1,21 +0,0 @@
-gpio-falcon: fix recursive locking in .irq_set_type
-this is called while already holding the "irq_desc_lock"
-
-diff --git a/drivers/gpio/gpio-falcon.c b/drivers/gpio/gpio-falcon.c
---- a/drivers/gpio/gpio-falcon.c
-+++ b/drivers/gpio/gpio-falcon.c
-@@ -166,12 +166,12 @@ static int falcon_gpio_irq_type(struct i
- 	if ((type & (IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) != 0) {
- 		/* level triggered */
- 		port_w32_mask(itop(d), 0, mask, GPIO_IRNCFG);
--		irq_set_chip_and_handler_name(d->irq,
-+		__irq_set_chip_handler_name_locked(d->irq,
- 			&falcon_gpio_irq_chip, handle_level_irq, "level");
- 	} else {
- 		/* edge triggered */
- 		port_w32_mask(itop(d), mask, 0, GPIO_IRNCFG);
--		irq_set_chip_and_handler_name(d->irq,
-+		__irq_set_chip_handler_name_locked(d->irq,
- 			&falcon_gpio_irq_chip, handle_simple_irq, "edge");
- 	}
- 
diff --git a/target/linux/lantiq/patches-3.18/2015-falcon-gpio-use-aliases.patch b/target/linux/lantiq/patches-3.18/2015-falcon-gpio-use-aliases.patch
deleted file mode 100644
index 4136eb51fc..0000000000
--- a/target/linux/lantiq/patches-3.18/2015-falcon-gpio-use-aliases.patch
+++ /dev/null
@@ -1,62 +0,0 @@
-gpio-falcon: use and prefer entries from "aliases" as bank number
-
-diff --git a/drivers/gpio/gpio-falcon.c b/drivers/gpio/gpio-falcon.c
---- a/drivers/gpio/gpio-falcon.c
-+++ b/drivers/gpio/gpio-falcon.c
-@@ -250,17 +250,25 @@ static int falcon_gpio_probe(struct plat
- {
- 	struct pinctrl_gpio_range *gpio_range;
- 	struct device_node *node = pdev->dev.of_node;
--	const __be32 *bank = of_get_property(node, "lantiq,bank", NULL);
-+	uint32_t bank;
- 	struct falcon_gpio_port *gpio_port;
- 	struct resource *gpiores, irqres;
- 	int ret, size;
- 
--	if (!bank || *bank >= MAX_BANKS)
-+	ret = of_alias_get_id(node, "gpio");
-+	if (ret >= 0) {
-+		bank = ret;
-+	} else {
-+		if (of_property_read_u32(node, "lantiq,bank", &bank))
-+			return -ENODEV;
-+	}
-+
-+	if (bank >= MAX_BANKS)
- 		return -ENODEV;
- 
--	size = pinctrl_falcon_get_range_size(*bank);
-+	size = pinctrl_falcon_get_range_size(bank);
- 	if (size < 1) {
--		dev_err(&pdev->dev, "pad not loaded for bank %d\n", *bank);
-+		dev_err(&pdev->dev, "pad not loaded for bank %d\n", bank);
- 		return size;
- 	}
- 
-@@ -274,7 +282,7 @@ static int falcon_gpio_probe(struct plat
- 	if (!gpio_port)
- 		return -ENOMEM;
- 
--	snprintf(gpio_port->name, 6, "gpio%d", *bank);
-+	snprintf(gpio_port->name, 6, "gpio%d", bank);
- 	gpio_port->gpio_chip.label = gpio_port->name;
- 	gpio_port->gpio_chip.direction_input = falcon_gpio_direction_input;
- 	gpio_port->gpio_chip.direction_output = falcon_gpio_direction_output;
-@@ -282,7 +290,7 @@ static int falcon_gpio_probe(struct plat
- 	gpio_port->gpio_chip.set = falcon_gpio_set;
- 	gpio_port->gpio_chip.request = falcon_gpio_request;
- 	gpio_port->gpio_chip.free = falcon_gpio_free;
--	gpio_port->gpio_chip.base = *bank * PINS_PER_PORT;
-+	gpio_port->gpio_chip.base = bank * PINS_PER_PORT;
- 	gpio_port->gpio_chip.ngpio = size;
- 	gpio_port->gpio_chip.dev = &pdev->dev;
- 
-@@ -313,7 +321,7 @@ static int falcon_gpio_probe(struct plat
- 	platform_set_drvdata(pdev, gpio_port);
- 
- 	gpio_range->name = "FALCON GPIO";
--	gpio_range->id = *bank;
-+	gpio_range->id = bank;
- 	gpio_range->base = gpio_port->gpio_chip.base;
- 	gpio_range->pin_base = gpio_port->gpio_chip.base;
- 	gpio_range->npins = gpio_port->gpio_chip.ngpio;
diff --git a/target/linux/lantiq/patches-3.18/2020-lantiq-serial-use-pinctrl.patch b/target/linux/lantiq/patches-3.18/2020-lantiq-serial-use-pinctrl.patch
deleted file mode 100644
index 3297f7ea11..0000000000
--- a/target/linux/lantiq/patches-3.18/2020-lantiq-serial-use-pinctrl.patch
+++ /dev/null
@@ -1,32 +0,0 @@
-add use of devm_pinctrl_get_select_default to active default pinctrl settings
-
---- a/drivers/tty/serial/lantiq.c
-+++ b/drivers/tty/serial/lantiq.c
-@@ -37,6 +37,8 @@
- #include <linux/io.h>
- #include <linux/clk.h>
- #include <linux/gpio.h>
-+#include <linux/pinctrl/consumer.h>
-+#include <linux/err.h>
- 
- #include <lantiq_soc.h>
- 
-@@ -681,6 +683,7 @@ lqasc_probe(struct platform_device *pdev
- 	struct ltq_uart_port *ltq_port;
- 	struct uart_port *port;
- 	struct resource *mmres, irqres[3];
-+	struct pinctrl *pinctrl;
- 	int line = 0;
- 	int ret;
- 
-@@ -719,6 +722,10 @@ lqasc_probe(struct platform_device *pdev
- 	port->irq	= irqres[0].start;
- 	port->mapbase	= mmres->start;
- 
-+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
-+	if (IS_ERR(pinctrl))
-+		dev_warn(&pdev->dev, "pins are not configured from the driver\n");
-+
- 	ltq_port->fpiclk = clk_get_fpi();
- 	if (IS_ERR(ltq_port->fpiclk)) {
- 		pr_err("failed to get fpi clk\n");
diff --git a/target/linux/lantiq/patches-3.18/2022-lantiq-serial-dummy-tty-tx.patch b/target/linux/lantiq/patches-3.18/2022-lantiq-serial-dummy-tty-tx.patch
deleted file mode 100644
index 4ffa35c405..0000000000
--- a/target/linux/lantiq/patches-3.18/2022-lantiq-serial-dummy-tty-tx.patch
+++ /dev/null
@@ -1,115 +0,0 @@
-this patch adds the possibility to disable tx output in the serial driver
-
-diff --git a/drivers/tty/serial/lantiq.c b/drivers/tty/serial/lantiq.c
---- a/drivers/tty/serial/lantiq.c
-+++ b/drivers/tty/serial/lantiq.c
-@@ -112,8 +112,9 @@
- #define ASCFSTAT_TXFREEMASK	0x3F000000
- #define ASCFSTAT_TXFREEOFF	24
- 
--static void lqasc_tx_chars(struct uart_port *port);
-+static void lqasc_tx_chars(struct uart_port *port, const bool dummy);
- static struct ltq_uart_port *lqasc_port[MAXPORTS];
-+static unsigned int lqasc_tx_block[MAXPORTS] = {0};
- static struct uart_driver lqasc_reg;
- static DEFINE_SPINLOCK(ltq_asc_lock);
- 
-@@ -128,6 +129,17 @@ struct ltq_uart_port {
- 	unsigned int		err_irq;
- };
- 
-+int lqasc_tty_block_tx(const unsigned int line, const unsigned int block)
-+{
-+	if (line >= MAXPORTS)
-+		return -1;
-+
-+	lqasc_tx_block[line] = block;
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL(lqasc_tty_block_tx);
-+
- static inline struct
- ltq_uart_port *to_ltq_uart_port(struct uart_port *port)
- {
-@@ -145,7 +157,7 @@ lqasc_start_tx(struct uart_port *port)
- {
- 	unsigned long flags;
- 	spin_lock_irqsave(&ltq_asc_lock, flags);
--	lqasc_tx_chars(port);
-+	lqasc_tx_chars(port, lqasc_tx_block[port->line] ? true : false);
- 	spin_unlock_irqrestore(&ltq_asc_lock, flags);
- 	return;
- }
-@@ -223,7 +235,7 @@ lqasc_rx_chars(struct uart_port *port)
- }
- 
- static void
--lqasc_tx_chars(struct uart_port *port)
-+lqasc_tx_chars(struct uart_port *port, const bool dummy)
- {
- 	struct circ_buf *xmit = &port->state->xmit;
- 	if (uart_tx_stopped(port)) {
-@@ -232,9 +244,12 @@ lqasc_tx_chars(struct uart_port *port)
- 	}
- 
- 	while (((ltq_r32(port->membase + LTQ_ASC_FSTAT) &
--		ASCFSTAT_TXFREEMASK) >> ASCFSTAT_TXFREEOFF) != 0) {
-+		ASCFSTAT_TXFREEMASK) >> ASCFSTAT_TXFREEOFF) != 0 || dummy) {
- 		if (port->x_char) {
--			ltq_w8(port->x_char, port->membase + LTQ_ASC_TBUF);
-+			if (!dummy)
-+				ltq_w8(port->x_char,
-+				       port->membase + LTQ_ASC_TBUF);
-+
- 			port->icount.tx++;
- 			port->x_char = 0;
- 			continue;
-@@ -243,8 +258,9 @@ lqasc_tx_chars(struct uart_port *port)
- 		if (uart_circ_empty(xmit))
- 			break;
- 
--		ltq_w8(port->state->xmit.buf[port->state->xmit.tail],
--			port->membase + LTQ_ASC_TBUF);
-+		if (!dummy)
-+			ltq_w8(port->state->xmit.buf[port->state->xmit.tail],
-+			       port->membase + LTQ_ASC_TBUF);
- 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
- 		port->icount.tx++;
- 	}
-@@ -597,18 +613,16 @@ lqasc_console_putchar(struct uart_port *
- 	ltq_w8(ch, port->membase + LTQ_ASC_TBUF);
- }
- 
--
--static void
--lqasc_console_write(struct console *co, const char *s, u_int count)
-+void lqasc_console_puts(const short index, const char *s, u_int count)
- {
- 	struct ltq_uart_port *ltq_port;
- 	struct uart_port *port;
- 	unsigned long flags;
- 
--	if (co->index >= MAXPORTS)
-+	if (index >= MAXPORTS)
- 		return;
- 
--	ltq_port = lqasc_port[co->index];
-+	ltq_port = lqasc_port[index];
- 	if (!ltq_port)
- 		return;
- 
-@@ -618,6 +632,13 @@ lqasc_console_write(struct console *co, 
- 	uart_console_write(port, s, count, lqasc_console_putchar);
- 	spin_unlock_irqrestore(&ltq_asc_lock, flags);
- }
-+EXPORT_SYMBOL(lqasc_console_puts);
-+
-+static void
-+lqasc_console_write(struct console *co, const char *s, u_int count)
-+{
-+	lqasc_console_puts(co->index, s, count);
-+}
- 
- static int __init
- lqasc_console_setup(struct console *co, char *options)
diff --git a/target/linux/lantiq/patches-3.18/2040-lantiq-i2c-use-pinctrl.patch b/target/linux/lantiq/patches-3.18/2040-lantiq-i2c-use-pinctrl.patch
deleted file mode 100644
index 3f1eedcc1a..0000000000
--- a/target/linux/lantiq/patches-3.18/2040-lantiq-i2c-use-pinctrl.patch
+++ /dev/null
@@ -1,33 +0,0 @@
-add use of devm_pinctrl_get_select_default to active default pinctrl settings
-
-diff --git a/drivers/i2c/busses/i2c-lantiq.c b/drivers/i2c/busses/i2c-lantiq.c
---- a/drivers/i2c/busses/i2c-lantiq.c
-+++ b/drivers/i2c/busses/i2c-lantiq.c
-@@ -32,6 +32,8 @@
- #include <linux/platform_device.h>
- #include <linux/io.h>
- #include <linux/of_irq.h>
-+#include <linux/pinctrl/consumer.h>
-+#include <linux/err.h>
- 
- #include <lantiq_soc.h>
- #include "i2c-lantiq.h"
-@@ -576,6 +578,7 @@ static int ltq_i2c_probe(struct platform
- 	struct ltq_i2c *priv;
- 	struct i2c_adapter *adap;
- 	struct resource *mmres, irqres[4];
-+	struct pinctrl *pinctrl;
- 	int ret = 0;
- 
- 	dev_dbg(&pdev->dev, "probing\n");
-@@ -587,6 +590,10 @@ static int ltq_i2c_probe(struct platform
- 		return -ENODEV;
- 	}
- 
-+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
-+	if (IS_ERR(pinctrl))
-+		dev_warn(&pdev->dev, "pins are not configured from the driver\n");
-+
- 	/* allocate private data */
- 	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
- 	if (!priv) {
diff --git a/target/linux/lantiq/patches-3.18/2041-lantiq-i2c-fix-parent.patch b/target/linux/lantiq/patches-3.18/2041-lantiq-i2c-fix-parent.patch
deleted file mode 100644
index d6e3445065..0000000000
--- a/target/linux/lantiq/patches-3.18/2041-lantiq-i2c-fix-parent.patch
+++ /dev/null
@@ -1,22 +0,0 @@
-fix assignment of parent and of_node
-
-diff --git a/drivers/i2c/busses/i2c-lantiq.c b/drivers/i2c/busses/i2c-lantiq.c
---- a/drivers/i2c/busses/i2c-lantiq.c
-+++ b/drivers/i2c/busses/i2c-lantiq.c
-@@ -608,6 +608,8 @@ static int ltq_i2c_probe(struct platform
- 	adap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
- 	strlcpy(adap->name, DRV_NAME "-adapter", sizeof(adap->name));
- 	adap->algo = &ltq_i2c_algorithm;
-+	adap->dev.parent = &pdev->dev;
-+	adap->dev.of_node = node;
- 
- 	if (of_property_read_u32(node, "clock-frequency", &priv->i2c_clock)) {
- 		dev_warn(&pdev->dev, "No I2C speed selected, using 100kHz\n");
-@@ -696,6 +698,7 @@ static int ltq_i2c_probe(struct platform
- 		dev_err(&pdev->dev, "can't configure adapter\n");
- 		i2c_del_adapter(adap);
- 		platform_set_drvdata(pdev, NULL);
-+		goto out;
- 	} else {
- 		dev_info(&pdev->dev, "version %s\n", DRV_VERSION);
- 	}
diff --git a/target/linux/lantiq/patches-3.18/2060-spi-xway-to-generic-lantiq-ssc.patch b/target/linux/lantiq/patches-3.18/2060-spi-xway-to-generic-lantiq-ssc.patch
deleted file mode 100644
index 0d5cde9b2e..0000000000
--- a/target/linux/lantiq/patches-3.18/2060-spi-xway-to-generic-lantiq-ssc.patch
+++ /dev/null
@@ -1,1881 +0,0 @@
-update Lantiq SPI driver to work on more platforms (e.g. Falcon, SVIP)
-
-diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
---- a/drivers/spi/Kconfig
-+++ b/drivers/spi/Kconfig
-@@ -598,13 +598,29 @@ config SPI_NUC900
- 	  SPI driver for Nuvoton NUC900 series ARM SoCs
- 
- config SPI_XWAY
--	tristate "Lantiq XWAY SPI controller"
--	depends on LANTIQ && SOC_TYPE_XWAY
-+	tristate "Lantiq SPI controller"
-+	depends on LANTIQ
- 	select SPI_BITBANG
- 	help
- 	  This driver supports the Lantiq SoC SPI controller in master
- 	  mode.
- 
-+config SPI_XWAY_BV
-+	bool "Byte valid control enable for Lantiq SPI controller"
-+	depends on SPI_XWAY
-+	help
-+	  With byte valid control enabled, the FPI opcode (from CPU) or
-+	  D2P_DMA_BE input (from DMA) controls data width for serial
-+	  transfer.
-+
-+config SPI_XWAY_CSI
-+	tristate "Lantiq SPI controller for CSI"
-+	depends on LANTIQ
-+	select SPI_BITBANG
-+	help
-+	  This driver supports the Lantiq SoC SPI controller in Combined
-+	  Serial Interface mode.
-+
- #
- # Add new SPI master controllers in alphabetical order above this line
- #
-diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
---- a/drivers/spi/Makefile
-+++ b/drivers/spi/Makefile
-@@ -87,3 +87,4 @@ obj-$(CONFIG_SPI_XCOMM)		+= spi-xcomm.o
- obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
- obj-$(CONFIG_SPI_XTENSA_XTFPGA)		+= spi-xtensa-xtfpga.o
- obj-$(CONFIG_SPI_XWAY)			+= spi-xway.o
-+obj-$(CONFIG_SPI_XWAY_CSI)		+= spi-xway-csi.o
-diff --git a/drivers/spi/spi-xway-csi.c b/drivers/spi/spi-xway-csi.c
-new file mode 100644
---- /dev/null
-+++ b/drivers/spi/spi-xway-csi.c
-@@ -0,0 +1,1178 @@
-+/*
-+ * Lantiq SoC SPI controller for Combined Serial Interface
-+ *
-+ * Copyright (C) 2011 Daniel Schwierzeck <daniel.schwierzeck@googlemail.com>
-+ * Copyright (C) 2012 John Crispin <blogic@openwrt.org>
-+ *
-+ * This program is free software; you can distribute it and/or modify it
-+ * under the terms of the GNU General Public License (Version 2) as
-+ * published by the Free Software Foundation.
-+ */
-+
-+#include <linux/init.h>
-+#include <linux/module.h>
-+#include <linux/workqueue.h>
-+#include <linux/platform_device.h>
-+#include <linux/io.h>
-+#include <linux/sched.h>
-+#include <linux/delay.h>
-+#include <linux/interrupt.h>
-+#include <linux/completion.h>
-+#include <linux/spinlock.h>
-+#include <linux/err.h>
-+#include <linux/clk.h>
-+#include <linux/spi/spi.h>
-+#include <linux/spi/spi_bitbang.h>
-+#include <linux/of_gpio.h>
-+#include <linux/of_irq.h>
-+#include <linux/gpio.h>
-+
-+#include <lantiq_soc.h>
-+
-+#define LTQ_SPI_CLC		0x00	/* Clock control */
-+#define LTQ_SPI_PISEL		0x04	/* Port input select */
-+#define LTQ_SPI_ID		0x08	/* Identification */
-+#define LTQ_SPI_CON		0x10	/* Control */
-+#define LTQ_SPI_STAT		0x14	/* Status */
-+#define LTQ_SPI_WHBSTATE	0x18	/* Write HW modified state */
-+#define LTQ_SPI_TB		0x20	/* Transmit buffer */
-+#define LTQ_SPI_RB		0x24	/* Receive buffer */
-+#define LTQ_SPI_RXFCON		0x30	/* Receive FIFO control */
-+#define LTQ_SPI_TXFCON		0x34	/* Transmit FIFO control */
-+#define LTQ_SPI_FSTAT		0x38	/* FIFO status */
-+#define LTQ_SPI_BRT		0x40	/* Baudrate timer */
-+#define LTQ_SPI_BRSTAT		0x44	/* Baudrate timer status */
-+#define LTQ_SPI_SFCON		0x60	/* Serial frame control */
-+#define LTQ_SPI_SFSTAT		0x64	/* Serial frame status */
-+#define LTQ_SPI_GPOCON		0x70	/* General purpose output control */
-+#define LTQ_SPI_GPOSTAT		0x74	/* General purpose output status */
-+#define LTQ_SPI_FGPO		0x78	/* Forced general purpose output */
-+#define LTQ_SPI_RXREQ		0x80	/* Receive request */
-+#define LTQ_SPI_RXCNT		0x84	/* Receive count */
-+#define LTQ_SPI_DMACON		0xEC	/* DMA control */
-+#define LTQ_SPI_IRNEN		0xF4	/* Interrupt node enable */
-+#define LTQ_SPI_IRNICR		0xF8	/* Interrupt node interrupt capture */
-+#define LTQ_SPI_IRNCR		0xFC	/* Interrupt node control */
-+
-+#define LTQ_SPI_CLC_SMC_SHIFT	16	/* Clock divider for sleep mode */
-+#define LTQ_SPI_CLC_SMC_MASK	0xFF
-+#define LTQ_SPI_CLC_RMC_SHIFT	8	/* Clock divider for normal run mode */
-+#define LTQ_SPI_CLC_RMC_MASK	0xFF
-+#define LTQ_SPI_CLC_DISS	BIT(1)	/* Disable status bit */
-+#define LTQ_SPI_CLC_DISR	BIT(0)	/* Disable request bit */
-+
-+#define LTQ_SPI_ID_TXFS_SHIFT	24	/* Implemented TX FIFO size */
-+#define LTQ_SPI_ID_TXFS_MASK	0x3F
-+#define LTQ_SPI_ID_RXFS_SHIFT	16	/* Implemented RX FIFO size */
-+#define LTQ_SPI_ID_RXFS_MASK	0x3F
-+#define LTQ_SPI_ID_REV_MASK	0x1F	/* Hardware revision number */
-+#define LTQ_SPI_ID_CFG		BIT(5)	/* DMA interface support */
-+
-+#define LTQ_SPI_CON_BM_SHIFT	16	/* Data width selection */
-+#define LTQ_SPI_CON_BM_MASK	0x1F
-+#define LTQ_SPI_CON_EM		BIT(24)	/* Echo mode */
-+#define LTQ_SPI_CON_IDLE	BIT(23)	/* Idle bit value */
-+#define LTQ_SPI_CON_ENBV	BIT(22)	/* Enable byte valid control */
-+#define LTQ_SPI_CON_RUEN	BIT(12)	/* Receive underflow error enable */
-+#define LTQ_SPI_CON_TUEN	BIT(11)	/* Transmit underflow error enable */
-+#define LTQ_SPI_CON_AEN		BIT(10)	/* Abort error enable */
-+#define LTQ_SPI_CON_REN		BIT(9)	/* Receive overflow error enable */
-+#define LTQ_SPI_CON_TEN		BIT(8)	/* Transmit overflow error enable */
-+#define LTQ_SPI_CON_LB		BIT(7)	/* Loopback control */
-+#define LTQ_SPI_CON_PO		BIT(6)	/* Clock polarity control */
-+#define LTQ_SPI_CON_PH		BIT(5)	/* Clock phase control */
-+#define LTQ_SPI_CON_HB		BIT(4)	/* Heading control */
-+#define LTQ_SPI_CON_CSBEN	BIT(3)	/* Chip Select Enable */
-+#define LTQ_SPI_CON_CSBINV	BIT(2)	/* Chip Select Invert */
-+#define LTQ_SPI_CON_RXOFF	BIT(1)	/* Switch receiver off */
-+#define LTQ_SPI_CON_TXOFF	BIT(0)	/* Switch transmitter off */
-+
-+#define LTQ_SPI_STAT_RXBV_MASK	0x7
-+#define LTQ_SPI_STAT_RXBV_SHIFT	28
-+#define LTQ_SPI_STAT_BSY	BIT(13)	/* Busy flag */
-+#define LTQ_SPI_STAT_RUE	BIT(12)	/* Receive underflow error flag */
-+#define LTQ_SPI_STAT_TUE	BIT(11)	/* Transmit underflow error flag */
-+#define LTQ_SPI_STAT_AE		BIT(10)	/* Abort error flag */
-+#define LTQ_SPI_STAT_RE		BIT(9)	/* Receive error flag */
-+#define LTQ_SPI_STAT_TE		BIT(8)	/* Transmit error flag */
-+#define LTQ_SPI_STAT_SSEL	BIT(2)	/* Slave Selected bit */
-+#define LTQ_SPI_STAT_MS		BIT(1)	/* Master/slave select bit */
-+#define LTQ_SPI_STAT_EN		BIT(0)	/* Enable bit */
-+
-+#define LTQ_SPI_WHBSTATE_SETTUE	BIT(15)	/* Set transmit underflow error flag */
-+#define LTQ_SPI_WHBSTATE_SETAE	BIT(14)	/* Set abort error flag */
-+#define LTQ_SPI_WHBSTATE_SETRE	BIT(13)	/* Set receive error flag */
-+#define LTQ_SPI_WHBSTATE_SETTE	BIT(12)	/* Set transmit error flag */
-+#define LTQ_SPI_WHBSTATE_CLRTUE	BIT(11)	/* Clear transmit underflow error
-+						flag */
-+#define LTQ_SPI_WHBSTATE_CLRAE	BIT(10)	/* Clear abort error flag */
-+#define LTQ_SPI_WHBSTATE_CLRRE	BIT(9)	/* Clear receive error flag */
-+#define LTQ_SPI_WHBSTATE_CLRTE	BIT(8)	/* Clear transmit error flag */
-+#define LTQ_SPI_WHBSTATE_SETME	BIT(7)	/* Set mode error flag */
-+#define LTQ_SPI_WHBSTATE_CLRME	BIT(6)	/* Clear mode error flag */
-+#define LTQ_SPI_WHBSTATE_SETRUE	BIT(5)	/* Set receive underflow error flag */
-+#define LTQ_SPI_WHBSTATE_CLRRUE	BIT(4)	/* Clear receive underflow error flag */
-+#define LTQ_SPI_WHBSTATE_SETMS	BIT(3)	/* Set master select bit */
-+#define LTQ_SPI_WHBSTATE_CLRMS	BIT(2)	/* Clear master select bit */
-+#define LTQ_SPI_WHBSTATE_SETEN	BIT(1)	/* Set enable bit (operational mode) */
-+#define LTQ_SPI_WHBSTATE_CLREN	BIT(0)	/* Clear enable bit (config mode */
-+#define LTQ_SPI_WHBSTATE_CLR_ERRORS	0x0F50
-+
-+#define LTQ_SPI_RXFCON_RXFITL_SHIFT	8 /* FIFO interrupt trigger level */
-+#define LTQ_SPI_RXFCON_RXFITL_MASK	0x3F
-+#define LTQ_SPI_RXFCON_RXFLU		BIT(1)	/* FIFO flush */
-+#define LTQ_SPI_RXFCON_RXFEN		BIT(0)	/* FIFO enable */
-+
-+#define LTQ_SPI_TXFCON_TXFITL_SHIFT	8 /* FIFO interrupt trigger level */
-+#define LTQ_SPI_TXFCON_TXFITL_MASK	0x3F
-+#define LTQ_SPI_TXFCON_TXFLU		BIT(1)	/* FIFO flush */
-+#define LTQ_SPI_TXFCON_TXFEN		BIT(0)	/* FIFO enable */
-+
-+#define LTQ_SPI_FSTAT_RXFFL_MASK	0x3f
-+#define LTQ_SPI_FSTAT_RXFFL_SHIFT	0
-+#define LTQ_SPI_FSTAT_TXFFL_MASK	0x3f
-+#define LTQ_SPI_FSTAT_TXFFL_SHIFT	8
-+
-+#define LTQ_SPI_GPOCON_ISCSBN_SHIFT	8
-+#define LTQ_SPI_GPOCON_INVOUTN_SHIFT	0
-+
-+#define LTQ_SPI_FGPO_SETOUTN_SHIFT	8
-+#define LTQ_SPI_FGPO_CLROUTN_SHIFT	0
-+
-+#define LTQ_SPI_RXREQ_RXCNT_MASK	0xFFFF	/* Receive count value */
-+#define LTQ_SPI_RXCNT_TODO_MASK		0xFFFF	/* Recevie to-do value */
-+
-+#define LTQ_SPI_IRNEN_F		BIT(3)	/* Frame end interrupt request */
-+#define LTQ_SPI_IRNEN_E		BIT(2)	/* Error end interrupt request */
-+#define LTQ_SPI_IRNEN_T		BIT(0)	/* Transmit end interrupt request */
-+#define LTQ_SPI_IRNEN_R		BIT(1)	/* Receive end interrupt request */
-+#define LTQ_SPI_IRNEN_T_XWAY	BIT(1)	/* Transmit end interrupt request */
-+#define LTQ_SPI_IRNEN_R_XWAY	BIT(0)	/* Receive end interrupt request */
-+#define LTQ_SPI_IRNEN_ALL	0xF
-+
-+struct ltq_spi {
-+	struct spi_bitbang	bitbang;
-+	spinlock_t		lock;
-+
-+	struct device		*dev;
-+	void __iomem		*base;
-+	struct clk		*fpiclk;
-+	struct clk		*spiclk;
-+
-+	int			status;
-+	int			irq[3];
-+
-+	const u8		*tx;
-+	u8			*rx;
-+	u32			tx_cnt;
-+	u32			rx_cnt;
-+	u32			len;
-+	struct spi_transfer	*curr_transfer;
-+
-+	u32 (*get_tx) (struct ltq_spi *);
-+
-+	u16			txfs;
-+	u16			rxfs;
-+	unsigned		dma_support:1;
-+	unsigned		cfg_mode:1;
-+	int			xrq_gpio;
-+
-+	u32			irnen_t;
-+	u32			irnen_r;
-+};
-+
-+static inline struct ltq_spi *ltq_spi_to_hw(struct spi_device *spi)
-+{
-+	return spi_master_get_devdata(spi->master);
-+}
-+
-+static inline u32 ltq_spi_reg_read(struct ltq_spi *hw, u32 reg)
-+{
-+	return ioread32be(hw->base + reg);
-+}
-+
-+static inline void ltq_spi_reg_write(struct ltq_spi *hw, u32 val, u32 reg)
-+{
-+	iowrite32be(val, hw->base + reg);
-+}
-+
-+static inline void ltq_spi_reg_setbit(struct ltq_spi *hw, u32 bits, u32 reg)
-+{
-+	u32 val;
-+
-+	val = ltq_spi_reg_read(hw, reg);
-+	val |= bits;
-+	ltq_spi_reg_write(hw, val, reg);
-+}
-+
-+static inline void ltq_spi_reg_clearbit(struct ltq_spi *hw, u32 bits, u32 reg)
-+{
-+	u32 val;
-+
-+	val = ltq_spi_reg_read(hw, reg);
-+	val &= ~bits;
-+	ltq_spi_reg_write(hw, val, reg);
-+}
-+
-+static void ltq_spi_hw_enable(struct ltq_spi *hw)
-+{
-+	u32 clc;
-+
-+	/* Power-up module */
-+	clk_enable(hw->spiclk);
-+
-+	/*
-+	 * Set clock divider for run mode to 1 to
-+	 * run at same frequency as FPI bus
-+	 */
-+	clc = (1 << LTQ_SPI_CLC_RMC_SHIFT);
-+	ltq_spi_reg_write(hw, clc, LTQ_SPI_CLC);
-+}
-+
-+static void ltq_spi_hw_disable(struct ltq_spi *hw)
-+{
-+	/* Set clock divider to 0 and set module disable bit */
-+	ltq_spi_reg_write(hw, LTQ_SPI_CLC_DISR, LTQ_SPI_CLC);
-+
-+	/* Power-down module */
-+	clk_disable(hw->spiclk);
-+}
-+
-+static void ltq_spi_reset_fifos(struct ltq_spi *hw)
-+{
-+	u32 val;
-+
-+	/*
-+	 * Enable and flush FIFOs. Set interrupt trigger level to
-+	 * half of FIFO count implemented in hardware.
-+	 */
-+	if (hw->txfs > 1) {
-+		val = hw->txfs << (LTQ_SPI_TXFCON_TXFITL_SHIFT - 1);
-+		val |= LTQ_SPI_TXFCON_TXFEN | LTQ_SPI_TXFCON_TXFLU;
-+		ltq_spi_reg_write(hw, val, LTQ_SPI_TXFCON);
-+	}
-+
-+	if (hw->rxfs > 1) {
-+		val = hw->rxfs << (LTQ_SPI_RXFCON_RXFITL_SHIFT - 1);
-+		val |= LTQ_SPI_RXFCON_RXFEN | LTQ_SPI_RXFCON_RXFLU;
-+		ltq_spi_reg_write(hw, val, LTQ_SPI_RXFCON);
-+	}
-+}
-+
-+static inline int ltq_spi_wait_ready(struct ltq_spi *hw)
-+{
-+	u32 stat;
-+	unsigned long timeout;
-+
-+	timeout = jiffies + msecs_to_jiffies(200);
-+
-+	do {
-+		stat = ltq_spi_reg_read(hw, LTQ_SPI_STAT);
-+		if (!(stat & LTQ_SPI_STAT_BSY))
-+			return 0;
-+
-+		cond_resched();
-+	} while (!time_after_eq(jiffies, timeout));
-+
-+	dev_err(hw->dev, "SPI wait ready timed out stat: %x\n", stat);
-+
-+	return -ETIMEDOUT;
-+}
-+
-+static inline int ltq_spi_wait_slave_selected(struct ltq_spi *hw)
-+{
-+	u32 stat;
-+	unsigned long timeout;
-+
-+	/* wait for the smallest amount of time possible, because chip select
-+	 * activation occurs within 3 clock periods */
-+	timeout = jiffies + 1;
-+
-+	do {
-+		stat = ltq_spi_reg_read(hw, LTQ_SPI_STAT);
-+		if (stat & LTQ_SPI_STAT_SSEL)
-+			return 0;
-+
-+		cond_resched();
-+	} while (!time_after_eq(jiffies, timeout));
-+	return -ETIMEDOUT;
-+}
-+
-+static inline int ltq_spi_wait_slave_not_selected(struct ltq_spi *hw)
-+{
-+	u32 stat;
-+	unsigned long timeout;
-+
-+	timeout = jiffies + msecs_to_jiffies(200);
-+
-+	do {
-+		stat = ltq_spi_reg_read(hw, LTQ_SPI_STAT);
-+		if (!(stat & LTQ_SPI_STAT_SSEL))
-+			return 0;
-+
-+		cond_resched();
-+	} while (!time_after_eq(jiffies, timeout));
-+
-+	dev_err(hw->dev, "SPI wait slave not selected timed out stat: %x\n",
-+		stat);
-+
-+	return -ETIMEDOUT;
-+}
-+
-+static inline int ltq_spi_wait_rx(struct ltq_spi *hw)
-+{
-+	u32 fstat;
-+	unsigned long timeout;
-+
-+	timeout = jiffies + msecs_to_jiffies(200);
-+
-+	do {
-+		if (hw->len - hw->rx_cnt == 0)
-+			return 0;
-+		/* Determine how much FIFOs are filled with RX data */
-+		fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
-+		if ((fstat >> LTQ_SPI_FSTAT_RXFFL_SHIFT) &
-+			LTQ_SPI_FSTAT_RXFFL_MASK)
-+			return 0;
-+		cond_resched();
-+	} while (!time_after_eq(jiffies, timeout));
-+
-+	dev_err(hw->dev, "SPI wait for RX data timed out, %d byte(s) missing\n",
-+		hw->len - hw->rx_cnt);
-+
-+	return -ETIMEDOUT;
-+}
-+
-+static void ltq_spi_config_mode_set(struct ltq_spi *hw)
-+{
-+	if (hw->cfg_mode)
-+		return;
-+
-+	/*
-+	 * Putting the SPI module in config mode is only safe if no
-+	 * transfer is in progress as indicated by busy flag STATE.BSY.
-+	 */
-+	if (ltq_spi_wait_ready(hw)) {
-+		ltq_spi_reset_fifos(hw);
-+		hw->status = -ETIMEDOUT;
-+	}
-+	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_CLREN, LTQ_SPI_WHBSTATE);
-+
-+	hw->cfg_mode = 1;
-+}
-+
-+static void ltq_spi_run_mode_set(struct ltq_spi *hw)
-+{
-+	if (!hw->cfg_mode)
-+		return;
-+
-+	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_SETEN, LTQ_SPI_WHBSTATE);
-+
-+	hw->cfg_mode = 0;
-+}
-+
-+static u32 ltq_spi_tx_word_u8(struct ltq_spi *hw)
-+{
-+	const u8 *tx = hw->tx;
-+	u32 data = *tx++;
-+
-+	hw->tx_cnt++;
-+	hw->tx++;
-+
-+	return data;
-+}
-+
-+static u32 ltq_spi_tx_word_u16(struct ltq_spi *hw)
-+{
-+	const u16 *tx = (u16 *) hw->tx;
-+	u32 data = *tx++;
-+
-+	hw->tx_cnt += 2;
-+	hw->tx += 2;
-+
-+	return data;
-+}
-+
-+static u32 ltq_spi_tx_word_u32(struct ltq_spi *hw)
-+{
-+	const u32 *tx = (u32 *) hw->tx;
-+	u32 data = *tx++;
-+
-+	hw->tx_cnt += 4;
-+	hw->tx += 4;
-+
-+	return data;
-+}
-+
-+static void ltq_spi_bits_per_word_set(struct spi_device *spi)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+	u32 bm;
-+	u8 bits_per_word = spi->bits_per_word;
-+
-+	/*
-+	 * Use either default value of SPI device or value
-+	 * from current transfer.
-+	 */
-+	if (hw->curr_transfer && hw->curr_transfer->bits_per_word)
-+		bits_per_word = hw->curr_transfer->bits_per_word;
-+
-+	if (bits_per_word <= 8)
-+		hw->get_tx = ltq_spi_tx_word_u8;
-+	else if (bits_per_word <= 16)
-+		hw->get_tx = ltq_spi_tx_word_u16;
-+	else if (bits_per_word <= 32)
-+		hw->get_tx = ltq_spi_tx_word_u32;
-+
-+	/* CON.BM value = bits_per_word - 1 */
-+	bm = (bits_per_word - 1) << LTQ_SPI_CON_BM_SHIFT;
-+
-+	ltq_spi_reg_clearbit(hw, LTQ_SPI_CON_BM_MASK <<
-+			     LTQ_SPI_CON_BM_SHIFT, LTQ_SPI_CON);
-+	ltq_spi_reg_setbit(hw, bm, LTQ_SPI_CON);
-+}
-+
-+static void ltq_spi_speed_set(struct spi_device *spi)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+	u32 br, max_speed_hz, spi_clk;
-+	u32 speed_hz = spi->max_speed_hz;
-+
-+	/*
-+	 * Use either default value of SPI device or value
-+	 * from current transfer.
-+	 */
-+	if (hw->curr_transfer && hw->curr_transfer->speed_hz)
-+		speed_hz = hw->curr_transfer->speed_hz;
-+
-+	/*
-+	 * SPI module clock is derived from FPI bus clock dependent on
-+	 * divider value in CLC.RMS which is always set to 1.
-+	 */
-+	spi_clk = clk_get_rate(hw->fpiclk);
-+
-+	/*
-+	 * Maximum SPI clock frequency in master mode is half of
-+	 * SPI module clock frequency. Maximum reload value of
-+	 * baudrate generator BR is 2^16.
-+	 */
-+	max_speed_hz = spi_clk / 2;
-+	if (speed_hz >= max_speed_hz)
-+		br = 0;
-+	else {
-+		/* BR calculation formula
-+		 * br = (max_speed_hz / speed_hz) - 1;
-+		 * given on page 1030 of SVIP product specification sets
-+		 * clock frequency bigger than requested, if
-+		 * max_speed_hz / speed_hz has a fractional part. The clock
-+		 * however must always be at maximum the requested value.
-+		 */
-+		br = max_speed_hz / speed_hz;
-+		if (!(max_speed_hz % speed_hz))
-+			br--;
-+	}
-+
-+	if (br > 0xFFFF)
-+		br = 0xFFFF;
-+	/*
-+	 * Whenever the SSC is in slave mode, you have to make sure, that
-+	 * BR.BR_VAL is 1 at least. Otherwise serial transmit and receive
-+	 * data is corrupted.
-+	 */
-+	if (br == 0)
-+		br = 1;
-+
-+	ltq_spi_reg_write(hw, br, LTQ_SPI_BRT);
-+}
-+
-+static void ltq_spi_clockmode_set(struct spi_device *spi)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+	u32 con;
-+
-+	con = ltq_spi_reg_read(hw, LTQ_SPI_CON);
-+
-+	/*
-+	 * SPI mode mapping in CON register:
-+	 * Mode CPOL CPHA CON.PO CON.PH
-+	 *  0    0    0      0      1
-+	 *  1    0    1      0      0
-+	 *  2    1    0      1      1
-+	 *  3    1    1      1      0
-+	 */
-+	if (spi->mode & SPI_CPHA)
-+		con &= ~LTQ_SPI_CON_PH;
-+	else
-+		con |= LTQ_SPI_CON_PH;
-+
-+	if (spi->mode & SPI_CPOL)
-+		con |= LTQ_SPI_CON_PO;
-+	else
-+		con &= ~LTQ_SPI_CON_PO;
-+
-+	/* Set heading control */
-+	if (spi->mode & SPI_LSB_FIRST)
-+		con &= ~LTQ_SPI_CON_HB;
-+	else
-+		con |= LTQ_SPI_CON_HB;
-+
-+	ltq_spi_reg_write(hw, con, LTQ_SPI_CON);
-+}
-+
-+static void ltq_spi_xmit_set(struct ltq_spi *hw, struct spi_transfer *t)
-+{
-+	u32 con;
-+
-+	con = ltq_spi_reg_read(hw, LTQ_SPI_CON);
-+
-+	if (t) {
-+		if (t->tx_buf && t->rx_buf) {
-+			con &= ~(LTQ_SPI_CON_TXOFF | LTQ_SPI_CON_RXOFF);
-+		} else if (t->rx_buf) {
-+			con &= ~LTQ_SPI_CON_RXOFF;
-+			con |= LTQ_SPI_CON_TXOFF;
-+		} else if (t->tx_buf) {
-+			con &= ~LTQ_SPI_CON_TXOFF;
-+			con |= LTQ_SPI_CON_RXOFF;
-+		}
-+	} else
-+		con |= (LTQ_SPI_CON_TXOFF | LTQ_SPI_CON_RXOFF);
-+
-+	ltq_spi_reg_write(hw, con, LTQ_SPI_CON);
-+}
-+
-+
-+static void ltq_spi_chipselect(struct spi_device *spi, int cs)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+
-+	ltq_spi_wait_ready(hw);
-+
-+	switch (cs) {
-+	case BITBANG_CS_ACTIVE:
-+		ltq_spi_bits_per_word_set(spi);
-+		ltq_spi_speed_set(spi);
-+		ltq_spi_clockmode_set(spi);
-+		/* Wait till chip select is inactive, otherwise it could
-+		 * happen that transfer is started in the middle of chip
-+		 * select and chip select is deactivated before all the
-+		 * data is sent/received.
-+		 */
-+		if (ltq_spi_wait_slave_not_selected(hw))
-+			hw->status = -ETIMEDOUT;
-+		ltq_spi_run_mode_set(hw);
-+		break;
-+
-+	case BITBANG_CS_INACTIVE:
-+		ltq_spi_config_mode_set(hw);
-+		break;
-+	}
-+}
-+
-+static int ltq_spi_setup_transfer(struct spi_device *spi,
-+				  struct spi_transfer *t)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+	u8 bits_per_word = spi->bits_per_word;
-+
-+	hw->curr_transfer = t;
-+
-+	if (t && t->bits_per_word)
-+		bits_per_word = t->bits_per_word;
-+
-+	if (bits_per_word > 32)
-+		return -EINVAL;
-+
-+	return 0;
-+}
-+
-+static int ltq_spi_setup(struct spi_device *spi)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+	u32 con;
-+
-+	/* Set default word length to 8 if not set */
-+	if (!spi->bits_per_word)
-+		spi->bits_per_word = 8;
-+
-+	if (spi->bits_per_word > 32)
-+		return -EINVAL;
-+
-+	/*
-+	 * reset SPI transmission request - set pin to low
-+	 */
-+	__gpio_set_value(hw->xrq_gpio, 0);
-+	wmb();
-+	/* configure chip select */
-+	con = ltq_spi_reg_read(hw, LTQ_SPI_CON);
-+	con |= LTQ_SPI_CON_CSBEN;
-+
-+	if (spi->mode & SPI_CS_HIGH)
-+		con |= LTQ_SPI_CON_CSBINV;
-+	else
-+		con &= ~LTQ_SPI_CON_CSBINV;
-+
-+	ltq_spi_reg_write(hw, con, LTQ_SPI_CON);
-+
-+	return 0;
-+}
-+
-+static void ltq_spi_cleanup(struct spi_device *spi)
-+{
-+
-+}
-+
-+
-+/*
-+ * "Normally" returns Byte Valid = 4.
-+ * If the unaligned remainder of the packet is 3 bytes, these have to be
-+ * transferred as a combination of a 16-bit and a 8-bit FPI transfer. For
-+ * 2 or 1 remaining bytes a single 16-bit or 8-bit transfer will do.
-+ */
-+static inline u8 _estimate_bv(u32 byte_pos, u32 bytelen)
-+{
-+	int remainder = bytelen % 4;
-+
-+	if (byte_pos < (bytelen - remainder))
-+		return 4;
-+
-+	if (remainder == 3) {
-+		if (byte_pos == (bytelen - remainder))
-+			return 2;
-+		else
-+			return 1;
-+	}
-+	return remainder;
-+}
-+
-+
-+static void ltq_spi_txfifo_write(struct ltq_spi *hw)
-+{
-+	u32 fstat, data;
-+	u16 fifo_space;
-+
-+	/* Determine how much FIFOs are free for TX data */
-+	fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
-+	fifo_space = hw->txfs - ((fstat >> LTQ_SPI_FSTAT_TXFFL_SHIFT) &
-+					LTQ_SPI_FSTAT_TXFFL_MASK);
-+
-+	if (!fifo_space)
-+		return;
-+
-+	while (hw->tx_cnt < hw->len && fifo_space) {
-+		data = hw->get_tx(hw);
-+		ltq_spi_reg_write(hw, data, LTQ_SPI_TB);
-+		fifo_space--;
-+	}
-+}
-+
-+
-+static void ltq_spi_rxfifo_read(struct ltq_spi *hw)
-+{
-+	u32 fstat, data, mcon;
-+	u16 fifo_fill;
-+	u8 rxbv, shift, *rx8;
-+
-+	/* Determine how much FIFOs are filled with RX data */
-+	fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
-+	fifo_fill = ((fstat >> LTQ_SPI_FSTAT_RXFFL_SHIFT)
-+			& LTQ_SPI_FSTAT_RXFFL_MASK);
-+
-+	if (!fifo_fill)
-+		return;
-+
-+	mcon = ltq_spi_reg_read(hw, LTQ_SPI_CON);
-+
-+	/* In slave mode, MCON.BM is
-+	 * the only control of the data width. */
-+	while (fifo_fill && hw->rx_cnt < hw->len) {
-+		rxbv = ((mcon >> LTQ_SPI_CON_BM_SHIFT &
-+			LTQ_SPI_CON_BM_MASK) >> 3) + 1;
-+		data = ltq_spi_reg_read(hw, LTQ_SPI_RB);
-+		shift = (rxbv - 1) << 3;
-+		rx8 = hw->rx;
-+		while (rxbv) {
-+			*rx8++ = (data >> shift) & 0xFF;
-+			rxbv--;
-+			shift -= 8;
-+			hw->rx_cnt++;
-+			hw->rx++;
-+		}
-+
-+		fifo_fill--;
-+	}
-+}
-+
-+static void ltq_spi_rxreq_set(struct ltq_spi *hw)
-+{
-+	u32 rxreq, rxreq_max, rxtodo, stat;
-+
-+	rxtodo = ltq_spi_reg_read(hw, LTQ_SPI_RXCNT) & LTQ_SPI_RXCNT_TODO_MASK;
-+	stat = ltq_spi_reg_read(hw, LTQ_SPI_STAT);
-+
-+	/*
-+	 * In RX-only mode the serial clock is activated only after writing
-+	 * the expected amount of RX bytes into RXREQ register.
-+	 * To avoid receive overflows at high clocks it is better to request
-+	 * only the amount of bytes that fits into all FIFOs. This value
-+	 * depends on the FIFO size implemented in hardware.
-+	 * Request additional data only if BSY bit is not set, otherwise timeout
-+	 * in ltq_spi_wait_ready will occur. Reason of this is unclear as
-+	 * documentation states that BSY bit is set either because a serial
-+	 * transfer is ongoing or because data is still in one of the FIFOs,
-+	 * however, debbugging code added to ltq_spi_wait_ready shows that FIFOs
-+	 * are empty (TXFFL and RXFFL of SSC_FSTAT are 0) and in some cases
-+	 * also transfer is not ongoing (EN bit of SSC_STATE is 0). The solution
-+	 * was taken from ltq_ssc driver from Linux 2.6 written by Andreas Schmidt
-+	 * <andreas.schmidt@infineon.com>.
-+	 */
-+	if (!(stat & LTQ_SPI_STAT_BSY) && !rxtodo) {
-+		rxreq = hw->len - hw->rx_cnt;
-+		rxreq_max = hw->rxfs << 2;
-+		rxreq = min(rxreq_max, rxreq);
-+		if (rxreq)
-+			ltq_spi_reg_write(hw, rxreq, LTQ_SPI_RXREQ);
-+	}
-+}
-+
-+static inline void ltq_spi_tx_complete(struct ltq_spi *hw)
-+{
-+
-+}
-+
-+
-+irqreturn_t ltq_spi_csi_tx_irq(int irq, void *data)
-+{
-+	struct ltq_spi *hw = data;
-+	unsigned long flags;
-+	int completed = 0;
-+
-+	spin_lock_irqsave(&hw->lock, flags);
-+
-+	if (hw->tx_cnt < hw->len)
-+		ltq_spi_txfifo_write(hw);
-+
-+	if (hw->tx_cnt == hw->len)
-+		completed = 1;
-+
-+	spin_unlock_irqrestore(&hw->lock, flags);
-+
-+	if (completed)
-+		ltq_spi_tx_complete(hw);
-+
-+	return IRQ_HANDLED;
-+}
-+
-+irqreturn_t ltq_spi_csi_rx_irq(int irq, void *data)
-+{
-+	struct ltq_spi *hw = data;
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&hw->lock, flags);
-+
-+	if (hw->rx_cnt < hw->len) {
-+		ltq_spi_rxfifo_read(hw);
-+
-+		if (hw->tx && hw->tx_cnt < hw->len)
-+			ltq_spi_txfifo_write(hw);
-+	}
-+
-+	if (hw->rx_cnt < hw->len && !hw->tx)
-+		ltq_spi_rxreq_set(hw);
-+
-+	spin_unlock_irqrestore(&hw->lock, flags);
-+
-+	return IRQ_HANDLED;
-+}
-+
-+irqreturn_t ltq_spi_csi_err_irq(int irq, void *data)
-+{
-+	struct ltq_spi *hw = data;
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&hw->lock, flags);
-+
-+	/* Disable all interrupts */
-+	ltq_spi_reg_clearbit(hw, LTQ_SPI_IRNEN_ALL, LTQ_SPI_IRNEN);
-+
-+	dev_err(hw->dev, "SPI error interrupt occurred stat: %x\n",
-+		ltq_spi_reg_read(hw, LTQ_SPI_STAT));
-+
-+	/* Clear all error flags */
-+	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_CLR_ERRORS, LTQ_SPI_WHBSTATE);
-+
-+	/* Flush FIFOs */
-+	ltq_spi_reg_setbit(hw, LTQ_SPI_RXFCON_RXFLU, LTQ_SPI_RXFCON);
-+	ltq_spi_reg_setbit(hw, LTQ_SPI_TXFCON_TXFLU, LTQ_SPI_TXFCON);
-+
-+	hw->status = -EIO;
-+	spin_unlock_irqrestore(&hw->lock, flags);
-+
-+	if (hw->tx)
-+		ltq_spi_tx_complete(hw);
-+
-+	return IRQ_HANDLED;
-+}
-+
-+static int ltq_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
-+{
-+	struct ltq_spi *hw = ltq_spi_to_hw(spi);
-+	u32 irq_flags = 0;
-+
-+	hw->tx = t->tx_buf;
-+	hw->rx = t->rx_buf;
-+	hw->len = t->len;
-+	hw->tx_cnt = 0;
-+	hw->rx_cnt = 0;
-+	hw->status = 0;
-+
-+	ltq_spi_xmit_set(hw, t);
-+
-+	/* Enable error interrupts */
-+	ltq_spi_reg_setbit(hw, LTQ_SPI_IRNEN_E, LTQ_SPI_IRNEN);
-+
-+	if (hw->tx) {
-+		/* Initially fill TX FIFO with as much data as possible */
-+		ltq_spi_txfifo_write(hw);
-+
-+		irq_flags |= hw->irnen_t;
-+
-+		/* Always enable RX interrupt in Full Duplex mode */
-+		if (hw->rx)
-+			irq_flags |= hw->irnen_r;
-+	} else if (hw->rx) {
-+		/* Start RX clock */
-+		ltq_spi_rxreq_set(hw);
-+
-+		/* Enable RX interrupt to receive data from RX FIFOs */
-+		irq_flags |= hw->irnen_r;
-+	}
-+
-+	/* Enable TX or RX interrupts */
-+	ltq_spi_reg_setbit(hw, irq_flags, LTQ_SPI_IRNEN);
-+
-+	/* A low to high edge requests SPI transmission */
-+	__gpio_set_value(hw->xrq_gpio, 1);
-+	wmb();
-+	/* Wait till start of SPI access (SSC.STATE.SSEL = 1) */
-+	/* Note. SSEL = 0 could simply mean that the whole SPI transfer
-+	 * has already been completed, and chip select returned to
-+	 * inactive state, therefore ltq_spi_wait_slave_selected
-+	 * returning non zero result is not signaled as error. */
-+	ltq_spi_wait_slave_selected(hw);
-+	/* Reset SPI transmission request */
-+	__gpio_set_value(hw->xrq_gpio, 0);
-+	wmb();
-+	/* Wait till end of SPI access (SSC.STATE.SSEL = 0) */
-+	if (ltq_spi_wait_slave_not_selected(hw)) {
-+		hw->status = -ETIMEDOUT;
-+		/* Disable all interrupts */
-+		ltq_spi_reg_clearbit(hw, LTQ_SPI_IRNEN_ALL,
-+			LTQ_SPI_IRNEN);
-+		return hw->status;
-+	}
-+
-+	if (hw->rx) {
-+		u32 fstat;
-+		u16 fifo_fill;
-+
-+		/* Completion can't be used with RX, because RX interrupt may
-+		 * never occur. RX interrupt occurs only when RX FIFO fill
-+		 * reaches specified level (half of FIFO size, in this driver).
-+		 * Additional uncertainty is introduced by the fact that rx_cnt
-+		 * and rxfs are counting bytes, but FIFO stores words (possibly
-+		 * of different size).
-+		 * Solution is just to poll for RX data.
-+		 */
-+		while (hw->rx_cnt < hw->len && !hw->status) {
-+			/* Determine how much FIFOs are filled with RX data */
-+			fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
-+			fifo_fill = ((fstat >> LTQ_SPI_FSTAT_RXFFL_SHIFT)
-+					& LTQ_SPI_FSTAT_RXFFL_MASK);
-+
-+			if (fifo_fill)
-+				ltq_spi_csi_rx_irq(hw->irq[0], hw);
-+			else {
-+				/* In slave mode exit, if nothing received
-+				 * within some predefined time interval */
-+				if (ltq_spi_wait_rx(hw)) {
-+					hw->status = -ETIMEDOUT;
-+					break;
-+				}
-+			}
-+		}
-+	}
-+
-+	/* Disable all interrupts */
-+	ltq_spi_reg_clearbit(hw, LTQ_SPI_IRNEN_ALL, LTQ_SPI_IRNEN);
-+
-+	if (!hw->status) {
-+		/*
-+		 * A signaled TX completion doesn't guarantee that the data has been sent
-+		 * on the SPI bus, it just garantees that it has been written to TX FIFO.
-+		 * Verification of completion of transfer is done by polling of BSY bit of
-+		 * SSC_STATE register.
-+		 */
-+		if (!hw->rx)
-+			hw->status = ltq_spi_wait_ready(hw);
-+		/*
-+		 * Return length of current transfer for bitbang utility code if
-+		 * no errors occurred during transmission.
-+		 */
-+		if (!hw->status)
-+			hw->status = hw->len;
-+	}
-+
-+	return hw->status;
-+}
-+
-+static const struct ltq_spi_irq_map {
-+	char *name;
-+	irq_handler_t handler;
-+} ltq_spi_irqs[] = {
-+	{ "spi_rx", ltq_spi_csi_rx_irq },
-+	{ "spi_tx", ltq_spi_csi_tx_irq },
-+	{ "spi_err", ltq_spi_csi_err_irq },
-+};
-+
-+static int ltq_spi_probe(struct platform_device *pdev)
-+{
-+	struct resource irqres[3];
-+	struct spi_master *master;
-+	struct resource *r;
-+	struct ltq_spi *hw;
-+	int ret, i;
-+	u32 data, id;
-+	struct pinctrl *pinctrl;
-+
-+	if (of_irq_to_resource_table(pdev->dev.of_node, irqres, 3) != 3) {
-+		dev_err(&pdev->dev, "IRQ settings missing in device tree\n");
-+		return -EINVAL;
-+	}
-+
-+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
-+	if (IS_ERR(pinctrl))
-+		dev_warn(&pdev->dev, "pins are not configured from the driver\n");
-+
-+	master = spi_alloc_master(&pdev->dev, sizeof(struct ltq_spi));
-+	if (!master) {
-+		dev_err(&pdev->dev, "spi_alloc_master\n");
-+		ret = -ENOMEM;
-+		goto err;
-+	}
-+
-+	hw = spi_master_get_devdata(master);
-+
-+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-+	if (r == NULL) {
-+		dev_err(&pdev->dev, "platform_get_resource\n");
-+		ret = -ENOENT;
-+		goto err_master;
-+	}
-+
-+	r = devm_request_mem_region(&pdev->dev, r->start, resource_size(r),
-+			pdev->name);
-+	if (!r) {
-+		dev_err(&pdev->dev, "failed to request memory region\n");
-+		ret = -ENXIO;
-+		goto err_master;
-+	}
-+
-+	hw->base = devm_ioremap_nocache(&pdev->dev, r->start, resource_size(r));
-+	if (!hw->base) {
-+		dev_err(&pdev->dev, "failed to remap memory region\n");
-+		ret = -ENXIO;
-+		goto err_master;
-+	}
-+
-+	/* setup transfer request gpio used by spi */
-+	hw->xrq_gpio = of_get_named_gpio(pdev->dev.of_node, "gpio-xrq",
-+		0);
-+	if (!gpio_is_valid(hw->xrq_gpio)) {
-+		dev_err(&pdev->dev, "invalid gpio %d\n", hw->xrq_gpio);
-+		ret = -EINVAL;
-+		goto err_master;
-+	}
-+	/* request a GPIO */
-+	ret = devm_gpio_request(&pdev->dev, hw->xrq_gpio, "spi-xrq");
-+	if (ret) {
-+		dev_err(&pdev->dev, "failed to request GPIO %d\n",
-+			hw->xrq_gpio);
-+		goto err_master;
-+	}
-+	/*
-+	 * configure pin as output and reset SPI transmission request -
-+	 * set pin to low
-+	 */
-+	ret = gpio_direction_output(hw->xrq_gpio, 0);
-+	if (ret) {
-+		dev_err(&pdev->dev, "failed to configure gpio %d as output driving low\n",
-+			hw->xrq_gpio);
-+		goto err_master;
-+	}
-+
-+	memset(hw->irq, 0, sizeof(hw->irq));
-+	for (i = 0; i < ARRAY_SIZE(ltq_spi_irqs); i++) {
-+		hw->irq[i] = irqres[i].start;
-+		ret = request_irq(hw->irq[i], ltq_spi_irqs[i].handler,
-+				  0, ltq_spi_irqs[i].name, hw);
-+		if (ret) {
-+			dev_err(&pdev->dev, "failed to request %s irq (%d)\n",
-+					ltq_spi_irqs[i].name, hw->irq[i]);
-+			goto err_irq;
-+		}
-+	}
-+
-+	hw->fpiclk = clk_get_fpi();
-+	if (IS_ERR(hw->fpiclk)) {
-+		dev_err(&pdev->dev, "failed to get fpi clock\n");
-+		ret = PTR_ERR(hw->fpiclk);
-+		goto err_clk;
-+	}
-+
-+	hw->spiclk = clk_get(&pdev->dev, NULL);
-+	if (IS_ERR(hw->spiclk)) {
-+		dev_err(&pdev->dev, "failed to get spi clock gate\n");
-+		ret = PTR_ERR(hw->spiclk);
-+		goto err_clk;
-+	}
-+
-+	hw->bitbang.master = spi_master_get(master);
-+	hw->bitbang.chipselect = ltq_spi_chipselect;
-+	hw->bitbang.setup_transfer = ltq_spi_setup_transfer;
-+	hw->bitbang.txrx_bufs = ltq_spi_txrx_bufs;
-+
-+	if (of_machine_is_compatible("lantiq,ase")) {
-+		master->num_chipselect = 3;
-+
-+		hw->irnen_t = LTQ_SPI_IRNEN_T_XWAY;
-+		hw->irnen_r = LTQ_SPI_IRNEN_R_XWAY;
-+	} else {
-+		master->num_chipselect = 6;
-+
-+		hw->irnen_t = LTQ_SPI_IRNEN_T;
-+		hw->irnen_r = LTQ_SPI_IRNEN_R;
-+	}
-+
-+	master->bus_num = pdev->id;
-+	master->setup = ltq_spi_setup;
-+	master->cleanup = ltq_spi_cleanup;
-+	master->dev.of_node = pdev->dev.of_node;
-+
-+	hw->dev = &pdev->dev;
-+	spin_lock_init(&hw->lock);
-+
-+	ltq_spi_hw_enable(hw);
-+
-+	/* Read module capabilities */
-+	id = ltq_spi_reg_read(hw, LTQ_SPI_ID);
-+	hw->txfs = (id >> LTQ_SPI_ID_TXFS_SHIFT) & LTQ_SPI_ID_TXFS_MASK;
-+	hw->rxfs = (id >> LTQ_SPI_ID_TXFS_SHIFT) & LTQ_SPI_ID_TXFS_MASK;
-+	hw->dma_support = (id & LTQ_SPI_ID_CFG) ? 1 : 0;
-+
-+	ltq_spi_config_mode_set(hw);
-+
-+	/* Enable error checking, disable TX/RX, set idle value high */
-+	data = LTQ_SPI_CON_RUEN | LTQ_SPI_CON_AEN |
-+		LTQ_SPI_CON_TEN | LTQ_SPI_CON_REN |
-+		LTQ_SPI_CON_TXOFF | LTQ_SPI_CON_RXOFF | LTQ_SPI_CON_IDLE;
-+	ltq_spi_reg_write(hw, data, LTQ_SPI_CON);
-+
-+	/* Enable slave mode and clear error flags */
-+	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_CLRMS |
-+		LTQ_SPI_WHBSTATE_CLR_ERRORS, LTQ_SPI_WHBSTATE);
-+
-+	/* Reset GPIO/CS registers */
-+	ltq_spi_reg_write(hw, 0x0, LTQ_SPI_GPOCON);
-+	ltq_spi_reg_write(hw, 0xFF00, LTQ_SPI_FGPO);
-+
-+	/* Enable and flush FIFOs */
-+	ltq_spi_reset_fifos(hw);
-+
-+	ret = spi_bitbang_start(&hw->bitbang);
-+	if (ret) {
-+		dev_err(&pdev->dev, "spi_bitbang_start failed\n");
-+		goto err_bitbang;
-+	}
-+
-+	platform_set_drvdata(pdev, hw);
-+
-+	pr_info("Lantiq SoC SPI controller rev %u (TXFS %u, RXFS %u, DMA %u, CSI mode)\n",
-+		id & LTQ_SPI_ID_REV_MASK, hw->txfs, hw->rxfs, hw->dma_support);
-+
-+	return 0;
-+
-+err_bitbang:
-+	ltq_spi_hw_disable(hw);
-+
-+err_clk:
-+	if (hw->fpiclk)
-+		clk_put(hw->fpiclk);
-+	if (hw->spiclk)
-+		clk_put(hw->spiclk);
-+
-+err_irq:
-+	clk_put(hw->fpiclk);
-+
-+	for (; i > 0; i--)
-+		free_irq(hw->irq[i], hw);
-+
-+err_master:
-+	spi_master_put(master);
-+
-+err:
-+	return ret;
-+}
-+
-+static int ltq_spi_remove(struct platform_device *pdev)
-+{
-+	struct ltq_spi *hw = platform_get_drvdata(pdev);
-+	int ret, i;
-+
-+	ret = spi_bitbang_stop(&hw->bitbang);
-+	if (ret)
-+		return ret;
-+
-+	platform_set_drvdata(pdev, NULL);
-+
-+	ltq_spi_config_mode_set(hw);
-+	ltq_spi_hw_disable(hw);
-+
-+	for (i = 0; i < ARRAY_SIZE(hw->irq); i++)
-+		if (0 < hw->irq[i])
-+			free_irq(hw->irq[i], hw);
-+
-+	if (hw->fpiclk)
-+		clk_put(hw->fpiclk);
-+	if (hw->spiclk)
-+		clk_put(hw->spiclk);
-+
-+	spi_master_put(hw->bitbang.master);
-+
-+	return 0;
-+}
-+
-+static const struct of_device_id ltq_spi_match[] = {
-+	{ .compatible = "lantiq,spi-xway-csi" },
-+	{ .compatible = "lantiq,spi-lantiq-ssc-csi" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, ltq_spi_match);
-+
-+static struct platform_driver ltq_spi_driver = {
-+	.probe = ltq_spi_probe,
-+	.remove = ltq_spi_remove,
-+	.driver = {
-+		.name = "spi-lantiq-ssc-csi",
-+		.owner = THIS_MODULE,
-+		.of_match_table = ltq_spi_match,
-+	},
-+};
-+
-+module_platform_driver(ltq_spi_driver);
-+
-+MODULE_DESCRIPTION("Lantiq SoC SPI controller driver in CSI mode");
-+MODULE_AUTHOR("Martins Pukitis <martins.pukitis@lantiq.com>");
-+MODULE_LICENSE("GPL");
-+MODULE_ALIAS("platform:spi-xway-csi");
-+MODULE_ALIAS("platform:spi-lantiq-ssc-csi");
-diff --git a/drivers/spi/spi-xway.c b/drivers/spi/spi-xway.c
---- a/drivers/spi/spi-xway.c
-+++ b/drivers/spi/spi-xway.c
-@@ -80,6 +80,8 @@
- #define LTQ_SPI_CON_PO		BIT(6)	/* Clock polarity control */
- #define LTQ_SPI_CON_PH		BIT(5)	/* Clock phase control */
- #define LTQ_SPI_CON_HB		BIT(4)	/* Heading control */
-+#define LTQ_SPI_CON_CSBEN	BIT(3)	/* Chip Select Enable */
-+#define LTQ_SPI_CON_CSBINV	BIT(2)	/* Chip Select Invert */
- #define LTQ_SPI_CON_RXOFF	BIT(1)	/* Switch receiver off */
- #define LTQ_SPI_CON_TXOFF	BIT(0)	/* Switch transmitter off */
- 
-@@ -91,6 +93,7 @@
- #define LTQ_SPI_STAT_AE		BIT(10)	/* Abort error flag */
- #define LTQ_SPI_STAT_RE		BIT(9)	/* Receive error flag */
- #define LTQ_SPI_STAT_TE		BIT(8)	/* Transmit error flag */
-+#define LTQ_SPI_STAT_SSEL	BIT(2)	/* Slave Selected bit */
- #define LTQ_SPI_STAT_MS		BIT(1)	/* Master/slave select bit */
- #define LTQ_SPI_STAT_EN		BIT(0)	/* Enable bit */
- 
-@@ -139,13 +142,15 @@
- 
- #define LTQ_SPI_IRNEN_F		BIT(3)	/* Frame end interrupt request */
- #define LTQ_SPI_IRNEN_E		BIT(2)	/* Error end interrupt request */
--#define LTQ_SPI_IRNEN_T		BIT(1)	/* Transmit end interrupt request */
--#define LTQ_SPI_IRNEN_R		BIT(0)	/* Receive end interrupt request */
-+#define LTQ_SPI_IRNEN_T		BIT(0)	/* Transmit end interrupt request */
-+#define LTQ_SPI_IRNEN_R		BIT(1)	/* Receive end interrupt request */
-+#define LTQ_SPI_IRNEN_T_XWAY	BIT(1)	/* Transmit end interrupt request */
-+#define LTQ_SPI_IRNEN_R_XWAY	BIT(0)	/* Receive end interrupt request */
- #define LTQ_SPI_IRNEN_ALL	0xF
- 
- struct ltq_spi {
- 	struct spi_bitbang	bitbang;
--	struct completion	done;
-+	struct completion	tx_done;
- 	spinlock_t		lock;
- 
- 	struct device		*dev;
-@@ -169,6 +174,9 @@ struct ltq_spi {
- 	u16			rxfs;
- 	unsigned		dma_support:1;
- 	unsigned		cfg_mode:1;
-+
-+	u32			irnen_t;
-+	u32			irnen_r;
- };
- 
- static inline struct ltq_spi *ltq_spi_to_hw(struct spi_device *spi)
-@@ -178,12 +186,20 @@ static inline struct ltq_spi *ltq_spi_to
- 
- static inline u32 ltq_spi_reg_read(struct ltq_spi *hw, u32 reg)
- {
-+#ifdef __BIG_ENDIAN
- 	return ioread32be(hw->base + reg);
-+#else /* __LITTLE_ENDIAN */
-+	return ioread32(hw->base + reg);
-+#endif
- }
- 
- static inline void ltq_spi_reg_write(struct ltq_spi *hw, u32 val, u32 reg)
- {
-+#ifdef __BIG_ENDIAN
- 	iowrite32be(val, hw->base + reg);
-+#else /* __LITTLE_ENDIAN */
-+	iowrite32(val, hw->base + reg);
-+#endif
- }
- 
- static inline void ltq_spi_reg_setbit(struct ltq_spi *hw, u32 bits, u32 reg)
-@@ -222,7 +238,7 @@ static void ltq_spi_hw_enable(struct ltq
- static void ltq_spi_hw_disable(struct ltq_spi *hw)
- {
- 	/* Set clock divider to 0 and set module disable bit */
--	ltq_spi_reg_write(hw, LTQ_SPI_CLC_DISS, LTQ_SPI_CLC);
-+	ltq_spi_reg_write(hw, LTQ_SPI_CLC_DISR, LTQ_SPI_CLC);
- 
- 	/* Power-down module */
- 	clk_disable(hw->spiclk);
-@@ -343,6 +359,14 @@ static void ltq_spi_bits_per_word_set(st
- 	if (hw->curr_transfer && hw->curr_transfer->bits_per_word)
- 		bits_per_word = hw->curr_transfer->bits_per_word;
- 
-+#ifdef CONFIG_SPI_XWAY_BV
-+	if (bits_per_word != 8) {
-+		dev_err(&spi->dev, "setup: invalid bits_per_word %u (expect 8 in byte valid mode)\n",
-+			spi->bits_per_word);
-+		bits_per_word = 8;
-+	}
-+#endif
-+
- 	if (bits_per_word <= 8)
- 		hw->get_tx = ltq_spi_tx_word_u8;
- 	else if (bits_per_word <= 16)
-@@ -385,8 +409,18 @@ static void ltq_spi_speed_set(struct spi
- 	max_speed_hz = spi_clk / 2;
- 	if (speed_hz >= max_speed_hz)
- 		br = 0;
--	else
--		br = (max_speed_hz / speed_hz) - 1;
-+	else {
-+		/* BR calculation formula
-+		 * br = (max_speed_hz / speed_hz) - 1;
-+		 * given on page 1030 of SVIP product specification sets
-+		 * clock frequency bigger than requested, if
-+		 * max_speed_hz / speed_hz has a fractional part. The clock
-+		 * however must always be at maximum the requested value.
-+		 */
-+		br = max_speed_hz / speed_hz;
-+		if (!(max_speed_hz % speed_hz))
-+			br--;
-+	}
- 
- 	if (br > 0xFFFF)
- 		br = 0xFFFF;
-@@ -472,6 +506,8 @@ static void ltq_spi_chipselect(struct sp
- {
- 	struct ltq_spi *hw = ltq_spi_to_hw(spi);
- 
-+	ltq_spi_wait_ready(hw);
-+
- 	switch (cs) {
- 	case BITBANG_CS_ACTIVE:
- 		ltq_spi_bits_per_word_set(spi);
-@@ -501,8 +537,10 @@ static int ltq_spi_setup_transfer(struct
- 
- 	if (bits_per_word > 32)
- 		return -EINVAL;
--
--	ltq_spi_config_mode_set(hw);
-+#ifdef CONFIG_SPI_XWAY_BV
-+	if (bits_per_word != 8)
-+		return -EINVAL;
-+#endif
- 
- 	return 0;
- }
-@@ -511,6 +549,9 @@ static int ltq_spi_setup(struct spi_devi
- {
- 	struct ltq_spi *hw = ltq_spi_to_hw(spi);
- 	u32 gpocon, fgpo;
-+#ifdef CONFIG_SPI_XWAY_BV
-+	u32 con;
-+#endif
- 
- 	/* Set default word length to 8 if not set */
- 	if (!spi->bits_per_word)
-@@ -518,6 +559,16 @@ static int ltq_spi_setup(struct spi_devi
- 
- 	if (spi->bits_per_word > 32)
- 		return -EINVAL;
-+#ifdef CONFIG_SPI_XWAY_BV
-+	if (spi->bits_per_word != 8) {
-+		dev_err(&spi->dev, "setup: invalid bits_per_word %u (expect 8 in byte valid mode)\n",
-+			spi->bits_per_word);
-+		return -EINVAL;
-+	}
-+	con = ltq_spi_reg_read(hw, LTQ_SPI_CON);
-+	con |= LTQ_SPI_CON_ENBV;
-+	ltq_spi_reg_write(hw, con, LTQ_SPI_CON);
-+#endif
- 
- 	/*
- 	 * Up to six GPIOs can be connected to the SPI module
-@@ -528,10 +579,11 @@ static int ltq_spi_setup(struct spi_devi
- 
- 	if (spi->mode & SPI_CS_HIGH)
- 		gpocon |= (1 << spi->chip_select);
-+	else
-+		gpocon &= ~(1 << spi->chip_select);
-+	ltq_spi_reg_setbit(hw, gpocon, LTQ_SPI_GPOCON);
- 
- 	fgpo = (1 << (spi->chip_select + LTQ_SPI_FGPO_SETOUTN_SHIFT));
--
--	ltq_spi_reg_setbit(hw, gpocon, LTQ_SPI_GPOCON);
- 	ltq_spi_reg_setbit(hw, fgpo, LTQ_SPI_FGPO);
- 
- 	return 0;
-@@ -542,10 +594,37 @@ static void ltq_spi_cleanup(struct spi_d
- 
- }
- 
-+
-+/*
-+ * "Normally" returns Byte Valid = 4.
-+ * If the unaligned remainder of the packet is 3 bytes, these have to be
-+ * transferred as a combination of a 16-bit and a 8-bit FPI transfer. For
-+ * 2 or 1 remaining bytes a single 16-bit or 8-bit transfer will do.
-+ */
-+static inline u8 _estimate_bv(u32 byte_pos, u32 bytelen)
-+{
-+	int remainder = bytelen % 4;
-+
-+	if (byte_pos < (bytelen - remainder))
-+		return 4;
-+
-+	if (remainder == 3) {
-+		if (byte_pos == (bytelen - remainder))
-+			return 2;
-+		else
-+			return 1;
-+	}
-+	return remainder;
-+}
-+
-+
- static void ltq_spi_txfifo_write(struct ltq_spi *hw)
- {
- 	u32 fstat, data;
- 	u16 fifo_space;
-+#ifdef CONFIG_SPI_XWAY_BV
-+	int i, txbv;
-+#endif
- 
- 	/* Determine how much FIFOs are free for TX data */
- 	fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
-@@ -556,15 +635,42 @@ static void ltq_spi_txfifo_write(struct 
- 		return;
- 
- 	while (hw->tx_cnt < hw->len && fifo_space) {
-+#ifndef CONFIG_SPI_XWAY_BV
- 		data = hw->get_tx(hw);
- 		ltq_spi_reg_write(hw, data, LTQ_SPI_TB);
-+#else /* CONFIG_SPI_XWAY_BV */
-+		txbv = _estimate_bv(hw->tx_cnt, hw->len);
-+
-+		for (i = 0, data = 0; i < txbv; i++)
-+			data |= hw->get_tx(hw) << ((txbv - i - 1) << 3);
-+
-+		switch (txbv) {
-+		case 1:
-+			iowrite8(data & 0xFF,
-+				(u8 *)(hw->base + LTQ_SPI_TB) + 3);
-+			break;
-+#ifdef __BIG_ENDIAN
-+		case 2:
-+			iowrite16be(data & 0xFFFF,
-+				(u16 *)(hw->base + LTQ_SPI_TB) + 1);
-+			break;
-+#else /* __LITTLE_ENDIAN */
-+		case 2:
-+			iowrite16(data & 0xFFFF, hw->base + LTQ_SPI_TB);
-+			break;
-+#endif
-+		default:
-+			ltq_spi_reg_write(hw, data, LTQ_SPI_TB);
-+		}
-+#endif /* CONFIG_SPI_XWAY_BV */
- 		fifo_space--;
- 	}
- }
- 
-+
- static void ltq_spi_rxfifo_read(struct ltq_spi *hw)
- {
--	u32 fstat, data, *rx32;
-+	u32 fstat, data, *rx32, mcon;
- 	u16 fifo_fill;
- 	u8 rxbv, shift, *rx8;
- 
-@@ -576,48 +682,95 @@ static void ltq_spi_rxfifo_read(struct l
- 	if (!fifo_fill)
- 		return;
- 
--	/*
--	 * The 32 bit FIFO is always used completely independent from the
--	 * bits_per_word value. Thus four bytes have to be read at once
--	 * per FIFO.
--	 */
--	rx32 = (u32 *) hw->rx;
--	while (hw->len - hw->rx_cnt >= 4 && fifo_fill) {
--		*rx32++ = ltq_spi_reg_read(hw, LTQ_SPI_RB);
--		hw->rx_cnt += 4;
--		hw->rx += 4;
--		fifo_fill--;
--	}
--
--	/*
--	 * If there are remaining bytes, read byte count from STAT.RXBV
--	 * register and read the data byte-wise.
--	 */
--	while (fifo_fill && hw->rx_cnt < hw->len) {
--		rxbv = (ltq_spi_reg_read(hw, LTQ_SPI_STAT) >>
--			LTQ_SPI_STAT_RXBV_SHIFT) & LTQ_SPI_STAT_RXBV_MASK;
--		data = ltq_spi_reg_read(hw, LTQ_SPI_RB);
--
--		shift = (rxbv - 1) * 8;
--		rx8 = hw->rx;
--
--		while (rxbv) {
--			*rx8++ = (data >> shift) & 0xFF;
--			rxbv--;
--			shift -= 8;
--			hw->rx_cnt++;
--			hw->rx++;
-+	mcon = ltq_spi_reg_read(hw, LTQ_SPI_CON);
-+	if (mcon & LTQ_SPI_CON_TXOFF) {
-+		/* If transmitter is off, all 32 bits are valid for all words of
-+		 * the receive request except the final word, which has less
-+		 * than 4 bytes valid if the value in RXREQ.RXCNT is not
-+		 * divisible by 4. */
-+		rx32 = (u32 *) hw->rx;
-+		while (hw->len - hw->rx_cnt >= 4 && fifo_fill) {
-+			*rx32++ = ltq_spi_reg_read(hw, LTQ_SPI_RB);
-+			hw->rx_cnt += 4;
-+			hw->rx += 4;
-+			fifo_fill--;
- 		}
- 
--		fifo_fill--;
-+		/*
-+		 * If there are remaining bytes, read byte count from STAT.RXBV
-+		 * register and read the data byte-wise.
-+		 */
-+		while (fifo_fill && hw->rx_cnt < hw->len) {
-+			rxbv = (ltq_spi_reg_read(hw, LTQ_SPI_STAT) >>
-+				LTQ_SPI_STAT_RXBV_SHIFT) &
-+				LTQ_SPI_STAT_RXBV_MASK;
-+			data = ltq_spi_reg_read(hw, LTQ_SPI_RB);
-+
-+			shift = (rxbv - 1) << 3;
-+			rx8 = hw->rx;
-+
-+			while (rxbv) {
-+				*rx8++ = (data >> shift) & 0xFF;
-+				rxbv--;
-+				shift -= 8;
-+				hw->rx_cnt++;
-+				hw->rx++;
-+			}
-+
-+			fifo_fill--;
-+		}
-+	} else {
-+		/* If transmitter is on */
-+		if (mcon & LTQ_SPI_CON_ENBV) {
-+			/* If SSC_MCON.ENBV = 1, the FPI opcode (from CPU)
-+			 * or D2P_DMA_BE input (from DMA) controls data width
-+			 * for serial transfer. */
-+			while (fifo_fill) {
-+				rxbv = _estimate_bv(hw->rx_cnt, hw->len);
-+				data = ltq_spi_reg_read(hw, LTQ_SPI_RB);
-+
-+				shift = (rxbv - 1) << 3;
-+				rx8 = hw->rx;
-+
-+				while (rxbv) {
-+					*rx8++ = (data >> shift) & 0xFF;
-+					rxbv--;
-+					shift -= 8;
-+					hw->rx_cnt++;
-+					hw->rx++;
-+				}
-+
-+				fifo_fill--;
-+			}
-+		} else {
-+			/* If SSC_MCON.ENBV = 0, the bit range
-+			 * SSC_MCON.BM:0 contains the received data. */
-+			while (fifo_fill && hw->rx_cnt < hw->len) {
-+				rxbv = ((mcon >> LTQ_SPI_CON_BM_SHIFT &
-+					LTQ_SPI_CON_BM_MASK) >> 3) + 1;
-+				data = ltq_spi_reg_read(hw, LTQ_SPI_RB);
-+				shift = (rxbv - 1) << 3;
-+				rx8 = hw->rx;
-+				while (rxbv) {
-+					*rx8++ = (data >> shift) & 0xFF;
-+					rxbv--;
-+					shift -= 8;
-+					hw->rx_cnt++;
-+					hw->rx++;
-+				}
-+
-+				fifo_fill--;
-+			}
-+		}
- 	}
- }
- 
- static void ltq_spi_rxreq_set(struct ltq_spi *hw)
- {
--	u32 rxreq, rxreq_max, rxtodo;
-+	u32 rxreq, rxreq_max, rxtodo, stat;
- 
- 	rxtodo = ltq_spi_reg_read(hw, LTQ_SPI_RXCNT) & LTQ_SPI_RXCNT_TODO_MASK;
-+	stat = ltq_spi_reg_read(hw, LTQ_SPI_STAT);
- 
- 	/*
- 	 * In RX-only mode the serial clock is activated only after writing
-@@ -625,20 +778,31 @@ static void ltq_spi_rxreq_set(struct ltq
- 	 * To avoid receive overflows at high clocks it is better to request
- 	 * only the amount of bytes that fits into all FIFOs. This value
- 	 * depends on the FIFO size implemented in hardware.
-+	 * Request additional data only if BSY bit is not set, otherwise timeout
-+	 * in ltq_spi_wait_ready will occur. Reason of this is unclear as
-+	 * documentation states that BSY bit is set either because a serial
-+	 * transfer is ongoing or because data is still in one of the FIFOs,
-+	 * however, debbugging code added to ltq_spi_wait_ready shows that FIFOs
-+	 * are empty (TXFFL and RXFFL of SSC_FSTAT are 0) and in some cases
-+	 * also transfer is not ongoing (EN bit of SSC_STATE is 0). The solution
-+	 * was taken from ltq_ssc driver from Linux 2.6 written by Andreas Schmidt
-+	 * <andreas.schmidt@infineon.com>.
- 	 */
--	rxreq = hw->len - hw->rx_cnt;
--	rxreq_max = hw->rxfs << 2;
--	rxreq = min(rxreq_max, rxreq);
--
--	if (!rxtodo && rxreq)
--		ltq_spi_reg_write(hw, rxreq, LTQ_SPI_RXREQ);
-+	if (!(stat & LTQ_SPI_STAT_BSY) && !rxtodo) {
-+		rxreq = hw->len - hw->rx_cnt;
-+		rxreq_max = hw->rxfs << 2;
-+		rxreq = min(rxreq_max, rxreq);
-+		if (rxreq)
-+			ltq_spi_reg_write(hw, rxreq, LTQ_SPI_RXREQ);
-+	}
- }
- 
--static inline void ltq_spi_complete(struct ltq_spi *hw)
-+static inline void ltq_spi_tx_complete(struct ltq_spi *hw)
- {
--	complete(&hw->done);
-+	complete(&hw->tx_done);
- }
- 
-+
- irqreturn_t ltq_spi_tx_irq(int irq, void *data)
- {
- 	struct ltq_spi *hw = data;
-@@ -656,7 +820,7 @@ irqreturn_t ltq_spi_tx_irq(int irq, void
- 	spin_unlock_irqrestore(&hw->lock, flags);
- 
- 	if (completed)
--		ltq_spi_complete(hw);
-+		ltq_spi_tx_complete(hw);
- 
- 	return IRQ_HANDLED;
- }
-@@ -665,7 +829,6 @@ irqreturn_t ltq_spi_rx_irq(int irq, void
- {
- 	struct ltq_spi *hw = data;
- 	unsigned long flags;
--	int completed = 0;
- 
- 	spin_lock_irqsave(&hw->lock, flags);
- 
-@@ -676,16 +839,11 @@ irqreturn_t ltq_spi_rx_irq(int irq, void
- 			ltq_spi_txfifo_write(hw);
- 	}
- 
--	if (hw->rx_cnt == hw->len)
--		completed = 1;
--	else if (!hw->tx)
-+	if (hw->rx_cnt < hw->len && !hw->tx)
- 		ltq_spi_rxreq_set(hw);
- 
- 	spin_unlock_irqrestore(&hw->lock, flags);
- 
--	if (completed)
--		ltq_spi_complete(hw);
--
- 	return IRQ_HANDLED;
- }
- 
-@@ -699,6 +857,9 @@ irqreturn_t ltq_spi_err_irq(int irq, voi
- 	/* Disable all interrupts */
- 	ltq_spi_reg_clearbit(hw, LTQ_SPI_IRNEN_ALL, LTQ_SPI_IRNEN);
- 
-+	dev_err(hw->dev, "SPI error interrupt occurred stat: %x\n",
-+		ltq_spi_reg_read(hw, LTQ_SPI_STAT));
-+
- 	/* Clear all error flags */
- 	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_CLR_ERRORS, LTQ_SPI_WHBSTATE);
- 
-@@ -709,7 +870,8 @@ irqreturn_t ltq_spi_err_irq(int irq, voi
- 	hw->status = -EIO;
- 	spin_unlock_irqrestore(&hw->lock, flags);
- 
--	ltq_spi_complete(hw);
-+	if (hw->tx)
-+		ltq_spi_tx_complete(hw);
- 
- 	return IRQ_HANDLED;
- }
-@@ -725,7 +887,7 @@ static int ltq_spi_txrx_bufs(struct spi_
- 	hw->tx_cnt = 0;
- 	hw->rx_cnt = 0;
- 	hw->status = 0;
--	init_completion(&hw->done);
-+	init_completion(&hw->tx_done);
- 
- 	ltq_spi_xmit_set(hw, t);
- 
-@@ -735,32 +897,68 @@ static int ltq_spi_txrx_bufs(struct spi_
- 	if (hw->tx) {
- 		/* Initially fill TX FIFO with as much data as possible */
- 		ltq_spi_txfifo_write(hw);
--		irq_flags |= LTQ_SPI_IRNEN_T;
-+
-+		irq_flags |= hw->irnen_t;
- 
- 		/* Always enable RX interrupt in Full Duplex mode */
- 		if (hw->rx)
--			irq_flags |= LTQ_SPI_IRNEN_R;
-+			irq_flags |= hw->irnen_r;
- 	} else if (hw->rx) {
- 		/* Start RX clock */
- 		ltq_spi_rxreq_set(hw);
- 
- 		/* Enable RX interrupt to receive data from RX FIFOs */
--		irq_flags |= LTQ_SPI_IRNEN_R;
-+		irq_flags |= hw->irnen_r;
- 	}
- 
- 	/* Enable TX or RX interrupts */
- 	ltq_spi_reg_setbit(hw, irq_flags, LTQ_SPI_IRNEN);
--	wait_for_completion_interruptible(&hw->done);
-+	if (hw->tx)
-+		wait_for_completion_interruptible(&hw->tx_done);
-+	if (hw->rx) {
-+		u32 fstat;
-+		u16 fifo_fill;
-+
-+		/* Completion can't be used with RX, because RX interrupt may
-+		 * never occur. RX interrupt occurs only when RX FIFO fill
-+		 * reaches specified level (half of FIFO size, in this driver).
-+		 * Additional uncertainty is introduced by the fact that rx_cnt
-+		 * and rxfs are counting bytes, but FIFO stores words (possibly
-+		 * of different size).
-+		 * Solution is just to poll for RX data.
-+		 */
-+		while (hw->rx_cnt < hw->len && !hw->status) {
-+			/* Determine how much FIFOs are filled with RX data */
-+			fstat = ltq_spi_reg_read(hw, LTQ_SPI_FSTAT);
-+			fifo_fill = ((fstat >> LTQ_SPI_FSTAT_RXFFL_SHIFT)
-+					& LTQ_SPI_FSTAT_RXFFL_MASK);
-+
-+			if (fifo_fill)
-+				ltq_spi_rx_irq(hw->irq[0], hw);
-+			else
-+				cond_resched();
-+		}
-+	}
- 
- 	/* Disable all interrupts */
- 	ltq_spi_reg_clearbit(hw, LTQ_SPI_IRNEN_ALL, LTQ_SPI_IRNEN);
- 
--	/*
--	 * Return length of current transfer for bitbang utility code if
--	 * no errors occured during transmission.
--	 */
--	if (!hw->status)
--		hw->status = hw->len;
-+	if (!hw->status) {
-+		/*
-+		 * A signaled TX completion doesn't guarantee that the data has been sent
-+		 * on the SPI bus, it just garantees that it has been written to TX FIFO.
-+		 * Verification of completion of transfer is done by polling of BSY bit of
-+		 * SSC_STATE register.
-+		 */
-+		if (!hw->rx)
-+			hw->status = ltq_spi_wait_ready(hw);
-+		/*
-+		 * Return length of current transfer for bitbang utility code if
-+		 * no errors occurred during transmission.
-+		 */
-+		if (!hw->status)
-+			hw->status = hw->len;
-+	}
- 
- 	return hw->status;
- }
-@@ -850,17 +1048,25 @@ static int ltq_spi_probe(struct platform
- 	hw->bitbang.setup_transfer = ltq_spi_setup_transfer;
- 	hw->bitbang.txrx_bufs = ltq_spi_txrx_bufs;
- 
--	if (of_machine_is_compatible("lantiq,ase"))
-+	if (of_machine_is_compatible("lantiq,ase")) {
- 		master->num_chipselect = 3;
--	else
-+
-+		hw->irnen_t = LTQ_SPI_IRNEN_T_XWAY;
-+		hw->irnen_r = LTQ_SPI_IRNEN_R_XWAY;
-+	} else {
- 		master->num_chipselect = 6;
-+
-+		hw->irnen_t = LTQ_SPI_IRNEN_T;
-+		hw->irnen_r = LTQ_SPI_IRNEN_R;
-+	}
-+
- 	master->bus_num = pdev->id;
- 	master->setup = ltq_spi_setup;
- 	master->cleanup = ltq_spi_cleanup;
- 	master->dev.of_node = pdev->dev.of_node;
- 
- 	hw->dev = &pdev->dev;
--	init_completion(&hw->done);
-+	init_completion(&hw->tx_done);
- 	spin_lock_init(&hw->lock);
- 
- 	ltq_spi_hw_enable(hw);
-@@ -875,13 +1081,13 @@ static int ltq_spi_probe(struct platform
- 
- 	/* Enable error checking, disable TX/RX, set idle value high */
- 	data = LTQ_SPI_CON_RUEN | LTQ_SPI_CON_AEN |
--	    LTQ_SPI_CON_TEN | LTQ_SPI_CON_REN |
--	    LTQ_SPI_CON_TXOFF | LTQ_SPI_CON_RXOFF | LTQ_SPI_CON_IDLE;
-+		LTQ_SPI_CON_TEN | LTQ_SPI_CON_REN |
-+		LTQ_SPI_CON_TXOFF | LTQ_SPI_CON_RXOFF | LTQ_SPI_CON_IDLE;
- 	ltq_spi_reg_write(hw, data, LTQ_SPI_CON);
- 
- 	/* Enable master mode and clear error flags */
- 	ltq_spi_reg_write(hw, LTQ_SPI_WHBSTATE_SETMS |
--			  LTQ_SPI_WHBSTATE_CLR_ERRORS, LTQ_SPI_WHBSTATE);
-+		LTQ_SPI_WHBSTATE_CLR_ERRORS, LTQ_SPI_WHBSTATE);
- 
- 	/* Reset GPIO/CS registers */
- 	ltq_spi_reg_write(hw, 0x0, LTQ_SPI_GPOCON);
-@@ -898,7 +1104,11 @@ static int ltq_spi_probe(struct platform
- 
- 	platform_set_drvdata(pdev, hw);
- 
--	pr_info("Lantiq SoC SPI controller rev %u (TXFS %u, RXFS %u, DMA %u)\n",
-+#ifdef CONFIG_SPI_XWAY_BV
-+	pr_info("Lantiq SoC SPI controller rev %u (TXFS %u, RXFS %u, DMA %u, byte valid mode on)\n",
-+#else
-+	pr_info("Lantiq SoC SPI controller rev %u (TXFS %u, RXFS %u, DMA %u, byte valid mode off)\n",
-+#endif
- 		id & LTQ_SPI_ID_REV_MASK, hw->txfs, hw->rxfs, hw->dma_support);
- 
- 	return 0;
-@@ -953,6 +1163,7 @@ static int ltq_spi_remove(struct platfor
- 
- static const struct of_device_id ltq_spi_match[] = {
- 	{ .compatible = "lantiq,spi-xway" },
-+	{ .compatible = "lantiq,spi-lantiq-ssc" },
- 	{},
- };
- MODULE_DEVICE_TABLE(of, ltq_spi_match);
-@@ -961,7 +1172,7 @@ static struct platform_driver ltq_spi_dr
- 	.probe = ltq_spi_probe,
- 	.remove = ltq_spi_remove,
- 	.driver = {
--		.name = "spi-xway",
-+		.name = "spi-lantiq-ssc",
- 		.owner = THIS_MODULE,
- 		.of_match_table = ltq_spi_match,
- 	},
-@@ -973,3 +1184,4 @@ MODULE_DESCRIPTION("Lantiq SoC SPI contr
- MODULE_AUTHOR("Daniel Schwierzeck <daniel.schwierzeck@googlemail.com>");
- MODULE_LICENSE("GPL");
- MODULE_ALIAS("platform:spi-xway");
-+MODULE_ALIAS("platform:spi-lantiq-ssc");
diff --git a/target/linux/lantiq/patches-3.18/2061-falcon-add-spi-clock.patch b/target/linux/lantiq/patches-3.18/2061-falcon-add-spi-clock.patch
deleted file mode 100644
index ede7f25e8f..0000000000
--- a/target/linux/lantiq/patches-3.18/2061-falcon-add-spi-clock.patch
+++ /dev/null
@@ -1,21 +0,0 @@
-Falcon: register clock for SPI
-
-diff --git a/arch/mips/lantiq/falcon/sysctrl.c b/arch/mips/lantiq/falcon/sysctrl.c
---- a/arch/mips/lantiq/falcon/sysctrl.c
-+++ b/arch/mips/lantiq/falcon/sysctrl.c
-@@ -61,6 +61,7 @@
- #define ACTS_PADCTRL2	0x00200000
- #define ACTS_PADCTRL3	0x00200000
- #define ACTS_PADCTRL4	0x00400000
-+#define ACTS_SSC0	0x00002000
- 
- #define sysctl_w32(m,val,reg)	ltq_w32((val), sysctl_membase[m] + (reg))
- #define sysctl_r32(m,reg)	ltq_r32(sysctl_membase[m] + (reg))
-@@ -245,6 +246,7 @@ void __init ltq_soc_init(void)
- 	clkdev_add_sys("1e100b00.serial", SYSCTL_SYS1, ACTS_ASC1_ACT);
- 	clkdev_add_sys("1e100c00.serial", SYSCTL_SYS1, ACTS_ASC0_ACT);
- 	clkdev_add_sys("1e200000.i2c", SYSCTL_SYS1, ACTS_I2C_ACT);
-+	clkdev_add_sys("1e100d00.spi", SYSCTL_SYS1, ACTS_SSC0);
- }
- 
- 
diff --git a/target/linux/lantiq/patches-3.18/2070-falcon-ext-sysctrl.patch b/target/linux/lantiq/patches-3.18/2070-falcon-ext-sysctrl.patch
deleted file mode 100644
index 7609152037..0000000000
--- a/target/linux/lantiq/patches-3.18/2070-falcon-ext-sysctrl.patch
+++ /dev/null
@@ -1,924 +0,0 @@
-extended sysctrl for SDK usage
-- provide locked access to shared registers
-- define some register bits and mask
-
-diff --git a/arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h b/arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h
---- a/arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h
-+++ b/arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h
-@@ -22,39 +22,475 @@
- 
- #include <falcon/lantiq_soc.h>
- 
--static inline void sys1_hw_activate(u32 mask)
-+#ifndef SYSCTRL_USE_EXTENDED
-+# define SYSCTRL_USE_EXTENDED
-+#endif
-+
-+/** Mask definition for SYS1.STATUS block */
-+#define SYSCTRL_SYS1_STATUS			0x80000000
-+/** Mask definition for SYS1.SHA1 block */
-+#define SYSCTRL_SYS1_SHA1			0x40000000
-+/** Mask definition for SYS1.AES block */
-+#define SYSCTRL_SYS1_AES 			0x20000000
-+/** Mask definition for SYS1.PCM block */
-+#define SYSCTRL_SYS1_PCM 			0x10000000
-+/** Mask definition for SYS1.FSCT block */
-+#define SYSCTRL_SYS1_FSCT 			0x08000000
-+/** Mask definition for SYS1.GPTC block */
-+#define SYSCTRL_SYS1_GPTC 			0x04000000
-+/** Mask definition for SYS1.MPS block */
-+#define SYSCTRL_SYS1_MPS 			0x02000000
-+/** Mask definition for SYS1.DFEV0 block */
-+#define SYSCTRL_SYS1_DFEV0 			0x01000000
-+/** Mask definition for SYS1.PADCTRL4 block */
-+#define SYSCTRL_SYS1_PADCTRL4 			0x00400000
-+/** Mask definition for SYS1.PADCTRL3 block */
-+#define SYSCTRL_SYS1_PADCTRL3 			0x00200000
-+/** Mask definition for SYS1.PADCTRL1 block */
-+#define SYSCTRL_SYS1_PADCTRL1 			0x00100000
-+/** Mask definition for SYS1.P4 block */
-+#define SYSCTRL_SYS1_P4 			0x00040000
-+/** Mask definition for SYS1.P3 block */
-+#define SYSCTRL_SYS1_P3 			0x00020000
-+/** Mask definition for SYS1.P1 block */
-+#define SYSCTRL_SYS1_P1 			0x00010000
-+/** Mask definition for SYS1.HOST block */
-+#define SYSCTRL_SYS1_HOST 			0x00008000
-+/** Mask definition for SYS1.I2C block */
-+#define SYSCTRL_SYS1_I2C 			0x00004000
-+/** Mask definition for SYS1.SSC0 block */
-+#define SYSCTRL_SYS1_SSC0 			0x00002000
-+/** Mask definition for SYS1.ASC0 block */
-+#define SYSCTRL_SYS1_ASC0 			0x00001000
-+/** Mask definition for SYS1.ASC1 block */
-+#define SYSCTRL_SYS1_ASC1 			0x00000800
-+/** Mask definition for SYS1.DCDCAPD block */
-+#define SYSCTRL_SYS1_DCDCAPD 			0x00000400
-+/** Mask definition for SYS1.DCDCDDR block */
-+#define SYSCTRL_SYS1_DCDCDDR 			0x00000200
-+/** Mask definition for SYS1.DCDC1V0 block */
-+#define SYSCTRL_SYS1_DCDC1V0 			0x00000100
-+/** Mask definition for SYS1.TRC2MEM block */
-+#define SYSCTRL_SYS1_TRC2MEM 			0x00000040
-+/** Mask definition for SYS1.DDR block */
-+#define SYSCTRL_SYS1_DDR 			0x00000020
-+/** Mask definition for SYS1.EBU block */
-+#define SYSCTRL_SYS1_EBU 			0x00000010
-+
-+/** Mask definition for SYS_ETH.GPHY1MII2 block */
-+#define SYSCTRL_SYS_ETH_GPHY1MII2 		0x02000000
-+/** Mask definition for SYS_ETH.GPHY0MII2 block */
-+#define SYSCTRL_SYS_ETH_GPHY0MII2 		0x01000000
-+/** Mask definition for SYS_ETH.PADCTRL2 block */
-+#define SYSCTRL_SYS_ETH_PADCTRL2 		0x00200000
-+/** Mask definition for SYS_ETH.PADCTRL0 block */
-+#define SYSCTRL_SYS_ETH_PADCTRL0 		0x00100000
-+/** Mask definition for SYS_ETH.P2 block */
-+#define SYSCTRL_SYS_ETH_P2 			0x00020000
-+/** Mask definition for SYS_ETH.P0 block */
-+#define SYSCTRL_SYS_ETH_P0 			0x00010000
-+/** Mask definition for SYS_ETH.xMII block */
-+#define SYSCTRL_SYS_ETH_XMII 			0x00000800
-+/** Mask definition for SYS_ETH.SGMII block */
-+#define SYSCTRL_SYS_ETH_SGMII 			0x00000400
-+/** Mask definition for SYS_ETH.GPHY1 block */
-+#define SYSCTRL_SYS_ETH_GPHY1 			0x00000200
-+/** Mask definition for SYS_ETH.GPHY0 block */
-+#define SYSCTRL_SYS_ETH_GPHY0 			0x00000100
-+/** Mask definition for SYS_ETH.MDIO block */
-+#define SYSCTRL_SYS_ETH_MDIO 			0x00000080
-+/** Mask definition for SYS_ETH.GMAC3 block */
-+#define SYSCTRL_SYS_ETH_GMAC3 			0x00000008
-+/** Mask definition for SYS_ETH.GMAC2 block */
-+#define SYSCTRL_SYS_ETH_GMAC2 			0x00000004
-+/** Mask definition for SYS_ETH.GMAC1 block */
-+#define SYSCTRL_SYS_ETH_GMAC1 			0x00000002
-+/** Mask definition for SYS_ETH.GMAC0 block */
-+#define SYSCTRL_SYS_ETH_GMAC0 			0x00000001
-+
-+/** Mask definition for SYS_GPE.COP7 block */
-+#define SYSCTRL_SYS_GPE_COP7 			0x80000000
-+/** Mask definition for SYS_GPE.COP6 block */
-+#define SYSCTRL_SYS_GPE_COP6 			0x40000000
-+/** Mask definition for SYS_GPE.COP5 block */
-+#define SYSCTRL_SYS_GPE_COP5 			0x20000000
-+/** Mask definition for SYS_GPE.COP4 block */
-+#define SYSCTRL_SYS_GPE_COP4 			0x10000000
-+/** Mask definition for SYS_GPE.COP3 block */
-+#define SYSCTRL_SYS_GPE_COP3 			0x08000000
-+/** Mask definition for SYS_GPE.COP2 block */
-+#define SYSCTRL_SYS_GPE_COP2 			0x04000000
-+/** Mask definition for SYS_GPE.COP1 block */
-+#define SYSCTRL_SYS_GPE_COP1 			0x02000000
-+/** Mask definition for SYS_GPE.COP0 block */
-+#define SYSCTRL_SYS_GPE_COP0 			0x01000000
-+/** Mask definition for SYS_GPE.PE5 block */
-+#define SYSCTRL_SYS_GPE_PE5 			0x00200000
-+/** Mask definition for SYS_GPE.PE4 block */
-+#define SYSCTRL_SYS_GPE_PE4 			0x00100000
-+/** Mask definition for SYS_GPE.PE3 block */
-+#define SYSCTRL_SYS_GPE_PE3 			0x00080000
-+/** Mask definition for SYS_GPE.PE2 block */
-+#define SYSCTRL_SYS_GPE_PE2 			0x00040000
-+/** Mask definition for SYS_GPE.PE1 block */
-+#define SYSCTRL_SYS_GPE_PE1 			0x00020000
-+/** Mask definition for SYS_GPE.PE0 block */
-+#define SYSCTRL_SYS_GPE_PE0 			0x00010000
-+/** Mask definition for SYS_GPE.ARB block */
-+#define SYSCTRL_SYS_GPE_ARB 			0x00002000
-+/** Mask definition for SYS_GPE.FSQM block */
-+#define SYSCTRL_SYS_GPE_FSQM 			0x00001000
-+/** Mask definition for SYS_GPE.TMU block */
-+#define SYSCTRL_SYS_GPE_TMU 			0x00000800
-+/** Mask definition for SYS_GPE.MRG block */
-+#define SYSCTRL_SYS_GPE_MRG 			0x00000400
-+/** Mask definition for SYS_GPE.DISP block */
-+#define SYSCTRL_SYS_GPE_DISP 			0x00000200
-+/** Mask definition for SYS_GPE.IQM block */
-+#define SYSCTRL_SYS_GPE_IQM 			0x00000100
-+/** Mask definition for SYS_GPE.CPUE block */
-+#define SYSCTRL_SYS_GPE_CPUE 			0x00000080
-+/** Mask definition for SYS_GPE.CPUI block */
-+#define SYSCTRL_SYS_GPE_CPUI 			0x00000040
-+/** Mask definition for SYS_GPE.GPONE block */
-+#define SYSCTRL_SYS_GPE_GPONE 			0x00000020
-+/** Mask definition for SYS_GPE.GPONI block */
-+#define SYSCTRL_SYS_GPE_GPONI 			0x00000010
-+/** Mask definition for SYS_GPE.LAN3 block */
-+#define SYSCTRL_SYS_GPE_LAN3 			0x00000008
-+/** Mask definition for SYS_GPE.LAN2 block */
-+#define SYSCTRL_SYS_GPE_LAN2 			0x00000004
-+/** Mask definition for SYS_GPE.LAN1 block */
-+#define SYSCTRL_SYS_GPE_LAN1 			0x00000002
-+/** Mask definition for SYS_GPE.LAN0 block */
-+#define SYSCTRL_SYS_GPE_LAN0 			0x00000001
-+
-+/** Chip Version Number Mask */
-+#define SYSCTRL_CHIPID_VERSION_MASK 		0xF0000000
-+/** Chip Version Number Offset */
-+#define SYSCTRL_CHIPID_VERSION_OFFSET 		28
-+/** Part Number, Constant Part Mask */
-+#define SYSCTRL_CHIPID_PARTNR_MASK 		0x0FFFF000
-+/** Part Number, Constant Part Offset */
-+#define SYSCTRL_CHIPID_PARTNR_OFFSET 		12
-+/** Manufacturer ID Mask */
-+#define SYSCTRL_CHIPID_MANID_MASK 		0x00000FFE
-+/** Manufacturer ID Offset */
-+#define SYSCTRL_CHIPID_MANID_OFFSET 		1
-+/** Constant bit Mask */
-+#define SYSCTRL_CHIPID_CONST1_MASK 		0x00000001
-+/** Constant bit Offset */
-+#define SYSCTRL_CHIPID_CONST1_OFFSET 		0
-+
-+/** PHY_CLKO pin frequency, 25 MHz */
-+#define SYSCTRL_EXTPHYC_CLKSEL_F25 		0x00000001
-+/** PHY_CLKO pin frequency, 125 MHz */
-+#define SYSCTRL_EXTPHYC_CLKSEL_F125 		0x00000002
-+/** PHY_CLKO pin frequency, 50 MHz */
-+#define SYSCTRL_EXTPHYC_CLKSEL_F50 		0x00000005
-+
-+/** GMAC connects to GPHY0_GMII interface */
-+#define SYSCTRL_MUX_GPHY0_GMII 			0x00000000
-+/** GMAC connects to GPHY0_MII2 interface */
-+#define SYSCTRL_MUX_GPHY0_MII2 			0x00000001
-+/** GMAC connects to GPHY1_GMII interface */
-+#define SYSCTRL_MUX_GPHY1_GMII 			0x00000002
-+/** GMAC connects to GPHY1_MII2 interface */
-+#define SYSCTRL_MUX_GPHY1_MII2 			0x00000003
-+/** GMAC connects to SGMII interface */
-+#define SYSCTRL_MUX_SGMII 			0x00000004
-+/** GMAC connects to xMII0 interface */
-+#define SYSCTRL_MUX_XMII0 			0x00000005
-+/** GMAC connects to xMII1 interface */
-+#define SYSCTRL_MUX_xMII1 			0x00000006
-+
-+/** FUSE0 SFC field Mask */
-+#define SYSCTRL_FUSE0_SFC_MASK 			0x80000000
-+/** FUSE0 SFC field Offset */
-+#define SYSCTRL_FUSE0_SFC_OFFSET 		31
-+/** FUSE0 SFC field Select */
-+#define SYSCTRL_FUSE0_SFC_SEL 			0x80000000
-+/** FUSE0 SC_MBCFG field Mask */
-+#define SYSCTRL_FUSE0_SC_MBCFG_MASK		0x40000000
-+/** FUSE0 SC_MBCFG field Offset */
-+#define SYSCTRL_FUSE0_SC_MBCFG_OFFSET		30
-+/** FUSE0 SC_MBCFG field Select */
-+#define SYSCTRL_FUSE0_SC_MBCFG_SEL 		0x40000000
-+/** FUSE0 Device Type field Mask */
-+#define SYSCTRL_FUSE0_F0_MASK 			0x3C000000
-+/** FUSE0 Device Type field Offset */
-+#define SYSCTRL_FUSE0_F0_OFFSET 		26
-+/** FUSE0 Device Type field value: FALCOND */
-+#define SYSCTRL_FUSE0_F0_FALCOND 		0x00000000
-+/** FUSE0 Device Type field value: FALCONV */
-+#define SYSCTRL_FUSE0_F0_FALCONV 		0x04000000
-+/** FUSE0 Device Type field value: FALCONM */
-+#define SYSCTRL_FUSE0_F0_FALCONM 		0x08000000
-+/** FUSE0 Device Type field value: SFP */
-+#define SYSCTRL_FUSE0_F0_FALCONS 		0x0C000000
-+/** FUSE0 Device Type field value: D2 */
-+#define SYSCTRL_FUSE0_F0_FALCOND2 		0x10000000
-+/** FUSE0 Device Type field value: SR */
-+#define SYSCTRL_FUSE0_F0_FALCONSR 		0x14000000
-+/** FUSE0 VCALMM20 Voltage Reference Mask */
-+#define SYSCTRL_FUSE0_VCALMM20_MASK 		0x03F00000
-+/** FUSE0 VCALMM20 Voltage Reference Offset */
-+#define SYSCTRL_FUSE0_VCALMM20_OFFSET 		20
-+/** FUSE0 VCALMM100 Voltage Reference Mask */
-+#define SYSCTRL_FUSE0_VCALMM100_MASK 		0x000FC000
-+/** FUSE0 VCALMM100 Voltage Reference Offset */
-+#define SYSCTRL_FUSE0_VCALMM100_OFFSET 		14
-+/** FUSE0 VCALMM400 Voltage Reference Mask */
-+#define SYSCTRL_FUSE0_VCALMM400_MASK 		0x00003F00
-+/** FUSE0 VCALMM400 Voltage Reference Offset */
-+#define SYSCTRL_FUSE0_VCALMM400_OFFSET 		8
-+/** FUSE0 RCALMM R error correction Mask */
-+#define SYSCTRL_FUSE0_RCALMM_MASK 		0x000000FF
-+/** FUSE0 RCALMM R error correction Offset */
-+#define SYSCTRL_FUSE0_RCALMM_OFFSET 		0
-+
-+/** FUSE1 Spare fuse1 Mask */
-+#define SYSCTRL_FUSE1_F1_MASK 			0xFFF00000
-+/** FUSE1 Spare fuse1 Offset */
-+#define SYSCTRL_FUSE1_F1_OFFSET 		20
-+/** FUSE1 FREE_1 Mask */
-+#define SYSCTRL_FUSE1_FR1_MASK 			0x000F0000
-+/** FUSE1 FREE_1 Offset */
-+#define SYSCTRL_FUSE1_FR1_OFFSET 		16
-+/** FUSE1 DCDC 1V0 OFFSET Mask */
-+#define SYSCTRL_FUSE1_OFFSET1V0DCDC_MASK   	0x0000F800
-+/** FUSE1 DCDC 1V0 OFFSET Offset */
-+#define SYSCTRL_FUSE1_OFFSET1V0DCDC_OFFSET	11
-+/** FUSE1 DCDC APD OFFSET Mask */
-+#define SYSCTRL_FUSE1_OFFSETAPDDCDC_MASK 	0x000007C0
-+/** FUSE1 DCDC APD OFFSET Offset */
-+#define SYSCTRL_FUSE1_OFFSETAPDDCDC_OFFSET 	6
-+/** FUSE1 DCDC APD GAIN Mask */
-+#define SYSCTRL_FUSE1_GAINAPDDCDC_MASK 		0x0000003F
-+/** FUSE1 DCDC APD GAIN Offset */
-+#define SYSCTRL_FUSE1_GAINAPDDCDC_OFFSET 	0
-+
-+/** ANALOG Status of written FUSES Mask */
-+#define SYSCTRL_ANALOG_FS_MASK 			0xE0000000
-+/** ANALOG Status of written FUSES Offset */
-+#define SYSCTRL_ANALOG_FS_OFFSET 		29
-+/** ANALOG fuse A11 format */
-+#define SYSCTRL_ANALOG_FS_FS0 			0x00000000
-+/** ANALOG fuse new format */
-+#define SYSCTRL_ANALOG_FS_FS1 			0x20000000
-+/** ANALOG fuse reserved format  */
-+#define SYSCTRL_ANALOG_FS_FS2 			0x40000000
-+/** Reserved Analog eFuses Mask */
-+#define SYSCTRL_ANALOG_A0_MASK 			0x1C000000
-+/** Reserved Analog eFuses Offset */
-+#define SYSCTRL_ANALOG_A0_OFFSET 		26
-+/** ANALOG fuse Absolut Temperature Mask */
-+#define SYSCTRL_ANALOG_TEMPMM_MASK 		0x03F00000
-+/** ANALOG fuse Absolut Temperature Offset */
-+#define SYSCTRL_ANALOG_TEMPMM_OFFSET 		20
-+/** ANALOG fuse Drive DAC Gain Mask */
-+#define SYSCTRL_ANALOG_GAINDRIVEDAC_MASK 	0x000F8000
-+/** ANALOG fuse Drive DAC Gain Offset */
-+#define SYSCTRL_ANALOG_GAINDRIVEDAC_OFFSET 	15
-+/** ANALOG fuse Bias Voltage Generation Mask */
-+#define SYSCTRL_ANALOG_VBGP_MASK 		0x00007000
-+/** ANALOG fuse Bias Voltage Generation Offset */
-+#define SYSCTRL_ANALOG_VBGP_OFFSET 		12
-+/** ANALOG fuse Bias Current Generation Mask */
-+#define SYSCTRL_ANALOG_IREFBGP_MASK 		0x00000F00
-+/** ANALOG fuse Bias Current Generation Offset */
-+#define SYSCTRL_ANALOG_IREFBGP_OFFSET 		8
-+/** ANALOG fuse Bias Voltage Generation Mask */
-+#define SYSCTRL_ANALOG_TBGP_MASK 		0x000000E0
-+/** ANALOG fuse Bias Voltage Generation Offset */
-+#define SYSCTRL_ANALOG_TBGP_OFFSET 		5
-+/** ANALOG fuse BIAS DAC Gain Mask */
-+#define SYSCTRL_ANALOG_GAINBIASDAC_MASK 	0x0000001F
-+/** ANALOG fuse BIAS DAC Gain Offset */
-+#define SYSCTRL_ANALOG_GAINBIASDAC_OFFSET 	0
-+
-+/** CONFIG fuse ddr PU driver Mask */
-+#define SYSCTRL_CONFIG_DDRPU_MASK 		0xC0000000
-+/** CONFIG fuse ddr PU driver Offset */
-+#define SYSCTRL_CONFIG_DDRPU_OFFSET 		30
-+/** CONFIG fuse ddr PD driver Mask */
-+#define SYSCTRL_CONFIG_DDRPD_MASK 		0x30000000
-+/** CONFIG fuse ddr PD driver Mask */
-+#define SYSCTRL_CONFIG_DDRPD_OFFSET 		28
-+/** CONFIG fuse Authentification Unit enable Mask */
-+#define SYSCTRL_CONFIG_SHA1EN_MASK 		0x08000000
-+/** CONFIG fuse Authentification Unit enable Offset */
-+#define SYSCTRL_CONFIG_SHA1EN_OFFSET 		27
-+/** CONFIG fuse Encryption Unit enable Mask */
-+#define SYSCTRL_CONFIG_AESEN_MASK 		0x04000000
-+/** CONFIG fuse Encryption Unit enable Offset */
-+#define SYSCTRL_CONFIG_AESEN_OFFSET 		26
-+/** CONFIG fuse Subversion Number Mask */
-+#define SYSCTRL_CONFIG_SUBVERS_MASK 		0x03C00000
-+/** CONFIG fuse Subversion Number Offset  */
-+#define SYSCTRL_CONFIG_SUBVERS_OFFSET 		22
-+/** CONFIG fuse Subversion Number: AV1 */
-+#define SYSCTRL_CONFIG_SUBVERS_AV1 		0x00000000
-+/** CONFIG fuse Subversion Number: AV2 */
-+#define SYSCTRL_CONFIG_SUBVERS_AV2 		0x00400000
-+/** CONFIG fuse Subversion Number: AV3 */
-+#define SYSCTRL_CONFIG_SUBVERS_AV3 		0x00800000
-+/** CONFIG fuse Subversion Number: AV4 */
-+#define SYSCTRL_CONFIG_SUBVERS_AV4 		0x00C00000
-+/** CONFIG fuse Subversion Number: BV1 */
-+#define SYSCTRL_CONFIG_SUBVERS_BV1 		0x01000000
-+/** CONFIG fuse PLL settings Mask */
-+#define SYSCTRL_CONFIG_PLLINFRA_MASK 		0x003FF000
-+/** CONFIG fuse PLL settings Offset */
-+#define SYSCTRL_CONFIG_PLLINFRA_OFFSET 		12
-+/** CONFIG fuse GPE frequency selection Mask */
-+#define SYSCTRL_CONFIG_GPEFREQ_MASK 		0x00000C00
-+/** CONFIG fuse GPE frequency selection Offset */
-+#define SYSCTRL_CONFIG_GPEFREQ_OFFSET		10
-+/** CONFIG fuse RM enable Mask */
-+#define SYSCTRL_CONFIG_RME_MASK 		0x00000200
-+/** CONFIG fuse RM enable Offset */
-+#define SYSCTRL_CONFIG_RME_OFFSET 		9
-+/** CONFIG fuse RM settings Mask */
-+#define SYSCTRL_CONFIG_RM_MASK 			0x000001E0
-+/** CONFIG fuse RM settings Offset */
-+#define SYSCTRL_CONFIG_RM_OFFSET 		5
-+/** CONFIG fuse RM enable for GPE Memories Mask */
-+#define SYSCTRL_CONFIG_RMEGPE_MASK 		0x00000010
-+/** CONFIG fuse RM enable for GPE Memories Offset */
-+#define SYSCTRL_CONFIG_RMEGPE_OFFSET 		4
-+/** CONFIG fuse RM settings for GPE Memories Mask */
-+#define SYSCTRL_CONFIG_RMGPE_MASK 		0x0000000F
-+/** CONFIG fuse RM settings for GPE Memories Offset */
-+#define SYSCTRL_CONFIG_RMGPE_OFFSET 		0
-+
-+/** FUSE0 Fuse Selector */
-+#define SYSCTRL_FUSE_0				0
-+/** FUSE1 Fuse Selector */
-+#define SYSCTRL_FUSE_1				1
-+/** ANALOG Fuse Selector */
-+#define SYSCTRL_FUSE_ANALOG			2
-+/** CONFIG Fuse Selector */
-+#define SYSCTRL_FUSE_CONFIG			3
-+
-+/** xMII0 Interface Selector */
-+#define SYSCTRL_INTERFACE_XMII0			0
-+/** xMII1 Interface Selector */
-+#define SYSCTRL_INTERFACE_XMII1			1
-+/** SGMII Interface Selector */
-+#define SYSCTRL_INTERFACE_SGMII			2
-+
-+/** Data Rate 10 MBit/s */
-+#define SYSCTRL_DRC_10				0
-+/** Data Rate 100 MBit/s */
-+#define SYSCTRL_DRC_100				1
-+/** Data Rate 200 MBit/s */
-+#define SYSCTRL_DRC_200				5
-+/** Data Rate 1000 MBit/s */
-+#define SYSCTRL_DRC_1000			2
-+/** Data Rate 2500 MBit/s */
-+#define SYSCTRL_DRC_2500			4
-+
-+/** Linear 1.5 V Regulator set to 1.34V */
-+#define SYSCTRL_LDO1V5_1V34		        0
-+/** Linear 1.5 V Regulator set to 1.39V */
-+#define SYSCTRL_LDO1V5_1V39		        1
-+/** Linear 1.5 V Regulator set to 1.44V */
-+#define SYSCTRL_LDO1V5_1V44		        2
-+/** Linear 1.5 V Regulator set to 1.50V */
-+#define SYSCTRL_LDO1V5_1V50		        3
-+/** Linear 1.5 V Regulator set to 1.56V */
-+#define SYSCTRL_LDO1V5_1V56		        4
-+/** Linear 1.5 V Regulator set to 1.63V */
-+#define SYSCTRL_LDO1V5_1V63		        5
-+/** Linear 1.5 V Regulator set to 1.70V */
-+#define SYSCTRL_LDO1V5_1V70		        6
-+/** Linear 1.5 V Regulator set to 1.78V */
-+#define SYSCTRL_LDO1V5_1V78		        7
-+
-+unsigned int ltq_sysctl_is_activated(const int module, const unsigned int mask);
-+
-+unsigned int ltq_sysctl_is_clocked(const int module, const unsigned int mask);
-+
-+static inline void ltq_sysctl_sys1_activate(unsigned int mask)
- { ltq_sysctl_activate(SYSCTL_SYS1, mask); }
--static inline void sys1_hw_deactivate(u32 mask)
-+static inline void ltq_sysctl_sys1_deactivate(unsigned int mask)
- { ltq_sysctl_deactivate(SYSCTL_SYS1, mask); }
--static inline void sys1_hw_clk_enable(u32 mask)
-+static inline void ltq_sysctl_sys1_clk_enable(unsigned int mask)
- { ltq_sysctl_clken(SYSCTL_SYS1, mask); }
--static inline void sys1_hw_clk_disable(u32 mask)
-+static inline void ltq_sysctl_sys1_clk_disable(unsigned int mask)
- { ltq_sysctl_clkdis(SYSCTL_SYS1, mask); }
--static inline void sys1_hw_activate_or_reboot(u32 mask)
-+static inline void ltq_sysctl_sys1_reboot(unsigned int mask)
- { ltq_sysctl_reboot(SYSCTL_SYS1, mask); }
-+static inline
-+unsigned int ltq_sysctl_sys1_is_activated(const unsigned int mask)
-+{ return ltq_sysctl_is_activated(SYSCTL_SYS1, mask); }
-+static inline
-+unsigned int ltq_sysctl_sys1_is_clocked(const unsigned int mask)
-+{ return ltq_sysctl_is_clocked(SYSCTL_SYS1, mask); }
- 
--static inline void sys_eth_hw_activate(u32 mask)
-+static inline void ltq_sysctl_sys_eth_activate(unsigned int mask)
- { ltq_sysctl_activate(SYSCTL_SYSETH, mask); }
--static inline void sys_eth_hw_deactivate(u32 mask)
-+static inline void ltq_sysctl_sys_eth_deactivate(unsigned int mask)
- { ltq_sysctl_deactivate(SYSCTL_SYSETH, mask); }
--static inline void sys_eth_hw_clk_enable(u32 mask)
-+static inline void ltq_sysctl_sys_eth_clk_enable(unsigned int mask)
- { ltq_sysctl_clken(SYSCTL_SYSETH, mask); }
--static inline void sys_eth_hw_clk_disable(u32 mask)
-+static inline void ltq_sysctl_sys_eth_clk_disable(unsigned int mask)
- { ltq_sysctl_clkdis(SYSCTL_SYSETH, mask); }
--static inline void sys_eth_hw_activate_or_reboot(u32 mask)
-+static inline void ltq_sysctl_sys_eth_reboot(unsigned int mask)
- { ltq_sysctl_reboot(SYSCTL_SYSETH, mask); }
-+static inline
-+unsigned int ltq_sysctl_sys_eth_is_activated(const unsigned int mask)
-+{ return ltq_sysctl_is_activated(SYSCTL_SYSETH, mask); }
-+static inline
-+unsigned int ltq_sysctl_sys_eth_is_clocked(const unsigned int mask)
-+{ return ltq_sysctl_is_clocked(SYSCTL_SYSETH, mask); }
- 
--static inline void sys_gpe_hw_activate(u32 mask)
-+static inline void ltq_sysctl_sys_gpe_activate(unsigned int mask)
- { ltq_sysctl_activate(SYSCTL_SYSGPE, mask); }
--static inline void sys_gpe_hw_deactivate(u32 mask)
-+static inline void ltq_sysctl_sys_gpe_deactivate(unsigned int mask)
- { ltq_sysctl_deactivate(SYSCTL_SYSGPE, mask); }
--static inline void sys_gpe_hw_clk_enable(u32 mask)
-+static inline void ltq_sysctl_sys_gpe_clk_enable(unsigned int mask)
- { ltq_sysctl_clken(SYSCTL_SYSGPE, mask); }
--static inline void sys_gpe_hw_clk_disable(u32 mask)
-+static inline void ltq_sysctl_sys_gpe_clk_disable(unsigned int mask)
- { ltq_sysctl_clkdis(SYSCTL_SYSGPE, mask); }
--static inline void sys_gpe_hw_activate_or_reboot(u32 mask)
-+static inline void ltq_sysctl_sys_gpe_reboot(unsigned int mask)
- { ltq_sysctl_reboot(SYSCTL_SYSGPE, mask); }
--static inline int sys_gpe_hw_is_activated(u32 mask)
--{ return 1; }
-+static inline
-+unsigned int ltq_sysctl_sys_gpe_is_activated(const unsigned int mask)
-+{ return ltq_sysctl_is_activated(SYSCTL_SYSGPE, mask); }
-+static inline
-+unsigned int ltq_sysctl_sys_gpe_is_clocked(const unsigned int mask)
-+{ return ltq_sysctl_is_clocked(SYSCTL_SYSGPE, mask); }
-+
-+unsigned int ltq_sysctl_sys_gpe_hw_is_activated(unsigned int mask);
-+
-+void ltq_sysctl_dgasp_cfg_set(const unsigned int enable,
-+			      const unsigned int hyst);
-+
-+void ltq_sysctl_dgasp_cfg_get(unsigned int *enable, unsigned int *hyst);
-+
-+void ltq_sysctl_clko_enable(const unsigned int enable);
-+
-+void ltq_sysctl_ldo1v5_cfg_set(const unsigned int enable,
-+			       const unsigned int control);
-+
-+void ltq_sysctl_ldo1v5_cfg_get(unsigned int *enable,
-+			       unsigned int *control);
-+
-+int ltq_sysctl_fuse_get(const unsigned int fuse, unsigned int *val);
-+
-+void ltq_sysctl_chipid_get(unsigned int *chipid);
-+
-+void ltq_sysctl_ephy_clko_set(const unsigned int enable,
-+			      const unsigned int clk);
-+
-+int ltq_sysctl_drc_set(const unsigned int interface, const unsigned int drc);
-+
-+int ltq_sysctl_mac_mux_set(const unsigned int mac, const unsigned int mux);
-+
-+int ltq_sysctl_mac_mux_get(const unsigned int mac, unsigned int *mux);
-+
-+int ltq_sysctl_mac_drs_get(const unsigned int mac, unsigned int *drs);
- 
- #endif /* __FALCON_SYSCTRL_H */
-diff --git a/arch/mips/lantiq/falcon/sysctrl.c b/arch/mips/lantiq/falcon/sysctrl.c
---- a/arch/mips/lantiq/falcon/sysctrl.c
-+++ b/arch/mips/lantiq/falcon/sysctrl.c
-@@ -11,16 +11,43 @@
- #include <linux/export.h>
- #include <linux/clkdev.h>
- #include <linux/of_address.h>
-+#include <linux/spinlock.h>
-+#include <falcon/sysctrl.h>
- #include <asm/delay.h>
- 
- #include <lantiq_soc.h>
- 
- #include "../clk.h"
- 
-+
-+/* CPU0 Clock Control Register */
-+#define SYS1_CPU0CC		0x0040
-+/* CLKO Pad Control Register */
-+#define SYS1_CLKOC		0x00b8
- /* infrastructure control register */
- #define SYS1_INFRAC		0x00bc
-+/* HRST_OUT_N Control Register */
-+#define SYS1_HRSTOUTC		0x00c0
-+
-+/* Chip Identification Register */
-+#define STATUS_CHIPID		0x000C
-+/* SPARE fuse register 0 */
-+#define STATUS_FUSE0		0x0038
-+/* Fuses for Analog modules */
-+#define STATUS_ANALOG		0x003C
- /* Configuration fuses for drivers and pll */
- #define STATUS_CONFIG		0x0040
-+/* SPARE fuse register 1 */
-+#define STATUS_FUSE1		0x0044
-+
-+/* External PHY Control Register */
-+#define SYS_ETH_EXTPHYC		0x00B0
-+/* Datarate Control Register */
-+#define SYS_ETH_DRC		0x00B8
-+/* GMAC Multiplexer Control Register */
-+#define SYS_ETH_GMUXC		0x00BC
-+/* Datarate Status Register */
-+#define SYS_ETH_DRS		0x00C0
- 
- /* GPE frequency selection */
- #define GPPC_OFFSET		24
-@@ -40,28 +67,39 @@
- #define SYSCTL_DEACT		0x0028
- /* reboot Register */
- #define SYSCTL_RBT		0x002c
--/* CPU0 Clock Control Register */
--#define SYS1_CPU0CC		0x0040
--/* HRST_OUT_N Control Register */
--#define SYS1_HRSTOUTC		0x00c0
-+
- /* clock divider bit */
- #define CPU0CC_CPUDIV		0x0001
- 
--/* Activation Status Register */
--#define ACTS_ASC0_ACT	0x00001000
--#define ACTS_ASC1_ACT	0x00000800
--#define ACTS_I2C_ACT	0x00004000
--#define ACTS_P0		0x00010000
--#define ACTS_P1		0x00010000
--#define ACTS_P2		0x00020000
--#define ACTS_P3		0x00020000
--#define ACTS_P4		0x00040000
--#define ACTS_PADCTRL0	0x00100000
--#define ACTS_PADCTRL1	0x00100000
--#define ACTS_PADCTRL2	0x00200000
--#define ACTS_PADCTRL3	0x00200000
--#define ACTS_PADCTRL4	0x00400000
--#define ACTS_SSC0	0x00002000
-+/* CLKO Pad Control Register */
-+#define CLKOC_OEN 		0x00000001
-+
-+/* Infrastructure Control Register */
-+#define INFRAC_DGASPEN 		0x00000040
-+#define INFRAC_DGASPHYS_MASK 	0x00000030
-+#define INFRAC_DGASPHYS_OFFSET 	4
-+#define INFRAC_LIN1V5C_MASK 	0x00000007
-+#define INFRAC_LIN1V5EN 	0x00000008
-+
-+/* External PHY Control Register */
-+#define EXTPHYC_CLKEN 		0x80000000
-+
-+/* Data Rate Control Register */
-+#define DRC_xMII0_MASK 	 	0x00700000
-+#define DRC_xMII0_OFFSET 	20
-+#define DRC_xMII1_MASK		0x07000000
-+#define DRC_xMII1_OFFSET 	24
-+#define DRC_SGMII_MASK 		0x00070000
-+#define DRC_SGMII_OFFSET	16
-+
-+/* GMAC Multiplexer Control Register */
-+#define GMUXC_GMAC0_MASK 	0x00000007
-+
-+/* GMAC Data Rate Status register */
-+#define DRS_GMAC1_OFFSET 	4
-+
-+#define GMAC_MASK(mac)		(GMUXC_GMAC0_MASK << (4 * (mac)))
-+#define GMAC_OFFSET(mac)	(DRS_GMAC1_OFFSET * (mac))
- 
- #define sysctl_w32(m,val,reg)	ltq_w32((val), sysctl_membase[m] + (reg))
- #define sysctl_r32(m,reg)	ltq_r32(sysctl_membase[m] + (reg))
-@@ -83,6 +121,8 @@ static void __iomem *sysctl_membase[ARRA
- void __iomem *ltq_sys1_membase, *ltq_ebu_membase;
- 
- 
-+static DEFINE_SPINLOCK(sysctrl_lock);
-+
- void falcon_trigger_hrst(int level)
- {
- 	sysctl_w32(SYSCTL_SYS1, level & 1, SYS1_HRSTOUTC);
-@@ -146,7 +186,7 @@ static void sysctl_reboot(struct clk *cl
- 	sysctl_wait(clk, clk->bits, SYSCTL_ACTS);
- }
- 
--/* enable the ONU core */
-+/* enable the ONU core (without locking, as only called once during init) */
- static void falcon_gpe_enable(void)
- {
- 	unsigned int freq;
-@@ -233,20 +273,20 @@ void __init ltq_soc_init(void)
- 		clkdev_add_static(CLOCK_400M, CLOCK_100M, CLOCK_200M, 0);
- 
- 	/* add our clock domains */
--	clkdev_add_sys("1d810000.gpio", SYSCTL_SYSETH, ACTS_P0);
--	clkdev_add_sys("1d810100.gpio", SYSCTL_SYSETH, ACTS_P2);
--	clkdev_add_sys("1e800100.gpio", SYSCTL_SYS1, ACTS_P1);
--	clkdev_add_sys("1e800200.gpio", SYSCTL_SYS1, ACTS_P3);
--	clkdev_add_sys("1e800300.gpio", SYSCTL_SYS1, ACTS_P4);
--	clkdev_add_sys("1db01000.pad", SYSCTL_SYSETH, ACTS_PADCTRL0);
--	clkdev_add_sys("1db02000.pad", SYSCTL_SYSETH, ACTS_PADCTRL2);
--	clkdev_add_sys("1e800400.pad", SYSCTL_SYS1, ACTS_PADCTRL1);
--	clkdev_add_sys("1e800500.pad", SYSCTL_SYS1, ACTS_PADCTRL3);
--	clkdev_add_sys("1e800600.pad", SYSCTL_SYS1, ACTS_PADCTRL4);
--	clkdev_add_sys("1e100b00.serial", SYSCTL_SYS1, ACTS_ASC1_ACT);
--	clkdev_add_sys("1e100c00.serial", SYSCTL_SYS1, ACTS_ASC0_ACT);
--	clkdev_add_sys("1e200000.i2c", SYSCTL_SYS1, ACTS_I2C_ACT);
--	clkdev_add_sys("1e100d00.spi", SYSCTL_SYS1, ACTS_SSC0);
-+	clkdev_add_sys("1d810000.gpio", SYSCTL_SYSETH, SYSCTRL_SYS_ETH_P0);
-+	clkdev_add_sys("1d810100.gpio", SYSCTL_SYSETH, SYSCTRL_SYS_ETH_P2);
-+	clkdev_add_sys("1e800100.gpio", SYSCTL_SYS1, SYSCTRL_SYS1_P1);
-+	clkdev_add_sys("1e800200.gpio", SYSCTL_SYS1, SYSCTRL_SYS1_P3);
-+	clkdev_add_sys("1e800300.gpio", SYSCTL_SYS1, SYSCTRL_SYS1_P4);
-+	clkdev_add_sys("1db01000.pad", SYSCTL_SYSETH, SYSCTRL_SYS_ETH_PADCTRL0);
-+	clkdev_add_sys("1db02000.pad", SYSCTL_SYSETH, SYSCTRL_SYS_ETH_PADCTRL2);
-+	clkdev_add_sys("1e800400.pad", SYSCTL_SYS1, SYSCTRL_SYS1_PADCTRL1);
-+	clkdev_add_sys("1e800500.pad", SYSCTL_SYS1, SYSCTRL_SYS1_PADCTRL3);
-+	clkdev_add_sys("1e800600.pad", SYSCTL_SYS1, SYSCTRL_SYS1_PADCTRL4);
-+	clkdev_add_sys("1e100b00.serial", SYSCTL_SYS1, SYSCTRL_SYS1_ASC1);
-+	clkdev_add_sys("1e100c00.serial", SYSCTL_SYS1, SYSCTRL_SYS1_ASC0);
-+	clkdev_add_sys("1e200000.i2c", SYSCTL_SYS1, SYSCTRL_SYS1_I2C);
-+	clkdev_add_sys("1e100d00.spi", SYSCTL_SYS1, SYSCTRL_SYS1_SSC0);
- }
- 
- 
-@@ -255,6 +295,15 @@ void __init ltq_soc_init(void)
-  * see arch/mips/include/asm/mach-lantiq/falcon/sysctrl.h
-  */
- 
-+unsigned int ltq_sysctl_sys_gpe_hw_is_activated(unsigned int mask)
-+{
-+	if (!ltq_sysctl_sys_gpe_is_clocked(mask))
-+		return 0;
-+
-+	return ltq_sysctl_sys_gpe_is_activated(mask);
-+}
-+EXPORT_SYMBOL(ltq_sysctl_sys_gpe_hw_is_activated);
-+
- void ltq_sysctl_activate(int module, unsigned int mask)
- {
- 	struct clk clk = { .module = module, .bits = mask };
-@@ -269,6 +318,30 @@ void ltq_sysctl_deactivate(int module, u
- }
- EXPORT_SYMBOL(ltq_sysctl_deactivate);
- 
-+unsigned int ltq_sysctl_is_activated(const int module, const unsigned int mask)
-+{
-+	switch(module) {
-+	case SYSCTL_SYS1:
-+	case SYSCTL_SYSETH:
-+	case SYSCTL_SYSGPE:
-+		return (sysctl_r32(module, SYSCTL_ACTS) & mask) == mask ? 1 : 0;
-+	}
-+	return 0;
-+}
-+EXPORT_SYMBOL(ltq_sysctl_is_activated);
-+
-+unsigned int ltq_sysctl_is_clocked(const int module, const unsigned int mask)
-+{
-+	switch(module) {
-+	case SYSCTL_SYS1:
-+	case SYSCTL_SYSETH:
-+	case SYSCTL_SYSGPE:
-+		return (sysctl_r32(module, SYSCTL_CLKS) & mask) == mask ? 1 : 0;
-+	}
-+	return 0;
-+}
-+EXPORT_SYMBOL(ltq_sysctl_is_clocked);
-+
- void ltq_sysctl_clken(int module, unsigned int mask)
- {
- 	struct clk clk = { .module = module, .bits = mask };
-@@ -289,3 +362,217 @@ void ltq_sysctl_reboot(int module, unsig
- 	sysctl_reboot(&clk);
- }
- EXPORT_SYMBOL(ltq_sysctl_reboot);
-+
-+void ltq_sysctl_dgasp_cfg_set(const unsigned int enable,
-+			      const unsigned int hyst)
-+{
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&sysctrl_lock, flags);
-+
-+	if (enable)
-+		sysctl_w32_mask(SYSCTL_SYS1,
-+				INFRAC_DGASPEN | INFRAC_DGASPHYS_MASK,
-+				INFRAC_DGASPEN |
-+					((hyst << INFRAC_DGASPHYS_OFFSET) &
-+							INFRAC_DGASPHYS_MASK),
-+				SYS1_INFRAC);
-+	else
-+		sysctl_w32_mask(SYSCTL_SYS1, INFRAC_DGASPEN, 0, SYS1_INFRAC);
-+
-+	spin_unlock_irqrestore(&sysctrl_lock, flags);
-+}
-+EXPORT_SYMBOL(ltq_sysctl_dgasp_cfg_set);
-+
-+void ltq_sysctl_dgasp_cfg_get(unsigned int *enable, unsigned int *hyst)
-+{
-+	unsigned int infrac;
-+
-+	infrac = sysctl_r32(SYSCTL_SYS1, SYS1_INFRAC);
-+
-+	if (enable)
-+		*enable = infrac & INFRAC_DGASPEN ? 1 : 0;
-+
-+	if (hyst)
-+		*hyst   = (infrac & INFRAC_DGASPHYS_MASK) >>
-+							INFRAC_DGASPHYS_OFFSET;
-+}
-+EXPORT_SYMBOL(ltq_sysctl_dgasp_cfg_get);
-+
-+void ltq_sysctl_clko_enable(const unsigned int enable)
-+{
-+	sysctl_w32_mask(SYSCTL_SYS1,
-+			CLKOC_OEN,
-+			enable ? CLKOC_OEN : 0,
-+			SYS1_CLKOC);
-+}
-+EXPORT_SYMBOL(ltq_sysctl_clko_enable);
-+
-+void ltq_sysctl_ldo1v5_cfg_set(const unsigned int enable,
-+			       const unsigned int control)
-+{
-+	unsigned long flags;
-+
-+	spin_lock_irqsave(&sysctrl_lock, flags);
-+
-+	if (enable)
-+		sysctl_w32_mask(SYSCTL_SYS1,
-+				INFRAC_LIN1V5C_MASK,
-+				control & INFRAC_LIN1V5C_MASK,
-+				SYS1_INFRAC);
-+
-+	sysctl_w32_mask(SYSCTL_SYS1,
-+			INFRAC_LIN1V5EN,
-+			enable ? INFRAC_LIN1V5EN : 0,
-+			SYS1_INFRAC);
-+
-+	spin_unlock_irqrestore(&sysctrl_lock, flags);
-+}
-+EXPORT_SYMBOL(ltq_sysctl_ldo1v5_cfg_set);
-+
-+void ltq_sysctl_ldo1v5_cfg_get(unsigned int *enable,
-+			       unsigned int *control)
-+{
-+	unsigned int infrac;
-+
-+	infrac = sysctl_r32(SYSCTL_SYS1, SYS1_INFRAC);
-+
-+	if (enable)
-+		*enable  = infrac & INFRAC_LIN1V5EN ? 1 : 0;
-+
-+	if (control)
-+		*control = infrac & INFRAC_LIN1V5C_MASK;
-+}
-+EXPORT_SYMBOL(ltq_sysctl_ldo1v5_cfg_get);
-+
-+int ltq_sysctl_fuse_get(const unsigned int fuse, unsigned int *val)
-+{
-+	switch (fuse) {
-+	case SYSCTRL_FUSE_0:
-+		*val = status_r32(STATUS_FUSE0);
-+		break;
-+	case SYSCTRL_FUSE_1:
-+		*val = status_r32(STATUS_FUSE1);
-+		break;
-+	case SYSCTRL_FUSE_ANALOG:
-+		*val = status_r32(STATUS_ANALOG);
-+		break;
-+	case SYSCTRL_FUSE_CONFIG:
-+		*val = status_r32(STATUS_CONFIG);
-+		break;
-+	default:
-+		return -1;
-+	}
-+	return 0;
-+}
-+EXPORT_SYMBOL(ltq_sysctl_fuse_get);
-+
-+void ltq_sysctl_chipid_get(unsigned int *chipid)
-+{
-+	if (chipid)
-+		*chipid = status_r32(STATUS_CHIPID);
-+}
-+EXPORT_SYMBOL(ltq_sysctl_chipid_get);
-+
-+void ltq_sysctl_ephy_clko_set(const unsigned int enable, const unsigned int clk)
-+{
-+	unsigned int val = clk & 0x7;
-+
-+	if (enable)
-+		val |= EXTPHYC_CLKEN;
-+
-+	sysctl_w32(SYSCTL_SYSETH, val, SYS_ETH_EXTPHYC);
-+}
-+EXPORT_SYMBOL(ltq_sysctl_ephy_clko_set);
-+
-+int ltq_sysctl_drc_set(const unsigned int interface, const unsigned int drc)
-+{
-+	unsigned int mask, reg;
-+	unsigned long flags;
-+
-+	switch (drc) {
-+	default:
-+		return -1;
-+	case SYSCTRL_DRC_2500:
-+		if (interface != SYSCTRL_INTERFACE_SGMII)
-+			return -1;
-+		break;
-+	case SYSCTRL_DRC_200:
-+		if (interface == SYSCTRL_INTERFACE_SGMII)
-+			return -1;
-+		break;
-+	case SYSCTRL_DRC_10:
-+	case SYSCTRL_DRC_100:
-+	case SYSCTRL_DRC_1000:
-+		break;
-+	}
-+
-+	switch (interface) {
-+	case SYSCTRL_INTERFACE_XMII0:
-+		mask = DRC_xMII0_MASK;
-+		reg  = drc << DRC_xMII0_OFFSET;
-+		break;
-+	case SYSCTRL_INTERFACE_XMII1:
-+		mask = DRC_xMII1_MASK;
-+		reg  = drc << DRC_xMII1_OFFSET;
-+		break;
-+	case SYSCTRL_INTERFACE_SGMII:
-+		mask = DRC_SGMII_MASK;
-+		reg  = drc << DRC_SGMII_OFFSET;
-+		break;
-+	default:
-+		return -1;
-+	}
-+
-+	spin_lock_irqsave(&sysctrl_lock, flags);
-+	sysctl_w32_mask(SYSCTL_SYSETH, mask, reg & mask, SYS_ETH_DRC);
-+	spin_unlock_irqrestore(&sysctrl_lock, flags);
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL(ltq_sysctl_drc_set);
-+
-+int ltq_sysctl_mac_mux_set(const unsigned int mac, const unsigned int mux)
-+{
-+	unsigned int mask;
-+	unsigned long flags;
-+
-+	if (mac > 3)
-+		return -1;
-+
-+	mask = GMAC_MASK(mac);
-+
-+	spin_lock_irqsave(&sysctrl_lock, flags);
-+	sysctl_w32_mask(SYSCTL_SYSETH,
-+			mask,
-+			(mux << GMAC_OFFSET(mac)) & mask,
-+			SYS_ETH_GMUXC);
-+	spin_unlock_irqrestore(&sysctrl_lock, flags);
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL(ltq_sysctl_mac_mux_set);
-+
-+int ltq_sysctl_mac_mux_get(const unsigned int mac, unsigned int *mux)
-+{
-+	if (mac > 3 || !mux)
-+		return -1;
-+
-+	*mux = (sysctl_r32(SYSCTL_SYSETH, SYS_ETH_GMUXC) & GMAC_MASK(mac)) >>
-+							       GMAC_OFFSET(mac);
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL(ltq_sysctl_mac_mux_get);
-+
-+int ltq_sysctl_mac_drs_get(const unsigned int mac, unsigned int *drs)
-+{
-+	if (mac > 3 || !drs)
-+		return -1;
-+
-+	*drs = (sysctl_r32(SYSCTL_SYSETH, SYS_ETH_DRS) & GMAC_MASK(mac)) >>
-+							       GMAC_OFFSET(mac);
-+
-+	return 0;
-+}
-+EXPORT_SYMBOL(ltq_sysctl_mac_drs_get);
diff --git a/target/linux/lantiq/patches-3.18/2080-gen-nand-of.patch b/target/linux/lantiq/patches-3.18/2080-gen-nand-of.patch
deleted file mode 100644
index 1b909e6a5d..0000000000
--- a/target/linux/lantiq/patches-3.18/2080-gen-nand-of.patch
+++ /dev/null
@@ -1,52 +0,0 @@
-check the dts file for mtd name, the auto generated name may not be compatible with uboot settings
-check the dts file for presence of bbt-use-flash variable, use bad block table in the flash (by default OOB is used)
-http://lists.infradead.org/pipermail/linux-mtd/2013-March/046371.html
-
---- a/drivers/mtd/nand/plat_nand.c
-+++ b/drivers/mtd/nand/plat_nand.c
-@@ -12,6 +12,7 @@
- #include <linux/io.h>
- #include <linux/module.h>
- #include <linux/platform_device.h>
-+#include <linux/of.h>
- #include <linux/slab.h>
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/nand.h>
-@@ -35,6 +36,7 @@ static int plat_nand_probe(struct platfo
- 	struct plat_nand_data *data;
- 	struct resource *res;
- 	const char **part_types;
-+	const char __maybe_unused	*of_mtd_name = NULL;
- 	int err = 0;
- 
- 	if (!pdata) {
-@@ -75,7 +77,20 @@ static int plat_nand_probe(struct platfo
- 	data->chip.priv = &data;
- 	data->mtd.priv = &data->chip;
- 	data->mtd.owner = THIS_MODULE;
--	data->mtd.name = dev_name(&pdev->dev);
-+	if (pdev->dev.of_node) {
-+		int i;
-+		of_property_read_string(pdev->dev.of_node,
-+						"linux,mtd-name", &of_mtd_name);
-+		if (of_mtd_name)
-+			data->mtd.name = of_mtd_name;
-+		else
-+			data->mtd.name = dev_name(&pdev->dev);
-+		if (of_get_property(pdev->dev.of_node, "bbt-use-flash", &i))
-+			data->chip.bbt_options |= NAND_BBT_USE_FLASH;
-+	} else {
-+		data->mtd.name = dev_name(&pdev->dev);
-+		data->chip.bbt_options |= pdata->chip.bbt_options;
-+	}
- 
- 	data->chip.IO_ADDR_R = data->io_base;
- 	data->chip.IO_ADDR_W = data->io_base;
-@@ -87,7 +102,6 @@ static int plat_nand_probe(struct platfo
- 	data->chip.read_byte = pdata->ctrl.read_byte;
- 	data->chip.chip_delay = pdata->chip.chip_delay;
- 	data->chip.options |= pdata->chip.options;
--	data->chip.bbt_options |= pdata->chip.bbt_options;
- 
- 	data->chip.ecc.hwctl = pdata->ctrl.hwcontrol;
- 	data->chip.ecc.layout = pdata->chip.ecclayout;
diff --git a/target/linux/lantiq/patches-3.18/2090-fix-bad-blocks-in-mtd-split.patch b/target/linux/lantiq/patches-3.18/2090-fix-bad-blocks-in-mtd-split.patch
deleted file mode 100644
index 6045131c1f..0000000000
--- a/target/linux/lantiq/patches-3.18/2090-fix-bad-blocks-in-mtd-split.patch
+++ /dev/null
@@ -1,84 +0,0 @@
-skip bad blocks when doing the mtd split
-
-diff --git a/drivers/mtd/mtdpart.c b/drivers/mtd/mtdpart.c
---- a/drivers/mtd/mtdpart.c
-+++ b/drivers/mtd/mtdpart.c
-@@ -759,6 +759,22 @@ mtd_pad_erasesize(struct mtd_info *mtd, 
- 	return len;
- }
- 
-+static unsigned long fix_size_for_bad_blocks(struct mtd_info *mtd,
-+			unsigned long offset, unsigned long size)
-+{
-+	unsigned long offs = 0;
-+
-+	if (mtd->_block_isbad) {
-+		while (offs < size) {
-+			if (mtd->_block_isbad(mtd, offs + offset))
-+				size += mtd->erasesize;
-+			offs += mtd->erasesize;
-+		}
-+	}
-+
-+	return size;
-+}
-+
- static int split_squashfs(struct mtd_info *master, int offset, int *split_offset)
- {
- 	size_t squashfs_len;
-@@ -768,12 +784,26 @@ static int split_squashfs(struct mtd_inf
- 	if (ret)
- 		return ret;
- 
-+	squashfs_len = fix_size_for_bad_blocks(master, offset, squashfs_len);
- 	len = mtd_pad_erasesize(master, offset, squashfs_len);
- 	*split_offset = offset + len;
- 
- 	return 0;
- }
- 
-+static int detect_squashfs_partition(struct mtd_info *master, unsigned long offset)
-+{
-+	unsigned long temp;
-+	size_t len;
-+	int ret;
-+
-+	ret = mtd_read(master, offset, 4, &len, (void *)&temp);
-+	if (ret || len != sizeof(temp))
-+		return 0;
-+
-+	return le32_to_cpu(temp) == SQUASHFS_MAGIC;
-+}
-+
- static void split_rootfs_data(struct mtd_info *master, struct mtd_part *part)
- {
- 	unsigned int split_offset = 0;
-@@ -810,15 +840,26 @@ static void split_uimage(struct mtd_info
- 		__be32 size;
- 	} hdr;
- 	size_t len;
-+	unsigned long offs = 0;
- 
--	if (mtd_read(master, part->offset, sizeof(hdr), &len, (void *) &hdr))
-+	if (master->_block_isbad) {
-+		while (master->_block_isbad(master, part->offset + offs)) {
-+			offs += master->erasesize;
-+		}
-+	}
-+
-+	if (mtd_read(master, part->offset + offs, sizeof(hdr), &len, (void *) &hdr))
- 		return;
- 
- 	if (len != sizeof(hdr) || hdr.magic != cpu_to_be32(UBOOT_MAGIC))
- 		return;
- 
- 	len = be32_to_cpu(hdr.size) + 0x40;
--	if (len + master->erasesize > part->mtd.size)
-+	len = fix_size_for_bad_blocks(master, part->offset, len);
-+	if (!detect_squashfs_partition(master, part->offset + len))
-+		len = mtd_pad_erasesize(master, part->offset, len);
-+
-+	if (len > part->mtd.size)
- 		return;
- 
- 	if (config_enabled(CONFIG_MTD_SPLIT_UIMAGE_FW))
diff --git a/target/linux/lantiq/patches-3.18/2100-spi-falcon-clock-setup-fix.patch b/target/linux/lantiq/patches-3.18/2100-spi-falcon-clock-setup-fix.patch
deleted file mode 100644
index 099f44ee93..0000000000
--- a/target/linux/lantiq/patches-3.18/2100-spi-falcon-clock-setup-fix.patch
+++ /dev/null
@@ -1,56 +0,0 @@
-spi_falcon: when setting up the clock, do not change the EBU clock but use it as input
-
-diff --git a/drivers/spi/spi-falcon.c b/drivers/spi/spi-falcon.c
---- a/drivers/spi/spi-falcon.c
-+++ b/drivers/spi/spi-falcon.c
-@@ -308,33 +308,32 @@ int falcon_sflash_xfer(struct spi_device
- 
- static int falcon_sflash_setup(struct spi_device *spi)
- {
--	unsigned int i;
-+	unsigned int i, ebuclk;
- 	unsigned long flags;
-+	struct device *dev = &spi->dev;
- 
- 	spin_lock_irqsave(&ebu_lock, flags);
- 
--	if (spi->max_speed_hz >= CLOCK_100M) {
--		/* set EBU clock to 100 MHz */
--		ltq_sys1_w32_mask(0, EBUCC_EBUDIV_SELF100, EBUCC);
--		i = 1; /* divider */
--	} else {
--		/* set EBU clock to 50 MHz */
--		ltq_sys1_w32_mask(EBUCC_EBUDIV_SELF100, 0, EBUCC);
-+	if (ltq_sys1_r32(EBUCC) & EBUCC_EBUDIV_SELF100)
-+		ebuclk = CLOCK_100M;
-+	else
-+		ebuclk = CLOCK_50M;
- 
--		/* search for suitable divider */
--		for (i = 1; i < 7; i++) {
--			if (CLOCK_50M / i <= spi->max_speed_hz)
--				break;
--		}
-+	/* search for suitable divider */
-+	for (i = 1; i < 7; i++) {
-+		if (ebuclk / i <= spi->max_speed_hz)
-+			break;
- 	}
-+	dev_dbg(dev, "max_speed is %d Hz, set speed to %d Hz\n", 
-+		spi->max_speed_hz, ebuclk / i);
- 
- 	/* setup period of serial clock */
- 	ltq_ebu_w32_mask(SFTIME_SCKF_POS_MASK
--		     | SFTIME_SCKR_POS_MASK
--		     | SFTIME_SCK_PER_MASK,
--		     (i << SFTIME_SCKR_POS_OFFSET)
--		     | (i << (SFTIME_SCK_PER_OFFSET + 1)),
--		     SFTIME);
-+			| SFTIME_SCKR_POS_MASK
-+			| SFTIME_SCK_PER_MASK,
-+			(i << SFTIME_SCKR_POS_OFFSET)
-+			| (i << (SFTIME_SCK_PER_OFFSET + 1)),
-+			SFTIME);
- 
- 	/*
- 	 * set some bits of unused_wd, to not trigger HOLD/WP
diff --git a/target/linux/lantiq/patches-3.18/2101-spi-falcon-reduce-blocking.patch b/target/linux/lantiq/patches-3.18/2101-spi-falcon-reduce-blocking.patch
deleted file mode 100644
index b306bcd65a..0000000000
--- a/target/linux/lantiq/patches-3.18/2101-spi-falcon-reduce-blocking.patch
+++ /dev/null
@@ -1,166 +0,0 @@
-reduce possible system-blocking by accesses to EBU registers:
-- use a small delay to relax system performance
-- do locking with a hardware semaphore (with no impact, if the MPS module is not active)
-
-diff --git a/drivers/spi/spi-falcon.c b/drivers/spi/spi-falcon.c
---- a/drivers/spi/spi-falcon.c
-+++ b/drivers/spi/spi-falcon.c
-@@ -78,6 +78,8 @@
- #define SFSTAT_CMD_ERR		0x20000000
- /* Access Command Pending */
- #define SFSTAT_CMD_PEND		0x00400000
-+/* Protocol Engine Active */
-+#define SFSTAT_ACTIVE		0x00100000
- /* Frequency set to 100MHz. */
- #define EBUCC_EBUDIV_SELF100	0x00000001
- /* Serial Flash */
-@@ -92,11 +94,44 @@
- #define CLOCK_100M	100000000
- #define CLOCK_50M	50000000
- 
-+#define UDELAY_VAL	1
-+
- struct falcon_sflash {
- 	u32 sfcmd; /* for caching of opcode, direction, ... */
- 	struct spi_master *master;
- };
- 
-+#define MPS_BASE		KSEG1ADDR(0x1D004000)
-+#define VPE0_BINSEM(x)		(0x100+4*(x))
-+#define VPE1_BINSEM(x)		(0x200+4*(x))
-+#define BINSEM_NR		1
-+
-+static inline void binsem_lock(void)
-+{
-+	while (ltq_r32((void*)(MPS_BASE + VPE0_BINSEM(BINSEM_NR))) != 0) ;
-+}
-+static inline void binsem_unlock(void)
-+{
-+	ltq_w32(0, (void*)(MPS_BASE + VPE0_BINSEM(BINSEM_NR)));
-+}
-+
-+static inline int wait_cmd_pending(struct device *dev)
-+{
-+	u32 val;
-+	do {
-+		binsem_lock();
-+		val = ltq_ebu_r32(SFSTAT);
-+		binsem_unlock();
-+		if (val & SFSTAT_CMD_ERR) {
-+			/* reset error status */
-+			dev_err(dev, "SFSTAT: CMD_ERR (%x)\n", val);
-+			ltq_ebu_w32(SFSTAT_CMD_ERR, SFSTAT);
-+			return -EBADE;
-+		}
-+	} while (val & (SFSTAT_CMD_PEND | SFSTAT_ACTIVE));
-+	return 0;
-+}
-+
- int falcon_sflash_xfer(struct spi_device *spi, struct spi_transfer *t,
- 		unsigned long flags)
- {
-@@ -196,8 +231,11 @@ int falcon_sflash_xfer(struct spi_device
- 			priv->sfcmd &= ~(SFCMD_ALEN_MASK | SFCMD_DUMLEN_MASK);
- 			priv->sfcmd |= (alen << SFCMD_ALEN_OFFSET) |
- 					 (dumlen << SFCMD_DUMLEN_OFFSET);
--			if (alen > 0)
-+			if (alen > 0) {
-+				binsem_lock();
- 				ltq_ebu_w32(val, SFADDR);
-+				binsem_unlock();
-+			}
- 
- 			dev_dbg(dev, "wr %02X, alen=%d (addr=%06X) dlen=%d\n",
- 				priv->sfcmd & SFCMD_OPC_MASK,
-@@ -233,14 +271,22 @@ int falcon_sflash_xfer(struct spi_device
- 						~SFCMD_KEEP_CS_KEEP_SELECTED;
- 				}
- 				if ((len == 4) || (bytelen == 0)) {
-+					if (wait_cmd_pending(dev)<0)
-+						return -EBADE;
-+					binsem_lock();
- 					ltq_ebu_w32(val, SFDATA);
- 					ltq_ebu_w32(priv->sfcmd
- 						| (len<<SFCMD_DLEN_OFFSET),
- 						SFCMD);
-+					binsem_unlock();
-+					udelay(UDELAY_VAL);
- 					len = 0;
- 					val = 0;
--					priv->sfcmd &= ~(SFCMD_ALEN_MASK
--							 | SFCMD_DUMLEN_MASK);
-+					if (priv->sfcmd & (SFCMD_ALEN_MASK | SFCMD_DUMLEN_MASK)) {
-+						priv->sfcmd &= ~(SFCMD_ALEN_MASK
-+								| SFCMD_DUMLEN_MASK);
-+						udelay(UDELAY_VAL);
-+					 }
- 				}
- 			} while (bytelen);
- 			state = state_end;
-@@ -258,22 +304,23 @@ int falcon_sflash_xfer(struct spi_device
- 				}
- 				len = (bytelen > 4) ? 4 : bytelen;
- 				bytelen -= len;
-+				if (wait_cmd_pending(dev)<0)
-+					return -EBADE;
-+				binsem_lock();
- 				ltq_ebu_w32(priv->sfcmd
- 					| (len << SFCMD_DLEN_OFFSET), SFCMD);
--				priv->sfcmd &= ~(SFCMD_ALEN_MASK
--						 | SFCMD_DUMLEN_MASK);
--				do {
--					val = ltq_ebu_r32(SFSTAT);
--					if (val & SFSTAT_CMD_ERR) {
--						/* reset error status */
--						dev_err(dev, "SFSTAT: CMD_ERR");
--						dev_err(dev, " (%x)\n", val);
--						ltq_ebu_w32(SFSTAT_CMD_ERR,
--							SFSTAT);
--						return -EBADE;
--					}
--				} while (val & SFSTAT_CMD_PEND);
-+				binsem_unlock();
-+				if (priv->sfcmd & (SFCMD_ALEN_MASK | SFCMD_DUMLEN_MASK)) {
-+					priv->sfcmd &= ~(SFCMD_ALEN_MASK
-+							| SFCMD_DUMLEN_MASK);
-+					udelay(UDELAY_VAL);
-+				 }
-+				udelay(UDELAY_VAL);
-+				if (wait_cmd_pending(dev)<0)
-+					return -EBADE;
-+				binsem_lock();
- 				val = ltq_ebu_r32(SFDATA);
-+				binsem_unlock();
- 				do {
- 					*rxp = (val & 0xFF);
- 					rxp++;
-@@ -287,9 +334,11 @@ int falcon_sflash_xfer(struct spi_device
- 		case state_disable_cs:
- 		{
- 			priv->sfcmd &= ~SFCMD_KEEP_CS_KEEP_SELECTED;
-+			binsem_lock();
- 			ltq_ebu_w32(priv->sfcmd | (0 << SFCMD_DLEN_OFFSET),
- 				SFCMD);
- 			val = ltq_ebu_r32(SFSTAT);
-+			binsem_unlock();
- 			if (val & SFSTAT_CMD_ERR) {
- 				/* reset error status */
- 				dev_err(dev, "SFSTAT: CMD_ERR (%x)\n", val);
-@@ -331,6 +380,8 @@ static int falcon_sflash_setup(struct sp
- 	dev_dbg(dev, "max_speed is %d Hz, set speed to %d Hz\n", 
- 		spi->max_speed_hz, ebuclk / i);
- 
-+	binsem_lock();
-+
- 	/* setup period of serial clock */
- 	ltq_ebu_w32_mask(SFTIME_SCKF_POS_MASK
- 			| SFTIME_SCKR_POS_MASK
-@@ -351,6 +402,8 @@ static int falcon_sflash_setup(struct sp
- 	/* set address wrap around to maximum for 24-bit addresses */
- 	ltq_ebu_w32_mask(SFCON_DEV_SIZE_MASK, SFCON_DEV_SIZE_A23_0, SFCON);
- 
-+	binsem_unlock();
-+
- 	spin_unlock_irqrestore(&ebu_lock, flags);
- 
- 	return 0;
diff --git a/target/linux/lantiq/patches-3.18/2102-spi-falcon-extend-addressing.patch b/target/linux/lantiq/patches-3.18/2102-spi-falcon-extend-addressing.patch
deleted file mode 100644
index b122aff587..0000000000
--- a/target/linux/lantiq/patches-3.18/2102-spi-falcon-extend-addressing.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-spi_falcon: support 4byte addressing modes as used for flashes > 128Mbit
-
-diff --git a/drivers/spi/spi-falcon.c b/drivers/spi/spi-falcon.c
---- a/drivers/spi/spi-falcon.c
-+++ b/drivers/spi/spi-falcon.c
-@@ -3,7 +3,8 @@
-  *  under the terms of the GNU General Public License version 2 as published
-  *  by the Free Software Foundation.
-  *
-- *  Copyright (C) 2012 Thomas Langer <thomas.langer@lantiq.com>
-+ *  Copyright (C) 2012, 2015 Lantiq Beteiligungs-GmbH & Co. KG
-+ *  Thomas Langer <thomas.langer@lantiq.com>
-  */
- 
- #include <linux/module.h>
-@@ -63,6 +64,7 @@
- #define SFTIME_SCKF_POS_MASK	0x0000F000
- /* Device Size */
- #define SFCON_DEV_SIZE_A23_0	0x03000000
-+#define SFCON_DEV_SIZE_A31_0	0x0B000000
- #define SFCON_DEV_SIZE_MASK	0x0F000000
- /* Read Data Position */
- #define SFTIME_RD_POS_MASK	0x000F0000
-@@ -213,14 +215,12 @@ int falcon_sflash_xfer(struct spi_device
- 			alen = 0;
- 			dumlen = 0;
- 			while (bytelen > 0) {
--				if (alen < 3) {
-+				if (alen < 4) {
-+					/* up to 4 bytes can by handled as address */
- 					val = (val << 8) | (*txp++);
- 					alen++;
--				} else if ((dumlen < 15) && (*txp == 0)) {
--					/*
--					 * assume dummy bytes are set to 0
--					 * from upper layer
--					 */
-+				} else if (dumlen < 15) {
-+					/* assume additional bytes are dummy */
- 					dumlen++;
- 					txp++;
- 				} else {
-@@ -399,8 +399,8 @@ static int falcon_sflash_setup(struct sp
- 	ltq_ebu_w32(BUSRCON0_AGEN_SERIAL_FLASH | BUSRCON0_PORTW_8_BIT_MUX,
- 			BUSRCON0);
- 	ltq_ebu_w32(BUSWCON0_AGEN_SERIAL_FLASH, BUSWCON0);
--	/* set address wrap around to maximum for 24-bit addresses */
--	ltq_ebu_w32_mask(SFCON_DEV_SIZE_MASK, SFCON_DEV_SIZE_A23_0, SFCON);
-+	/* set address wrap around to maximum for 32-bit addresses */
-+	ltq_ebu_w32_mask(SFCON_DEV_SIZE_MASK, SFCON_DEV_SIZE_A31_0, SFCON);
- 
- 	binsem_unlock();
- 
diff --git a/target/linux/lantiq/patches-3.18/2110-conntrack-hook.patch b/target/linux/lantiq/patches-3.18/2110-conntrack-hook.patch
deleted file mode 100644
index bb16498bc9..0000000000
--- a/target/linux/lantiq/patches-3.18/2110-conntrack-hook.patch
+++ /dev/null
@@ -1,139 +0,0 @@
-allow registration of multiple conntrack_event callbacks
-currently fixed to 2
-
-diff --git a/include/net/netfilter/nf_conntrack_ecache.h b/include/net/netfilter/nf_conntrack_ecache.h
---- a/include/net/netfilter/nf_conntrack_ecache.h
-+++ b/include/net/netfilter/nf_conntrack_ecache.h
-@@ -80,7 +80,8 @@ nf_conntrack_event_cache(enum ip_conntra
- 	struct net *net = nf_ct_net(ct);
- 	struct nf_conntrack_ecache *e;
- 
--	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb))
-+	if (!rcu_access_pointer(net->ct.nf_conntrack_event_cb[0]) &&
-+		  !rcu_access_pointer(net->ct.nf_conntrack_event_cb[1]))
- 		return;
- 
- 	e = nf_ct_ecache_find(ct);
-@@ -98,12 +99,13 @@ nf_conntrack_eventmask_report(unsigned i
- {
- 	int ret = 0;
- 	struct net *net = nf_ct_net(ct);
--	struct nf_ct_event_notifier *notify;
-+	struct nf_ct_event_notifier *notify[2];
- 	struct nf_conntrack_ecache *e;
- 
- 	rcu_read_lock();
--	notify = rcu_dereference(net->ct.nf_conntrack_event_cb);
--	if (notify == NULL)
-+	notify[0] = rcu_dereference(net->ct.nf_conntrack_event_cb[0]);
-+	notify[1] = rcu_dereference(net->ct.nf_conntrack_event_cb[1]);
-+	if (notify[0] == NULL && notify[1] == NULL)
- 		goto out_unlock;
- 
- 	e = nf_ct_ecache_find(ct);
-@@ -122,7 +124,10 @@ nf_conntrack_eventmask_report(unsigned i
- 		if (!((eventmask | missed) & e->ctmask))
- 			goto out_unlock;
- 
--		ret = notify->fcn(eventmask | missed, &item);
-+		if (notify[0])
-+			ret = notify[0]->fcn(eventmask | missed, &item);
-+		if (notify[1])
-+			notify[1]->fcn(eventmask | missed, &item);
- 		if (unlikely(ret < 0 || missed)) {
- 			spin_lock_bh(&ct->lock);
- 			if (ret < 0) {
-diff --git a/include/net/netns/conntrack.h b/include/net/netns/conntrack.h
---- a/include/net/netns/conntrack.h
-+++ b/include/net/netns/conntrack.h
-@@ -101,7 +101,7 @@ struct netns_ct {
- 	struct hlist_head	*expect_hash;
- 	struct ct_pcpu __percpu *pcpu_lists;
- 	struct ip_conntrack_stat __percpu *stat;
--	struct nf_ct_event_notifier __rcu *nf_conntrack_event_cb;
-+	struct nf_ct_event_notifier __rcu *nf_conntrack_event_cb[2];
- 	struct nf_exp_event_notifier __rcu *nf_expect_event_cb;
- 	struct nf_ip_net	nf_ct_proto;
- #if defined(CONFIG_NF_CONNTRACK_LABELS)
-diff --git a/net/netfilter/nf_conntrack_ecache.c b/net/netfilter/nf_conntrack_ecache.c
---- a/net/netfilter/nf_conntrack_ecache.c
-+++ b/net/netfilter/nf_conntrack_ecache.c
-@@ -119,14 +119,15 @@ void nf_ct_deliver_cached_events(struct 
- {
- 	struct net *net = nf_ct_net(ct);
- 	unsigned long events, missed;
--	struct nf_ct_event_notifier *notify;
-+	struct nf_ct_event_notifier *notify[2];
- 	struct nf_conntrack_ecache *e;
- 	struct nf_ct_event item;
--	int ret;
-+	int ret = 0;
- 
- 	rcu_read_lock();
--	notify = rcu_dereference(net->ct.nf_conntrack_event_cb);
--	if (notify == NULL)
-+	notify[0] = rcu_dereference(net->ct.nf_conntrack_event_cb[0]);
-+	notify[1] = rcu_dereference(net->ct.nf_conntrack_event_cb[1]);
-+	if (notify[0] == NULL && notify[1] == NULL)
- 		goto out_unlock;
- 
- 	e = nf_ct_ecache_find(ct);
-@@ -150,7 +151,11 @@ void nf_ct_deliver_cached_events(struct 
- 	item.portid = 0;
- 	item.report = 0;
- 
--	ret = notify->fcn(events | missed, &item);
-+	if (notify[0])
-+		ret = notify[0]->fcn(events | missed, &item);
-+
-+	if (notify[1])
-+		notify[1]->fcn(events, &item);
- 
- 	if (likely(ret >= 0 && !missed))
- 		goto out_unlock;
-@@ -172,15 +177,20 @@ int nf_conntrack_register_notifier(struc
- {
- 	int ret;
- 	struct nf_ct_event_notifier *notify;
-+	int idx = 0;
- 
- 	mutex_lock(&nf_ct_ecache_mutex);
--	notify = rcu_dereference_protected(net->ct.nf_conntrack_event_cb,
-+	notify = rcu_dereference_protected(net->ct.nf_conntrack_event_cb[idx],
- 					   lockdep_is_held(&nf_ct_ecache_mutex));
- 	if (notify != NULL) {
--		ret = -EBUSY;
--		goto out_unlock;
-+		notify = rcu_dereference_protected(net->ct.nf_conntrack_event_cb[++idx],
-+					   lockdep_is_held(&nf_ct_ecache_mutex));
-+		if (notify != NULL) {
-+			ret = -EBUSY;
-+			goto out_unlock;
-+		}
- 	}
--	rcu_assign_pointer(net->ct.nf_conntrack_event_cb, new);
-+	rcu_assign_pointer(net->ct.nf_conntrack_event_cb[idx], new);
- 	ret = 0;
- 
- out_unlock:
-@@ -195,10 +205,17 @@ void nf_conntrack_unregister_notifier(st
- 	struct nf_ct_event_notifier *notify;
- 
- 	mutex_lock(&nf_ct_ecache_mutex);
--	notify = rcu_dereference_protected(net->ct.nf_conntrack_event_cb,
-+	notify = rcu_dereference_protected(net->ct.nf_conntrack_event_cb[0],
- 					   lockdep_is_held(&nf_ct_ecache_mutex));
--	BUG_ON(notify != new);
--	RCU_INIT_POINTER(net->ct.nf_conntrack_event_cb, NULL);
-+	if (notify == new) {
-+		RCU_INIT_POINTER(net->ct.nf_conntrack_event_cb[0], NULL);
-+	} else {
-+		notify = rcu_dereference_protected(net->ct.nf_conntrack_event_cb[1],
-+						   lockdep_is_held(&nf_ct_ecache_mutex));
-+		if (notify == new) {
-+			RCU_INIT_POINTER(net->ct.nf_conntrack_event_cb[1], NULL);
-+		}
-+	}
- 	mutex_unlock(&nf_ct_ecache_mutex);
- }
- EXPORT_SYMBOL_GPL(nf_conntrack_unregister_notifier);
diff --git a/target/linux/lantiq/patches-3.18/2120-ipv6-ndisc-table-export.patch b/target/linux/lantiq/patches-3.18/2120-ipv6-ndisc-table-export.patch
deleted file mode 100644
index d6642d458a..0000000000
--- a/target/linux/lantiq/patches-3.18/2120-ipv6-ndisc-table-export.patch
+++ /dev/null
@@ -1,13 +0,0 @@
-add EXPORT_SYMBOL for "nd_tbl" to allow neigh_lookup from a module
-
-diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
---- a/net/ipv6/ndisc.c
-+++ b/net/ipv6/ndisc.c
-@@ -142,6 +142,7 @@ struct neigh_table nd_tbl = {
- 	.gc_thresh2 =	 512,
- 	.gc_thresh3 =	1024,
- };
-+EXPORT_SYMBOL(nd_tbl);
- 
- static void ndisc_fill_addr_option(struct sk_buff *skb, int type, void *data)
- {
diff --git a/target/linux/lantiq/patches-3.18/3000-DT-PLATFORM-DRIVER-Fill-the-resources-before-probe-and-defer-if-needed.patch b/target/linux/lantiq/patches-3.18/3000-DT-PLATFORM-DRIVER-Fill-the-resources-before-probe-and-defer-if-needed.patch
deleted file mode 100644
index bc7acde1e8..0000000000
--- a/target/linux/lantiq/patches-3.18/3000-DT-PLATFORM-DRIVER-Fill-the-resources-before-probe-and-defer-if-needed.patch
+++ /dev/null
@@ -1,205 +0,0 @@
-Subject:	[PATCH v2] dt: platform driver: Fill the resources before probe and defer if needed
-(rebased for 3.10.x, Thomas Langer)
-
-From:	devicetree-owner@vger.kernel.org on behalf of Jean-Jacques Hiblot <jjhiblot@traphandler.com>
-Sent:	Freitag, 21. Februar 2014 14:19
-To:	grant.likely@linaro.org; gregkh@linuxfoundation.org; robh+dt@kernel.org
-Cc:	gregory.clement@free-electrons.com; devicetree@vger.kernel.org; linux-kernel@vger.kernel.org; linux-arm-kernel@lists.infradead.org; Jean-Jacques Hiblot
-
-
-The goal of this patch is to allow drivers to be probed even if at the time of
-the DT parsing some of their ressources are not available yet.
-
-In the current situation, the resource of a platform device are filled from the
-DT at the time the device is created (of_device_alloc()). The drawbackof this
-is that a device sitting close to the top of the DT (ahb for example) but
-depending on ressources that are initialized later (IRQ domain dynamically
-created for example)  will fail to probe because the ressources don't exist
-at this time.
-
-This patch fills the resource structure only before the device is probed and
-will defer the probe if the resource are not available yet.
-
-Signed-off-by: Jean-Jacques Hiblot <jjhiblot@traphandler.com>
-Reviewed-by: Gregory CLEMENT <gregory.clement@free-electrons.com>
----
-
-Hi Grant,
-
-I reworked the patch as you proposed. To keep the overhead minimum, nirq and
-nreg are computed only the first time.
-In this implementation, only the missing IRQ ressources are re-tried for. It could
-easily be changed to re-parse all the IRQs though (replace if (!res->flags)
-with if ((!res->flags) || (res->flags & IORESOURCE_IRQ)).
-
-drivers/base/platform.c     |   5 +++
- drivers/of/platform.c       | 100 +++++++++++++++++++++++++++++++++-----------
- include/linux/of_platform.h |  10 +++++
- 3 files changed, 90 insertions(+), 25 deletions(-)
-
-diff --git a/drivers/base/platform.c b/drivers/base/platform.c
---- a/drivers/base/platform.c
-+++ b/drivers/base/platform.c
-@@ -503,6 +503,10 @@ static int platform_drv_probe(struct dev
- 	struct platform_device *dev = to_platform_device(_dev);
- 	int ret;
- 
-+	ret = of_platform_device_prepare(dev);
-+	if (ret)
-+		goto error;
-+
- 	ret = of_clk_set_defaults(_dev->of_node, false);
- 	if (ret < 0)
- 		return ret;
-@@ -519,6 +523,7 @@ static int platform_drv_probe(struct dev
- 		ret = -ENXIO;
- 	}
- 
-+error:
- 	return ret;
- }
- 
-diff --git a/drivers/of/platform.c b/drivers/of/platform.c
---- a/drivers/of/platform.c
-+++ b/drivers/of/platform.c
-@@ -106,37 +106,11 @@ struct platform_device *of_device_alloc(
- 				  struct device *parent)
- {
- 	struct platform_device *dev;
--	int rc, i, num_reg = 0, num_irq;
--	struct resource *res, temp_res;
- 
- 	dev = platform_device_alloc("", -1);
- 	if (!dev)
- 		return NULL;
- 
--	/* count the io and irq resources */
--	while (of_address_to_resource(np, num_reg, &temp_res) == 0)
--		num_reg++;
--	num_irq = of_irq_count(np);
--
--	/* Populate the resource table */
--	if (num_irq || num_reg) {
--		res = kzalloc(sizeof(*res) * (num_irq + num_reg), GFP_KERNEL);
--		if (!res) {
--			platform_device_put(dev);
--			return NULL;
--		}
--
--		dev->num_resources = num_reg + num_irq;
--		dev->resource = res;
--		for (i = 0; i < num_reg; i++, res++) {
--			rc = of_address_to_resource(np, i, res);
--			WARN_ON(rc);
--		}
--		if (of_irq_to_resource_table(np, res, num_irq) != num_irq)
--			pr_debug("not all legacy IRQ resources mapped for %s\n",
--				 np->name);
--	}
--
- 	dev->dev.of_node = of_node_get(np);
- 	dev->dev.parent = parent;
- 
-@@ -249,6 +223,81 @@ err_clear_flag:
- 	return NULL;
- }
- 
-+static int of_reg_count(struct device_node *np)
-+{
-+	int nreg = 0;
-+	struct resource temp_res;
-+
-+	while (of_address_to_resource(np, nreg, &temp_res) == 0)
-+		nreg++;
-+
-+	return nreg;
-+}
-+
-+int of_platform_device_prepare(struct platform_device *dev)
-+{
-+	struct device_node *np;
-+	int i, irq_index;
-+	struct resource *res;
-+
-+	/*
-+	 * This function applies only devices described in the DT.
-+	 * Other platform devices have their ressources already populated.
-+	 */
-+	np = dev->dev.of_node;
-+	if (!np)
-+		return 0;
-+
-+	/* Populate the resource table */
-+	if (!dev->resource) {
-+		int rc, nreg = 0, nirq;
-+		/* count the io and irq resources */
-+		nreg = of_reg_count(np);
-+		nirq = of_irq_count(np);
-+
-+		if (!nirq && !nreg)
-+			return 0;
-+
-+		res = kzalloc(sizeof(*res) * (nirq + nreg), GFP_KERNEL);
-+		if (!res)
-+			return -ENOMEM;
-+
-+		dev->resource = res;
-+		dev->num_resources = nreg + nirq;
-+
-+		for (i = 0; i < nreg; i++, res++) {
-+			rc = of_address_to_resource(np, i, res);
-+			if (WARN_ON(rc)) {
-+				/* THIS IS BAD; don't try to defer probing */
-+				dev->num_resources = 0;
-+				dev->resource = NULL;
-+				kfree(res);
-+				return rc;
-+			}
-+		}
-+
-+		if (!rc && of_irq_to_resource_table(np, res, nirq) != nirq) {
-+			/* IRQ controller is yet available. defer probing */
-+			return -EPROBE_DEFER;
-+		}
-+
-+		return 0;
-+	}
-+
-+	/* See which IRQ resources need to be redone */
-+	irq_index = 0;
-+	for (i = 0, res = dev->resource; i < dev->num_resources; i++, res++) {
-+		if (!res->flags) {
-+			if (!of_irq_to_resource(np, irq_index, res))
-+				return -EPROBE_DEFER;
-+			irq_index++;
-+		} else if (res->flags & IORESOURCE_IRQ)
-+			irq_index++;
-+	}
-+	return 0;
-+}
-+EXPORT_SYMBOL(of_platform_device_prepare);
-+
- /**
-  * of_platform_device_create - Alloc, initialize and register an of_device
-  * @np: pointer to node to create device for
-diff --git a/include/linux/of_platform.h b/include/linux/of_platform.h
---- a/include/linux/of_platform.h
-+++ b/include/linux/of_platform.h
-@@ -53,6 +53,17 @@ struct of_dev_auxdata {
- 
- extern const struct of_device_id of_default_bus_match_table[];
- 
-+/* Populate the resource for a platform device */
-+#ifdef CONFIG_OF
-+int of_platform_device_prepare(struct platform_device *dev);
-+#else
-+static inline int of_platform_device_prepare(
-+	struct platform_device *dev)
-+{
-+	return 0;
-+}
-+#endif
-+
- /* Platform drivers register/unregister */
- extern struct platform_device *of_device_alloc(struct device_node *np,
- 					 const char *bus_id,
diff --git a/target/linux/lantiq/xrx200/config-default b/target/linux/lantiq/xrx200/config-default
deleted file mode 100644
index c18ad1f135..0000000000
--- a/target/linux/lantiq/xrx200/config-default
+++ /dev/null
@@ -1,76 +0,0 @@
-CONFIG_ADM6996_PHY=y
-CONFIG_AR8216_PHY=y
-# CONFIG_ARCH_HAS_SG_CHAIN is not set
-CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
-CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
-CONFIG_CLONE_BACKWARDS=y
-CONFIG_CPU_NEEDS_NO_SMARTMIPS_OR_MICROMIPS=y
-CONFIG_CPU_SUPPORTS_MSA=y
-CONFIG_CRC16=y
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_LZO=y
-CONFIG_FIRMWARE_IN_KERNEL=y
-CONFIG_GPIO_DEVRES=y
-CONFIG_HAS_IOPORT_MAP=y
-# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
-CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
-CONFIG_HAVE_ARCH_TRACEHOOK=y
-# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
-CONFIG_HAVE_BPF_JIT=y
-CONFIG_HAVE_CC_STACKPROTECTOR=y
-CONFIG_HAVE_CONTEXT_TRACKING=y
-CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
-CONFIG_HAVE_DMA_CONTIGUOUS=y
-CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
-CONFIG_HZ_PERIODIC=y
-CONFIG_INPUT=y
-CONFIG_INPUT_EVDEV=y
-CONFIG_INPUT_POLLDEV=y
-CONFIG_IRQCHIP=y
-CONFIG_IRQ_WORK=y
-# CONFIG_ISDN is not set
-CONFIG_LANTIQ_PHY=y
-CONFIG_LANTIQ_XRX200=y
-CONFIG_LEDS_TRIGGER_HEARTBEAT=y
-CONFIG_LIBFDT=y
-CONFIG_LZO_COMPRESS=y
-CONFIG_LZO_DECOMPRESS=y
-CONFIG_MTD_NAND=y
-CONFIG_MTD_NAND_ECC=y
-CONFIG_MTD_NAND_PLATFORM=y
-CONFIG_MTD_NAND_XWAY=y
-# CONFIG_MTD_PHYSMAP_OF is not set
-CONFIG_MTD_UBI=y
-CONFIG_MTD_UBI_BEB_LIMIT=20
-CONFIG_MTD_UBI_BLOCK=y
-# CONFIG_MTD_UBI_FASTMAP is not set
-# CONFIG_MTD_UBI_GLUEBI is not set
-CONFIG_MTD_UBI_WL_THRESHOLD=4096
-CONFIG_NLS=y
-# CONFIG_NO_IOPORT_MAP is not set
-CONFIG_OF_ADDRESS_PCI=y
-CONFIG_PCIE_LANTIQ=y
-# CONFIG_RCU_STALL_COMMON is not set
-CONFIG_RTL8306_PHY=y
-CONFIG_RTL8366S_PHY=y
-CONFIG_RTL8367B_PHY=y
-CONFIG_RTL8367_PHY=y
-CONFIG_SPI=y
-CONFIG_SPI_BITBANG=y
-CONFIG_SPI_GPIO=y
-CONFIG_SPI_MASTER=y
-CONFIG_SPI_XWAY=y
-CONFIG_SYS_SUPPORTS_MIPS16=y
-CONFIG_UBIFS_FS=y
-CONFIG_UBIFS_FS_ADVANCED_COMPR=y
-CONFIG_UBIFS_FS_LZO=y
-# CONFIG_UBIFS_FS_XZ is not set
-CONFIG_UBIFS_FS_ZLIB=y
-CONFIG_USB=y
-CONFIG_USB_COMMON=y
-# CONFIG_USB_EHCI_HCD is not set
-CONFIG_USB_SUPPORT=y
-# CONFIG_USB_UHCI_HCD is not set
-CONFIG_XRX200_PHY_FW=y
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_ZLIB_INFLATE=y
diff --git a/target/linux/lantiq/xrx200/profiles/arv.mk b/target/linux/lantiq/xrx200/profiles/arv.mk
deleted file mode 100644
index 3dc22c00da..0000000000
--- a/target/linux/lantiq/xrx200/profiles/arv.mk
+++ /dev/null
@@ -1,46 +0,0 @@
-define Profile/VG3503J
-  NAME:=BT Openreach - ECI VDSL Modem
-endef
-
-$(eval $(call Profile,VG3503J))
-
-define Profile/VG3503J_V2
-  NAME:=BT Openreach - ECI VDSL Modem v2
-endef
-
-$(eval $(call Profile,VG3503J_V2))
-
-define Profile/VGV7510KW22NOR
-  NAME:=o2 Box 6431 / Arcadyan VGV7510KW22 (NOR)
-  PACKAGES:=kmod-rt2800-pci wpad-mini kmod-usb-dwc2
-endef
-
-$(eval $(call Profile,VGV7510KW22NOR))
-
-define Profile/VGV7510KW22BRN
-  NAME:=o2 Box 6431 / Arcadyan VGV7510KW22 (BRN)
-  PACKAGES:=kmod-rt2800-pci wpad-mini kmod-usb-dwc2
-endef
-
-$(eval $(call Profile,VGV7510KW22BRN))
-
-define Profile/VGV7519NOR
-  NAME:=Experiabox 8 VGV7519
-  PACKAGES:=kmod-rt2800-pci wpad-mini kmod-usb-dwc2
-endef
-
-$(eval $(call Profile,VGV7519NOR))
-
-define Profile/VGV7519BRN
-  NAME:=Experiabox 8 VGV7519 (BRN)
-  PACKAGES:=kmod-rt2800-pci wpad-mini kmod-usb-dwc2
-endef
-
-$(eval $(call Profile,VGV7519BRN))
-
-define Profile/ARV7519RW22
-  NAME:=Livebox Astoria ARV7519RW22
-  PACKAGES:=kmod-usb-dwc2
-endef
-
-$(eval $(call Profile,ARV7519RW22))
diff --git a/target/linux/lantiq/xrx200/profiles/avm.mk b/target/linux/lantiq/xrx200/profiles/avm.mk
deleted file mode 100644
index 89909b92e3..0000000000
--- a/target/linux/lantiq/xrx200/profiles/avm.mk
+++ /dev/null
@@ -1,9 +0,0 @@
-define Profile/FRITZ3370
-  NAME:=Fritz!Box WLan - FRITZ3370
-  PACKAGES:=kmod-ath9k wpad-mini kmod-usb-dwc2
-endef
-
-FRITZ3370_UBIFS_OPTS:="-m 2048 -e 126KiB -c 4096"
-FRITZ3370_UBI_OPTS:="-m 2048 -p 128KiB -s 512"
-
-$(eval $(call Profile,FRITZ3370))
diff --git a/target/linux/lantiq/xrx200/profiles/lantiq.mk b/target/linux/lantiq/xrx200/profiles/lantiq.mk
deleted file mode 100644
index 0ec6be4c05..0000000000
--- a/target/linux/lantiq/xrx200/profiles/lantiq.mk
+++ /dev/null
@@ -1,13 +0,0 @@
-define Profile/EASY80920NOR
-  NAME:=Lantiq VR9 - EASY80920NOR
-  PACKAGES:=kmod-ath9k wpad-mini kmod-usb-dwc2
-endef
-
-$(eval $(call Profile,EASY80920NOR))
-
-define Profile/EASY80920NAND
-  NAME:=Lantiq VR9 - EASY80920NAND
-  PACKAGES:=kmod-ath9k wpad-mini kmod-usb-dwc2
-endef
-
-$(eval $(call Profile,EASY80920NAND))
diff --git a/target/linux/lantiq/xrx200/profiles/tplink.mk b/target/linux/lantiq/xrx200/profiles/tplink.mk
deleted file mode 100644
index 1ee010ce3c..0000000000
--- a/target/linux/lantiq/xrx200/profiles/tplink.mk
+++ /dev/null
@@ -1,6 +0,0 @@
-define Profile/TDW8970
-  NAME:=TP-LINK TD-W8970
-  PACKAGES:=kmod-ath9k wpad-mini kmod-usb-dwc2 kmod-ledtrig-usbdev
-endef
-
-$(eval $(call Profile,TDW8970))
diff --git a/target/linux/lantiq/xrx200/profiles/zyxel.mk b/target/linux/lantiq/xrx200/profiles/zyxel.mk
deleted file mode 100644
index f6995f946b..0000000000
--- a/target/linux/lantiq/xrx200/profiles/zyxel.mk
+++ /dev/null
@@ -1,20 +0,0 @@
-define Profile/P2812HNUF1
-  NAME:=ZyXEL P-2812HNU-F1
-  PACKAGES:=kmod-rt2800-pci wpad-mini kmod-usb-dwc2
-endef
-
-P2812HNUF1_UBIFS_OPTS:="-m 2048 -e 126KiB -c 4096"
-P2812HNUF1_UBI_OPTS:="-m 2048 -p 128KiB -s 512"
-
-$(eval $(call Profile,P2812HNUF1))
-
-define Profile/P2812HNUF3
-  NAME:=ZyXEL P-2812HNU-F3
-  PACKAGES:=kmod-rt2800-pci wpad-mini kmod-usb-dwc2
-endef
-
-P2812HNUF3_UBIFS_OPTS:="-m 2048 -e 126KiB -c 4096"
-P2812HNUF3_UBI_OPTS:="-m 2048 -p 128KiB -s 512"
-
-$(eval $(call Profile,P2812HNUF3))
-
diff --git a/target/linux/lantiq/xrx200/target.mk b/target/linux/lantiq/xrx200/target.mk
deleted file mode 100644
index a2350158ab..0000000000
--- a/target/linux/lantiq/xrx200/target.mk
+++ /dev/null
@@ -1,23 +0,0 @@
-ARCH:=mips
-SUBTARGET:=xrx200
-BOARDNAME:=XRX200
-FEATURES:=squashfs atm mips16 jffs2 nand ubifs
-CPU_TYPE:=34kc
-CPU_SUBTYPE:=dsp
-
-DEFAULT_PACKAGES+=kmod-leds-gpio \
-	kmod-gpio-button-hotplug \
-	ltq-vdsl-vr9-fw-installer \
-	kmod-ltq-vdsl-vr9-mei \
-	kmod-ltq-vdsl-vr9 \
-	kmod-ltq-atm-vr9 \
-	kmod-ltq-ptm-vr9 \
-	kmod-ltq-deu-vr9 \
-	ltq-vdsl-app \
-	ppp-mod-pppoa \
-	swconfig \
-	atm-esi
-
-define Target/Description
-	Lantiq XRX200
-endef
diff --git a/target/linux/lantiq/xway/config-default b/target/linux/lantiq/xway/config-default
deleted file mode 100644
index 7334c97764..0000000000
--- a/target/linux/lantiq/xway/config-default
+++ /dev/null
@@ -1,74 +0,0 @@
-CONFIG_ADM6996_PHY=y
-CONFIG_AR8216_PHY=y
-# CONFIG_ARCH_HAS_SG_CHAIN is not set
-CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
-CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
-CONFIG_CLONE_BACKWARDS=y
-CONFIG_CPU_NEEDS_NO_SMARTMIPS_OR_MICROMIPS=y
-CONFIG_CPU_SUPPORTS_MSA=y
-CONFIG_CRC16=y
-CONFIG_CRYPTO_DEFLATE=y
-CONFIG_CRYPTO_LZO=y
-CONFIG_FIRMWARE_IN_KERNEL=y
-CONFIG_GPIO_DEVRES=y
-CONFIG_HAS_IOPORT_MAP=y
-# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
-CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
-CONFIG_HAVE_ARCH_TRACEHOOK=y
-# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
-CONFIG_HAVE_BPF_JIT=y
-CONFIG_HAVE_CC_STACKPROTECTOR=y
-CONFIG_HAVE_CONTEXT_TRACKING=y
-CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
-CONFIG_HAVE_DMA_CONTIGUOUS=y
-CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
-CONFIG_HZ_PERIODIC=y
-CONFIG_INPUT=y
-CONFIG_INPUT_EVDEV=y
-CONFIG_INPUT_POLLDEV=y
-CONFIG_IRQCHIP=y
-CONFIG_IRQ_WORK=y
-# CONFIG_ISDN is not set
-CONFIG_LEDS_TRIGGER_HEARTBEAT=y
-CONFIG_LIBFDT=y
-CONFIG_LZO_COMPRESS=y
-CONFIG_LZO_DECOMPRESS=y
-CONFIG_MTD_NAND=y
-CONFIG_MTD_NAND_ECC=y
-CONFIG_MTD_NAND_PLATFORM=y
-CONFIG_MTD_NAND_XWAY=y
-# CONFIG_MTD_PHYSMAP_OF is not set
-CONFIG_MTD_SPLIT_UIMAGE_FW=y
-CONFIG_MTD_UBI=y
-CONFIG_MTD_UBI_BEB_LIMIT=20
-CONFIG_MTD_UBI_BLOCK=y
-# CONFIG_MTD_UBI_FASTMAP is not set
-# CONFIG_MTD_UBI_GLUEBI is not set
-CONFIG_MTD_UBI_WL_THRESHOLD=4096
-CONFIG_NLS=y
-# CONFIG_NO_IOPORT_MAP is not set
-CONFIG_OF_ADDRESS_PCI=y
-# CONFIG_RCU_STALL_COMMON is not set
-CONFIG_RTL8306_PHY=y
-CONFIG_RTL8366S_PHY=y
-CONFIG_RTL8367B_PHY=y
-CONFIG_RTL8367_PHY=y
-CONFIG_SPI=y
-CONFIG_SPI_BITBANG=y
-CONFIG_SPI_GPIO=y
-CONFIG_SPI_MASTER=y
-CONFIG_SPI_XWAY=y
-CONFIG_SYS_SUPPORTS_MIPS16=y
-CONFIG_UBIFS_FS=y
-CONFIG_UBIFS_FS_ADVANCED_COMPR=y
-CONFIG_UBIFS_FS_LZO=y
-# CONFIG_UBIFS_FS_XZ is not set
-CONFIG_UBIFS_FS_ZLIB=y
-CONFIG_USB=y
-CONFIG_USB_COMMON=y
-# CONFIG_USB_EHCI_HCD is not set
-CONFIG_USB_SUPPORT=y
-# CONFIG_USB_UHCI_HCD is not set
-# CONFIG_XRX200_PHY_FW is not set
-CONFIG_ZLIB_DEFLATE=y
-CONFIG_ZLIB_INFLATE=y
diff --git a/target/linux/lantiq/xway/profiles/arv.mk b/target/linux/lantiq/xway/profiles/arv.mk
deleted file mode 100644
index 773243717e..0000000000
--- a/target/linux/lantiq/xway/profiles/arv.mk
+++ /dev/null
@@ -1,155 +0,0 @@
-define Profile/ARV4525PW
-  NAME:=Speedport W502V Typ A - ARV4525PW
-  PACKAGES:=kmod-ath5k wpad-mini \
-	kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-	kmod-ltq-adsl-danube-fw-b kmod-ltq-atm-danube \
-	ltq-adsl-app ppp-mod-pppoa
-endef
-
-$(eval $(call Profile,ARV4525PW))
-
-define Profile/ARV7525PW
-  NAME:=Speedport W303V Typ A - ARV7525PW
-  PACKAGES:=kmod-rt2800-pci wpad-mini \
-	kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-	kmod-ltq-adsl-danube-fw-b kmod-ltq-atm-danube \
-	ltq-adsl-app ppp-mod-pppoa
-endef
-
-$(eval $(call Profile,ARV7525PW))
-
-define Profile/ARV4518PWR01
-  NAME:=ARV4518PWR01
-  PACKAGES:=kmod-ltq-hcd-danube kmod-ledtrig-usbdev \
-	kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-	kmod-ltq-adsl-danube-fw-a kmod-ltq-atm-danube \
-	ltq-adsl-app ppp-mod-pppoa \
-  	kmod-ath5k wpad-mini \
-	swconfig
-endef
-
-$(eval $(call Profile,ARV4518PWR01))
-
-define Profile/ARV4518PWR01A
-  NAME:=ARV4518PWR01A
-  PACKAGES:=kmod-ltq-hcd-danube kmod-ledtrig-usbdev \
-        kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-        kmod-ltq-adsl-danube-fw-a kmod-ltq-atm-danube \
-        ltq-adsl-app ppp-mod-pppoa \
-        kmod-ath5k wpad-mini \
-        swconfig
-endef
-
-$(eval $(call Profile,ARV4518PWR01A))
-
-define Profile/ARV4510PW
-  NAME:=Wippies, Elisa - ARV4510PW
-  PACKAGES:=kmod-ledtrig-usbdev kmod-usb2-pci kmod-usb-uhci \
-	kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-	kmod-ltq-adsl-danube-fw-a kmod-ltq-atm-danube \
-	ltq-adsl-app ppp-mod-pppoa \
-	kmod-ltq-tapi kmod-ltq-vmmc \
-	kmod-rt2800-pci kmod-ath5k wpad-mini \
-	swconfig
-endef
-
-$(eval $(call Profile,ARV4510PW))
-
-define Profile/ARV4519PW
-  NAME:=Vodafone, Pirelli - ARV4519PW
-  PACKAGES:=kmod-ltq-hcd-danube kmod-ledtrig-usbdev \
-	kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-	kmod-ltq-adsl-danube-fw-a kmod-ltq-atm-danube \
-	ltq-adsl-app ppp-mod-pppoa \
-	swconfig
-endef
-
-$(eval $(call Profile,ARV4519PW))
-
-define Profile/ARV7510PW22
-  NAME:=Astoria - ARV7510PW22
-  PACKAGES:=kmod-ltq-hcd-danube kmod-ledtrig-usbdev \
-	kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-	kmod-ltq-adsl-danube-fw-a kmod-ltq-atm-danube \
-	ltq-adsl-app ppp-mod-pppoa \
-	kmod-ltq-tapi kmod-ltq-vmmc \
-	kmod-rt2800-pci wpad-mini \
-	kmod-usb-uhci kmod-usb2 kmod-usb2-pci \
-	swconfig
-endef
-
-$(eval $(call Profile,ARV7510PW22))
-
-define Profile/ARV7518PW
-  NAME:=Astoria - ARV7518PW
-  PACKAGES:=kmod-ltq-hcd-danube kmod-ledtrig-usbdev \
-	kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-	kmod-ltq-adsl-danube-fw-a kmod-ltq-atm-danube \
-	ltq-adsl-app ppp-mod-pppoa \
-  	kmod-ath9k wpad-mini \
-	swconfig
-endef
-
-$(eval $(call Profile,ARV7518PW))
-
-define Profile/ARV7519PW
-  NAME:=Astoria - ARV7519PW
-  PACKAGES:=kmod-ltq-hcd-danube kmod-ledtrig-usbdev \
-	kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-	kmod-ltq-adsl-danube-fw-a kmod-ltq-atm-danube \
-	ltq-adsl-app ppp-mod-pppoa \
-  	kmod-rt2800-pci wpad-mini \
-	swconfig
-endef
-
-$(eval $(call Profile,ARV7519PW))
-
-define Profile/ARV4520PW
-  NAME:=Easybox 800, WAV-281 - ARV4520PW
-  PACKAGES:=kmod-ltq-hcd-danube kmod-ledtrig-usbdev \
-	kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-	kmod-ltq-adsl-danube-fw-b kmod-ltq-atm-danube \
-	ltq-adsl-app ppp-mod-pppoa \
-  	kmod-rt61-pci wpad-mini \
-	swconfig
-endef
-
-$(eval $(call Profile,ARV4520PW))
-
-define Profile/ARV452CQW
-  NAME:=Easybox 801 - ARV452CQW
-  PACKAGES:=kmod-ltq-hcd-danube kmod-ledtrig-usbdev \
-  	kmod-ath5k wpad-mini \
-	kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-	kmod-ltq-adsl-danube-fw-b kmod-ltq-atm-danube \
-	ltq-adsl-app ppp-mod-pppoa \
-	swconfig
-endef
-
-$(eval $(call Profile,ARV452CQW))
-
-define Profile/ARV752DPW
-  NAME:=Easybox 802 - ARV752DPW
-  PACKAGES:=kmod-ltq-hcd-danube kmod-ledtrig-usbdev \
-	kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-	kmod-ltq-adsl-danube-fw-b kmod-ltq-atm-danube \
-	ltq-adsl-app ppp-mod-pppoa \
-	kmod-ltq-tapi kmod-ltq-vmmc \
-	kmod-rt2800-pci wpad-mini \
-	swconfig
-endef
-
-$(eval $(call Profile,ARV752DPW))
-
-define Profile/ARV752DPW22
-  NAME:=Easybox 803 - ARV752DPW22
-  PACKAGES:=kmod-usb2-pci kmod-usb-uhci kmod-ltq-hcd-danube kmod-ledtrig-usbdev \
-	kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-	kmod-ltq-adsl-danube-fw-b kmod-ltq-atm-danube \
-	ltq-adsl-app ppp-mod-pppoa \
-	kmod-ltq-tapi kmod-ltq-vmmc \
-	kmod-rt2800-pci wpad-mini \
-	swconfig
-endef
-
-$(eval $(call Profile,ARV752DPW22))
diff --git a/target/linux/lantiq/xway/profiles/audiocodes.mk b/target/linux/lantiq/xway/profiles/audiocodes.mk
deleted file mode 100644
index 006cc50c13..0000000000
--- a/target/linux/lantiq/xway/profiles/audiocodes.mk
+++ /dev/null
@@ -1,9 +0,0 @@
-define Profile/ACMP252
-  NAME:=AudioCodes MediaPack MP-252
-  PACKAGES:=kmod-rt2x00-pci wpad-mini \
-	kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-	kmod-ltq-adsl-danube-fw-a kmod-ltq-ptm-danube \
-	ltq-adsl-app
-endef
-
-$(eval $(call Profile,ACMP252))
diff --git a/target/linux/lantiq/xway/profiles/avm.mk b/target/linux/lantiq/xway/profiles/avm.mk
deleted file mode 100644
index 1ca963b7cb..0000000000
--- a/target/linux/lantiq/xway/profiles/avm.mk
+++ /dev/null
@@ -1,10 +0,0 @@
-define Profile/FRITZ7320
-  NAME:=1&1 HomeServer - FRITZ7320
-  PACKAGES:=kmod-ath9k wpad-mini \
-	kmod-ltq-adsl-ar9-mei kmod-ltq-adsl-ar9 \
-	kmod-ltq-adsl-ar9-fw-b kmod-ltq-atm-ar9 \
-	ltq-adsl-app ppp-mod-pppoa \
-	kmod-ltq-deu-ar9 kmod-ltq-hcd-ar9
-endef
-
-$(eval $(call Profile,FRITZ7320))
diff --git a/target/linux/lantiq/xway/profiles/aztech.mk b/target/linux/lantiq/xway/profiles/aztech.mk
deleted file mode 100644
index 3b9e92dc43..0000000000
--- a/target/linux/lantiq/xway/profiles/aztech.mk
+++ /dev/null
@@ -1,7 +0,0 @@
-define Profile/GR7000
-  NAME:=Aztech GR7000
-  PACKAGES:= \
-	kmod-ltq-deu-ar9 kmod-ltq-hcd-ar9 \
-	swconfig
-endef
-$(eval $(call Profile,GR7000))
diff --git a/target/linux/lantiq/xway/profiles/bt.mk b/target/linux/lantiq/xway/profiles/bt.mk
deleted file mode 100644
index e04a60701e..0000000000
--- a/target/linux/lantiq/xway/profiles/bt.mk
+++ /dev/null
@@ -1,34 +0,0 @@
-define Profile/BTHOMEHUBV2B
-  NAME:=BT Home Hub 2B
-  PACKAGES:=kmod-ltq-hcd-danube kmod-ledtrig-usbdev \
-	kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-	kmod-ltq-adsl-danube-fw-a kmod-ltq-atm-danube \
-	kmod-ltq-deu-danube \
-	ltq-adsl-app ppp-mod-pppoa \
-	kmod-ath9k wpad-mini \
-	swconfig
-endef
-
-
-BTHOMEHUBV2B_UBIFS_OPTS:="-m 512 -e 15872 -c 1959"
-BTHOMEHUBV2B_UBI_OPTS:="-m 512 -p 16KiB -s 256"
-
-
-$(eval $(call Profile,BTHOMEHUBV2B))
-
-define Profile/BTHOMEHUBV3A
-  NAME:=BT Home Hub 3A
-  PACKAGES:=kmod-ltq-hcd-ar9 kmod-ledtrig-usbdev \
-	kmod-ltq-adsl-ar9-mei kmod-ltq-adsl-ar9 \
-	kmod-ltq-adsl-ar9-fw-a kmod-ltq-atm-ar9 \
-	kmod-ltq-deu-ar9 \
-	ltq-adsl-app ppp-mod-pppoa \
-	kmod-ath9k wpad-mini \
-	swconfig
-endef
-
-BTHOMEHUBV3A_UBIFS_OPTS:="-m 512 -e 15872 -c 1959"
-BTHOMEHUBV3A_UBI_OPTS:="-m 512 -p 16KiB -s 256"
-
-
-$(eval $(call Profile,BTHOMEHUBV3A))
diff --git a/target/linux/lantiq/xway/profiles/buffalo.mk b/target/linux/lantiq/xway/profiles/buffalo.mk
deleted file mode 100644
index 3567d5f81a..0000000000
--- a/target/linux/lantiq/xway/profiles/buffalo.mk
+++ /dev/null
@@ -1,23 +0,0 @@
-define Profile/WBMRA
-  NAME:=Buffalo WBMR-HP-G300H (A) - WBMR
-  PACKAGES:=kmod-ltq-hcd-ar9 kmod-ledtrig-usbdev \
-	kmod-ltq-adsl-ar9-mei kmod-ltq-adsl-ar9 \
-	kmod-ltq-adsl-ar9-fw-a kmod-ltq-atm-ar9 \
-	ltq-adsl-app ppp-mod-pppoa \
-	kmod-ath9k wpad hostapd-utils \
-	swconfig
-endef
-
-$(eval $(call Profile,WBMRA))
-
-define Profile/WBMRB
-  NAME:=Buffalo WBMR-HP-G300H (B) - WBMR
-  PACKAGES:=kmod-ltq-hcd-ar9 kmod-ledtrig-usbdev \
-	kmod-ltq-adsl-ar9-mei kmod-ltq-adsl-ar9 \
-	kmod-ltq-adsl-ar9-fw-b kmod-ltq-atm-ar9 \
-	ltq-adsl-app ppp-mod-pppoa \
-	kmod-ath9k wpad hostapd-utils \
-	swconfig
-endef
-
-$(eval $(call Profile,WBMRB))
diff --git a/target/linux/lantiq/xway/profiles/gigaset.mk b/target/linux/lantiq/xway/profiles/gigaset.mk
deleted file mode 100644
index c6259af972..0000000000
--- a/target/linux/lantiq/xway/profiles/gigaset.mk
+++ /dev/null
@@ -1,11 +0,0 @@
-define Profile/GIGASX76X
-  NAME:=Gigaset sx76x
-  PACKAGES:= kmod-ltq-hcd-danube kmod-ledtrig-usbdev \
-        kmod-ltq-adsl-danube-mei kmod-ltq-adsl-danube \
-        kmod-ltq-adsl-danube-fw-b kmod-ltq-atm-danube \
-        ltq-adsl-app ppp-mod-pppoe \
-        kmod-ath5k wpad-mini \
-        swconfig
-endef
-
-$(eval $(call Profile,GIGASX76X))
diff --git a/target/linux/lantiq/xway/profiles/lantiq.mk b/target/linux/lantiq/xway/profiles/lantiq.mk
deleted file mode 100644
index 800a9f6768..0000000000
--- a/target/linux/lantiq/xway/profiles/lantiq.mk
+++ /dev/null
@@ -1,5 +0,0 @@
-define Profile/EASY50712
-  NAME:=Lantiq Danube - EASY50712
-endef
-
-$(eval $(call Profile,EASY50712))
diff --git a/target/linux/lantiq/xway/profiles/netgear.mk b/target/linux/lantiq/xway/profiles/netgear.mk
deleted file mode 100644
index e29f711a64..0000000000
--- a/target/linux/lantiq/xway/profiles/netgear.mk
+++ /dev/null
@@ -1,23 +0,0 @@
-define Profile/DGN3500
-  NAME:=Netgear DGN3500
-  PACKAGES:=kmod-ltq-hcd-ar9 kmod-ledtrig-usbdev \
-	kmod-ath9k wpad-mini \
-	kmod-ltq-adsl-ar9-mei kmod-ltq-adsl-ar9 \
-	kmod-ltq-adsl-ar9-fw-a kmod-ltq-atm-ar9 \
-	ltq-adsl-app ppp-mod-pppoa \
-	kmod-ltq-deu-ar9 swconfig
-endef
-
-$(eval $(call Profile,DGN3500))
-
-define Profile/DGN3500B
-  NAME:=Netgear DGN3500B
-  PACKAGES:=kmod-ltq-hcd-ar9 kmod-ledtrig-usbdev \
-	kmod-ath9k wpad-mini \
-	kmod-ltq-adsl-ar9-mei kmod-ltq-adsl-ar9 \
-	kmod-ltq-adsl-ar9-fw-b kmod-ltq-atm-ar9 \
-	ltq-adsl-app ppp-mod-pppoa \
-	kmod-ltq-deu-ar9 swconfig
-endef
-
-$(eval $(call Profile,DGN3500B))
diff --git a/target/linux/lantiq/xway/profiles/zte.mk b/target/linux/lantiq/xway/profiles/zte.mk
deleted file mode 100644
index d6e70f2329..0000000000
--- a/target/linux/lantiq/xway/profiles/zte.mk
+++ /dev/null
@@ -1,12 +0,0 @@
-define Profile/H201L
-  NAME:=ZTE H201L - H201L
-  PACKAGES:=kmod-ath9k-htc wpad-mini \
-	kmod-ltq-adsl-ar9-mei kmod-ltq-adsl-ar9 \
-	kmod-ltq-adsl-ar9-fw-b kmod-ltq-atm-ar9 \
-	ltq-adsl-app ppp-mod-pppoe \
-	kmod-ltq-deu-ar9 kmod-ltq-hcd-ar9 \
-	kmod-ltq-tapi kmod-ltq-vmmc \
-	swconfig
-endef
-
-$(eval $(call Profile,H201L))
diff --git a/target/linux/lantiq/xway/profiles/zyxel.mk b/target/linux/lantiq/xway/profiles/zyxel.mk
deleted file mode 100644
index b2c6ef5bb1..0000000000
--- a/target/linux/lantiq/xway/profiles/zyxel.mk
+++ /dev/null
@@ -1,10 +0,0 @@
-define Profile/P2601HNFX
-  NAME:=ZyXEL P-2601HN-Fx
-  PACKAGES:= kmod-rt2800-usb wpad-mini \
-	kmod-ltq-adsl-ar9-mei kmod-ltq-adsl-ar9 \
-	kmod-ltq-adsl-ar9-fw-b kmod-ltq-atm-ar9 \
-	ltq-adsl-app ppp-mod-pppoe \
-	kmod-ltq-deu-ar9 kmod-ltq-hcd-ar9 \
-	swconfig
-endef
-$(eval $(call Profile,P2601HNFX))
diff --git a/target/linux/lantiq/xway/target.mk b/target/linux/lantiq/xway/target.mk
deleted file mode 100644
index 9434cc93e7..0000000000
--- a/target/linux/lantiq/xway/target.mk
+++ /dev/null
@@ -1,12 +0,0 @@
-ARCH:=mips
-SUBTARGET:=xway
-BOARDNAME:=XWAY
-FEATURES:=squashfs atm mips16 nand ubifs ramdisk
-CPU_TYPE:=34kc
-CPU_SUBTYPE:=dsp
-
-DEFAULT_PACKAGES+=kmod-leds-gpio kmod-gpio-button-hotplug atm-esi
-
-define Target/Description
-	Lantiq XWAY
-endef
diff --git a/target/linux/x86/base-files-openwrt b/target/linux/x86/base-files-openwrt
new file mode 120000
index 0000000000..0d5ede810a
--- /dev/null
+++ b/target/linux/x86/base-files-openwrt
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/openwrt/core/ugw/target/linux/x86/base-files-openwrt
\ No newline at end of file
diff --git a/target/linux/x86/base-files-ugw-newframework b/target/linux/x86/base-files-ugw-newframework
new file mode 120000
index 0000000000..88142d42d7
--- /dev/null
+++ b/target/linux/x86/base-files-ugw-newframework
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/openwrt/core/ugw/target/linux/x86/base-files-ugw-newframework
\ No newline at end of file
diff --git a/target/linux/x86/base-files.mk b/target/linux/x86/base-files.mk
new file mode 120000
index 0000000000..e76447e9e9
--- /dev/null
+++ b/target/linux/x86/base-files.mk
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/openwrt/core/ugw/target/linux/x86/base-files.mk
\ No newline at end of file
diff --git a/target/linux/x86/files b/target/linux/x86/files
new file mode 120000
index 0000000000..f4285af733
--- /dev/null
+++ b/target/linux/x86/files
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/openwrt/core/ugw/target/linux/x86/files
\ No newline at end of file
diff --git a/target/linux/x86/image/Config.in b/target/linux/x86/image/Config.in
deleted file mode 100644
index f232c647a5..0000000000
--- a/target/linux/x86/image/Config.in
+++ /dev/null
@@ -1,14 +0,0 @@
-config X86_ETHERBOOT_IMAGES
-	bool "Build Etherboot image"
-	depends on TARGET_x86_thincan_DBE61
-	default y
-	help
-	  Builds network bootable image for ThinCan DBE61 (Etherboot BIOS)
-
-config X86_ETHERBOOT_BOOTOPTS
-	string "Extra kernel boot options"
-	depends on X86_ETHERBOOT_IMAGES
-	default "ip=dhcp nbdport=2000 " if TARGET_ROOTFS_SQUASHFS
-	default "ip=dhcp root=/dev/nfs nfsroot=192.168.0.1:/srv/dbe61"
-	help
-	  Kernel arguments to pass to the kernel eg. NFS root location etc.
diff --git a/target/linux/x86/image/Config.in b/target/linux/x86/image/Config.in
new file mode 120000
index 0000000000..ac05fa32b3
--- /dev/null
+++ b/target/linux/x86/image/Config.in
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/openwrt/core/ugw/target/linux/x86/image/Config.in
\ No newline at end of file
diff --git a/target/linux/x86/patches-3.12 b/target/linux/x86/patches-3.12
new file mode 120000
index 0000000000..62418fb1fe
--- /dev/null
+++ b/target/linux/x86/patches-3.12
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/openwrt/core/ugw/target/linux/x86/patches-3.12
\ No newline at end of file
diff --git a/target/linux/x86/puma b/target/linux/x86/puma
new file mode 120000
index 0000000000..98ca84af47
--- /dev/null
+++ b/target/linux/x86/puma
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/openwrt/core/ugw/target/linux/x86/puma
\ No newline at end of file
diff --git a/target/ugw-sdk b/target/ugw-sdk
new file mode 120000
index 0000000000..930c304090
--- /dev/null
+++ b/target/ugw-sdk
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/openwrt/core/ugw/target/ugw-sdk
\ No newline at end of file
diff --git a/ugw/build/build_support b/ugw/build/build_support
new file mode 120000
index 0000000000..f58b63c92b
--- /dev/null
+++ b/ugw/build/build_support
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/config_cpe/build_support
\ No newline at end of file
diff --git a/ugw/build/buildsystem_patches b/ugw/build/buildsystem_patches
new file mode 120000
index 0000000000..5356ee5675
--- /dev/null
+++ b/ugw/build/buildsystem_patches
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/openwrt/patches
\ No newline at end of file
diff --git a/ugw/config b/ugw/config
new file mode 120000
index 0000000000..3fa3fa5208
--- /dev/null
+++ b/ugw/config
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/config_cpe/ugw_5_x
\ No newline at end of file
diff --git a/ugw/feeds.conf b/ugw/feeds.conf
new file mode 120000
index 0000000000..31c71dbcc0
--- /dev/null
+++ b/ugw/feeds.conf
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/config_cpe/feeds_config/feeds.conf
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/bootloaders/open_uboot b/ugw/feeds_opensrc/bootloaders/open_uboot
new file mode 120000
index 0000000000..ea7664dc12
--- /dev/null
+++ b/ugw/feeds_opensrc/bootloaders/open_uboot
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_uboot/open_uboot/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/ToolBox b/ugw/feeds_opensrc/debug_tools/ToolBox
new file mode 120000
index 0000000000..15962f419d
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/ToolBox
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/ToolBox/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/electric_fence b/ugw/feeds_opensrc/debug_tools/electric_fence
new file mode 120000
index 0000000000..ee384beca7
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/electric_fence
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/electric_fence/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/errorhd b/ugw/feeds_opensrc/debug_tools/errorhd
new file mode 120000
index 0000000000..b1577bffaa
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/errorhd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/errorhd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/gdb b/ugw/feeds_opensrc/debug_tools/gdb
new file mode 120000
index 0000000000..a0d1385a46
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/gdb
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/gdb/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/io b/ugw/feeds_opensrc/debug_tools/io
new file mode 120000
index 0000000000..f10ae3fbcf
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/io
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/io/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/iperf b/ugw/feeds_opensrc/debug_tools/iperf
new file mode 120000
index 0000000000..a2c6085267
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/iperf
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/iperf/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/iperf3 b/ugw/feeds_opensrc/debug_tools/iperf3
new file mode 120000
index 0000000000..ee43179558
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/iperf3
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/iperf3/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/libbfd b/ugw/feeds_opensrc/debug_tools/libbfd
new file mode 120000
index 0000000000..9994bad443
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/libbfd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/libbfd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/nuttcp b/ugw/feeds_opensrc/debug_tools/nuttcp
new file mode 120000
index 0000000000..615904e3ba
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/nuttcp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/nuttcp/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/oprofile b/ugw/feeds_opensrc/debug_tools/oprofile
new file mode 120000
index 0000000000..48fc1b62fd
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/oprofile
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/oprofile/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/pecoevent b/ugw/feeds_opensrc/debug_tools/pecoevent
new file mode 120000
index 0000000000..639bac502d
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/pecoevent
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/pecoevent/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/pecostat b/ugw/feeds_opensrc/debug_tools/pecostat
new file mode 120000
index 0000000000..b43c9c0abc
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/pecostat
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/pecostat/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/pecostat_interaptiv b/ugw/feeds_opensrc/debug_tools/pecostat_interaptiv
new file mode 120000
index 0000000000..c923b160be
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/pecostat_interaptiv
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/pecostat_interaptiv/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/perf b/ugw/feeds_opensrc/debug_tools/perf
new file mode 120000
index 0000000000..977fe6366b
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/perf
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/perf/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/perf-new b/ugw/feeds_opensrc/debug_tools/perf-new
new file mode 120000
index 0000000000..52781045c6
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/perf-new
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/perf-new/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/popt b/ugw/feeds_opensrc/debug_tools/popt
new file mode 120000
index 0000000000..84694710d2
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/popt
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/popt/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/procps b/ugw/feeds_opensrc/debug_tools/procps
new file mode 120000
index 0000000000..d335227295
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/procps
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/procps/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/readchip b/ugw/feeds_opensrc/debug_tools/readchip
new file mode 120000
index 0000000000..531df0a5ef
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/readchip
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/readchip/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/strace b/ugw/feeds_opensrc/debug_tools/strace
new file mode 120000
index 0000000000..6b99ec6a25
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/strace
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/strace/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/sysstat b/ugw/feeds_opensrc/debug_tools/sysstat
new file mode 120000
index 0000000000..241e53f079
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/sysstat
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/sysstat/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/tcpdump b/ugw/feeds_opensrc/debug_tools/tcpdump
new file mode 120000
index 0000000000..b5e1c289a1
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/tcpdump
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/tcpdump/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/debug_tools/valgrind b/ugw/feeds_opensrc/debug_tools/valgrind
new file mode 120000
index 0000000000..ab0208f2fe
--- /dev/null
+++ b/ugw/feeds_opensrc/debug_tools/valgrind
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/valgrind/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/luci b/ugw/feeds_opensrc/luci
new file mode 120000
index 0000000000..6faa5056ec
--- /dev/null
+++ b/ugw/feeds_opensrc/luci
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/openwrt/luci
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/6rd b/ugw/feeds_opensrc/packages/6rd
new file mode 120000
index 0000000000..1c8d22f8a7
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/6rd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/6rd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/acpid b/ugw/feeds_opensrc/packages/acpid
new file mode 120000
index 0000000000..08fd9f9d55
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/acpid
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/acpid/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/avahi b/ugw/feeds_opensrc/packages/avahi
new file mode 120000
index 0000000000..df4336a361
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/avahi
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/avahi/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/bash b/ugw/feeds_opensrc/packages/bash
new file mode 120000
index 0000000000..58cbd3195d
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/bash
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/bash/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/bluez b/ugw/feeds_opensrc/packages/bluez
new file mode 120000
index 0000000000..0a7f117cbe
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/bluez
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/bluez/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/boost b/ugw/feeds_opensrc/packages/boost
new file mode 120000
index 0000000000..41ac6a9eee
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/boost
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/boost/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/br2684ctl b/ugw/feeds_opensrc/packages/br2684ctl
new file mode 120000
index 0000000000..6a47eb8201
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/br2684ctl
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/br2684ctl/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/bridge-utils b/ugw/feeds_opensrc/packages/bridge-utils
new file mode 120000
index 0000000000..52b9796544
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/bridge-utils
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/bridge-utils/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/busybox b/ugw/feeds_opensrc/packages/busybox
new file mode 120000
index 0000000000..9b1a5be818
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/busybox
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/busybox/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/cJSON b/ugw/feeds_opensrc/packages/cJSON
new file mode 120000
index 0000000000..03aefec860
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/cJSON
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/cJSON/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/comgt b/ugw/feeds_opensrc/packages/comgt
new file mode 120000
index 0000000000..5e1a1e3096
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/comgt
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/comgt/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/conntrack-tools b/ugw/feeds_opensrc/packages/conntrack-tools
new file mode 120000
index 0000000000..a268eb2cf6
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/conntrack-tools
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/conntrack-tools/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/crda b/ugw/feeds_opensrc/packages/crda
new file mode 120000
index 0000000000..8276595a14
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/crda
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/crda/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/cryptodev-linux b/ugw/feeds_opensrc/packages/cryptodev-linux
new file mode 120000
index 0000000000..821c659508
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/cryptodev-linux
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/cryptodev-linux/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/db47 b/ugw/feeds_opensrc/packages/db47
new file mode 120000
index 0000000000..49808676aa
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/db47
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/db47/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/dbus b/ugw/feeds_opensrc/packages/dbus
new file mode 120000
index 0000000000..04d59a7557
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/dbus
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/dbus/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/dnrd b/ugw/feeds_opensrc/packages/dnrd
new file mode 120000
index 0000000000..8e49d23887
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/dnrd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/dnrd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/dnsmasq b/ugw/feeds_opensrc/packages/dnsmasq
new file mode 120000
index 0000000000..abd0758744
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/dnsmasq
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/dnsmasq/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/dot1ag-utils b/ugw/feeds_opensrc/packages/dot1ag-utils
new file mode 120000
index 0000000000..2ae1117201
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/dot1ag-utils
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/dot1ag-utils/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/dpdk b/ugw/feeds_opensrc/packages/dpdk
new file mode 120000
index 0000000000..99f58d988e
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/dpdk
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/dpdk/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/dropbear b/ugw/feeds_opensrc/packages/dropbear
new file mode 120000
index 0000000000..58b6682641
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/dropbear
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/dropbear/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/ebtables b/ugw/feeds_opensrc/packages/ebtables
new file mode 120000
index 0000000000..e353f99ef9
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/ebtables
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/ebtables/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/elfutils b/ugw/feeds_opensrc/packages/elfutils
new file mode 120000
index 0000000000..1fb15cf5b6
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/elfutils
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/elfutils/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/ethtool b/ugw/feeds_opensrc/packages/ethtool
new file mode 120000
index 0000000000..213883d95f
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/ethtool
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/ethtool/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/expat b/ugw/feeds_opensrc/packages/expat
new file mode 120000
index 0000000000..85c34a7555
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/expat
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/expat/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/ezipupdate b/ugw/feeds_opensrc/packages/ezipupdate
new file mode 120000
index 0000000000..cb2984d258
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/ezipupdate
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/ezipupdate/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/ezxml b/ugw/feeds_opensrc/packages/ezxml
new file mode 120000
index 0000000000..533471b74d
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/ezxml
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/ezxml/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/fann b/ugw/feeds_opensrc/packages/fann
new file mode 120000
index 0000000000..d84c856b73
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/fann
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/fann/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/fftw3 b/ugw/feeds_opensrc/packages/fftw3
new file mode 120000
index 0000000000..45a52b15d5
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/fftw3
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/fftw3/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/files b/ugw/feeds_opensrc/packages/files
new file mode 120000
index 0000000000..c87a01522d
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/files
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_upnpdm/files/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/gdbm b/ugw/feeds_opensrc/packages/gdbm
new file mode 120000
index 0000000000..201ef22eca
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/gdbm
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/gdbm/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/gearmand b/ugw/feeds_opensrc/packages/gearmand
new file mode 120000
index 0000000000..d20a11772e
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/gearmand
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/gearmand/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/glib2 b/ugw/feeds_opensrc/packages/glib2
new file mode 120000
index 0000000000..4ef60994d4
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/glib2
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/glib2/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/hostapd b/ugw/feeds_opensrc/packages/hostapd
new file mode 120000
index 0000000000..8908303572
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/hostapd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/hostapd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/hostapd_2_3_wave_5_1_1 b/ugw/feeds_opensrc/packages/hostapd_2_3_wave_5_1_1
new file mode 120000
index 0000000000..2487183066
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/hostapd_2_3_wave_5_1_1
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/hostapd_2_3_wave_5_1_1/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/hyperscan b/ugw/feeds_opensrc/packages/hyperscan
new file mode 120000
index 0000000000..fe0247b4f7
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/hyperscan
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/hyperscan/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/intel_wps b/ugw/feeds_opensrc/packages/intel_wps
new file mode 120000
index 0000000000..3e2d242c4f
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/intel_wps
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/intel_wps/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/iproute2 b/ugw/feeds_opensrc/packages/iproute2
new file mode 120000
index 0000000000..b6fa2a6295
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/iproute2
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/iproute2/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/ipsec-tools b/ugw/feeds_opensrc/packages/ipsec-tools
new file mode 120000
index 0000000000..d32e326623
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/ipsec-tools
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/ipsec-tools/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/iptables b/ugw/feeds_opensrc/packages/iptables
new file mode 120000
index 0000000000..b121f8fdda
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/iptables
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/iptables/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/iptables_old b/ugw/feeds_opensrc/packages/iptables_old
new file mode 120000
index 0000000000..b982d96768
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/iptables_old
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/iptables_old/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/irqbalance b/ugw/feeds_opensrc/packages/irqbalance
new file mode 120000
index 0000000000..9ff8ac4306
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/irqbalance
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/irqbalance/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/jvm b/ugw/feeds_opensrc/packages/jvm
new file mode 120000
index 0000000000..8638c185f2
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/jvm
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/jvm/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/klish b/ugw/feeds_opensrc/packages/klish
new file mode 120000
index 0000000000..67dd5d4f75
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/klish
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/klish/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/l2tpv3tun b/ugw/feeds_opensrc/packages/l2tpv3tun
new file mode 120000
index 0000000000..e7f4aead50
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/l2tpv3tun
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/l2tpv3tun/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libcap b/ugw/feeds_opensrc/packages/libcap
new file mode 120000
index 0000000000..7769507252
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libcap
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libcap/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libdaemon b/ugw/feeds_opensrc/packages/libdaemon
new file mode 120000
index 0000000000..15775f062e
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libdaemon
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libdaemon/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libevdev b/ugw/feeds_opensrc/packages/libevdev
new file mode 120000
index 0000000000..56b2ee32c2
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libevdev
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libevdev/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libevent b/ugw/feeds_opensrc/packages/libevent
new file mode 120000
index 0000000000..228c2f3da6
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libevent
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libevent/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libffi b/ugw/feeds_opensrc/packages/libffi
new file mode 120000
index 0000000000..b7ae6ad06d
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libffi
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libffi/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libhanfun b/ugw/feeds_opensrc/packages/libhanfun
new file mode 120000
index 0000000000..7c44984d1a
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libhanfun
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libhanfun/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libical b/ugw/feeds_opensrc/packages/libical
new file mode 120000
index 0000000000..f27d37633e
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libical
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libical/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libmnl b/ugw/feeds_opensrc/packages/libmnl
new file mode 120000
index 0000000000..b6e0faa873
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libmnl
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libmnl/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libnet-1.1.x b/ugw/feeds_opensrc/packages/libnet-1.1.x
new file mode 120000
index 0000000000..2831f72b40
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libnet-1.1.x
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libnet-1.1.x/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libnetfilter_conntrack b/ugw/feeds_opensrc/packages/libnetfilter_conntrack
new file mode 120000
index 0000000000..905a83d384
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libnetfilter_conntrack
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libnetfilter_conntrack/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libnfnetlink b/ugw/feeds_opensrc/packages/libnfnetlink
new file mode 120000
index 0000000000..9c2e4e9ccd
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libnfnetlink
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libnfnetlink/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libnl b/ugw/feeds_opensrc/packages/libnl
new file mode 120000
index 0000000000..6bf4b54111
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libnl
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libnl/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libnl3 b/ugw/feeds_opensrc/packages/libnl3
new file mode 120000
index 0000000000..be1839ed7a
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libnl3
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libnl3/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libol b/ugw/feeds_opensrc/packages/libol
new file mode 120000
index 0000000000..bac1f9ac37
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libol
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libol/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libreadline b/ugw/feeds_opensrc/packages/libreadline
new file mode 120000
index 0000000000..d881a0aeb1
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libreadline
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libreadline/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libreadline6 b/ugw/feeds_opensrc/packages/libreadline6
new file mode 120000
index 0000000000..1fc58ad4f0
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libreadline6
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libreadline6/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libseccomp b/ugw/feeds_opensrc/packages/libseccomp
new file mode 120000
index 0000000000..4c93692038
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libseccomp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libseccomp/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libubox b/ugw/feeds_opensrc/packages/libubox
new file mode 120000
index 0000000000..64774916f6
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libubox
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libubox/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libwebsockets b/ugw/feeds_opensrc/packages/libwebsockets
new file mode 120000
index 0000000000..b25be3bcff
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libwebsockets
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libwebsockets/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libxml2 b/ugw/feeds_opensrc/packages/libxml2
new file mode 120000
index 0000000000..ed66d0d1d7
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libxml2
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libxml2/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/libxslt b/ugw/feeds_opensrc/packages/libxslt
new file mode 120000
index 0000000000..74fe7e8c56
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/libxslt
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/libxslt/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/lighttpd b/ugw/feeds_opensrc/packages/lighttpd
new file mode 120000
index 0000000000..2fc713ba00
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/lighttpd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/lighttpd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/linux-atm b/ugw/feeds_opensrc/packages/linux-atm
new file mode 120000
index 0000000000..feaf34b045
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/linux-atm
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/linux-atm/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/linux-firmware b/ugw/feeds_opensrc/packages/linux-firmware
new file mode 120000
index 0000000000..d1a46e4ae2
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/linux-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/linux-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/linux-ftpd b/ugw/feeds_opensrc/packages/linux-ftpd
new file mode 120000
index 0000000000..d43ca25d1e
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/linux-ftpd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/linux-ftpd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/lmbench b/ugw/feeds_opensrc/packages/lmbench
new file mode 120000
index 0000000000..dd48841fc3
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/lmbench
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/lmbench/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/lsqlite b/ugw/feeds_opensrc/packages/lsqlite
new file mode 120000
index 0000000000..d42057b6a5
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/lsqlite
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/lsqlite/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/ltq-cgroups b/ugw/feeds_opensrc/packages/ltq-cgroups
new file mode 120000
index 0000000000..f1a2425958
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/ltq-cgroups
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/ltq-cgroups/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/lua-cjson b/ugw/feeds_opensrc/packages/lua-cjson
new file mode 120000
index 0000000000..0b380c530d
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/lua-cjson
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/lua-cjson/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/luacurl b/ugw/feeds_opensrc/packages/luacurl
new file mode 120000
index 0000000000..40e93b1fe3
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/luacurl
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/luacurl/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/lxc b/ugw/feeds_opensrc/packages/lxc
new file mode 120000
index 0000000000..ec57672ba8
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/lxc
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/lxc/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/lxml b/ugw/feeds_opensrc/packages/lxml
new file mode 120000
index 0000000000..4cf44b60cd
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/lxml
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/lxml/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/lzo b/ugw/feeds_opensrc/packages/lzo
new file mode 120000
index 0000000000..ab3920811b
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/lzo
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/lzo/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/mac80211 b/ugw/feeds_opensrc/packages/mac80211
new file mode 120000
index 0000000000..15beb103f3
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/mac80211
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/mac80211/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/mini-httpd b/ugw/feeds_opensrc/packages/mini-httpd
new file mode 120000
index 0000000000..98f41714eb
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/mini-httpd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/mini-httpd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/minissdpd b/ugw/feeds_opensrc/packages/minissdpd
new file mode 120000
index 0000000000..2705173d0c
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/minissdpd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/minissdpd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/miniupnpc b/ugw/feeds_opensrc/packages/miniupnpc
new file mode 120000
index 0000000000..8ddd429cfa
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/miniupnpc
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/miniupnpc/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/miniupnpd b/ugw/feeds_opensrc/packages/miniupnpd
new file mode 120000
index 0000000000..3989bf9246
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/miniupnpd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/miniupnpd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/mns_1905 b/ugw/feeds_opensrc/packages/mns_1905
new file mode 120000
index 0000000000..f02fc5383b
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/mns_1905
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/mns_1905/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/mountd b/ugw/feeds_opensrc/packages/mountd
new file mode 120000
index 0000000000..77bb7f0826
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/mountd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/mountd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/mrd6 b/ugw/feeds_opensrc/packages/mrd6
new file mode 120000
index 0000000000..ca98836b2f
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/mrd6
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/mrd6/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/mtd-utils b/ugw/feeds_opensrc/packages/mtd-utils
new file mode 120000
index 0000000000..bf752de7c3
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/mtd-utils
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/mtd-utils/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/multimedia b/ugw/feeds_opensrc/packages/multimedia
new file mode 120000
index 0000000000..289e0591bc
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/multimedia
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/multimedia/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/mwan3 b/ugw/feeds_opensrc/packages/mwan3
new file mode 120000
index 0000000000..ecf739eb0c
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/mwan3
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/mwan3/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/net-snmp b/ugw/feeds_opensrc/packages/net-snmp
new file mode 120000
index 0000000000..2939c7b964
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/net-snmp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/net-snmp/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/netatalk b/ugw/feeds_opensrc/packages/netatalk
new file mode 120000
index 0000000000..f2bc5565c2
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/netatalk
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/netatalk/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/netifd b/ugw/feeds_opensrc/packages/netifd
new file mode 120000
index 0000000000..45607f76d8
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/netifd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/netifd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/netperf b/ugw/feeds_opensrc/packages/netperf
new file mode 120000
index 0000000000..082779aa72
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/netperf
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/netperf/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/nginx b/ugw/feeds_opensrc/packages/nginx
new file mode 120000
index 0000000000..8502754fff
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/nginx
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/nginx/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/ntfs_3g b/ugw/feeds_opensrc/packages/ntfs_3g
new file mode 120000
index 0000000000..09baaea621
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/ntfs_3g
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/ntfs_3g/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/ntpclient b/ugw/feeds_opensrc/packages/ntpclient
new file mode 120000
index 0000000000..aa47a1ec69
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/ntpclient
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/ntpclient/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/odhcp6c b/ugw/feeds_opensrc/packages/odhcp6c
new file mode 120000
index 0000000000..03b2bd4b75
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/odhcp6c
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/odhcp6c/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/odhcpd b/ugw/feeds_opensrc/packages/odhcpd
new file mode 120000
index 0000000000..cb22ea56cc
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/odhcpd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/odhcpd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/opencv b/ugw/feeds_opensrc/packages/opencv
new file mode 120000
index 0000000000..29dda7a71b
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/opencv
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/opencv/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/openssl b/ugw/feeds_opensrc/packages/openssl
new file mode 120000
index 0000000000..ec2444adb7
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/openssl
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/openssl/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/osgi b/ugw/feeds_opensrc/packages/osgi
new file mode 120000
index 0000000000..369d72f390
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/osgi
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/osgi/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/p910nd b/ugw/feeds_opensrc/packages/p910nd
new file mode 120000
index 0000000000..d615bb1f90
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/p910nd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/p910nd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/pciutils b/ugw/feeds_opensrc/packages/pciutils
new file mode 120000
index 0000000000..84f69193fa
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/pciutils
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/pciutils/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/pcre b/ugw/feeds_opensrc/packages/pcre
new file mode 120000
index 0000000000..5f674f9ac7
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/pcre
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/pcre/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/perl b/ugw/feeds_opensrc/packages/perl
new file mode 120000
index 0000000000..878e5619a5
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/perl
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/perl/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/ppp b/ugw/feeds_opensrc/packages/ppp
new file mode 120000
index 0000000000..dc7fa93b13
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/ppp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/ppp/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/procd b/ugw/feeds_opensrc/packages/procd
new file mode 120000
index 0000000000..327486e468
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/procd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/procd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/psmisc b/ugw/feeds_opensrc/packages/psmisc
new file mode 120000
index 0000000000..6909e46e2c
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/psmisc
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/psmisc/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/pyinotify b/ugw/feeds_opensrc/packages/pyinotify
new file mode 120000
index 0000000000..1f070d4707
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/pyinotify
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/pyinotify/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/python b/ugw/feeds_opensrc/packages/python
new file mode 120000
index 0000000000..77a0afd476
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/python
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/python/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/python-gearman b/ugw/feeds_opensrc/packages/python-gearman
new file mode 120000
index 0000000000..15f70a7487
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/python-gearman
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/python-gearman/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/quagga b/ugw/feeds_opensrc/packages/quagga
new file mode 120000
index 0000000000..1f8765c74f
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/quagga
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/quagga/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/racoon2 b/ugw/feeds_opensrc/packages/racoon2
new file mode 120000
index 0000000000..a601f53574
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/racoon2
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/racoon2/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/radvd b/ugw/feeds_opensrc/packages/radvd
new file mode 120000
index 0000000000..868712416b
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/radvd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/radvd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/ragel b/ugw/feeds_opensrc/packages/ragel
new file mode 120000
index 0000000000..15970f8958
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/ragel
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/ragel/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/rp-pppoe b/ugw/feeds_opensrc/packages/rp-pppoe
new file mode 120000
index 0000000000..d38ca2ca2f
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/rp-pppoe
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/rp-pppoe/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/rsync b/ugw/feeds_opensrc/packages/rsync
new file mode 120000
index 0000000000..e6fe8342b8
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/rsync
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/rsync/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/safec b/ugw/feeds_opensrc/packages/safec
new file mode 120000
index 0000000000..188548db7d
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/safec
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/safec/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/samba3 b/ugw/feeds_opensrc/packages/samba3
new file mode 120000
index 0000000000..6aa487d8cd
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/samba3
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/updates/samba3/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/socat b/ugw/feeds_opensrc/packages/socat
new file mode 120000
index 0000000000..7a322fdf56
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/socat
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/socat/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/sqlite3 b/ugw/feeds_opensrc/packages/sqlite3
new file mode 120000
index 0000000000..c7617a5761
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/sqlite3
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/sqlite3/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/strongswan b/ugw/feeds_opensrc/packages/strongswan
new file mode 120000
index 0000000000..53365c56fd
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/strongswan
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/strongswan/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/stunnel b/ugw/feeds_opensrc/packages/stunnel
new file mode 120000
index 0000000000..39f79990a7
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/stunnel
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/stunnel/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/supervisor b/ugw/feeds_opensrc/packages/supervisor
new file mode 120000
index 0000000000..5e24e8e3dc
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/supervisor
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/supervisor/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/syslog-ng b/ugw/feeds_opensrc/packages/syslog-ng
new file mode 120000
index 0000000000..3721afc2b9
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/syslog-ng
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/syslog-ng/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/tc-latest b/ugw/feeds_opensrc/packages/tc-latest
new file mode 120000
index 0000000000..be3ed26a4c
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/tc-latest
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/tc-latest/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/tinytcl b/ugw/feeds_opensrc/packages/tinytcl
new file mode 120000
index 0000000000..d7fa078427
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/tinytcl
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/tinytcl/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/tornado b/ugw/feeds_opensrc/packages/tornado
new file mode 120000
index 0000000000..ce0cab10e1
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/tornado
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/tornado/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/ubox b/ugw/feeds_opensrc/packages/ubox
new file mode 120000
index 0000000000..eb917aeefa
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/ubox
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/ubox/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/ubus b/ugw/feeds_opensrc/packages/ubus
new file mode 120000
index 0000000000..aefae04021
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/ubus
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/ubus/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/uci b/ugw/feeds_opensrc/packages/uci
new file mode 120000
index 0000000000..a20cbffc2e
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/uci
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/uci/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/ugw-qos-scripts b/ugw/feeds_opensrc/packages/ugw-qos-scripts
new file mode 120000
index 0000000000..5ea4729865
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/ugw-qos-scripts
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/ugw-qos-scripts/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/umbim b/ugw/feeds_opensrc/packages/umbim
new file mode 120000
index 0000000000..963ebd452e
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/umbim
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/umbim/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/upnpdm b/ugw/feeds_opensrc/packages/upnpdm
new file mode 120000
index 0000000000..46eaecc06d
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/upnpdm
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_upnpdm/upnpdm/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/urlfilterd_service b/ugw/feeds_opensrc/packages/urlfilterd_service
new file mode 120000
index 0000000000..4fc5d21a9a
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/urlfilterd_service
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/urlfilterd_service/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/usb-modeswitch b/ugw/feeds_opensrc/packages/usb-modeswitch
new file mode 120000
index 0000000000..a12895b7fb
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/usb-modeswitch
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/usb-modeswitch/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/usb-modeswitch-data b/ugw/feeds_opensrc/packages/usb-modeswitch-data
new file mode 120000
index 0000000000..b7d672ddbd
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/usb-modeswitch-data
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/usb-modeswitch-data/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/vsftpd b/ugw/feeds_opensrc/packages/vsftpd
new file mode 120000
index 0000000000..b33440c8c8
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/vsftpd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/vsftpd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/wide-dhcpv6 b/ugw/feeds_opensrc/packages/wide-dhcpv6
new file mode 120000
index 0000000000..fa590a25ad
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/wide-dhcpv6
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/wide-dhcpv6/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/wireless-tools b/ugw/feeds_opensrc/packages/wireless-tools
new file mode 120000
index 0000000000..41c799ac41
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/wireless-tools
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/wireless-tools/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/wpa_supplicant_0511 b/ugw/feeds_opensrc/packages/wpa_supplicant_0511
new file mode 120000
index 0000000000..132c290641
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/wpa_supplicant_0511
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/wpa_supplicant_0511/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/xl2tpd b/ugw/feeds_opensrc/packages/xl2tpd
new file mode 120000
index 0000000000..1f469949b3
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/xl2tpd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/xl2tpd/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/zebra b/ugw/feeds_opensrc/packages/zebra
new file mode 120000
index 0000000000..e2f3ca7ed1
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/zebra
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/zebra/
\ No newline at end of file
diff --git a/ugw/feeds_opensrc/packages/zip b/ugw/feeds_opensrc/packages/zip
new file mode 120000
index 0000000000..438353cf35
--- /dev/null
+++ b/ugw/feeds_opensrc/packages/zip
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_opensource_apps/zip/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/altair-lte b/ugw/feeds_thirdparty/altair-lte
new file mode 120000
index 0000000000..ab83ec31d3
--- /dev/null
+++ b/ugw/feeds_thirdparty/altair-lte
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/altair-lte/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/atheros b/ugw/feeds_thirdparty/atheros
new file mode 120000
index 0000000000..3cb32e1dfc
--- /dev/null
+++ b/ugw/feeds_thirdparty/atheros
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/atheros/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/atheros-bin b/ugw/feeds_thirdparty/atheros-bin
new file mode 120000
index 0000000000..e2259c76ff
--- /dev/null
+++ b/ugw/feeds_thirdparty/atheros-bin
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty_nda/atheros-bin/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/eip123 b/ugw/feeds_thirdparty/eip123
new file mode 120000
index 0000000000..3d84dbaa73
--- /dev/null
+++ b/ugw/feeds_thirdparty/eip123
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/eip123/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/eip97 b/ugw/feeds_thirdparty/eip97
new file mode 120000
index 0000000000..85bdf95d60
--- /dev/null
+++ b/ugw/feeds_thirdparty/eip97
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/eip97/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/icc b/ugw/feeds_thirdparty/icc
new file mode 120000
index 0000000000..aef32942d2
--- /dev/null
+++ b/ugw/feeds_thirdparty/icc
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/icc/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/jbed-cdca b/ugw/feeds_thirdparty/jbed-cdca
new file mode 120000
index 0000000000..7b2b2a39b5
--- /dev/null
+++ b/ugw/feeds_thirdparty/jbed-cdca
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/jbed-cdca/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/mt7603e b/ugw/feeds_thirdparty/mt7603e
new file mode 120000
index 0000000000..8355a704e7
--- /dev/null
+++ b/ugw/feeds_thirdparty/mt7603e
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/mt7603e/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/quantenna b/ugw/feeds_thirdparty/quantenna
new file mode 120000
index 0000000000..35a8e72efa
--- /dev/null
+++ b/ugw/feeds_thirdparty/quantenna
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/quantenna/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/ralink b/ugw/feeds_thirdparty/ralink
new file mode 120000
index 0000000000..7f74d99921
--- /dev/null
+++ b/ugw/feeds_thirdparty/ralink
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/ralink/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/rtdot1xd b/ugw/feeds_thirdparty/rtdot1xd
new file mode 120000
index 0000000000..23b714f30b
--- /dev/null
+++ b/ugw/feeds_thirdparty/rtdot1xd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/rtdot1xd/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/secure-app b/ugw/feeds_thirdparty/secure-app
new file mode 120000
index 0000000000..1935ada5a1
--- /dev/null
+++ b/ugw/feeds_thirdparty/secure-app
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/secure-app/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/secure_boot b/ugw/feeds_thirdparty/secure_boot
new file mode 120000
index 0000000000..6471c2ffc4
--- /dev/null
+++ b/ugw/feeds_thirdparty/secure_boot
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/secure_boot/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/tuxera b/ugw/feeds_thirdparty/tuxera
new file mode 120000
index 0000000000..c88fb96693
--- /dev/null
+++ b/ugw/feeds_thirdparty/tuxera
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/tuxera/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/tuxera_xRx500 b/ugw/feeds_thirdparty/tuxera_xRx500
new file mode 120000
index 0000000000..3af7fe25a6
--- /dev/null
+++ b/ugw/feeds_thirdparty/tuxera_xRx500
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/tuxera_xRx500/
\ No newline at end of file
diff --git a/ugw/feeds_thirdparty/utmproxy b/ugw/feeds_thirdparty/utmproxy
new file mode 120000
index 0000000000..f15f4bf42f
--- /dev/null
+++ b/ugw/feeds_thirdparty/utmproxy
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_3rdparty/utmproxy/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/cwmp/sl_managementserver b/ugw/feeds_ugw/cwmp/sl_managementserver
new file mode 120000
index 0000000000..42e88bbb29
--- /dev/null
+++ b/ugw/feeds_ugw/cwmp/sl_managementserver
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_managementserver
\ No newline at end of file
diff --git a/ugw/feeds_ugw/cwmp/ugw_devm b/ugw/feeds_ugw/cwmp/ugw_devm
new file mode 120000
index 0000000000..df266cadec
--- /dev/null
+++ b/ugw/feeds_ugw/cwmp/ugw_devm
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/devm_ss/feed_devm/ugw_devm
\ No newline at end of file
diff --git a/ugw/feeds_ugw/datapath/directconnect_dp b/ugw/feeds_ugw/datapath/directconnect_dp
new file mode 120000
index 0000000000..7bb87a448b
--- /dev/null
+++ b/ugw/feeds_ugw/datapath/directconnect_dp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_datapath/directconnect_dp
\ No newline at end of file
diff --git a/ugw/feeds_ugw/debug/pad b/ugw/feeds_ugw/debug/pad
new file mode 120000
index 0000000000..9b4091a295
--- /dev/null
+++ b/ugw/feeds_ugw/debug/pad
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/pad
\ No newline at end of file
diff --git a/ugw/feeds_ugw/debug/system-analyzer b/ugw/feeds_ugw/debug/system-analyzer
new file mode 120000
index 0000000000..d1e474f2f0
--- /dev/null
+++ b/ugw/feeds_ugw/debug/system-analyzer
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_debug_tools/system-analyzer
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dect/ltq_dect b/ugw/feeds_ugw/dect/ltq_dect
new file mode 120000
index 0000000000..c5d605880c
--- /dev/null
+++ b/ugw/feeds_ugw/dect/ltq_dect
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dect/ltq_dect/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dect/ltq_hanfun_agent b/ugw/feeds_ugw/dect/ltq_hanfun_agent
new file mode 120000
index 0000000000..f05e2cae07
--- /dev/null
+++ b/ugw/feeds_ugw/dect/ltq_hanfun_agent
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dect/ltq_hanfun_agent/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dect/ltq_hanserver b/ugw/feeds_ugw/dect/ltq_hanserver
new file mode 120000
index 0000000000..ac900439e3
--- /dev/null
+++ b/ugw/feeds_ugw/dect/ltq_hanserver
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dect/ltq_hanserver/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-cpe-api-vrx b/ugw/feeds_ugw/dsl/dsl-cpe-api-vrx
new file mode 120000
index 0000000000..3454cf8f08
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-cpe-api-vrx
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-cpe-api-vrx/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-cpe-control-vrx b/ugw/feeds_ugw/dsl/dsl-cpe-control-vrx
new file mode 120000
index 0000000000..ae61577e60
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-cpe-control-vrx
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-cpe-control-vrx/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-cpe-dti-agent b/ugw/feeds_ugw/dsl/dsl-cpe-dti-agent
new file mode 120000
index 0000000000..2cc48f4727
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-cpe-dti-agent
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-cpe-dti-agent/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-cpe-fapi b/ugw/feeds_ugw/dsl/dsl-cpe-fapi
new file mode 120000
index 0000000000..383209882a
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-cpe-fapi
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-cpe-fapi/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-cpe-logger b/ugw/feeds_ugw/dsl/dsl-cpe-logger
new file mode 120000
index 0000000000..5f9ddfca62
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-cpe-logger
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-cpe-logger/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-cpe-mei-vrx b/ugw/feeds_ugw/dsl/dsl-cpe-mei-vrx
new file mode 120000
index 0000000000..ded1a56255
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-cpe-mei-vrx
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-cpe-mei-vrx/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-cpe-sl b/ugw/feeds_ugw/dsl/dsl-cpe-sl
new file mode 120000
index 0000000000..af9894a06b
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-cpe-sl
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-cpe-sl/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-gfast-api-vrx618 b/ugw/feeds_ugw/dsl/dsl-gfast-api-vrx618
new file mode 120000
index 0000000000..dafe5cbd08
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-gfast-api-vrx618
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-gfast-api-vrx618/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-gfast-drv-pciep b/ugw/feeds_ugw/dsl/dsl-gfast-drv-pciep
new file mode 120000
index 0000000000..ac59e3e18a
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-gfast-drv-pciep
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-gfast-drv-pciep/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-gfast-drv-pmi b/ugw/feeds_ugw/dsl/dsl-gfast-drv-pmi
new file mode 120000
index 0000000000..abdd935ada
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-gfast-drv-pmi
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-gfast-drv-pmi/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-gfast-drv-pmi-sim b/ugw/feeds_ugw/dsl/dsl-gfast-drv-pmi-sim
new file mode 120000
index 0000000000..93802f22d3
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-gfast-drv-pmi-sim
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-gfast-drv-pmi-sim/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-gfast-drv-vrx618-dp-emul b/ugw/feeds_ugw/dsl/dsl-gfast-drv-vrx618-dp-emul
new file mode 120000
index 0000000000..61c099e19b
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-gfast-drv-vrx618-dp-emul
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-gfast-drv-vrx618-dp-emul/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-gfast-fw-sim b/ugw/feeds_ugw/dsl/dsl-gfast-fw-sim
new file mode 120000
index 0000000000..3574f59ea1
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-gfast-fw-sim
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-gfast-fw-sim/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-vnx101-firmware b/ugw/feeds_ugw/dsl/dsl-vnx101-firmware
new file mode 120000
index 0000000000..3eee04ea0b
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-vnx101-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-vnx101-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-vr10-firmware-xdsl b/ugw/feeds_ugw/dsl/dsl-vr10-firmware-xdsl
new file mode 120000
index 0000000000..be38fa1041
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-vr10-firmware-xdsl
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-vr10-firmware-xdsl/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-vr11-firmware-xdsl b/ugw/feeds_ugw/dsl/dsl-vr11-firmware-xdsl
new file mode 120000
index 0000000000..c6aeb0d3a3
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-vr11-firmware-xdsl
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-vr11-firmware-xdsl/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-vr9-firmware-vdsl-2p-bonding b/ugw/feeds_ugw/dsl/dsl-vr9-firmware-vdsl-2p-bonding
new file mode 120000
index 0000000000..97657b2346
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-vr9-firmware-vdsl-2p-bonding
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-vr9-firmware-vdsl-2p-bonding/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-vr9-firmware-xdsl b/ugw/feeds_ugw/dsl/dsl-vr9-firmware-xdsl
new file mode 120000
index 0000000000..7afd41225d
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-vr9-firmware-xdsl
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-vr9-firmware-xdsl/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dsl-vrx618-firmware b/ugw/feeds_ugw/dsl/dsl-vrx618-firmware
new file mode 120000
index 0000000000..aeaa91c1a2
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dsl-vrx618-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dsl-vrx618-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/dti-pmi b/ugw/feeds_ugw/dsl/dti-pmi
new file mode 120000
index 0000000000..92e9d4b2af
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/dti-pmi
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_cpe/dti-pmi/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/dsl/vrx518 b/ugw/feeds_ugw/dsl/vrx518
new file mode 120000
index 0000000000..2cca60416d
--- /dev/null
+++ b/ugw/feeds_ugw/dsl/vrx518
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_ppe/vrx518/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/feed_intel/Beihai b/ugw/feeds_ugw/feed_intel/Beihai
new file mode 120000
index 0000000000..a65b0e8ddb
--- /dev/null
+++ b/ugw/feeds_ugw/feed_intel/Beihai
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_intel/packages/Beihai/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/feed_intel/photoindex b/ugw/feeds_ugw/feed_intel/photoindex
new file mode 120000
index 0000000000..aa956e0335
--- /dev/null
+++ b/ugw/feeds_ugw/feed_intel/photoindex
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_intel/packages/photoindex/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/feed_intel/telemetrics-client b/ugw/feeds_ugw/feed_intel/telemetrics-client
new file mode 120000
index 0000000000..e412d70813
--- /dev/null
+++ b/ugw/feeds_ugw/feed_intel/telemetrics-client
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_intel/packages/telemetrics-client/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/feed_intel/telemetrics-probes b/ugw/feeds_ugw/feed_intel/telemetrics-probes
new file mode 120000
index 0000000000..fedcf1996b
--- /dev/null
+++ b/ugw/feeds_ugw/feed_intel/telemetrics-probes
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_intel/packages/telemetrics-probes/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/firewall/firewallnat b/ugw/feeds_ugw/firewall/firewallnat
new file mode 120000
index 0000000000..eac0f65188
--- /dev/null
+++ b/ugw/feeds_ugw/firewall/firewallnat
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_firewall_nat/firewallnat
\ No newline at end of file
diff --git a/ugw/feeds_ugw/firewall/urlfilterd_service b/ugw/feeds_ugw/firewall/urlfilterd_service
new file mode 120000
index 0000000000..a71cef9a0f
--- /dev/null
+++ b/ugw/feeds_ugw/firewall/urlfilterd_service
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_firewall_nat/urlfilterd_service
\ No newline at end of file
diff --git a/ugw/feeds_ugw/framework/csd b/ugw/feeds_ugw/framework/csd
new file mode 120000
index 0000000000..fb945b42a0
--- /dev/null
+++ b/ugw/feeds_ugw/framework/csd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_sdk/csd/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/framework/helper b/ugw/feeds_ugw/framework/helper
new file mode 120000
index 0000000000..868154b3e7
--- /dev/null
+++ b/ugw/feeds_ugw/framework/helper
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_sdk/helper/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/framework/libcal b/ugw/feeds_ugw/framework/libcal
new file mode 120000
index 0000000000..8de174bbaa
--- /dev/null
+++ b/ugw/feeds_ugw/framework/libcal
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_sdk/libcal/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/framework/libscapi b/ugw/feeds_ugw/framework/libscapi
new file mode 120000
index 0000000000..c18e24a631
--- /dev/null
+++ b/ugw/feeds_ugw/framework/libscapi
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_sdk/libscapi/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/framework/netlinkd b/ugw/feeds_ugw/framework/netlinkd
new file mode 120000
index 0000000000..76964546e9
--- /dev/null
+++ b/ugw/feeds_ugw/framework/netlinkd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_sdk/netlinkd/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/framework/polld b/ugw/feeds_ugw/framework/polld
new file mode 120000
index 0000000000..71bf659428
--- /dev/null
+++ b/ugw/feeds_ugw/framework/polld
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_sdk/polld/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/framework/servd b/ugw/feeds_ugw/framework/servd
new file mode 120000
index 0000000000..2c68a4d3ae
--- /dev/null
+++ b/ugw/feeds_ugw/framework/servd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_sdk/servd/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/framework/tools b/ugw/feeds_ugw/framework/tools
new file mode 120000
index 0000000000..9bf8313341
--- /dev/null
+++ b/ugw/feeds_ugw/framework/tools
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_sdk/tools/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/base-files-ieee1588 b/ugw/feeds_ugw/gpon/base-files-ieee1588
new file mode 120000
index 0000000000..494828434d
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/base-files-ieee1588
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/base-files-ieee1588/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/base-files-nfs b/ugw/feeds_ugw/gpon/base-files-nfs
new file mode 120000
index 0000000000..4e61db996d
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/base-files-nfs
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/base-files-nfs/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/f24s-drv b/ugw/feeds_ugw/gpon/f24s-drv
new file mode 120000
index 0000000000..716e4f1d84
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/f24s-drv
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/f24s-drv/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gfast-drv b/ugw/feeds_ugw/gpon/gfast-drv
new file mode 120000
index 0000000000..6d5ca86c1d
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gfast-drv
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gfast-drv/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-base-files b/ugw/feeds_ugw/gpon/gpon-base-files
new file mode 120000
index 0000000000..c3cf9a656f
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-base-files
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-base-files/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-base-files-easycwmp b/ugw/feeds_ugw/gpon/gpon-base-files-easycwmp
new file mode 120000
index 0000000000..4b2f63668d
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-base-files-easycwmp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-base-files-easycwmp/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-base-files-fttdp b/ugw/feeds_ugw/gpon/gpon-base-files-fttdp
new file mode 120000
index 0000000000..0ddcfbc7f7
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-base-files-fttdp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-base-files-fttdp/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-base-files-gfast b/ugw/feeds_ugw/gpon/gpon-base-files-gfast
new file mode 120000
index 0000000000..759a88e83b
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-base-files-gfast
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-base-files-gfast/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-base-files-hgu-2chip-host b/ugw/feeds_ugw/gpon/gpon-base-files-hgu-2chip-host
new file mode 120000
index 0000000000..10724a4461
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-base-files-hgu-2chip-host
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-base-files-hgu-2chip-host/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-base-files-hgu-2chip-omci-host b/ugw/feeds_ugw/gpon/gpon-base-files-hgu-2chip-omci-host
new file mode 120000
index 0000000000..ecb2114580
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-base-files-hgu-2chip-omci-host
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-base-files-hgu-2chip-omci-host/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-base-files-sfu b/ugw/feeds_ugw/gpon/gpon-base-files-sfu
new file mode 120000
index 0000000000..6e7824d9cf
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-base-files-sfu
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-base-files-sfu/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-dti-agent b/ugw/feeds_ugw/gpon/gpon-dti-agent
new file mode 120000
index 0000000000..14ab5cd8a3
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-dti-agent
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-dti-agent/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-falcon-ecos-firmware b/ugw/feeds_ugw/gpon/gpon-falcon-ecos-firmware
new file mode 120000
index 0000000000..cb8e1d57c3
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-falcon-ecos-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-falcon-ecos-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-falcon-ecos-omciclean-firmware b/ugw/feeds_ugw/gpon/gpon-falcon-ecos-omciclean-firmware
new file mode 120000
index 0000000000..2498316fd8
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-falcon-ecos-omciclean-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-falcon-ecos-omciclean-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-fire b/ugw/feeds_ugw/gpon/gpon-fire
new file mode 120000
index 0000000000..84ba7a24ba
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-fire
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-fire/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-gphy-firmware b/ugw/feeds_ugw/gpon/gpon-gphy-firmware
new file mode 120000
index 0000000000..c4e96a9c3a
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-gphy-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-gphy-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-libs b/ugw/feeds_ugw/gpon/gpon-libs
new file mode 120000
index 0000000000..23f5a4ad2e
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-libs
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-libs/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-luci b/ugw/feeds_ugw/gpon/gpon-luci
new file mode 120000
index 0000000000..330ff19c7c
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-luci
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-luci/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-ocal b/ugw/feeds_ugw/gpon/gpon-ocal
new file mode 120000
index 0000000000..df863584f3
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-ocal
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-ocal/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-omci-api b/ugw/feeds_ugw/gpon/gpon-omci-api
new file mode 120000
index 0000000000..d7f1ebeaff
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-omci-api
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-omci-api/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-omci-onu b/ugw/feeds_ugw/gpon/gpon-omci-onu
new file mode 120000
index 0000000000..0dd07794c0
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-omci-onu
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-omci-onu/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-onu-drv b/ugw/feeds_ugw/gpon/gpon-onu-drv
new file mode 120000
index 0000000000..9ad4e208df
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-onu-drv
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-onu-drv/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-optic-config b/ugw/feeds_ugw/gpon/gpon-optic-config
new file mode 120000
index 0000000000..bd958ae013
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-optic-config
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-optic-config/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-optic-drv b/ugw/feeds_ugw/gpon/gpon-optic-drv
new file mode 120000
index 0000000000..25289951c8
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-optic-drv
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-optic-drv/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-pe-firmware b/ugw/feeds_ugw/gpon/gpon-pe-firmware
new file mode 120000
index 0000000000..c46f377e47
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-pe-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-pe-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-pe-fttdp-firmware b/ugw/feeds_ugw/gpon/gpon-pe-fttdp-firmware
new file mode 120000
index 0000000000..1978ed9eb4
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-pe-fttdp-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-pe-fttdp-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-pe-oam-firmware b/ugw/feeds_ugw/gpon/gpon-pe-oam-firmware
new file mode 120000
index 0000000000..d31d8d3efe
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-pe-oam-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-pe-oam-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-rpc b/ugw/feeds_ugw/gpon/gpon-rpc
new file mode 120000
index 0000000000..30283cac60
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-rpc
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-rpc/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-sfp b/ugw/feeds_ugw/gpon/gpon-sfp
new file mode 120000
index 0000000000..b949246233
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-sfp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-sfp/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-sfp-eeprom b/ugw/feeds_ugw/gpon/gpon-sfp-eeprom
new file mode 120000
index 0000000000..c69c315b46
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-sfp-eeprom
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-sfp-eeprom/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-sfp-i2c-drv b/ugw/feeds_ugw/gpon/gpon-sfp-i2c-drv
new file mode 120000
index 0000000000..9891b770bc
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-sfp-i2c-drv
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-sfp-i2c-drv/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-sfp-i2c-gpio-drv b/ugw/feeds_ugw/gpon/gpon-sfp-i2c-gpio-drv
new file mode 120000
index 0000000000..d93f384bb6
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-sfp-i2c-gpio-drv
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-sfp-i2c-gpio-drv/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-sip-agent b/ugw/feeds_ugw/gpon/gpon-sip-agent
new file mode 120000
index 0000000000..8728f6cd83
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-sip-agent
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-sip-agent/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-toolbox b/ugw/feeds_ugw/gpon/gpon-toolbox
new file mode 120000
index 0000000000..979febc452
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-toolbox
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-toolbox/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-uboot b/ugw/feeds_ugw/gpon/gpon-uboot
new file mode 120000
index 0000000000..f18996b850
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-uboot
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-uboot/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/gpon-version b/ugw/feeds_ugw/gpon/gpon-version
new file mode 120000
index 0000000000..6fae25cf1b
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/gpon-version
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/gpon-version/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/matrixssh-ecos b/ugw/feeds_ugw/gpon/matrixssh-ecos
new file mode 120000
index 0000000000..3fa83bfdaf
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/matrixssh-ecos
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/matrixssh-ecos/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/opensource b/ugw/feeds_ugw/gpon/opensource
new file mode 120000
index 0000000000..c0ca591192
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/opensource
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/opensource/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/pon-gpon-firmware b/ugw/feeds_ugw/gpon/pon-gpon-firmware
new file mode 120000
index 0000000000..ad81a505b2
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/pon-gpon-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/pon-gpon-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/pon-lib b/ugw/feeds_ugw/gpon/pon-lib
new file mode 120000
index 0000000000..34a01a6479
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/pon-lib
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/pon-lib/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/pon-mbox-drv b/ugw/feeds_ugw/gpon/pon-mbox-drv
new file mode 120000
index 0000000000..cb84751c68
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/pon-mbox-drv
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gpon_onu/pon-mbox-drv/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/gpon/sl_gpon b/ugw/feeds_ugw/gpon/sl_gpon
new file mode 120000
index 0000000000..51ff4eb952
--- /dev/null
+++ b/ugw/feeds_ugw/gpon/sl_gpon
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_gpon
\ No newline at end of file
diff --git a/ugw/feeds_ugw/host_utils/DBTool b/ugw/feeds_ugw/host_utils/DBTool
new file mode 120000
index 0000000000..d7cf4c7333
--- /dev/null
+++ b/ugw/feeds_ugw/host_utils/DBTool
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/sdk_utils/DBTool/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/hotspot/cli_hotspot b/ugw/feeds_ugw/hotspot/cli_hotspot
new file mode 120000
index 0000000000..5ed11363a9
--- /dev/null
+++ b/ugw/feeds_ugw/hotspot/cli_hotspot
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_hotspot_services/cli_hotspot/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/hotspot/fapi_hotspot b/ugw/feeds_ugw/hotspot/fapi_hotspot
new file mode 120000
index 0000000000..de71eaa291
--- /dev/null
+++ b/ugw/feeds_ugw/hotspot/fapi_hotspot
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_hotspot_services/fapi_hotspot/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/hotspot/l2f_hotspot b/ugw/feeds_ugw/hotspot/l2f_hotspot
new file mode 120000
index 0000000000..611438868e
--- /dev/null
+++ b/ugw/feeds_ugw/hotspot/l2f_hotspot
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_hotspot_services/l2f_hotspot/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/hotspot/parp_hotspot b/ugw/feeds_ugw/hotspot/parp_hotspot
new file mode 120000
index 0000000000..4ea92d2cf3
--- /dev/null
+++ b/ugw/feeds_ugw/hotspot/parp_hotspot
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_hotspot_services/parp_hotspot/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/hotspot/sl_wms b/ugw/feeds_ugw/hotspot/sl_wms
new file mode 120000
index 0000000000..4c838dfa85
--- /dev/null
+++ b/ugw/feeds_ugw/hotspot/sl_wms
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_hotspot_services/sl_wms/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/iotivity/iotivity b/ugw/feeds_ugw/iotivity/iotivity
new file mode 120000
index 0000000000..7d353d5ad2
--- /dev/null
+++ b/ugw/feeds_ugw/iotivity/iotivity
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_iotivity//iotivity/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/iotivity/iotivity-hanfun b/ugw/feeds_ugw/iotivity/iotivity-hanfun
new file mode 120000
index 0000000000..de8f255ecc
--- /dev/null
+++ b/ugw/feeds_ugw/iotivity/iotivity-hanfun
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_iotivity//iotivity-hanfun/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/iotivity/libltqhanfun b/ugw/feeds_ugw/iotivity/libltqhanfun
new file mode 120000
index 0000000000..06bb6f80ba
--- /dev/null
+++ b/ugw/feeds_ugw/iotivity/libltqhanfun
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_iotivity//libltqhanfun/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/iotivity/wss_gateway-common b/ugw/feeds_ugw/iotivity/wss_gateway-common
new file mode 120000
index 0000000000..c0dd4be278
--- /dev/null
+++ b/ugw/feeds_ugw/iotivity/wss_gateway-common
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_iotivity//wss_gateway-common/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/iotivity/wss_gateway-hue_plugin b/ugw/feeds_ugw/iotivity/wss_gateway-hue_plugin
new file mode 120000
index 0000000000..98d3d2a065
--- /dev/null
+++ b/ugw/feeds_ugw/iotivity/wss_gateway-hue_plugin
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_iotivity//wss_gateway-hue_plugin/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/iotivity/wss_gateway-mini_plugin_manager b/ugw/feeds_ugw/iotivity/wss_gateway-mini_plugin_manager
new file mode 120000
index 0000000000..b3b02321ba
--- /dev/null
+++ b/ugw/feeds_ugw/iotivity/wss_gateway-mini_plugin_manager
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_iotivity//wss_gateway-mini_plugin_manager/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/ipv6/sl_ipv6 b/ugw/feeds_ugw/ipv6/sl_ipv6
new file mode 120000
index 0000000000..5309b26818
--- /dev/null
+++ b/ugw/feeds_ugw/ipv6/sl_ipv6
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_ipv6
\ No newline at end of file
diff --git a/ugw/feeds_ugw/mcast/cli_mcast b/ugw/feeds_ugw/mcast/cli_mcast
new file mode 120000
index 0000000000..004a3c199e
--- /dev/null
+++ b/ugw/feeds_ugw/mcast/cli_mcast
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_mcast_service/cli_mcast/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/mcast/daemon_mcast b/ugw/feeds_ugw/mcast/daemon_mcast
new file mode 120000
index 0000000000..0c40a9f77c
--- /dev/null
+++ b/ugw/feeds_ugw/mcast/daemon_mcast
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_mcast_service/daemon_mcast/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/mcast/fapi_mcast b/ugw/feeds_ugw/mcast/fapi_mcast
new file mode 120000
index 0000000000..ac7cd77308
--- /dev/null
+++ b/ugw/feeds_ugw/mcast/fapi_mcast
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_mcast_service/fapi_mcast/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/mcast/sl_mcast b/ugw/feeds_ugw/mcast/sl_mcast
new file mode 120000
index 0000000000..650572f5a9
--- /dev/null
+++ b/ugw/feeds_ugw/mcast/sl_mcast
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_mcast_service/sl_mcast/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/eembc-mb b/ugw/feeds_ugw/misc/eembc-mb
new file mode 120000
index 0000000000..7af9f6c0da
--- /dev/null
+++ b/ugw/feeds_ugw/misc/eembc-mb
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/eembc-mb/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/ifx-base-files-common b/ugw/feeds_ugw/misc/ifx-base-files-common
new file mode 120000
index 0000000000..47daefd196
--- /dev/null
+++ b/ugw/feeds_ugw/misc/ifx-base-files-common
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/ifx-base-files-common/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/ifx-base-files-template b/ugw/feeds_ugw/misc/ifx-base-files-template
new file mode 120000
index 0000000000..2e5f8947fb
--- /dev/null
+++ b/ugw/feeds_ugw/misc/ifx-base-files-template
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/ifx-base-files-template/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/ifx-dti b/ugw/feeds_ugw/misc/ifx-dti
new file mode 120000
index 0000000000..162acc1021
--- /dev/null
+++ b/ugw/feeds_ugw/misc/ifx-dti
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/ifx-dti/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/ifx-eeprom b/ugw/feeds_ugw/misc/ifx-eeprom
new file mode 120000
index 0000000000..92c6d3f0c8
--- /dev/null
+++ b/ugw/feeds_ugw/misc/ifx-eeprom
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/ifx-eeprom/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/ifx-lib-tf b/ugw/feeds_ugw/misc/ifx-lib-tf
new file mode 120000
index 0000000000..b41dbadeae
--- /dev/null
+++ b/ugw/feeds_ugw/misc/ifx-lib-tf
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/ifx-lib-tf/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/ifx-spi b/ugw/feeds_ugw/misc/ifx-spi
new file mode 120000
index 0000000000..7056562607
--- /dev/null
+++ b/ugw/feeds_ugw/misc/ifx-spi
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/ifx-spi/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/ifx-vdsl2-winhost b/ugw/feeds_ugw/misc/ifx-vdsl2-winhost
new file mode 120000
index 0000000000..86a46fef8b
--- /dev/null
+++ b/ugw/feeds_ugw/misc/ifx-vdsl2-winhost
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/ifx-vdsl2-winhost/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/ifx-vos b/ugw/feeds_ugw/misc/ifx-vos
new file mode 120000
index 0000000000..dc09408dfc
--- /dev/null
+++ b/ugw/feeds_ugw/misc/ifx-vos
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/ifx-vos/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/ifxos b/ugw/feeds_ugw/misc/ifxos
new file mode 120000
index 0000000000..c8c6a300d1
--- /dev/null
+++ b/ugw/feeds_ugw/misc/ifxos
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/ifxos/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/ifxos-devio b/ugw/feeds_ugw/misc/ifxos-devio
new file mode 120000
index 0000000000..a138277449
--- /dev/null
+++ b/ugw/feeds_ugw/misc/ifxos-devio
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/ifxos-devio/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/ifxos-ecos b/ugw/feeds_ugw/misc/ifxos-ecos
new file mode 120000
index 0000000000..456cf313cf
--- /dev/null
+++ b/ugw/feeds_ugw/misc/ifxos-ecos
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/ifxos-ecos/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/lib-cli b/ugw/feeds_ugw/misc/lib-cli
new file mode 120000
index 0000000000..62c6fa251d
--- /dev/null
+++ b/ugw/feeds_ugw/misc/lib-cli
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/lib-cli/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/lib-cli-ecos b/ugw/feeds_ugw/misc/lib-cli-ecos
new file mode 120000
index 0000000000..fa04d4d04f
--- /dev/null
+++ b/ugw/feeds_ugw/misc/lib-cli-ecos
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/lib-cli-ecos/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/lib-dti b/ugw/feeds_ugw/misc/lib-dti
new file mode 120000
index 0000000000..a69082b678
--- /dev/null
+++ b/ugw/feeds_ugw/misc/lib-dti
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/lib-dti/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/lib-dti-ecos b/ugw/feeds_ugw/misc/lib-dti-ecos
new file mode 120000
index 0000000000..7d42834cff
--- /dev/null
+++ b/ugw/feeds_ugw/misc/lib-dti-ecos
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/lib-dti-ecos/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/lib-ezbox b/ugw/feeds_ugw/misc/lib-ezbox
new file mode 120000
index 0000000000..66bf5f078c
--- /dev/null
+++ b/ugw/feeds_ugw/misc/lib-ezbox
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/lib-ezbox/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/lq-base-files-common b/ugw/feeds_ugw/misc/lq-base-files-common
new file mode 120000
index 0000000000..548c71eb83
--- /dev/null
+++ b/ugw/feeds_ugw/misc/lq-base-files-common
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/lq-base-files-common/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/ltq-acli b/ugw/feeds_ugw/misc/ltq-acli
new file mode 120000
index 0000000000..522ce004ff
--- /dev/null
+++ b/ugw/feeds_ugw/misc/ltq-acli
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/ltq-acli/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/ltq-base-files-common b/ugw/feeds_ugw/misc/ltq-base-files-common
new file mode 120000
index 0000000000..aea4afa8cd
--- /dev/null
+++ b/ugw/feeds_ugw/misc/ltq-base-files-common
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/ltq-base-files-common/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/ltq-evtlog b/ugw/feeds_ugw/misc/ltq-evtlog
new file mode 120000
index 0000000000..7146129c04
--- /dev/null
+++ b/ugw/feeds_ugw/misc/ltq-evtlog
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/ltq-evtlog/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/memedit b/ugw/feeds_ugw/misc/memedit
new file mode 120000
index 0000000000..9eb2ff4265
--- /dev/null
+++ b/ugw/feeds_ugw/misc/memedit
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/memedit/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/uboot-amazon-se b/ugw/feeds_ugw/misc/uboot-amazon-se
new file mode 120000
index 0000000000..8315a53a87
--- /dev/null
+++ b/ugw/feeds_ugw/misc/uboot-amazon-se
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/uboot-amazon-se/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/uboot-tqm86x b/ugw/feeds_ugw/misc/uboot-tqm86x
new file mode 120000
index 0000000000..f613dd1805
--- /dev/null
+++ b/ugw/feeds_ugw/misc/uboot-tqm86x
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/uboot-tqm86x/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/misc/uthash b/ugw/feeds_ugw/misc/uthash
new file mode 120000
index 0000000000..9883237a81
--- /dev/null
+++ b/ugw/feeds_ugw/misc/uthash
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_common/uthash/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/multiap/multiap_common b/ugw/feeds_ugw/multiap/multiap_common
new file mode 120000
index 0000000000..0b01765a0b
--- /dev/null
+++ b/ugw/feeds_ugw/multiap/multiap_common
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_multiap/multiap_common/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/multiap/multiap_framework b/ugw/feeds_ugw/multiap/multiap_framework
new file mode 120000
index 0000000000..2e6f1523c6
--- /dev/null
+++ b/ugw/feeds_ugw/multiap/multiap_framework
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_multiap/multiap_framework/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/multiap/sl_multiap b/ugw/feeds_ugw/multiap/sl_multiap
new file mode 120000
index 0000000000..2903e5c7af
--- /dev/null
+++ b/ugw/feeds_ugw/multiap/sl_multiap
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_multiap/sl_multiap/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/network/autowan b/ugw/feeds_ugw/network/autowan
new file mode 120000
index 0000000000..301ad52ecc
--- /dev/null
+++ b/ugw/feeds_ugw/network/autowan
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_network_service/autowan/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/network/dyndns b/ugw/feeds_ugw/network/dyndns
new file mode 120000
index 0000000000..d74805ef30
--- /dev/null
+++ b/ugw/feeds_ugw/network/dyndns
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_network_service/dyndns/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/network/lan_services b/ugw/feeds_ugw/network/lan_services
new file mode 120000
index 0000000000..f13721fe6a
--- /dev/null
+++ b/ugw/feeds_ugw/network/lan_services
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_network_service/lan_services/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/network/lq-ethsw-cli b/ugw/feeds_ugw/network/lq-ethsw-cli
new file mode 120000
index 0000000000..3492f9ed2e
--- /dev/null
+++ b/ugw/feeds_ugw/network/lq-ethsw-cli
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_switch_api/lq-ethsw-cli/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/network/multiwan b/ugw/feeds_ugw/network/multiwan
new file mode 120000
index 0000000000..8e3f741455
--- /dev/null
+++ b/ugw/feeds_ugw/network/multiwan
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_network_service/multiwan/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/network/network b/ugw/feeds_ugw/network/network
new file mode 120000
index 0000000000..53ede3532b
--- /dev/null
+++ b/ugw/feeds_ugw/network/network
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_network_service/network/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/network/sl_upnp b/ugw/feeds_ugw/network/sl_upnp
new file mode 120000
index 0000000000..4590dd6339
--- /dev/null
+++ b/ugw/feeds_ugw/network/sl_upnp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_network_service/sl_upnp/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/network/sl_wwan b/ugw/feeds_ugw/network/sl_wwan
new file mode 120000
index 0000000000..b4ecdf908e
--- /dev/null
+++ b/ugw/feeds_ugw/network/sl_wwan
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_wwan_service/sl_wwan
\ No newline at end of file
diff --git a/ugw/feeds_ugw/network/ugw_mptcp b/ugw/feeds_ugw/network/ugw_mptcp
new file mode 120000
index 0000000000..2262672cb2
--- /dev/null
+++ b/ugw/feeds_ugw/network/ugw_mptcp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_network_service/ugw_mptcp/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/network/ugw_oam b/ugw/feeds_ugw/network/ugw_oam
new file mode 120000
index 0000000000..5be17210df
--- /dev/null
+++ b/ugw/feeds_ugw/network/ugw_oam
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_network_service/ugw_oam/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/AQS b/ugw/feeds_ugw/puma_components/AQS
new file mode 120000
index 0000000000..9eb99a3f05
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/AQS
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/AQS/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/I2C_INA219 b/ugw/feeds_ugw/puma_components/I2C_INA219
new file mode 120000
index 0000000000..d0d27eb2b4
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/I2C_INA219
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/I2C_INA219/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/appcpu-infr b/ugw/feeds_ugw/puma_components/appcpu-infr
new file mode 120000
index 0000000000..2a0f572e6e
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/appcpu-infr
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/appcpu-infr/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/aquantia_phy b/ugw/feeds_ugw/puma_components/aquantia_phy
new file mode 120000
index 0000000000..4521081f5b
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/aquantia_phy
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/aquantia_phy/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/aquantia_phy_daemon b/ugw/feeds_ugw/puma_components/aquantia_phy_daemon
new file mode 120000
index 0000000000..4e19f16bb7
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/aquantia_phy_daemon
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/aquantia_phy_daemon/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/arm_images b/ugw/feeds_ugw/puma_components/arm_images
new file mode 120000
index 0000000000..966f15fe0d
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/arm_images
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/arm_images/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/atom-swdl-utility b/ugw/feeds_ugw/puma_components/atom-swdl-utility
new file mode 120000
index 0000000000..b4c042794b
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/atom-swdl-utility
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/atom-swdl-utility/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/autolink b/ugw/feeds_ugw/puma_components/autolink
new file mode 120000
index 0000000000..693612f092
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/autolink
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/autolink/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/bios_images b/ugw/feeds_ugw/puma_components/bios_images
new file mode 120000
index 0000000000..4d547ef8b8
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/bios_images
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/bios_images/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/cli_menus b/ugw/feeds_ugw/puma_components/cli_menus
new file mode 120000
index 0000000000..3b95e82584
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/cli_menus
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/cli_menus/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/common_headers b/ugw/feeds_ugw/puma_components/common_headers
new file mode 120000
index 0000000000..5e1e64b427
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/common_headers
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/common_headers/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/cppp b/ugw/feeds_ugw/puma_components/cppp
new file mode 120000
index 0000000000..8e94ccd86f
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/cppp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/cppp/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/datapath b/ugw/feeds_ugw/puma_components/datapath
new file mode 120000
index 0000000000..7aa0cfd4cd
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/datapath
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/datapath/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/dpdk-dpi b/ugw/feeds_ugw/puma_components/dpdk-dpi
new file mode 120000
index 0000000000..21ec7f26e9
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/dpdk-dpi
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/dpdk-dpi/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/gpiolib b/ugw/feeds_ugw/puma_components/gpiolib
new file mode 120000
index 0000000000..8e964c2233
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/gpiolib
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/gpiolib/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/host_tools b/ugw/feeds_ugw/puma_components/host_tools
new file mode 120000
index 0000000000..3fb3f45a8e
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/host_tools
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/host_tools/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/image_upgrade b/ugw/feeds_ugw/puma_components/image_upgrade
new file mode 120000
index 0000000000..152ded892c
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/image_upgrade
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/image_upgrade/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/initscripts b/ugw/feeds_ugw/puma_components/initscripts
new file mode 120000
index 0000000000..4f3325bbbb
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/initscripts
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/initscripts/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/intelce_autoconf b/ugw/feeds_ugw/puma_components/intelce_autoconf
new file mode 120000
index 0000000000..eeb360f0d8
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/intelce_autoconf
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/intelce_autoconf/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/it_store b/ugw/feeds_ugw/puma_components/it_store
new file mode 120000
index 0000000000..c2e4b314c7
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/it_store
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/it_store/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/ltq_oam_le b/ugw/feeds_ugw/puma_components/ltq_oam_le
new file mode 120000
index 0000000000..e0a2606ff7
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/ltq_oam_le
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/ltq_oam_le/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/ltq_vrx320_datapath_drv b/ugw/feeds_ugw/puma_components/ltq_vrx320_datapath_drv
new file mode 120000
index 0000000000..09edd6520c
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/ltq_vrx320_datapath_drv
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/ltq_vrx320_datapath_drv/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/pp_cli b/ugw/feeds_ugw/puma_components/pp_cli
new file mode 120000
index 0000000000..ba9c7309b5
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/pp_cli
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/pp_cli/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/pp_driver b/ugw/feeds_ugw/puma_components/pp_driver
new file mode 120000
index 0000000000..1a867d1896
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/pp_driver
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/pp_driver/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/pp_fw_download b/ugw/feeds_ugw/puma_components/pp_fw_download
new file mode 120000
index 0000000000..c780a20cd7
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/pp_fw_download
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/pp_fw_download/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/puma-power-app b/ugw/feeds_ugw/puma_components/puma-power-app
new file mode 120000
index 0000000000..d8b22c3880
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/puma-power-app
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/puma-power-app/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/puma_config_features b/ugw/feeds_ugw/puma_components/puma_config_features
new file mode 120000
index 0000000000..6e101964a1
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/puma_config_features
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/puma_config_features/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/puma_dc_mode1 b/ugw/feeds_ugw/puma_components/puma_dc_mode1
new file mode 120000
index 0000000000..5f35b6d001
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/puma_dc_mode1
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/puma_dc_mode1/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/puma_hal b/ugw/feeds_ugw/puma_components/puma_hal
new file mode 120000
index 0000000000..117ac6f97a
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/puma_hal
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/puma_hal/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/puma_lpdp b/ugw/feeds_ugw/puma_components/puma_lpdp
new file mode 120000
index 0000000000..ead5f3bb39
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/puma_lpdp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/puma_lpdp/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/puma_uart b/ugw/feeds_ugw/puma_components/puma_uart
new file mode 120000
index 0000000000..c5aeab09ac
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/puma_uart
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/puma_uart/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/rpc-management b/ugw/feeds_ugw/puma_components/rpc-management
new file mode 120000
index 0000000000..5e53d1283d
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/rpc-management
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/rpc-management/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/rpc-wlan-config b/ugw/feeds_ugw/puma_components/rpc-wlan-config
new file mode 120000
index 0000000000..7429636f0f
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/rpc-wlan-config
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/rpc-wlan-config/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/sepdk b/ugw/feeds_ugw/puma_components/sepdk
new file mode 120000
index 0000000000..08ec79aa18
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/sepdk
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/sepdk/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/sga b/ugw/feeds_ugw/puma_components/sga
new file mode 120000
index 0000000000..225bef3b56
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/sga
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/sga/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/synopsys-gbe b/ugw/feeds_ugw/puma_components/synopsys-gbe
new file mode 120000
index 0000000000..6ceb9bb037
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/synopsys-gbe
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/synopsys-gbe/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/utilities b/ugw/feeds_ugw/puma_components/utilities
new file mode 120000
index 0000000000..fc923250c3
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/utilities
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/utilities/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/wifi_proxy b/ugw/feeds_ugw/puma_components/wifi_proxy
new file mode 120000
index 0000000000..53a999a666
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/wifi_proxy
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/wifi_proxy/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/puma_components/wps_button_drv b/ugw/feeds_ugw/puma_components/wps_button_drv
new file mode 120000
index 0000000000..c4c6c06ea3
--- /dev/null
+++ b/ugw/feeds_ugw/puma_components/wps_button_drv
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_puma_components/packages/wps_button_drv/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/qos/cli_qos b/ugw/feeds_ugw/qos/cli_qos
new file mode 120000
index 0000000000..8f2ea9e680
--- /dev/null
+++ b/ugw/feeds_ugw/qos/cli_qos
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_qos_service/cli_qos/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/qos/fapi_qos b/ugw/feeds_ugw/qos/fapi_qos
new file mode 120000
index 0000000000..a92f0fe7b1
--- /dev/null
+++ b/ugw/feeds_ugw/qos/fapi_qos
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_qos_service/fapi_qos/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/qos/sl_qos b/ugw/feeds_ugw/qos/sl_qos
new file mode 120000
index 0000000000..8076334392
--- /dev/null
+++ b/ugw/feeds_ugw/qos/sl_qos
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_qos_service/sl_qos/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/sample/sl_sample b/ugw/feeds_ugw/sample/sl_sample
new file mode 120000
index 0000000000..6e68d9f14b
--- /dev/null
+++ b/ugw/feeds_ugw/sample/sl_sample
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_sample/sl_sample/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap/broker b/ugw/feeds_ugw/shdap/broker
new file mode 120000
index 0000000000..5067edee44
--- /dev/null
+++ b/ugw/feeds_ugw/shdap/broker
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_shdap//broker/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap/iotivity_111 b/ugw/feeds_ugw/shdap/iotivity_111
new file mode 120000
index 0000000000..c59cc88f56
--- /dev/null
+++ b/ugw/feeds_ugw/shdap/iotivity_111
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_shdap//iotivity_111/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap/libmmb b/ugw/feeds_ugw/shdap/libmmb
new file mode 120000
index 0000000000..976e3dcb7c
--- /dev/null
+++ b/ugw/feeds_ugw/shdap/libmmb
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_shdap//libmmb/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap/node b/ugw/feeds_ugw/shdap/node
new file mode 120000
index 0000000000..a77e353e8b
--- /dev/null
+++ b/ugw/feeds_ugw/shdap/node
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_shdap//node/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap/ppm b/ugw/feeds_ugw/shdap/ppm
new file mode 120000
index 0000000000..6714ca77f3
--- /dev/null
+++ b/ugw/feeds_ugw/shdap/ppm
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_shdap//ppm/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap/tal b/ugw/feeds_ugw/shdap/tal
new file mode 120000
index 0000000000..388fc69aa5
--- /dev/null
+++ b/ugw/feeds_ugw/shdap/tal
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_shdap//tal/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap/watchdogtimer b/ugw/feeds_ugw/shdap/watchdogtimer
new file mode 120000
index 0000000000..ee9172323e
--- /dev/null
+++ b/ugw/feeds_ugw/shdap/watchdogtimer
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_shdap//watchdogtimer/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap/zmq3 b/ugw/feeds_ugw/shdap/zmq3
new file mode 120000
index 0000000000..c24f0081dc
--- /dev/null
+++ b/ugw/feeds_ugw/shdap/zmq3
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_shdap//zmq3/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap_src/broker b/ugw/feeds_ugw/shdap_src/broker
new file mode 120000
index 0000000000..24d8f92698
--- /dev/null
+++ b/ugw/feeds_ugw/shdap_src/broker
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/shdap_src//broker/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap_src/copernicus-cpp b/ugw/feeds_ugw/shdap_src/copernicus-cpp
new file mode 120000
index 0000000000..cecc011989
--- /dev/null
+++ b/ugw/feeds_ugw/shdap_src/copernicus-cpp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/shdap_src//copernicus-cpp/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap_src/dep b/ugw/feeds_ugw/shdap_src/dep
new file mode 120000
index 0000000000..42d72afd38
--- /dev/null
+++ b/ugw/feeds_ugw/shdap_src/dep
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/shdap_src//dep/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap_src/goddard b/ugw/feeds_ugw/shdap_src/goddard
new file mode 120000
index 0000000000..7e36632308
--- /dev/null
+++ b/ugw/feeds_ugw/shdap_src/goddard
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/shdap_src//goddard/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap_src/tal b/ugw/feeds_ugw/shdap_src/tal
new file mode 120000
index 0000000000..ca604bbd3e
--- /dev/null
+++ b/ugw/feeds_ugw/shdap_src/tal
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/shdap_src//tal/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap_src/watchdogtimer b/ugw/feeds_ugw/shdap_src/watchdogtimer
new file mode 120000
index 0000000000..30fbe42c8c
--- /dev/null
+++ b/ugw/feeds_ugw/shdap_src/watchdogtimer
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/shdap_src//watchdogtimer/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shdap_src/wss_gateway-source b/ugw/feeds_ugw/shdap_src/wss_gateway-source
new file mode 120000
index 0000000000..127097d672
--- /dev/null
+++ b/ugw/feeds_ugw/shdap_src/wss_gateway-source
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/shdap_src//wss_gateway-source/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shgw/shgw b/ugw/feeds_ugw/shgw/shgw
new file mode 120000
index 0000000000..83b8831c2b
--- /dev/null
+++ b/ugw/feeds_ugw/shgw/shgw
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_shgw//shgw/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/shgw/shgw_int b/ugw/feeds_ugw/shgw/shgw_int
new file mode 120000
index 0000000000..1f56079b59
--- /dev/null
+++ b/ugw/feeds_ugw/shgw/shgw_int
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_shgw//shgw_int/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/beerocks-core b/ugw/feeds_ugw/system/beerocks-core
new file mode 120000
index 0000000000..1663e48ed4
--- /dev/null
+++ b/ugw/feeds_ugw/system/beerocks-core
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_beerocks/beerocks-core/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/device_prioritization b/ugw/feeds_ugw/system/device_prioritization
new file mode 120000
index 0000000000..c53a1cc583
--- /dev/null
+++ b/ugw/feeds_ugw/system/device_prioritization
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_device_prioritization/device_prioritization
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/emagii-cpufrequtils b/ugw/feeds_ugw/system/emagii-cpufrequtils
new file mode 120000
index 0000000000..029b77cb9f
--- /dev/null
+++ b/ugw/feeds_ugw/system/emagii-cpufrequtils
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_coc/emagii-cpufrequtils/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/feed_sl_beerocks b/ugw/feeds_ugw/system/feed_sl_beerocks
new file mode 120000
index 0000000000..e6d6ad3fa1
--- /dev/null
+++ b/ugw/feeds_ugw/system/feed_sl_beerocks
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_sl_beerocks
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/feed_sl_client_mode b/ugw/feeds_ugw/system/feed_sl_client_mode
new file mode 120000
index 0000000000..9c8e55af4d
--- /dev/null
+++ b/ugw/feeds_ugw/system/feed_sl_client_mode
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_sl_client_mode
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/feed_sl_wisp b/ugw/feeds_ugw/system/feed_sl_wisp
new file mode 120000
index 0000000000..2262e1053e
--- /dev/null
+++ b/ugw/feeds_ugw/system/feed_sl_wisp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_sl_wisp
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/glibc_container b/ugw/feeds_ugw/system/glibc_container
new file mode 120000
index 0000000000..894b3977b8
--- /dev/null
+++ b/ugw/feeds_ugw/system/glibc_container
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_lxc/glibc_container/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/home_nwk_mgr b/ugw/feeds_ugw/system/home_nwk_mgr
new file mode 120000
index 0000000000..ca4320e444
--- /dev/null
+++ b/ugw/feeds_ugw/system/home_nwk_mgr
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_sl_home_nwk_mgr/home_nwk_mgr/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/ltq-gphy-firmware b/ugw/feeds_ugw/system/ltq-gphy-firmware
new file mode 120000
index 0000000000..0b8fe731a8
--- /dev/null
+++ b/ugw/feeds_ugw/system/ltq-gphy-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gphy_firmware/ltq-gphy-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/ltq-hwmon b/ugw/feeds_ugw/system/ltq-hwmon
new file mode 120000
index 0000000000..e987fdd39e
--- /dev/null
+++ b/ugw/feeds_ugw/system/ltq-hwmon
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_coc/ltq-hwmon/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/ltq-pm-util b/ugw/feeds_ugw/system/ltq-pm-util
new file mode 120000
index 0000000000..4d31c8f903
--- /dev/null
+++ b/ugw/feeds_ugw/system/ltq-pm-util
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_coc/ltq-pm-util/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/ltq-pmcu b/ugw/feeds_ugw/system/ltq-pmcu
new file mode 120000
index 0000000000..77f3b3e444
--- /dev/null
+++ b/ugw/feeds_ugw/system/ltq-pmcu
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_coc/ltq-pmcu/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/ltq-ppmd b/ugw/feeds_ugw/system/ltq-ppmd
new file mode 120000
index 0000000000..fe38779913
--- /dev/null
+++ b/ugw/feeds_ugw/system/ltq-ppmd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_coc/ltq-ppmd/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/ltq-regulator b/ugw/feeds_ugw/system/ltq-regulator
new file mode 120000
index 0000000000..0fbf34dd11
--- /dev/null
+++ b/ugw/feeds_ugw/system/ltq-regulator
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_coc/ltq-regulator/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/ltq-regulator-consumer b/ugw/feeds_ugw/system/ltq-regulator-consumer
new file mode 120000
index 0000000000..461c1c25af
--- /dev/null
+++ b/ugw/feeds_ugw/system/ltq-regulator-consumer
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_coc/ltq-regulator-consumer/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/ltq-regulator-cpufreq b/ugw/feeds_ugw/system/ltq-regulator-cpufreq
new file mode 120000
index 0000000000..7c1f319d9a
--- /dev/null
+++ b/ugw/feeds_ugw/system/ltq-regulator-cpufreq
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_coc/ltq-regulator-cpufreq/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/ltq-temp b/ugw/feeds_ugw/system/ltq-temp
new file mode 120000
index 0000000000..28bd262203
--- /dev/null
+++ b/ugw/feeds_ugw/system/ltq-temp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_coc/ltq-temp/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/ltq_fw_PHY_IP b/ugw/feeds_ugw/system/ltq_fw_PHY_IP
new file mode 120000
index 0000000000..0ef2689ace
--- /dev/null
+++ b/ugw/feeds_ugw/system/ltq_fw_PHY_IP
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_gphy_firmware/ltq_fw_PHY_IP/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/lxc_container b/ugw/feeds_ugw/system/lxc_container
new file mode 120000
index 0000000000..8c3725e102
--- /dev/null
+++ b/ugw/feeds_ugw/system/lxc_container
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_lxc/lxc_container/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/pmistat b/ugw/feeds_ugw/system/pmistat
new file mode 120000
index 0000000000..031dcadd4f
--- /dev/null
+++ b/ugw/feeds_ugw/system/pmistat
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_driver_tools/pmistat/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/pmon b/ugw/feeds_ugw/system/pmon
new file mode 120000
index 0000000000..3c9edec4de
--- /dev/null
+++ b/ugw/feeds_ugw/system/pmon
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_driver_tools/pmon/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/ppacmd b/ugw/feeds_ugw/system/ppacmd
new file mode 120000
index 0000000000..63abfa8966
--- /dev/null
+++ b/ugw/feeds_ugw/system/ppacmd
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_driver_tools/ppacmd/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/priomark b/ugw/feeds_ugw/system/priomark
new file mode 120000
index 0000000000..3140f882ba
--- /dev/null
+++ b/ugw/feeds_ugw/system/priomark
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_device_prioritization/priomark
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/sess_mgmt b/ugw/feeds_ugw/system/sess_mgmt
new file mode 120000
index 0000000000..063103624c
--- /dev/null
+++ b/ugw/feeds_ugw/system/sess_mgmt
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_session_management/sess_mgmt
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/sl_acl b/ugw/feeds_ugw/system/sl_acl
new file mode 120000
index 0000000000..9b4191c0bf
--- /dev/null
+++ b/ugw/feeds_ugw/system/sl_acl
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_acl
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/sl_device_info b/ugw/feeds_ugw/system/sl_device_info
new file mode 120000
index 0000000000..d86c0567a5
--- /dev/null
+++ b/ugw/feeds_ugw/system/sl_device_info
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_device_info
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/sl_diagnostics b/ugw/feeds_ugw/system/sl_diagnostics
new file mode 120000
index 0000000000..89f4eaf3af
--- /dev/null
+++ b/ugw/feeds_ugw/system/sl_diagnostics
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_diagnostics
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/sl_guest_access b/ugw/feeds_ugw/system/sl_guest_access
new file mode 120000
index 0000000000..b7c1b80cbf
--- /dev/null
+++ b/ugw/feeds_ugw/system/sl_guest_access
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_guest_access
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/sl_syslogng b/ugw/feeds_ugw/system/sl_syslogng
new file mode 120000
index 0000000000..6c77b29213
--- /dev/null
+++ b/ugw/feeds_ugw/system/sl_syslogng
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_syslogng
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/sl_upgrade b/ugw/feeds_ugw/system/sl_upgrade
new file mode 120000
index 0000000000..bdc14c1983
--- /dev/null
+++ b/ugw/feeds_ugw/system/sl_upgrade
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_upgrade
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/sl_usb_hosts b/ugw/feeds_ugw/system/sl_usb_hosts
new file mode 120000
index 0000000000..6f60155a0a
--- /dev/null
+++ b/ugw/feeds_ugw/system/sl_usb_hosts
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_usb_hosts
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/sl_user_management b/ugw/feeds_ugw/system/sl_user_management
new file mode 120000
index 0000000000..32599693b3
--- /dev/null
+++ b/ugw/feeds_ugw/system/sl_user_management
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_user_management
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/sl_vendor_cfg b/ugw/feeds_ugw/system/sl_vendor_cfg
new file mode 120000
index 0000000000..4007b5184b
--- /dev/null
+++ b/ugw/feeds_ugw/system/sl_vendor_cfg
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/sl_components/sl_vendor_cfg
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/spdmon-tools b/ugw/feeds_ugw/system/spdmon-tools
new file mode 120000
index 0000000000..b7ea838f92
--- /dev/null
+++ b/ugw/feeds_ugw/system/spdmon-tools
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_driver_tools/spdmon-tools/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/system_service b/ugw/feeds_ugw/system/system_service
new file mode 120000
index 0000000000..9b65148dbe
--- /dev/null
+++ b/ugw/feeds_ugw/system/system_service
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/system_service
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/vrx518_aca_fw b/ugw/feeds_ugw/system/vrx518_aca_fw
new file mode 120000
index 0000000000..2b87deb636
--- /dev/null
+++ b/ugw/feeds_ugw/system/vrx518_aca_fw
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_ppe/vrx518/vrx518_aca_fw
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/vrx518_ppe_fw b/ugw/feeds_ugw/system/vrx518_ppe_fw
new file mode 120000
index 0000000000..7e030f30f5
--- /dev/null
+++ b/ugw/feeds_ugw/system/vrx518_ppe_fw
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_ppe/vrx518/vrx518_ppe_fw
\ No newline at end of file
diff --git a/ugw/feeds_ugw/system/vrx518_tc_drv b/ugw/feeds_ugw/system/vrx518_tc_drv
new file mode 120000
index 0000000000..a12b286016
--- /dev/null
+++ b/ugw/feeds_ugw/system/vrx518_tc_drv
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_dsl_ppe/vrx518/vrx518_tc_drv
\ No newline at end of file
diff --git a/ugw/feeds_ugw/utils/upgrade_utils b/ugw/feeds_ugw/utils/upgrade_utils
new file mode 120000
index 0000000000..94e0d4a0cc
--- /dev/null
+++ b/ugw/feeds_ugw/utils/upgrade_utils
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_ugw_utils/upgrade_utils/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ifx_voip_common b/ugw/feeds_ugw/voip/ifx_voip_common
new file mode 120000
index 0000000000..573bc91355
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ifx_voip_common
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voip/ifx_voip_common/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/libsrtp b/ugw/feeds_ugw/voip/libsrtp
new file mode 120000
index 0000000000..ce7fa7efc5
--- /dev/null
+++ b/ugw/feeds_ugw/voip/libsrtp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice/libs/libsrtp/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/libsrtp-km b/ugw/feeds_ugw/voip/libsrtp-km
new file mode 120000
index 0000000000..ac6b76aaf5
--- /dev/null
+++ b/ugw/feeds_ugw/voip/libsrtp-km
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice/libs/libsrtp-km/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-board-grx750 b/ugw/feeds_ugw/voip/ltq-voice-board-grx750
new file mode 120000
index 0000000000..8e1a944991
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-board-grx750
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-board-grx750/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-board-xrx500 b/ugw/feeds_ugw/voip/ltq-voice-board-xrx500
new file mode 120000
index 0000000000..54da8a56eb
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-board-xrx500
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-board-xrx500/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-c55-dsp-firmware b/ugw/feeds_ugw/voip/ltq-voice-c55-dsp-firmware
new file mode 120000
index 0000000000..487ac69138
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-c55-dsp-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-c55-dsp-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-dspmod b/ugw/feeds_ugw/voip/ltq-voice-dspmod
new file mode 120000
index 0000000000..3ca5c7937f
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-dspmod
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-dspmod/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-duslic_xs b/ugw/feeds_ugw/voip/ltq-voice-duslic_xs
new file mode 120000
index 0000000000..d62960beb7
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-duslic_xs
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-duslic_xs/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-duslic_xs-coef b/ugw/feeds_ugw/voip/ltq-voice-duslic_xs-coef
new file mode 120000
index 0000000000..31f959f528
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-duslic_xs-coef
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-duslic_xs-coef/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-duslic_xs-firmware b/ugw/feeds_ugw/voip/ltq-voice-duslic_xs-firmware
new file mode 120000
index 0000000000..7da3c19bf0
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-duslic_xs-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-duslic_xs-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-grx750-coef b/ugw/feeds_ugw/voip/ltq-voice-grx750-coef
new file mode 120000
index 0000000000..3cf78f346a
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-grx750-coef
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-grx750-coef/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-grx750-slic220-firmware b/ugw/feeds_ugw/voip/ltq-voice-grx750-slic220-firmware
new file mode 120000
index 0000000000..6a2c610abf
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-grx750-slic220-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-grx750-slic220-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-kpi2udp b/ugw/feeds_ugw/voip/ltq-voice-kpi2udp
new file mode 120000
index 0000000000..50a5fa41cd
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-kpi2udp
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-kpi2udp/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-ni b/ugw/feeds_ugw/voip/ltq-voice-ni
new file mode 120000
index 0000000000..afbee9c159
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-ni
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-ni/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-palsys b/ugw/feeds_ugw/voip/ltq-voice-palsys
new file mode 120000
index 0000000000..35c7dac555
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-palsys
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-palsys/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-sdd-mbx b/ugw/feeds_ugw/voip/ltq-voice-sdd-mbx
new file mode 120000
index 0000000000..f05c392a91
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-sdd-mbx
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-sdd-mbx/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-tapi b/ugw/feeds_ugw/voip/ltq-voice-tapi
new file mode 120000
index 0000000000..3dc44a6553
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-tapi
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-tapi/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-tapi-cli b/ugw/feeds_ugw/voip/ltq-voice-tapi-cli
new file mode 120000
index 0000000000..ca81a30455
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-tapi-cli
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-tapi-cli/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-tapi-lib-country b/ugw/feeds_ugw/voip/ltq-voice-tapi-lib-country
new file mode 120000
index 0000000000..8d9c86b30b
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-tapi-lib-country
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-tapi-lib-country/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-tapi-lib-nlt b/ugw/feeds_ugw/voip/ltq-voice-tapi-lib-nlt
new file mode 120000
index 0000000000..6efcdb2482
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-tapi-lib-nlt
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-tapi-lib-nlt/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-tapi-sipua b/ugw/feeds_ugw/voip/ltq-voice-tapi-sipua
new file mode 120000
index 0000000000..c63911bb53
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-tapi-sipua
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-tapi-sipua/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-tapidemo b/ugw/feeds_ugw/voip/ltq-voice-tapidemo
new file mode 120000
index 0000000000..a27e0a2dc8
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-tapidemo
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-tapidemo/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-tapidump b/ugw/feeds_ugw/voip/ltq-voice-tapidump
new file mode 120000
index 0000000000..15fc2ee283
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-tapidump
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-tapidump/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-usr-demo b/ugw/feeds_ugw/voip/ltq-voice-usr-demo
new file mode 120000
index 0000000000..94fb82e860
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-usr-demo
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-usr-demo/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-vmmc b/ugw/feeds_ugw/voip/ltq-voice-vmmc
new file mode 120000
index 0000000000..2a71c3b5a2
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-vmmc
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-vmmc/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-vmmc-grx750 b/ugw/feeds_ugw/voip/ltq-voice-vmmc-grx750
new file mode 120000
index 0000000000..94f1c63f20
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-vmmc-grx750
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-vmmc-grx750/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx200-coef b/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx200-coef
new file mode 120000
index 0000000000..1d6e6765df
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx200-coef
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-vmmc-xrx200-coef/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx200-firmware b/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx200-firmware
new file mode 120000
index 0000000000..25d1665ccd
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx200-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-vmmc-xrx200-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx300-coef b/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx300-coef
new file mode 120000
index 0000000000..fa6ba32591
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx300-coef
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-vmmc-xrx300-coef/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx300-firmware b/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx300-firmware
new file mode 120000
index 0000000000..0cf558319d
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx300-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-vmmc-xrx300-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx500 b/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx500
new file mode 120000
index 0000000000..1c91686b07
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx500
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-vmmc-xrx500/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx500-coef b/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx500-coef
new file mode 120000
index 0000000000..79953a72e5
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx500-coef
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-vmmc-xrx500-coef/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx500-firmware b/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx500-firmware
new file mode 120000
index 0000000000..5eb56b233e
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-vmmc-xrx500-firmware
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-vmmc-xrx500-firmware/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq-voice-wineasy b/ugw/feeds_ugw/voip/ltq-voice-wineasy
new file mode 120000
index 0000000000..23e2ced893
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq-voice-wineasy
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice_cpe/ltq-voice-wineasy/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/ltq_voip b/ugw/feeds_ugw/voip/ltq_voip
new file mode 120000
index 0000000000..f0de1a7aca
--- /dev/null
+++ b/ugw/feeds_ugw/voip/ltq_voip
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voip/ltq_voip/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/pjproject b/ugw/feeds_ugw/voip/pjproject
new file mode 120000
index 0000000000..8d33d2335c
--- /dev/null
+++ b/ugw/feeds_ugw/voip/pjproject
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voice/libs/pjproject/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/voip/sl_voip b/ugw/feeds_ugw/voip/sl_voip
new file mode 120000
index 0000000000..6f39fc0a20
--- /dev/null
+++ b/ugw/feeds_ugw/voip/sl_voip
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_voip/sl_voip/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/web/web-cgi b/ugw/feeds_ugw/web/web-cgi
new file mode 120000
index 0000000000..97a68cada7
--- /dev/null
+++ b/ugw/feeds_ugw/web/web-cgi
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/webui/web-cgi/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/web/websockets b/ugw/feeds_ugw/web/websockets
new file mode 120000
index 0000000000..8d2cfff255
--- /dev/null
+++ b/ugw/feeds_ugw/web/websockets
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/webui/websockets/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/fapi_wlan_common b/ugw/feeds_ugw/wlan/fapi_wlan_common
new file mode 120000
index 0000000000..dfa79af982
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/fapi_wlan_common
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/fapi_wlan_common
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/fapi_wlan_common_6x b/ugw/feeds_ugw/wlan/fapi_wlan_common_6x
new file mode 120000
index 0000000000..1efb91c5b5
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/fapi_wlan_common_6x
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/fapi_wlan_common_6x
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/fapi_wlan_vendor_mtk b/ugw/feeds_ugw/wlan/fapi_wlan_vendor_mtk
new file mode 120000
index 0000000000..53c7ca8574
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/fapi_wlan_vendor_mtk
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/fapi_wlan_vendor_mtk
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/fapi_wlan_vendor_qca b/ugw/feeds_ugw/wlan/fapi_wlan_vendor_qca
new file mode 120000
index 0000000000..fbe2f75f7f
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/fapi_wlan_vendor_qca
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/fapi_wlan_vendor_qca
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/fapi_wlan_vendor_wave b/ugw/feeds_ugw/wlan/fapi_wlan_vendor_wave
new file mode 120000
index 0000000000..789dc8c5d2
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/fapi_wlan_vendor_wave
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/fapi_wlan_vendor_wave
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/fapi_wlan_vendor_wave_6x b/ugw/feeds_ugw/wlan/fapi_wlan_vendor_wave_6x
new file mode 120000
index 0000000000..c226c42c42
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/fapi_wlan_vendor_wave_6x
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/fapi_wlan_vendor_wave_6x
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/feed_fapi_wlan b/ugw/feeds_ugw/wlan/feed_fapi_wlan
new file mode 120000
index 0000000000..a156101b75
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/feed_fapi_wlan
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_fapi_wlan
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/feed_sl_wlan b/ugw/feeds_ugw/wlan/feed_sl_wlan
new file mode 120000
index 0000000000..f3e0679ba0
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/feed_sl_wlan
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_sl_wlan
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/feed_sl_wlan_6x b/ugw/feeds_ugw/wlan/feed_sl_wlan_6x
new file mode 120000
index 0000000000..f4cc431541
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/feed_sl_wlan_6x
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/ugw_components/feed_sl_wlan_6x
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/wlan_feed b/ugw/feeds_ugw/wlan/wlan_feed
new file mode 120000
index 0000000000..ac742c368c
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/wlan_feed
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_wlan/wlan_feed
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/wlan_wave_feed/crda_wave b/ugw/feeds_ugw/wlan/wlan_wave_feed/crda_wave
new file mode 120000
index 0000000000..8d982a58c0
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/wlan_wave_feed/crda_wave
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_wlan_5_x/wlan_wave_feed/crda_wave/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/wlan_wave_feed/hostapd_wave b/ugw/feeds_ugw/wlan/wlan_wave_feed/hostapd_wave
new file mode 120000
index 0000000000..db3837467a
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/wlan_wave_feed/hostapd_wave
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_wlan_5_x/wlan_wave_feed/hostapd_wave/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/wlan_wave_feed/iw_wave b/ugw/feeds_ugw/wlan/wlan_wave_feed/iw_wave
new file mode 120000
index 0000000000..7ad0276e45
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/wlan_wave_feed/iw_wave
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_wlan_5_x/wlan_wave_feed/iw_wave/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/wlan_wave_feed/lq-wave-300_5_x b/ugw/feeds_ugw/wlan/wlan_wave_feed/lq-wave-300_5_x
new file mode 120000
index 0000000000..4839b1c32e
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/wlan_wave_feed/lq-wave-300_5_x
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_wlan_5_x/wlan_wave_feed/lq-wave-300_5_x/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/WFA_Sigma_Test_Suite b/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/WFA_Sigma_Test_Suite
new file mode 120000
index 0000000000..c711434077
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/WFA_Sigma_Test_Suite
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_wlan_6x/wlan_wave_feed/WFA_Sigma_Test_Suite/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/crda_wave_6x b/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/crda_wave_6x
new file mode 120000
index 0000000000..125f3a36e1
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/crda_wave_6x
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_wlan_6x/wlan_wave_feed/crda_wave_6x/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/hostapd_wave_6x b/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/hostapd_wave_6x
new file mode 120000
index 0000000000..27e5eb0e90
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/hostapd_wave_6x
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_wlan_6x/wlan_wave_feed/hostapd_wave_6x/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/iw_wave_6x b/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/iw_wave_6x
new file mode 120000
index 0000000000..87c50c9099
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/iw_wave_6x
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_wlan_6x/wlan_wave_feed/iw_wave_6x/
\ No newline at end of file
diff --git a/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/lq-wave-300_6x b/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/lq-wave-300_6x
new file mode 120000
index 0000000000..c126242765
--- /dev/null
+++ b/ugw/feeds_ugw/wlan/wlan_wave_feed_6x/lq-wave-300_6x
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_wlan_6x/wlan_wave_feed/lq-wave-300_6x/
\ No newline at end of file
diff --git a/ugw/gendocs.sh b/ugw/gendocs.sh
new file mode 120000
index 0000000000..4f6cb6eb53
--- /dev/null
+++ b/ugw/gendocs.sh
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/config_cpe/gendocs.sh
\ No newline at end of file
diff --git a/ugw/target/linux/intel-x86 b/ugw/target/linux/intel-x86
new file mode 120000
index 0000000000..ca58c8a948
--- /dev/null
+++ b/ugw/target/linux/intel-x86
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_target_x86
\ No newline at end of file
diff --git a/ugw/target/linux/intel-xway b/ugw/target/linux/intel-xway
new file mode 120000
index 0000000000..1f378456d7
--- /dev/null
+++ b/ugw/target/linux/intel-xway
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/feed_target_xway
\ No newline at end of file
diff --git a/ugw/target/linux/lantiq b/ugw/target/linux/lantiq
new file mode 120000
index 0000000000..adfcf7e944
--- /dev/null
+++ b/ugw/target/linux/lantiq
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/target/target_linux_lantiq
\ No newline at end of file
diff --git a/ugw/target/linux/x86/base-files-openwrt b/ugw/target/linux/x86/base-files-openwrt
new file mode 120000
index 0000000000..7756cc4394
--- /dev/null
+++ b/ugw/target/linux/x86/base-files-openwrt
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/rootfs/openwrt_ltq_rootfs_source
\ No newline at end of file
diff --git a/ugw/target/linux/x86/base-files-ugw-newframework b/ugw/target/linux/x86/base-files-ugw-newframework
new file mode 120000
index 0000000000..ddb805926b
--- /dev/null
+++ b/ugw/target/linux/x86/base-files-ugw-newframework
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/rootfs/ugw_newframework_basefiles
\ No newline at end of file
diff --git a/ugw/target/linux/x86/base-files.mk b/ugw/target/linux/x86/base-files.mk
new file mode 120000
index 0000000000..733882be0f
--- /dev/null
+++ b/ugw/target/linux/x86/base-files.mk
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/target/target_linux_lantiq/base-files.mk
\ No newline at end of file
diff --git a/ugw/target/linux/x86/files b/ugw/target/linux/x86/files
new file mode 120000
index 0000000000..04588fbe50
--- /dev/null
+++ b/ugw/target/linux/x86/files
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/drivers/drivers_config/files-3.12
\ No newline at end of file
diff --git a/ugw/target/linux/x86/image/Config.in b/ugw/target/linux/x86/image/Config.in
new file mode 120000
index 0000000000..174cf26e28
--- /dev/null
+++ b/ugw/target/linux/x86/image/Config.in
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/target/target_linux_puma/image/Config.in
\ No newline at end of file
diff --git a/ugw/target/linux/x86/patches-3.12 b/ugw/target/linux/x86/patches-3.12
new file mode 120000
index 0000000000..4e35db5880
--- /dev/null
+++ b/ugw/target/linux/x86/patches-3.12
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/puma_kernel_patches
\ No newline at end of file
diff --git a/ugw/target/linux/x86/puma b/ugw/target/linux/x86/puma
new file mode 120000
index 0000000000..e13a7ae70c
--- /dev/null
+++ b/ugw/target/linux/x86/puma
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/target/target_linux_puma
\ No newline at end of file
diff --git a/ugw/target/ugw-sdk b/ugw/target/ugw-sdk
new file mode 120000
index 0000000000..fbc53cf3b6
--- /dev/null
+++ b/ugw/target/ugw-sdk
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/target/ltq-sdk
\ No newline at end of file
diff --git a/ugw/ugw-prepare-all.sh b/ugw/ugw-prepare-all.sh
new file mode 120000
index 0000000000..7dbf8b2ccc
--- /dev/null
+++ b/ugw/ugw-prepare-all.sh
@@ -0,0 +1 @@
+/local/chdauto_2/work/build/ugw_sw/ugw/config_cpe/ugw-prepare-all.sh
\ No newline at end of file
diff --git a/ugw/ugw_version b/ugw/ugw_version
new file mode 100644
index 0000000000..b3b8925b7b
--- /dev/null
+++ b/ugw/ugw_version
@@ -0,0 +1 @@
+7.5.1.40
diff --git a/ugw_version b/ugw_version
new file mode 100644
index 0000000000..b3b8925b7b
--- /dev/null
+++ b/ugw_version
@@ -0,0 +1 @@
+7.5.1.40
