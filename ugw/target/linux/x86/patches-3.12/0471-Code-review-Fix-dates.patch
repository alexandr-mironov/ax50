From 588b17c9f468963cb3df692ffb42f8ef01b16fae Mon Sep 17 00:00:00 2001
From: ofirbitt <ofir1.bitton@intel.com>
Date: Thu, 1 Sep 2016 10:39:36 +0300
Subject: [PATCH 471/639] * Code review - Fix dates * Import silicon step
 function from UGW

Signed-off-by: Ofir Bitton <ofir1.bitton@intel.com>

Kernel: Align Arm & Atom PP Kernel Changes - Periodic sync between headers and sources:
	Summary of 55 commits which was merged from arm kernel

commit 3657d835d45609d293852e4f024502605cfb2e11
Merge: a87fe21 56fd5c1
Author: Bitton, Ofir1 <ofir1.bitton@intel.com>
Date:   Mon Aug 22 14:03:15 2016 +0200

    Merge pull request #11 in SW_ARM/arm-intelce-kernel from feature/ARMBUILDSW-276 to D3.1_GW-SDK7.0_int
--
    * commit '56fd5c18d84a2b05826b517f58201edf30ffeacc':
      Modify wifi proxy server

Notes:
    Title: Add multi vap support configs
    Issue: ARMBUILDSW-276
--
commit a87fe2136af66b23ca4f6589a15a12736c14e2b3
Merge: b019358 9eb9618
Author: Gerber, Eli <eli.gerber@intel.com>
Date:   Mon Aug 22 13:09:33 2016 +0200

    Merge pull request #15 in SW_ARM/arm-intelce-kernel from Feature/PSMQuerySupport to D3.1_GW-SDK7.0_int
--
    * commit '9eb9618dee5e21ea99392198c8f3ec2476e43283':
      ARMBUILDSW-278: Switch to direct communication with CPPI through proc

Notes:
    Title: Add support for CPPI PM querry
    Issue: Jira ARMBUILDSW-278
--
commit 9eb9618dee5e21ea99392198c8f3ec2476e43283
Author: egerber <eli.gerber@intel.com>
Date:   Sun Aug 21 14:03:11 2016 +0300

    ARMBUILDSW-278: Switch to direct communication with CPPI through proc

commit b0193582a5729b283b447558bd71792bbcdf3c6d
Merge: 6dbf21b e64819f
Author: Fernandes, Elad <elad.fernandes@intel.com>
Date:   Thu Aug 18 10:04:33 2016 +0200

    Merge pull request #13 in SW_ARM/arm-intelce-kernel from feature/AddL2TPv3TerminationSupport to D3.1_GW-SDK7.0_int
--
    * commit 'e64819fdf04dbc75840e19de24d0e82a836e6cc1':
      ARMBUILDSW-279 Support L2TPv3 termination acceleration in PP

Notes:
    Title: ARMBUILDSW-279 Support L2TPv3 termination acceleration in PP
    Issue: 279
--
commit e64819fdf04dbc75840e19de24d0e82a836e6cc1
Author: Fernandes Elad <elad.fernandes@intel.com>
Date:   Thu Aug 18 10:36:23 2016 +0300

    ARMBUILDSW-279 Support L2TPv3 termination acceleration in PP

commit 6dbf21be00d53aa5debb321c5c7fc27354a788cb
Merge: 5cac2f7 3f9d483
Author: Gerber, Eli <eli.gerber@intel.com>
Date:   Wed Aug 17 17:13:24 2016 +0200

    Merge pull request #12 in SW_ARM/arm-intelce-kernel from Feature/LPMQuerySupport to D3.1_GW-SDK7.0_int
--
    * commit '3f9d483d515232023dcfaf336ad527e8b9454751':
      ARMBUILDSW-278: CPPI PM querry support

Notes:
    Title: Add support for CPPI PM querry
    Issue: Jira ARMBUILDSW-278
--
commit 3f9d483d515232023dcfaf336ad527e8b9454751
Author: egerber <eli.gerber@intel.com>
Date:   Tue Aug 16 18:27:03 2016 +0300

    ARMBUILDSW-278: CPPI PM querry support

commit 56fd5c18d84a2b05826b517f58201edf30ffeacc
Author: ofirbitt <ofir1.bitton@intel.com>
Date:   Wed Aug 17 14:51:40 2016 +0300

    Modify wifi proxy server

commit 5cac2f714933845a569b4e07e163a5836d1ab7ea
Merge: 4fb444c 369c16e
Author: Rudek, Mark <mark.rudek@intel.com>
Date:   Tue Aug 16 11:30:32 2016 +0200

    Merge pull request #9 in SW_ARM/arm-intelce-kernel from Feature/HSD_247771_Separate_SKB_CPPI to D3.1_GW-SDK7.0_int
--
    * commit '369c16efd96bda7f5bb0333e0eea3c9813f14476':
      Separate the SKB allocation from the CPPI

commit 369c16efd96bda7f5bb0333e0eea3c9813f14476
Author: mrudek <mark.rudek@intel.com>
Date:   Mon Aug 15 18:30:00 2016 +0300

    Separate the SKB allocation from the CPPI

commit 4fb444c755ed7e5cd31e5b2cc973bcbd4c7a7782
Merge: 59707a8 3b794c3
Author: Dadosh, Peled <peled.dadosh@intel.com>
Date:   Mon Aug 15 13:01:12 2016 +0200

    Merge pull request #7 in SW_ARM/arm-intelce-kernel from Feature/BBU_Manager_PUMA7 to D3.1_GW-SDK7.0_int
--
    * commit '3b794c312ee0e3b62bd216ad2945e7ae9c4ecf92':
      Integrate new BBU7 feature

Notes:
     Title:Integrate new BBU7 feature to SDK7.0
     Issue: HSD_247293
--
commit 59707a875f1035fc013dea61d34f7d6a31b5a587
Merge: 595b618 201dbc0
Author: Bitton, Ofir1 <ofir1.bitton@intel.com>
Date:   Sun Aug 14 17:56:47 2016 +0200

    Merge pull request #6 in SW_ARM/arm-intelce-kernel from feature/HSD_247638 to D3.1_GW-SDK7.0_int
--
    * commit '201dbc02b583509dfd753323ce951500a02c426a':
      Code review fixes
      HSD_247638 - Add arm capability to use only GMAC4 - Allocate new queues & tx complete interrupt for arm

Notes:
    Title: Add Arm no pp flavor
--
commit 3b794c312ee0e3b62bd216ad2945e7ae9c4ecf92
Author: pdadosh <peled.dadosh@intel.com>
Date:   Sun Aug 14 17:00:52 2016 +0300

    Integrate new BBU7 feature

commit 201dbc02b583509dfd753323ce951500a02c426a
Author: ofirbitt <ofir1.bitton@intel.com>
Date:   Sun Aug 14 16:25:12 2016 +0300

    Code review fixes

commit 3450962a9df5c4ac8c2237a671c5415b0e8e0df0
Author: ofirbitt <ofir1.bitton@intel.com>
Date:   Thu Aug 11 18:19:11 2016 +0300

    HSD_247638 - Add arm capability to use only GMAC4 - Allocate new queues & tx complete interrupt for arm

--
commit 595b618d47f17f12404ecf8f3a38662ed9254673
Merge: b028b88 70c0464
Author: Emergi, Idan <idan.emergi@intel.com>
Date:   Sun Aug 14 11:06:34 2016 +0200

    Merge pull request #5 in SW_ARM/arm-intelce-kernel from Feature/wifiFullOffloadIntegration to D3.1_GW-SDK7.0_int
--
    * commit '70c0464e7eb1e3fecb5b07c19da9b7aa9a70adc8':
      ARMBUILDSW-275: Wifi Full offload integration changes

Notes:
    Wifi Full offload integration
    Issue: Jira: ARMBUILDSW-275
--
commit 70c0464e7eb1e3fecb5b07c19da9b7aa9a70adc8
Author: iemergi <idan.emergi@intel.com>
Date:   Thu Aug 11 20:39:37 2016 +0300

    ARMBUILDSW-275: Wifi Full offload integration changes

--
commit b028b88e8d9a5b7955f1464a77221f06cff83af8
Merge: 9c1ec73 9fde3ab
Author: Fernandes, Elad <elad.fernandes@intel.com>
Date:   Sun Aug 14 08:58:54 2016 +0200

    Merge pull request #3 in SW_ARM/arm-intelce-kernel from feature/AddL2TPv3PassThroughSupport to D3.1_GW-SDK7.0_int
--
    * commit '9fde3ab052734aa5eb1864c38e3091a2024df1f8':
      ARMBUILDSW-274 Support acceleration of L2TPv3 pass-through traffic in PP

Notes:
    Title: ARMBUILDSW-274 Support acceleration of L2TPv3 pass-through traffic in PP
    Issue: 274
--
commit 9c1ec73a68d6a9f220b5b446210a7ca9be01fc01
Merge: b3c10a0 34bd991
Author: Gerber, Eli <eli.gerber@intel.com>
Date:   Thu Aug 11 18:39:08 2016 +0200

    Merge pull request #1 in SW_ARM/arm-intelce-kernel from feature/ppSanityTestTool to D3.1_GW-SDK7.0_int
--
    * commit '34bd9910b7128f10c4a991ccc75a4e8d2dedd846':
      ARMBUILDSW-273: CR1 fixes
      ARMBUILDSW-273 Stage 1 implementation

Notes:
    Title: Add support in PP traffic generator tool
--
commit 34bd9910b7128f10c4a991ccc75a4e8d2dedd846
Author: egerber <eli.gerber@intel.com>
Date:   Thu Aug 11 17:34:02 2016 +0300

    ARMBUILDSW-273: CR1 fixes

commit 9fde3ab052734aa5eb1864c38e3091a2024df1f8
Author: Fernandes Elad <elad.fernandes@intel.com>
Date:   Thu Aug 11 15:13:35 2016 +0300

    ARMBUILDSW-274 Support acceleration of L2TPv3 pass-through traffic in PP

commit 29edd47d54b51085fdbb9de54fe05ed340d00e4f
Author: egerber <eli.gerber@intel.com>
Date:   Thu Aug 11 11:21:51 2016 +0300

    ARMBUILDSW-273 Stage 1 implementation

commit b3c10a0cd43b93c77be20abb180f13b0d540bd79
Merge: 0364b48 b712613
Author: mrudek <mark.rudek@intel.com>
Date:   Mon Aug 8 17:10:00 2016 +0300

    Merge branch 'HSD_247642' into D3.1_GW-SDK7.0_int
--
commit b7126133c51cfcf991e9ab37e4ff31be3b41af1f
Author: mrudek <mark.rudek@intel.com>
Date:   Mon Aug 8 16:50:23 2016 +0300

    HSD_247642 - Add PP-Less build flavor to defconfig

--
commit 0364b488b2d47dddef219a47304b0dc8cce7d50c
Merge: 28fc9af 746e151
Author: iemergi <idan.emergi@intel.com>
Date:   Wed Jul 27 16:41:57 2016 +0300

    Merge branch 'HSD_247531' into D3.1_GW-SDK7.0_int
--
commit 746e151e9e9ab9a2df2e861f2b830380b95feaab
Author: iemergi <idan.emergi@intel.com>
Date:   Wed Jul 27 16:20:37 2016 +0300

    HSD_247531 - WIFI direct connect support

--
commit 28fc9af6a148c8dd3573b2ed7221dbf42b914e24
Merge: 42d89f7 2ce3299
Author: ybiran <yaniv.biran@intel.com>
Date:   Sun Jul 24 15:33:56 2016 +0300

    Merge branch 'HSD_247402' into D3.1_GW-SDK7.0_int
--
commit 2ce32990992849e443908553efe07de872ba2ad2
Author: ybiran <yaniv.biran@intel.com>
Date:   Sun Jul 24 15:17:25 2016 +0300

    HSD_247402 - [CGP - Yocto 2.0] LV failure - Policy 1 MicroSemi Tid. - Fixed compilation issue

--
commit a1af51cb884435098bf75522f2258b8bb49601b1
Author: ybiran <yaniv.biran@intel.com>
Date:   Sun Jul 24 13:22:03 2016 +0300

    HSD_247402 - [CGP - Yocto 2.0] LV failure - Policy 1 MicroSemi Tid. - Integrated changes from SDK2.0

--
commit 42d89f7489be04058c36e98288242aa2b949e175
Merge: 01dfac0 a23fb4e
Author: Fernandes Elad <elad.fernandes@intel.com>
Date:   Thu Jul 21 16:03:47 2016 +0300

    Merge branch 'HSD_247485' into D3.1_GW-SDK7.0_int
--
commit a23fb4e2cfa914cf21e35a9e6aeb919315ce88dc
Author: Fernandes Elad <elad.fernandes@intel.com>
Date:   Thu Jul 21 12:16:50 2016 +0300

    HSD_247485 - Adding acceleration support for new types of tunnels in PP

--
commit 01dfac09db54ff40d2337fb3054d4990e1e99377
Merge: 8a87ebe 81ef916
Author: ylermanx <ylermanx@intel.com>
Date:   Wed Jul 20 18:49:53 2016 +0300

    Merge branch 'HSD_245978' into D3.1_GW-SDK7.0_int
--
commit 81ef916d051d981418f1be7af9f7801acf696083
Author: ylermanx <ylermanx@intel.com>
Date:   Wed Jul 20 18:36:27 2016 +0300

    HSD_245978 - Automatic CRLF replacement by LF, prevent different line ending formats

--
commit 8a87ebe42bd5deb31c5c0462bc51c60b01c7157c
Merge: 39af34d c235723
Author: Fernandes Elad <elad.fernandes@intel.com>
Date:   Tue Jul 19 10:44:27 2016 +0300

    Merge branch 'HSD_247490' into D3.1_GW-SDK7.0_int
--
commit c235723c2b9291444d5849df535748470b3c01c8
Author: Fernandes Elad <elad.fernandes@intel.com>
Date:   Mon Jul 18 13:06:57 2016 +0300

    HSD_247490 - Adding QoS queue shaping support (rate limit for specific QoS queue)

--
commit 39af34d2b72aa64776caf4f5ad9db054525fecc6
Merge: 79c5aea ab28ad9
Author: Fernandes Elad <elad.fernandes@intel.com>
Date:   Thu Jul 14 18:24:47 2016 +0300

    Merge branch 'HSD_247459' into D3.1_GW-SDK7.0_int
--
commit ab28ad99fe6e1a45b2f3a9374b886f3aed871dbd
Author: Fernandes Elad <elad.fernandes@intel.com>
Date:   Thu Jul 14 18:20:53 2016 +0300

    HSD_247459 - SF-09.3| High priority Packets not getting precedence in case of non-accelerated traffic

--
commit 79c5aea7b177e342ff8009582e6cf72339eff18e
Merge: e13df0d 95daacd
Author: ofirbitt <ofir1.bitton@intel.com>
Date:   Sun Jul 10 18:41:10 2016 +0300

    Merge branch 'HSD_247388' into D3.1_GW-SDK7.0_int
--
commit 95daacd99e3a8d969fa5052f0d89f70bdbd60e11
Author: ofirbitt <ofir1.bitton@intel.com>
Date:   Sun Jul 10 16:04:31 2016 +0300

    HSD_247388 - [RDKB] Arm get hang and then perform reset (2.0.0.31) - Added 12 reserved bytes until atom sync

--
commit e13df0dc775491725e49837aa99a6f0b3b5811bf
Merge: ad4b378 01e5772
Author: Fernandes Elad <elad.fernandes@intel.com>
Date:   Thu Jul 7 17:41:03 2016 +0300

    Merge branch 'HSD_247360' into D3.1_GW-SDK2.0_int
--
commit 01e577235d6ffe590be03c25a738f05ec3041855
Author: Fernandes Elad <elad.fernandes@intel.com>
Date:   Thu Jul 7 15:37:34 2016 +0300

    HSD_247360 - Support Padding in PP FW for Moca traffic - Linux

--
commit ad4b378d8f04c496b8d86881f101309dc4b431a0
Merge: 1dc21a1 61fad25
Author: tshapira <tal.shapira@intel.com>
Date:   Thu Jul 7 15:17:54 2016 +0300

    Merge branch 'HSD_246297' into D3.1_GW-SDK2.0_int
--
commit 61fad257d136849ad69dcadeef9653754c98c12b
Author: tshapira <tal.shapira@intel.com>
Date:   Thu Jul 7 15:06:36 2016 +0300

    HSD_246297 - marge avalanch_pp -

--
commit 1dc21a10abeee7903a25404c1ac27f0a1e6b94cf
Merge: 2d4f1b0 098f407
Author: tshapira <tal.shapira@intel.com>
Date:   Thu Jul 7 12:21:29 2016 +0300

    Merge branch 'HSD_246297' into D3.1_GW-SDK2.0_int
--
commit 098f407a504d35ce144589303d999cef7fb75b47
Author: tshapira <tal.shapira@intel.com>
Date:   Thu Jul 7 11:56:13 2016 +0300

    HSD_246297 - marge avalanch_pp - marge avalnche_pp

--
commit 2d4f1b0fd2948d912da3dcdbb60ffd7f94f5180e
Merge: 7341438 d3f17c2
Author: avishalo <avi1.shalom@intel.com>
Date:   Wed Jul 6 14:14:38 2016 +0300

    Merge branch 'HSD_246667' into D3.1_GW-SDK2.0_int
--
commit d3f17c2fb8f67ade1ec15389200d47b2e58fea53
Author: avishalo <avi1.shalom@intel.com>
Date:   Wed Jul 6 11:50:45 2016 +0300

    HSD_246667 - fix session cache - fifo interface - Change global counters
     Link:https://vthsd.intel.com/hsd/ceswe/unified_defect/default.aspx?unified_defect_id=246667
--
commit 73414389d279c60d3185d21ab68921a0601e8858
Merge: 02c3a41 0d6b9de
Author: Fernandes Elad <elad.fernandes@intel.com>
Date:   Wed Jul 6 12:22:03 2016 +0300

    Merge branch 'HSD_246984' into D3.1_GW-SDK2.0_int
--
commit 0d6b9deb2885053751b0e9a507c8ccbadc834428
Author: Fernandes Elad <elad.fernandes@intel.com>
Date:   Wed Jul 6 11:08:55 2016 +0300

    HSD_246984 - Low DS TCP traffic on realtek switch when data is from DS to ETH - Adding PP QoS Port Shaper support + LAN link speed events

--
commit 02c3a41c27a706c4bb5d58659aeae06f29aabfea
Merge: 504ab0a 4d27d9b
Author: ikolomin <ilia.kolominsky@intel.com>
Date:   Tue Jul 5 16:58:28 2016 +0300

    Merge branch 'HSD_245630' into D3.1_GW-SDK2.0_int
--
commit 4d27d9b95cc7d8735ffd1f2f893a748ecf460345
Author: ikolomin <ilia.kolominsky@intel.com>
Date:   Tue Jul 5 16:43:58 2016 +0300

    HSD_245630 - Modphy KGREGS should be configurable from user-supplied binary files

--
commit 504ab0ae7c293d0fe27bc3f18324f1549579201f
Merge: ac48cb6 b5a93ba
Author: pdadosh <peled.dadosh@intel.com>
Date:   Sun Jul 3 14:37:42 2016 +0300

    Merge branch 'HSD_247001' into D3.1_GW-SDK2.0_int
--
commit b5a93bae912918ced9338f1fa42c08d52ef6d96d
Author: pdadosh <peled.dadosh@intel.com>
Date:   Wed Jun 29 14:56:36 2016 +0300

    HSD_247001 - Integrate new BBU7 feature to SDK2.0

--
commit ac48cb62c8931cad304fedc90fa20a68245b1c3d
Merge: 5bcc3f3 32da11c
Author: ofirbitt <ofir1.bitton@intel.com>
Date:   Wed Jun 29 18:31:57 2016 +0300

    Merge branch 'HSD_245911' into D3.1_GW-SDK2.0_int
--
commit 32da11c83e48b69d4e82ffcc72bd3b2c332fd102
Author: ofirbitt <ofir1.bitton@intel.com>
Date:   Wed Jun 29 16:19:44 2016 +0300

    HSD_245911 - Prevent host from reaching 100% cpu - Add accumulator cmds
---
 arch/x86/NetIP_SubSystem/netip_mem_util.c          |   3 +-
 arch/x86/NetIP_SubSystem/netip_subsystem_config.c  |  38 ++-
 arch/x86/NetIP_SubSystem/netip_subsystem_lld.c     |   7 +-
 arch/x86/pal_cppi41/pal_cppi41.c                   |  49 ++++
 .../linux/avalanche/generic/avalanche_pdsp_api.h   |  16 +-
 include/linux/avalanche/generic/avalanche_pp_api.h | 279 +++++++++++++++------
 include/linux/avalanche/generic/pal.h              |   2 +
 include/linux/avalanche/generic/pal_cppi41.h       |  27 ++
 include/linux/avalanche/generic/pal_osCfg.h        |   2 +-
 include/linux/avalanche/generic/pal_osTimer.h      | 154 ++++++++++++
 .../linux/avalanche/generic/pal_osTimer_inline.h   | 146 +++++++++++
 include/linux/avalanche/generic/pp_qos_p7.h        |  76 +++++-
 .../linux/avalanche/puma7/puma7_cppi_bmgr_pools.h  |  75 ++++++
 .../linux/avalanche/puma7/puma7_cppi_gqmgr2_q.h    |  18 +-
 include/linux/avalanche/puma7/puma7_cppi_prv.h     |  84 ++++---
 include/linux/avalanche/puma7/puma7_pp.h           |   3 +-
 .../linux/avalanche/puma7/synopsys_gbe_interface.h |  40 ++-
 include/linux/hw_mbox_defs.h                       |   4 +-
 include/linux/netip_subsystem.h                    |   4 +
 include/linux/ti_hil.h                             |  19 ++
 net/l2tp/l2tp_core.c                               |  21 +-
 net/ti/pp/ti_hil_core.c                            |   0
 22 files changed, 914 insertions(+), 153 deletions(-)
 create mode 100755 include/linux/avalanche/generic/pal_osTimer.h
 create mode 100755 include/linux/avalanche/generic/pal_osTimer_inline.h
 create mode 100755 include/linux/avalanche/puma7/puma7_cppi_bmgr_pools.h
 mode change 100644 => 100755 net/ti/pp/ti_hil_core.c

diff --git a/arch/x86/NetIP_SubSystem/netip_mem_util.c b/arch/x86/NetIP_SubSystem/netip_mem_util.c
index f0d5b8b..37c3abe 100644
--- a/arch/x86/NetIP_SubSystem/netip_mem_util.c
+++ b/arch/x86/NetIP_SubSystem/netip_mem_util.c
@@ -107,7 +107,8 @@ static struct netip_mem_rgion_device mem_util_dev[] =
     {NETSS_DEV_TDM1, NULL, false, 0xF0120000, NULL, "NETSS_DEV_TDM1"},
     {NETSS_DEV_TIMER2, NULL, false, 0xF0130000, NULL, "NETSS_DEV_TIMER2"},
     {NETSS_DEV_TDM2, NULL, false, 0xF0180000, NULL, "NETSS_DEV_TDM2"},
-    {NETSS_DEV_VCODEC, NULL, false, 0xF00F6000, NULL, "NETSS_DEV_VCODEC"},    
+    {NETSS_DEV_VCODEC, NULL, false, 0xF00F6000, NULL, "NETSS_DEV_VCODEC"},
+    {NETSS_DEV_BOOT_RAM, NULL, false, 0xFFFF0000, NULL, "NETSS_DEV_BOOT_RAM"},
 };
 
 int netip_memmap_init(void)
diff --git a/arch/x86/NetIP_SubSystem/netip_subsystem_config.c b/arch/x86/NetIP_SubSystem/netip_subsystem_config.c
index 7b4504c..7bb8a90 100644
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_config.c
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_config.c
@@ -30,8 +30,10 @@
 #include <linux/netip_mem_util.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include "netip_subsystem_defs.h"
 
-#define NETSS_DEV_BOOTCFG_BASE 0xF00C0000
+#define NETSS_DEV_BOOTCFG_BASE    0xF00C0000
+#define NETSS_SILICON_STEPPING         0xFFFF3FF4
 
 #define MAX_DOMAIN_REGS             (38)
 #define LOCK_REG1_OFF               (0x007c)
@@ -77,6 +79,39 @@ static struct file_operations g_proc_file_ipsec_seq_fops = {
     .release = single_release,
 };
 
+unsigned int netss_subsystem_get_silicon_step(void)
+{
+    unsigned int siliconStep;
+    unsigned int *siliconStepReg;
+
+    siliconStepReg = netip_mmio_to_virtual(NETSS_SILICON_STEPPING);
+
+    siliconStep = be32_to_cpu(*siliconStepReg);
+
+    return siliconStep;
+}
+EXPORT_SYMBOL(netss_subsystem_get_silicon_step);
+
+static int netss_subsystem_proc_read_silicon_step(struct seq_file *seq, void *v)
+{
+    seq_printf(seq, "%d\n", netss_subsystem_get_silicon_step());
+
+    return 0;
+}
+
+static int netss_subsystem_proc_open_silicon_step(struct inode *inode, struct file *file)
+{
+    return single_open(file, netss_subsystem_proc_read_silicon_step, NULL);
+}
+
+static struct file_operations g_proc_file_silicon_step_seq_fops = {
+    .owner = THIS_MODULE,
+    .open = netss_subsystem_proc_open_silicon_step,
+    .read = seq_read,
+    .llseek = seq_lseek,
+    .release = single_release,
+};
+
 void netss_bootcfg_init(void)
 {
     /* Check if bootcfg folder already exists */
@@ -92,6 +127,7 @@ void netss_bootcfg_init(void)
     }
 
     proc_create("ipsec_disable", S_IRUGO, g_netss_subsystem_proc_dir, &g_proc_file_ipsec_seq_fops);
+    proc_create("silicon_step", S_IRUGO, g_netss_subsystem_proc_dir, &g_proc_file_silicon_step_seq_fops);
 }
 
 void netss_enable_snooped_mode(void)
diff --git a/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c b/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c
index 88850b0..a8e8fed 100644
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c
@@ -215,7 +215,7 @@ int netss_device_get_info(netss_dev_t subdevice, netss_dev_info_t *mmio)
          mmio->base = net_ip_mmios.region1_base + NETSS_DEV_PP1_MMIO_OFFSET;
          mmio->size = NETSS_DEV_PP1_MMIO_SIZE;
          ret = 0;
-      break;
+      break; 
       case NETSS_DEV_PACKET_PROCESSOR2:
          mmio->base = net_ip_mmios.region1_base + NETSS_DEV_PP2_MMIO_OFFSET;
          mmio->size = NETSS_DEV_PP2_MMIO_SIZE;
@@ -331,6 +331,11 @@ int netss_device_get_info(netss_dev_t subdevice, netss_dev_info_t *mmio)
          mmio->size = NETSS_DEV_VCODEC_MMIO_SIZE;
          ret = 0;
       break;
+      case NETSS_DEV_BOOT_RAM:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_BOOT_RAM_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_BOOT_RAM_MMIO_SIZE;
+         ret = 0;
+      break;
       default:
          ret = -1;
    }
diff --git a/arch/x86/pal_cppi41/pal_cppi41.c b/arch/x86/pal_cppi41/pal_cppi41.c
index 6423b31..ded6044 100644
--- a/arch/x86/pal_cppi41/pal_cppi41.c
+++ b/arch/x86/pal_cppi41/pal_cppi41.c
@@ -88,6 +88,8 @@
 #include <linux/avalanche/generic/avalanche_pp_api.h>
 #include <linux/avalanche/generic/pal_cppi41.h>
 #include <linux/avalanche/generic/pal_os.h>
+#include <linux/avalanche/generic/pal_osProtect.h>
+#include <linux/avalanche/generic/pal_osProtect_inline.h>
 
 #include "cppi41_hw_mbox_if.h"
 #include <linux/hw_mailbox.h>
@@ -396,6 +398,26 @@ static AVALANCHE_PP_RET_e __cppi4AccChOpen(AVALANCHE_PP_ACC_CH_INFO_t *ptr_ch_cf
 	return (PP_RC_SUCCESS);
 }
 
+static AVALANCHE_PP_RET_e __cppi4AccChEnRateLimit(AVALANCHE_PP_ACC_CH_INFO_t *ptr_ch_cfg)
+{
+    AVALANCHE_PP_RET_e rc;
+
+    BUG_ON(!__pdsp_cmd_send);
+
+    rc = __pdsp_cmd_send(PDSP_ID_Accumulator,
+                         PDSP_PREP_CMD(PDSP_ACCUMULATOR_ENABLE_CH_RATE_LIMIT, ptr_ch_cfg->Channel, ptr_ch_cfg->Index),
+                         &(ptr_ch_cfg->Param0Ret),
+                         SIZE_IN_WORD(AVALANCHE_PP_ACC_CH_INFO_t) - SIZE_IN_WORD(Int32) /* Size of the parameters = total size - command size*/,
+                         NULL,   0);
+
+    if (rc)
+    {
+        return (rc + PP_RC_FAILURE);
+    }
+
+    return (PP_RC_SUCCESS);
+}
+
 PAL_Cppi4AccChHnd PAL_cppi4AccChOpen(PAL_Handle hnd, Cppi4AccumulatorCfg* accCfg)
 {
     Uint32 cookie;
@@ -487,6 +509,33 @@ PAL_Cppi4AccChHnd PAL_cppi4AccChOpen(PAL_Handle hnd, Cppi4AccumulatorCfg* accCfg
 }
 EXPORT_SYMBOL(PAL_cppi4AccChOpen);
 
+void PAL_cppi4AccChEnRateLimit(Cppi4AccumulatorRateLimitCfg* accCfg)
+{
+    Uint32                      cookie;
+    AVALANCHE_PP_RET_e          rc;
+    AVALANCHE_PP_ACC_CH_INFO_t  ptr_ch_cfg;
+
+    /* Need to protect the accumulator register writes. They are shared with pre-fetcher */
+    PAL_osProtectEntry(PAL_OSPROTECT_INTERRUPT, &cookie);
+
+    ptr_ch_cfg.Index        =   1 ; // Enable Rate Limit
+    ptr_ch_cfg.Channel      =   accCfg->accChanNum ;
+    ptr_ch_cfg.Command      =   0 ;
+    ptr_ch_cfg.Param0Ret    =   (accCfg->retQ);
+    ptr_ch_cfg.Param1       =   (accCfg->upperThreshold << 16) | (accCfg->lowerThreshold);
+    ptr_ch_cfg.Param2       =   0;
+
+    rc = __cppi4AccChEnRateLimit(&ptr_ch_cfg);
+    if (PP_RC_SUCCESS != rc)
+    {
+        PAL_osProtectExit(PAL_OSPROTECT_INTERRUPT, cookie);
+        return;
+    }
+
+    PAL_osProtectExit(PAL_OSPROTECT_INTERRUPT, cookie);
+}
+EXPORT_SYMBOL(PAL_cppi4AccChEnRateLimit);
+
 int PAL_cppi4AccChClose(PAL_Cppi4AccChHnd hnd, void *closeArgs)
 {
     PAL_Cppi4AccChObj *accChObj = (PAL_Cppi4AccChObj *) hnd;
diff --git a/include/linux/avalanche/generic/avalanche_pdsp_api.h b/include/linux/avalanche/generic/avalanche_pdsp_api.h
index 293b3c9..e4e1715 100755
--- a/include/linux/avalanche/generic/avalanche_pdsp_api.h
+++ b/include/linux/avalanche/generic/avalanche_pdsp_api.h
@@ -141,14 +141,24 @@ typedef enum
     PDSP_QOS_CMD_CONFIG_CLUSTER     = 0x83,
 
     // Accumulator  commands
-    PDSP_ACCUMULATOR_ENABLE_CH      = 0x83,
-    PDSP_ACCUMULATOR_DISABLE_CH     = 0x84,
+    PDSP_ACCUMULATOR_ENABLE_CH              = 0x83,
+    PDSP_ACCUMULATOR_DISABLE_CH             = 0x84,
+    PDSP_ACCUMULATOR_ENABLE_CH_RATE_LIMIT   = 0x85,
+    PDSP_ACCUMULATOR_ENABLE_RATE_LIMIT      = 0x86,
+
+    // Recycler  commands
+    PDSP_RECYCLER_SANITY_START_CMD          = 0x83,
+    PDSP_RECYCLER_SANITY_STOP_CMD           = 0x84,
 
     // Session Cache Commands
     PDSP_SESSION_CACHE_SESSION_CMD  = 0x83,
     PDSP_SESSION_CACHE_FLUSH_ALL    = 0x84,
     PDSP_SESSION_CACHE_SESSION_TIMEOUT  = 0x85,
 
+
+    // Moca Commands
+    PDSP_MOCA_SET_PADDING                = 0x83,
+
 #ifdef CONFIG_WIFI_PROXY
     //Wifi TX commands
     PDSP_CMD_WIFI_TX_INIT                = 0x83,
@@ -157,7 +167,6 @@ typedef enum
     PDSP_CMD_WIFI_TX_START_CHANNEL       = 0x86,
     PDSP_CMD_WIFI_TX_STOP_CHANNEL        = 0x87,
     PDSP_CMD_WIFI_TX_INIT_DBG            = 0x88,
-    PDSP_CMD_WIFI_TX_SET_MAX_BURST       = 0x89,
 
     //Wifi RX commands
     PDSP_CMD_WIFI_RX_INIT                = 0x83,
@@ -166,7 +175,6 @@ typedef enum
     PDSP_CMD_WIFI_RX_START_CHANNEL       = 0x86,
     PDSP_CMD_WIFI_RX_STOP_CHANNEL        = 0x87,
     PDSP_CMD_WIFI_RX_INIT_DBG            = 0x88,
-    PDSP_CMD_WIFI_RX_SET_MAX_BURST       = 0x89,
 #endif
 
 #else
diff --git a/include/linux/avalanche/generic/avalanche_pp_api.h b/include/linux/avalanche/generic/avalanche_pp_api.h
index 8211bfd..13ef624d 100755
--- a/include/linux/avalanche/generic/avalanche_pp_api.h
+++ b/include/linux/avalanche/generic/avalanche_pp_api.h
@@ -60,7 +60,6 @@
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 */
-
 #ifndef     _AVALANCHE_PP_H
 #define     _AVALANCHE_PP_H
 #ifdef CONFIG_ARM_AVALANCHE_SOC
@@ -121,6 +120,7 @@
 #define AVALANCHE_PP_MAX_ACCELERATED_SESSIONS           (AVALANCHE_PP_MAX_STATIC_ENTRIES + AVALANCHE_PP_MAX_LUT_ENTRIES)
 #define AVALANCHE_PP_MAX_ACCELERATED_TDOX_SESSIONS      512
 #define VPID_IF_NAME_SIZE                               16
+
 #endif
 
 #ifdef CONFIG_WIFI_MESH_TUNNEL
@@ -173,14 +173,12 @@ typedef struct
     Uint32  WifiRxPDSPver;
     Uint32  MocaPPver;
     Uint32  MocaPDSPver;
-	Uint32  CryptoPPver;
+    Uint32  CryptoPPver;
     Uint32  CryptoPDSPver;
     Uint32  EncryptPPver;
     Uint32  EncryptPDSPver;
     Uint32  DecryptPPver;
     Uint32  DecryptPDSPver;
-    Uint32  IpsecPPver;
-    Uint32  IpsecPDSPver;
 
     Uint32  MinPPver;
     Uint32  MaxPPver;
@@ -336,13 +334,13 @@ AVALANCHE_PP_PID_RANGE_t;
 typedef struct // former TI_PP_QOS_QUEUE
 {
     Uint8               q_num;                  /* Index of the QOS queue (offset from QOS queue base) */
-    Uint8               flags;                  /* Control how packets in the queue should be handled. Available options: AVALANCHE_PP_QOS_Q_REALTIME - Disable scaling of the credit. */
+    Uint8               flags;                  /* Control how packets in the queue should be handled */
     Uint16              egr_q;                  /* Queue manager and queue index of forwarding queue */
 
-    Uint32              it_credit_bytes;        /* The amount of forwarding byte “credit” that the queue receives every 25us. */
-    Uint16              it_credit_packets;      /* The amount of forwarding packets “credit” that the queue receives every 25us. */
-    Uint32              max_credit_bytes;       /* The maximum amount of forwarding byte “credit” that the queue is allowed to hold at the end of the 25us iteration. */
-    Uint16              max_credit_packets;     /* The maximum amount of forwarding byte “credit” that the queue is allowed to hold at the end of the 25us iteration. */
+    Uint32              it_credit_bytes;        /* The amount of forwarding byte ?credit? that the queue receives every 25us. */
+    Uint16              it_credit_packets;      /* The amount of forwarding packets ?credit? that the queue receives every 25us. */
+    Uint32              max_credit_bytes;       /* The maximum amount of forwarding byte ?credit? that the queue is allowed to hold at the end of the 25us iteration. */
+    Uint16              max_credit_packets;     /* The maximum amount of forwarding byte ?credit? that the queue is allowed to hold at the end of the 25us iteration. */
     Uint32              congst_thrsh_bytes;     /* The size in bytes at which point the QOS queue is considered to be congested. */
     Uint16              congst_thrsh_packets;   /* The maximum number of packets to be kept in QOS queue */
 }
@@ -376,6 +374,8 @@ typedef struct // former TI_PP_QOS_CLST_CFG
     Uint16                      egr_congst_thrsh_packets3; /* Egress Congestion Pkts Threshold 3 */
     Uint16                      egr_congst_thrsh_packets4; /* Egress Congestion Pkts Threshold 4 */
 
+    Uint8                       shaperClusters[4];
+
 }
 AVALANCHE_PP_QOS_CLST_CFG_t;
 
@@ -484,7 +484,7 @@ typedef struct // former TI_PP_VPID
     unsigned char                   qos_clusters_count;
 #else
     /* This is the name of the interface. */
-    char                            devName[VPID_IF_NAME_SIZE];
+	char			                devName[VPID_IF_NAME_SIZE];
 #endif
 }
 AVALANCHE_PP_VPID_INFO_t;
@@ -504,14 +504,12 @@ typedef struct // former TI_PP_VPID_STATS
     Uint64      rx_broadcast_pkt;
     Uint64      rx_multicast_pkt;
     Uint64      rx_discard_pkt;
-    Uint64      rx_res[3];
+
     Uint64      tx_byte;
     Uint64      tx_unicast_pkt;
     Uint64      tx_broadcast_pkt;
     Uint64      tx_multicast_pkt;
     Uint64      tx_discard_pkt;
-    Uint64      tx_error;
-    Uint64      tx_res[2];
 }AVALANCHE_PP_VPID_STATS_t;
 #else
 typedef struct // former TI_PP_VPID_STATS
@@ -551,7 +549,7 @@ typedef enum
 #ifdef CONFIG_WIFI_MESH_TUNNEL
     AVALANCHE_PP_LUT_ENTRY_WIFI_MESH,
 #else
-    AVALANCHE_PP_LUT_ENTRY_reserved_1,
+   AVALANCHE_PP_LUT_ENTRY_reserved_1,
 #endif
     AVALANCHE_PP_LUT_ENTRY_reserved_2,
     AVALANCHE_PP_LUT_ENTRY_reserved_3,
@@ -658,6 +656,7 @@ typedef enum
 }
 AVALANCHE_PP_LUT2_FIELD_ENABLE_e;
 
+
 #ifndef CONFIG_WIFI_MESH_TUNNEL
 typedef struct
 {
@@ -697,28 +696,39 @@ typedef struct
     }u;
 }
 __Avalanche_PP_LUT2_inputs_t;
+
 #else
 typedef struct
 {
     union
     {
+        /*------------------------------------------*/
         Uint8       raw[32];
+        /*------------------------------------------*/
         struct
         {
+
             Uint16                                  vlan_id;
             Uint8                                   frame_control_flags;
             Uint8                                   packet_type;
+
             Uint16                                  src_intf_id;
             Uint16                                  dst_intf_id;
+
             Uint8                                   receive_mac[6];
             Uint8                                   transmit_mac[6];
             Uint8                                   dst_mac[6];
 			Uint8                                   src_mac[6];
+
+
         }
         fields;
+        /*------------------------------------------*/
+
     }u;
 }
 __Avalanche_PP_LUT2_inputs_t;    /* For WIFI MESH mode*/
+
 #endif
 
 typedef struct
@@ -747,7 +757,11 @@ typedef enum
     CLASSIFICATION_MODE_MOCA_IRREG     = 2    // Accelerate packets with ip v4/6/ and L3=ffff for MoCA only (L4 is optional)
 }PP_CLASSIFICATION_MODE_e;
 
+#ifdef CONFIG_LTQ_PPA_DATAPATH
+#define CLASSIFICATION_MODE_DEFAULT CLASSIFICATION_MODE_IPV4_IPV6_L4
+#else
 #define CLASSIFICATION_MODE_DEFAULT CLASSIFICATION_MODE_IPV4_IPV6
+#endif
 
 
 typedef enum
@@ -766,6 +780,7 @@ typedef enum
 {
     PP_LOOKUP_FIELD_L4_PROTOCOL_UDP             = 1,
     PP_LOOKUP_FIELD_L4_PROTOCOL_TCP             = 2,
+    PP_LOOKUP_FIELD_L4_PROTOCOL_L2TPv3          = 3,
     PP_LOOKUP_FIELD_L4_PROTOCOL_0xFF            = 15
 }PP_LOOKUP_FIELD_L4_TYPES_e;
 
@@ -773,7 +788,9 @@ typedef enum
 {
     PP_LOOKUP_FIELD_TUNNEL_TYPE_GRE             = 1,
     PP_LOOKUP_FIELD_TUNNEL_TYPE_DsLITE          = 2,
-    PP_LOOKUP_FIELD_TUNNEL_TYPE_PPPoE           = 3
+    PP_LOOKUP_FIELD_TUNNEL_TYPE_PPPoE           = 3,
+    PP_LOOKUP_FIELD_TUNNEL_TYPE_6rd             = 4,
+    PP_LOOKUP_FIELD_TUNNEL_TYPE_L2TPv3          = 5
 }PP_LOOKUP_FIELD_TUNNEL_TYPE_e;
 
 typedef enum
@@ -822,7 +839,7 @@ typedef struct
     Uint8       IPv6_Flow_Label[4];     /* IPv6 Flow Label (MSbits must be 0). For DS-Lite holds IPv4 destination IP */
     Uint8       ToS;                    /* IP TOS for IPv4, Traffic Class for IPv6               */
     Uint8       Reserved;               /* Must be 0                                             */
-    __be16      PPPoE_session_id;       /* 0xFFFF if none                                        */
+    __be16      Tunn_L2_session_id;     /* 0xFFFF if none                                        */
     __be16      L4_SRC_PORT;            /* UDP/TCP Source       Port. If not set, must be 0      */
     __be16      L4_DST_PORT;            /* UDP/TCP Destintation Port. If not set, must be 0      */
 }
@@ -852,7 +869,7 @@ typedef struct // former TI_PP_SESSION_PROPERTY
 {
     Uint8                               vpid_handle;
 #if PUMA7_OR_NEWER_SOC_TYPE
-    Uint8                               reserved0;
+    Uint8                               host_strip_off;
 #else
     Uint8                               pid_type;       /* Needed for WAN/LAN direction selection */
 #endif
@@ -861,11 +878,11 @@ typedef struct // former TI_PP_SESSION_PROPERTY
 #if defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
     Bool                                isTunnel;
 #endif
+
     __Avalanche_PP_LUTs_Data_t          lookup;
 
 }AVALANCHE_PP_INGRESS_SESSION_PROPERTY_t;
 
-
 #if PUMA7_OR_NEWER_SOC_TYPE
 #define AVALNCHE_PP_WRAP_HEADER_MAX_LEN 96
 #else
@@ -892,14 +909,30 @@ AVALANCHE_PP_EGRESS_FIELD_ENABLE_e;
 #if PUMA7_OR_NEWER_SOC_TYPE
 typedef struct
 {
+#if defined(__BIG_ENDIAN_BITFIELD)
     Uint8                               sf_index;
     Uint8                               res1;
     Uint16                              do_not_encrypt  :   1,
-                                        fw_internal     :   3,
+                                        fw_internal     :   2,
+                                        tdox_candidate  :   1,
                                         high_priority   :   1,
                                         tdox_ignore_ts  :   1,
                                         tdox_enabled    :   1,
                                         tdox_id         :   9;
+
+#elif defined (__LITTLE_ENDIAN_BITFIELD)
+
+   Uint16                               tdox_id         :   9,
+                                        tdox_enabled    :   1,
+                                        tdox_ignore_ts  :   1,
+                                        high_priority   :   1,
+                                        tdox_candidate  :   1,
+                                        fw_internal     :   2,
+                                        do_not_encrypt  :   1;
+
+   Uint8                                res1;
+   Uint8                                sf_index;
+#endif
 }
 AVALANCHE_PP_PSI_t;
 #else
@@ -928,8 +961,11 @@ struct wifi_proxy_psi_t {
 #endif
 
 #ifndef CONFIG_WIFI_MESH_TUNNEL
+
 #define AVALANCHE_PP_EGRESS_DROP_SESS    0x01
 
+
+
 /**************************************************************************
  * STRUCTURE NAME : AVALANCHE_PP_EGRESS_SESSION_PROPERTY_t
  **************************************************************************
@@ -956,8 +992,6 @@ typedef struct
 
     __Avalanche_PP_LUTs_Data_t  lookup;
 
-
-
     union
     {
 #ifdef CONFIG_WIFI_PROXY
@@ -971,6 +1005,7 @@ typedef struct
     Uint16                      eth_type;
     Uint8                       wrapHeaderOffLayer3;
     Uint8                       wrapHeaderLen;
+
     Uint8                       wrapHeader[ AVALNCHE_PP_WRAP_HEADER_MAX_LEN ];
 
 } AVALANCHE_PP_EGRESS_SESSION_PROPERTY_t;
@@ -979,6 +1014,7 @@ typedef struct // former TI_PP_SESSION_PROPERTY
 {
     Uint8                               vpid_handle;
     Uint8                               pid_type;       /* Needed for WAN/LAN direction selection */
+
     Uint16                              enable;             /* Type: AVALANCHE_PP_EGRESS_FIELD_ENABLE_e */
     Bool                                isTunnel;
 
@@ -1025,6 +1061,7 @@ typedef struct // former TI_PP_SESSION_PROPERTY
 
     Uint16                              L4_SrcPort;
     Uint16                              L4_DstPort;
+
     Uint16                              pppoe_sid;
     Uint8                               drop_sess;
     Uint8                               wrapHeader_type;     /* Type : AVALANCHE_PP_LUT_ENTRY_TYPE_e */
@@ -1032,13 +1069,18 @@ typedef struct // former TI_PP_SESSION_PROPERTY
 AVALANCHE_PP_EGRESS_SESSION_PROPERTY_t;
 #endif
 #else
+
 typedef enum
 {
     AVALANCHE_PP_WIFI_MESH_B_HEADER_SIZE  = 22,   /* ethernet header + 2 Vlans (22B) */
     AVALANCHE_PP_WIFI_MESH_CB_HEADER_SIZE = 49,   /* ethernet header (18B) + dragon header (13B) + ethernet header (18B) */
     AVALANCHE_PP_WIFI_MESH_CA_HEADER_SIZE = 61,   /* ethernet header (18B)- 2bytes of ethernet type + dragon header (13B) + wifi header (30B)*/
+
 }AVALANCHE_PP_WIFI_MESH_HEADER_SIZE_e;
+
+
 #define AVALNCHE_PP_WIFI_MESH_HEADER_MAX_LEN        (61)
+
 /**************************************************************************
  * STRUCTURE NAME : AVALANCHE_PP_EGRESS_SESSION_PROPERTY_t
  **************************************************************************
@@ -1053,13 +1095,18 @@ typedef struct // former TI_PP_SESSION_PROPERTY
     Uint8                               vpid_handle;
     Uint8                               reserved;
     Uint16                              enable;             /* Type: AVALANCHE_PP_EGRESS_FIELD_ENABLE_e */
+
     Uint8                               dstmac[6];
     Uint8                               srcmac[6];
+
     Uint8                               newHeader[AVALNCHE_PP_WIFI_MESH_HEADER_MAX_LEN];
+
 }
 AVALANCHE_PP_EGRESS_SESSION_PROPERTY_t;
+
 #endif
 
+
 #if PUMA7_OR_NEWER_SOC_TYPE
 typedef enum
 {
@@ -1140,10 +1187,20 @@ typedef struct // former TI_PP_SESSION
      *  leaves the box. */
     AVALANCHE_PP_EGRESS_SESSION_PROPERTY_t  egress;
 
+
+#if defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
+
     AVALANCHE_PP_SESSION_TDOX_STATS_t   tdox_stats;
-#if PUMA7_OR_NEWER_SOC_TYPE
+#else
+    /* Added 12 bytes as reserved until Atom sync */
+    Uint32                  reserved1;
+    Uint32                  reserved2;
+    Uint32                  reserved3;
+
     Uint8                   is_irreg_moca;
 #endif
+
+
 }
 AVALANCHE_PP_SESSION_INFO_t;
 
@@ -1204,52 +1261,63 @@ PP_HAL_SESSION_RECORD_NON_ACCELERATED_STATS_t;
 
 typedef struct
 {
-    Uint32  cmp_recv      ;
-    Uint32  cmp_recv_valid;
-    Uint32  cmp_irq_cnt   ;
-    Uint32  req_sent      ;
-    Uint32  req_irq_cnt   ;
-    Uint32  dev_cnt5      ;
+    Uint32 cmp_recv      ;
+    Uint32 cmp_recv_valid;
+    Uint32 req_sent      ;
+    Uint32 dev_cnt3      ;
 
 } wifi_tx_dev_stats_t;
 
 typedef struct
 {
-    Uint32  req_recv      ;
-    Uint32  req_recv_valid;
-    Uint32  req_irq_cnt   ;
-    Uint32  cmp_sent      ;
-    Uint32  cmp_irq_cnt   ;
-    Uint32  dev_cnt5      ;
+    Uint32 req_recv      ;
+    Uint32 req_recv_valid;
+    Uint32 req_drops     ;
+    Uint32 cmp_sent      ;
 } wifi_rx_dev_stats_t;
 
 typedef struct
 {
-    /* global */
-    Uint32  rx_pkts                ;
-    Uint32  tx_pkts                ;
-    Uint32  cmp_null_buffer        ;
-    Uint32  cmp_ring_full          ;
-    Uint32  cmp_ring_empty         ;
-    Uint32  cmp_pattern_buffer     ;
-    Uint32  req_int_desc_starvation;
-    Uint32  req_ring_full          ;
-    Uint32  req_ring_empty         ;
-    Uint32  req_ring_ooo           ;
+    Uint32 rx_pkts              ;
+    Uint32 tx_pkts              ;
+    Uint32 cmp_null_buffer      ;
+    Uint32 cmp_read_retries     ;
+    Uint32 cmp_irq_cnt          ;
+    Uint32 cmp_addr_out_of_range;
+    Uint32 cmp_pattern_buffer   ;
+    Uint32 req_irq_cnt          ;
+    Uint32 req_addr_out_of_range;
+    Uint32 req_out_of_order     ;
+    Uint32 req_int_desc_starv   ;
+    Uint32 cnt11                ;
+    Uint32 cnt12                ;
+    Uint32 cnt13                ;
+    Uint32 cnt14                ;
+    Uint32 cnt15                ;
+    Uint32 cnt16                ;
+    Uint32 cnt17                ;
 } avalanche_pp_wifi_tx_stats_t;
 
 typedef struct
 {
-    Uint32 rx_pkts            ;
-    Uint32 tx_pkts            ;
-    Uint32 req_desc_starvation;
-    Uint32 req_null_buffer    ;
-    Uint32 req_zero_date_len  ;
-    Uint32 req_ring_full      ;
-    Uint32 req_ring_empty     ;
-    Uint32 cmp_buff_starvation;
-    Uint32 cmp_ring_full      ;
-    Uint32 cmp_ring_empty     ;
+    Uint32 rx_pkts              ;
+    Uint32 tx_pkts              ;
+    Uint32 cmp_buff_starv       ;
+    Uint32 req_desc_starv       ;
+    Uint32 req_null_buffer      ;
+    Uint32 req_zero_dateLen     ;
+    Uint32 req_read_retries     ;
+    Uint32 req_irq_cnt          ;
+    Uint32 req_addr_out_of_range;
+    Uint32 req_vpid_invalid     ;
+    Uint32 req_pattern_buffer   ;
+    Uint32 cmp_irq_cnt          ;
+    Uint32 cmp_addr_out_of_range;
+    Uint32 cnt13                ;
+    Uint32 cnt14                ;
+    Uint32 cnt15                ;
+    Uint32 cnt16                ;
+    Uint32 cnt17                ;
 } avalanche_pp_wifi_rx_stats_t;
 
 typedef struct
@@ -1302,8 +1370,8 @@ typedef struct
     Uint32      SessionCache_lookup_failures;
     Uint32      SessionCache_lookup_matches;
     Uint32      SessionCache_lookup_matches_internal;
-    Uint32      SessionCache_lookup_matches_external_fifo;
-    Uint32      SessionCache_lookup_matches_external_not_fifo;
+    Uint32      SessionCache_lru_cleared;
+    Uint32      SessionCache_lookup_matches_external;
     Uint32      SessionCache_lookup_matches_popped_from_internal;
     Uint32      SessionCache_no_free_McDMA_channel;
 
@@ -1321,10 +1389,10 @@ typedef struct
     Uint32      TurboDOX_rx_pkts;
     Uint32      TurboDOX_pkts_frwrd_to_next_hop;
     Uint32      TurboDOX_pkts_frwrd_to_qos;
-    Uint32      TurboDOX_res4;
-    Uint32      TurboDOX_res5;
-    Uint32      TurboDOX_res6;
-    Uint32      TurboDOX_res7;
+    Uint32      TurboDOX_enabled_pkts;
+    Uint32      TurboDOX_qulified_pkts;
+    Uint32      TurboDOX_non_qulified_pkts;
+    Uint32      TurboDOX_suppressed_pkts;
     //Uint32      TurboDOX_res8; Taken for ReSequencer usage
     Uint32      ReSequencer_host_rx_pkts;
 
@@ -1363,7 +1431,7 @@ typedef struct
 
     Uint32      Accumulator_rx_pkts;
     Uint32      Accumulator_interrupts;
-    Uint32      Accumulator_res3;
+    Uint32      Accumulator_drops;
     Uint32      Accumulator_res4;
     Uint32      Accumulator_res5;
     Uint32      Accumulator_res6;
@@ -1452,8 +1520,7 @@ typedef struct
 #define AVALANCHE_PP_US_SERVICE_FLOW_COUNTERS 16
 typedef struct
 {
-    /* one 64-bit counter per service flow. 16 is a reasonable upper bound on
-    the number of active service flows, although the system supports more (56?).*/
+    // one 64-bit counter per service flow. 16 is a reasonable upper bound on the number of active service flows, although the system supports more (56?).
     // In reality, only 1-2 flows are used.
     Uint64 us_sent_packets[AVALANCHE_PP_US_SERVICE_FLOW_COUNTERS];
 } AVALANCHE_PP_US_STATS_t;
@@ -1562,6 +1629,7 @@ extern AVALANCHE_PP_RET_e    avalanche_pp_vpid_get_info         ( Uint8     vpid
 #ifdef CONFIG_WIFI_MESH_TUNNEL
 extern AVALANCHE_PP_RET_e    avalanche_pp_wifi_mesh_get_vpid_packet_header_size           ( AVALANCHE_PP_VPID_TYPE_e        vpid_type, AVALANCHE_PP_WIFI_MESH_HEADER_SIZE_e* headerSize);
 #endif
+
 /* Session Management API */
 extern AVALANCHE_PP_RET_e    avalanche_pp_session_create        ( AVALANCHE_PP_SESSION_INFO_t *  ptr_session, void * pkt_ptr );
 #if PUMA7_OR_NEWER_SOC_TYPE
@@ -1582,11 +1650,12 @@ extern AVALANCHE_PP_RET_e   avalanche_pp_session_post_action_bind  ( Uint8     v
 #ifdef CONFIG_WIFI_MESH_TUNNEL
 extern AVALANCHE_PP_RET_e    avalanche_pp_sessions_delete_by_addr ( Uint8 mask, Uint8* srcMacAdr, Uint8* dstMacAdr, Uint8* rxMacAdr, Uint8* txMacAdr, Uint32* num_deleted_sessions);
 #endif
+
 /* Statistics API */
-extern AVALANCHE_PP_RET_e   avalanche_pp_modify_stats_counters      ( Uint32 session_handle, Uint32 packet_size);
-extern AVALANCHE_PP_RET_e   avalanche_pp_get_stats_session          ( Uint32 session_handle, AVALANCHE_PP_SESSION_STATS_t* ptr_session_stats );
-extern AVALANCHE_PP_RET_e   avalanche_pp_get_stats_vpid             ( Uint8  vpid_handle, AVALANCHE_PP_VPID_STATS_t* ptr_vpid_stats );
-extern AVALANCHE_PP_RET_e   avalanche_pp_get_stats_global           ( AVALANCHE_PP_GLOBAL_STATS_t* ptr_stats );
+extern AVALANCHE_PP_RET_e   avalanche_pp_modify_stats_counters              ( Uint32 session_handle, Uint32 packet_size);
+extern AVALANCHE_PP_RET_e   avalanche_pp_get_stats_session                  ( Uint32 session_handle, AVALANCHE_PP_SESSION_STATS_t* ptr_session_stats );
+extern AVALANCHE_PP_RET_e   avalanche_pp_get_stats_vpid                     ( Uint8  vpid_handle, AVALANCHE_PP_VPID_STATS_t* ptr_vpid_stats );
+extern AVALANCHE_PP_RET_e   avalanche_pp_get_stats_global                   ( AVALANCHE_PP_GLOBAL_STATS_t* ptr_stats );
 extern AVALANCHE_PP_RET_e   avalanche_pp_reset_stats_global                 ( void );
 extern void                 avalanche_pp_substract_stats_global_counters(AVALANCHE_PP_GLOBAL_STATS_t* old_stats, AVALANCHE_PP_GLOBAL_STATS_t* new_stats);
 
@@ -1596,6 +1665,7 @@ extern void                 avalanche_pp_substract_stats_global_counters(AVALANC
 #define DST_MAC_ADDR_COMPARE       BIT1
 #define TX_MAC_ADDR_COMPARE        BIT2
 #define RX_MAC_ADDR_COMPARE        BIT3
+
 #define MAC_ADDR_SIZE              6
 #endif
 
@@ -1667,8 +1737,10 @@ typedef struct
     Uint32                              lut2_histogram[AVALANCHE_PP_LUT_HISTOGRAM_SIZE];
     Uint32                              lut2_starvation;
     Uint32                              tdox_starvation;
-
-#if defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
+#if PUMA7_OR_NEWER_SOC_TYPE
+    Uint32                              tdox_sessions;
+    Uint32                              tdox_candidates;
+#else
     Uint32                              lut1_histogram[AVALANCHE_PP_LUT_HISTOGRAM_SIZE];
     Uint32                              lut1_starvation;
     Uint32                              active_lut1_keys;
@@ -1679,20 +1751,24 @@ AVALANCHE_PP_Misc_Statistics_t;
 
 #if PUMA7_OR_NEWER_SOC_TYPE
 extern AVALANCHE_PP_RET_e    avalanche_pp_event_init(void);
-#else
-extern AVALANCHE_PP_RET_e    avalanche_pp_event_poll_timer_init( void );
 #endif
+extern AVALANCHE_PP_RET_e    avalanche_pp_event_poll_timer_init( void );
+
 
 #ifndef CONFIG_WIFI_MESH_TUNNEL
 extern AVALANCHE_PP_RET_e    avalanche_pp_session_tdox_capability_set( Uint32 session_handle, Bool     enable );
+#if PUMA7_OR_NEWER_SOC_TYPE
+extern AVALANCHE_PP_RET_e    avalanche_pp_session_tdox_capability_get( Uint32 session_handle, Bool *   enable, Bool * qualified );
+extern AVALANCHE_PP_RET_e    avalanche_pp_get_tdox_candidate_session( Uint32* session_handle);
+#else
 extern AVALANCHE_PP_RET_e    avalanche_pp_session_tdox_capability_get( Uint32 session_handle, Bool *   enable );
 #endif
-
+#endif
 extern AVALANCHE_PP_RET_e    avalanche_pp_version_get( AVALANCHE_PP_VERSION_t * version );
 extern AVALANCHE_PP_RET_e    avalanche_pp_set_mta_mac_address ( Uint8 * mtaAddress );
 extern AVALANCHE_PP_RET_e    avalanche_pp_get_db_stats ( AVALANCHE_PP_Misc_Statistics_t * stats_ptr );
 extern AVALANCHE_PP_RET_e    avalanche_pp_reset_db_stats ( void );
-extern AVALANCHE_PP_RET_e    avalanche_pp_modify_stats_counters   ( Uint32 session_handle, Uint32 packet_size);
+extern AVALANCHE_PP_RET_e   avalanche_pp_modify_stats_counters   ( Uint32 session_handle, Uint32 packet_size);
 
 extern Bool                  avalanche_pp_state_is_active( void );
 extern Bool                  avalanche_pp_state_is_psm( void );
@@ -1791,8 +1867,10 @@ struct wifi_proxy_dev_ch_t {
  * @rx_destQMgr rx pdsp destination queue manager number
  */
 struct wifi_proxy_fw_init_info_t {
-    Uint32 bMgr;
-    Uint32 bPool;
+    Uint32 rx_bMgr;
+    Uint32 rx_bPool;
+    Uint32 tx_bMgr;
+    Uint32 tx_bPool;
     Uint32 tx_int_qMgr;
     Uint32 tx_int_qNum;
     Uint32 tx_int_cnt;
@@ -1856,7 +1934,7 @@ typedef enum {
  * wifi_proxy_add_ch_info_t
  * @dev_id device id
  * @tx_ch tx channel configuration, fw to wifi soc
- * @rx_ch rx channel configuration, wifi soc to fw 
+ * @rx_ch rx channel configuration, wifi soc to fw
  * @f_mode specify if the device is working in full offload mode
  * @author iemergi (2/2/2016)
  */
@@ -2078,7 +2156,6 @@ struct __attribute__((packed, aligned(64))) fw_rx_pdsp_devs_db_entry {
 };
 
 AVALANCHE_PP_RET_e avalanche_pp_wifi_init(struct wifi_proxy_fw_init_info_t *init_info);
-AVALANCHE_PP_RET_e avalanche_pp_wifi_set_max_copy_burst(Uint8 max_burst);
 AVALANCHE_PP_RET_e avalanche_pp_add_wifi_dev_ch(struct wifi_proxy_add_ch_info_t *info,
                                                 struct wifi_proxy_add_ch_ret_info_t *ret_vals);
 AVALANCHE_PP_RET_e avalanche_pp_rem_wifi_dev_ch(wifi_dev_id_e wifi_dev_id);
@@ -2133,7 +2210,48 @@ typedef     struct
     Uint32  session_timeout_base_address;
     Uint32  hop_list_base_address;
     Uint16  syncQThreshold;
+    Uint8   bAccRateLimitActive;
+    Uint8   mocaPaddingMode;
 }avalanche_pp_db_address_param_t;
+
+/***************** Sanity manager api *******************/
+typedef struct
+{
+    Uint8* pktDataIngressDevName;
+    Uint8* pktDataEgressDevName;
+    Uint8* pktDataIngressP;
+    Uint8* pktDataEgressP;
+    Uint16 pktDataIngressSize;
+    Uint16 pktDataEgressSize;
+}
+session_info_t;
+
+#ifdef CONFIG_PP_SANITY_TESTS
+
+#define SANITY_PROC_NAME "sanity"
+
+#endif
+
+
+/************** Power management info ****************/
+
+#define MAX_MONITORED_OBJECTS_NUM 16
+
+typedef struct
+{
+    Uint32* currResourcesNumRegAddr;
+    Uint32 lpmThreshold;
+
+}AVALANCHE_PP_OBJECT_INFO_t;
+
+typedef struct
+{
+    AVALANCHE_PP_OBJECT_INFO_t PMobjectsInfos[MAX_MONITORED_OBJECTS_NUM];
+    Uint32 ppsStatCntPhyAddr;
+    Uint32 validEntriesCount;
+
+}AVALANCHE_PP_PM_INFO_t;
+
 /********************************************************************************************************/
 /* IOCTL commands:
 
@@ -2179,9 +2297,8 @@ typedef     struct
 #define PP_DRIVER_KERNEL_POST_INIT                  _IO   (PP_DRIVER_MODULE_ID, 11)
 #define PP_DRIVER_SET_ACK_SUPP                      _IOWR (PP_DRIVER_MODULE_ID, 12, avalanche_pp_ackSupp_ioctl_param_t)
 #define PP_DRIVER_GET_DB_PARAMS                     _IOWR (PP_DRIVER_MODULE_ID, 13, avalanche_pp_db_address_param_t)
-#define PP_DRIVER_GET_GLOBAL_STATS                  _IOR  (PP_DRIVER_MODULE_ID, 14, AVALANCHE_PP_GLOBAL_STATS_t)
-#define PP_DRIVER_GET_SESSION_STATS                 _IOWR (PP_DRIVER_MODULE_ID, 15, AVALANCHE_PP_EXTENDED_SESSION_STATS_t)
-
+#define PP_DRIVER_GET_SESSION_STATS                 _IOWR (PP_DRIVER_MODULE_ID, 14, AVALANCHE_PP_EXTENDED_SESSION_STATS_t)
 
 #endif //   _AVALANCHE_PP_H
 
+
diff --git a/include/linux/avalanche/generic/pal.h b/include/linux/avalanche/generic/pal.h
index c4b523e..31f4fda 100755
--- a/include/linux/avalanche/generic/pal.h
+++ b/include/linux/avalanche/generic/pal.h
@@ -92,5 +92,7 @@
 #include <linux/avalanche/generic/avalanche_intd.h>
 #include <linux/avalanche/generic/avalanche_intc.h>
 #include <linux/avalanche/generic/pal_sys.h>
+#include <linux/avalanche/generic/pal_osTimer.h>
+#include <linux/avalanche/generic/pal_osTimer_inline.h>
 #endif
 #endif /* _PAL_H_ */
diff --git a/include/linux/avalanche/generic/pal_cppi41.h b/include/linux/avalanche/generic/pal_cppi41.h
index 0f87094..829c7f0 100644
--- a/include/linux/avalanche/generic/pal_cppi41.h
+++ b/include/linux/avalanche/generic/pal_cppi41.h
@@ -462,6 +462,22 @@ typedef struct
 } Cppi4AccumulatorCfg;
 
 /**
+ * \brief Accumulator channel rate limit configuration
+ *
+ * This defines the accumulator channel properties for a given host mode Tx/Rx channel
+ * An instance of this structure will be part of the channel initial configuration
+ * structure. This structure makes sense only for host mode channels.
+ */
+typedef struct
+{
+    Uint32  accChanNum;         /**< Accumulator channel number */
+    Uint16  retQ;            /**< Host FD Return Queue */
+    Uint16  upperThreshold;  /**< Infra DMA OutQ threshold from which we start dropping packets */
+    Uint16  lowerThreshold;  /**< Infra DMA OutQ threshold from which we stop dropping packets */
+    Uint16  reserved;
+} Cppi4AccumulatorRateLimitCfg;
+
+/**
  *  \brief CPPI4 PAL Accumulator Channel object
  *
  *  CPPI4 PAL layer Object - encapsulates all bookeeping and data structures for
@@ -630,6 +646,17 @@ PAL_Cppi4BD *PAL_cppi4QueuePop(PAL_Cppi4QueueHnd hnd);
 int PAL_cppi4QueueGetEntryCount(PAL_Handle hnd, Cppi4Queue queue, unsigned int *entryCount);
 
 /**
+ *  \brief PAL CPPI 4.1 accumulator channel enable rate limit.
+ *
+ * Sets up an accumulator channel rate limit onfiguration
+ * 
+ *  @param  accCfg        [IN]      Pointer to the accumulator
+ *                        rate limit configuration structure.
+ *
+ */
+void PAL_cppi4AccChEnRateLimit(Cppi4AccumulatorRateLimitCfg* accCfg);
+
+/**
  *  \brief PAL CPPI 4.1 pdsp_cmd_send registration.
  *
  * Sets up the pdsp_cmd_send function callback used by PAL CPPI
diff --git a/include/linux/avalanche/generic/pal_osCfg.h b/include/linux/avalanche/generic/pal_osCfg.h
index 674f009..9a90887 100755
--- a/include/linux/avalanche/generic/pal_osCfg.h
+++ b/include/linux/avalanche/generic/pal_osCfg.h
@@ -84,7 +84,6 @@
 #define INLINE
 
 #define PAL_INCLUDE_OSMEM
-#define PAL_INCLUDE_OSPROTECT
 #ifdef CONFIG_ARM_AVALANCHE_SOC
 #define PAL_INCLUDE_OSBUF
 #define PAL_INCLUDE_OSSEM
@@ -93,6 +92,7 @@
 #define PAL_INCLUDE_OSLIST
 #define PAL_INCLUDE_OSCACHE
 #define PAL_INCLUDE_OSTIMER
+#define PAL_INCLUDE_OSPROTECT
 #endif
 
 #endif
diff --git a/include/linux/avalanche/generic/pal_osTimer.h b/include/linux/avalanche/generic/pal_osTimer.h
new file mode 100755
index 0000000..daa7aa1
--- /dev/null
+++ b/include/linux/avalanche/generic/pal_osTimer.h
@@ -0,0 +1,154 @@
+/*
+ * pal_osTimer.h
+ * Description:
+ * See below.
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2008-2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE 
+
+  Copyright(c) 2008-2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** \file   pal_osTimer.h
+    \brief  OsTIMER Services Header File
+
+    This file declares OS abstraction services for OS Timers.
+    All services run in the context of the calling thread or program.
+    OsTIMER does not spawn a thread of its own to implement the APIs
+    declared here.
+
+ 
+    \author     PSP Architecture Team
+    \version    1.0
+ */
+
+#ifndef __PAL_OSTIMER_H__
+#define __PAL_OSTIMER_H__
+
+#include "pal_defs.h"
+#include "pal_os.h"
+
+/**
+ * \defgroup PalOSTimer PAL OS Timer Interface
+ * 
+ * PAL OS Timer Interface
+ * @{
+ */
+
+/** \name PAL OS Timer Interface
+ *  PAL OS Timer Interface
+ * @{
+ */
+
+typedef Ptr PAL_OsTimerHandle;
+typedef void (*PAL_OsTimerFunc) (unsigned long);
+
+
+/**
+ * \brief   PAL OS Timer Create
+ * 
+ *      This function creates and initializes a timer with user provided timer
+ *      function. 
+ * \warn    Note that the timer function is called in (software) interrupt
+ *          context and thus all the constraints related to interrupt handlers
+ *          are applicable.
+ * \param   pfn [IN] pointer to timer function 
+ * \param   arg [IN] parameter to be passed to timer function
+ * \param   phTimer [OUT] location to recieve the handle to timer just created
+ * \return  PAL_SOK if succesful, else a suitable error code.
+ */
+PAL_INLINE PAL_Result PAL_osTimerCreate(PAL_OsTimerFunc pfn, 
+                                Uint32 arg, 
+                                PAL_OsTimerHandle* phTimer);
+
+/**
+ * \brief   PAL OS Timer Destroy
+ * 
+ *      This function destroys the specified timer. The timer is stopped if
+ *      active and data associated is cleaned up. 
+ * \param   hTimer [IN] handle to the timer
+ * \return  PAL_SOK if succesful, else a suitable error code.
+ */
+PAL_INLINE PAL_Result PAL_osTimerDestroy(PAL_OsTimerHandle hTimer);
+
+/**
+ * \brief   PAL OS Timer Start
+ * 
+ *      This function activates the specified timer. The timer is areloaded
+ *      with new timeout if already started.
+ * \param   hTimer [IN] handle to the timer
+ * \param   msec [IN] timeout in milli seconds before the timer expires
+ * \return  PAL_SOK if succesful, else a suitable error code.
+ */
+PAL_INLINE PAL_Result PAL_osTimerStart(PAL_OsTimerHandle hTimer, Uint32 msec);
+
+/**
+ * \brief   PAL OS Timer Stop
+ * 
+ *      This function deactivates the specified timer. 
+ * \param   hTimer [IN] handle to the timer
+ * \return  PAL_SOK if succesful, else a suitable error code.
+ */
+PAL_INLINE PAL_Result PAL_osTimerStop(PAL_OsTimerHandle hTimer);
+
+/*@}*/
+/*@}*/
+
+#endif /* _PAL_OSSTIMER_H_ */
diff --git a/include/linux/avalanche/generic/pal_osTimer_inline.h b/include/linux/avalanche/generic/pal_osTimer_inline.h
new file mode 100755
index 0000000..f070807
--- /dev/null
+++ b/include/linux/avalanche/generic/pal_osTimer_inline.h
@@ -0,0 +1,146 @@
+/*
+ * pal_osTimer_inline.h
+ * Description:
+ * See below.
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2008-2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE 
+
+  Copyright(c) 2008-2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+/** \file   pal_osTimer_inline.h
+    \brief  OsTIMER Services Source File
+
+    This file implements the OsTIMER services for Linux.
+
+
+    \author     PSP Architecture Team
+    \version    0.1
+*/
+
+#ifndef __PAL_OSTIMER_INLINE_H__
+#define __PAL_OSTIMER_INLINE_H__
+
+#include "pal_os.h"
+#include "pal_defs.h"
+#include <linux/timer.h>
+
+/**
+ * \defgroup PalOSTimer PAL OS Timer Interface
+ * 
+ * PAL OS Timer Interface
+ * @{
+ */
+
+/** \name PAL OS Timer Interface
+ *  PAL OS Timer Interface
+ * @{
+ */
+
+/**
+ * \brief   PAL OS Timer Create 
+ */
+PAL_INLINE PAL_Result PAL_osTimerCreate(PAL_OsTimerFunc pfn, 
+                                Uint32 arg, 
+                                PAL_OsTimerHandle* phTimer)
+{
+    if ((*phTimer =  kmalloc(sizeof(struct timer_list),GFP_KERNEL)) == NULL)
+	{
+        return PAL_OS_ERROR_NO_RESOURCES;
+	}
+
+    setup_timer((struct timer_list *) *phTimer, pfn, arg);
+    return PAL_SOK;
+}
+
+/**
+ * \brief   PAL OS Timer Destroy
+ */
+PAL_INLINE PAL_Result PAL_osTimerDestroy(PAL_OsTimerHandle hTimer)
+{
+    del_timer((struct timer_list*) hTimer); 
+    kfree(hTimer);
+    return PAL_SOK;
+}
+
+/**
+ * \brief   PAL OS Timer Activate
+ */
+PAL_INLINE PAL_Result PAL_osTimerStart(PAL_OsTimerHandle hTimer, Uint32 msec)
+{
+    mod_timer((struct timer_list*) hTimer, msecs_to_jiffies(msec) + jiffies); 
+    return 0;
+}
+
+/**
+ * \brief   PAL OS Timer Deactivate
+ */
+PAL_INLINE PAL_Result PAL_osTimerStop(PAL_OsTimerHandle hTimer)
+{
+    del_timer((struct timer_list*) hTimer); 
+    return 0;
+}
+
+/*@}*/
+/*@}*/
+#endif /* !__PAL_OSTIMER_INLINE_H__ */ 
+
diff --git a/include/linux/avalanche/generic/pp_qos_p7.h b/include/linux/avalanche/generic/pp_qos_p7.h
index b6ff712..563924f 100755
--- a/include/linux/avalanche/generic/pp_qos_p7.h
+++ b/include/linux/avalanche/generic/pp_qos_p7.h
@@ -80,11 +80,14 @@
 #define PP_QOS_MAX_QUEUES            (192)
 #define PP_QOS_MAX_QUEUES_IN_CLUSTER AVALANCHE_PP_QOS_CLST_MAX_QCNT
 
-#define PP_QOS_MAX_QUEUE_INDEX       (PP_QOS_MAX_QUEUES - 1)
+#define PP_QOS_MAX_QUEUE_INDEX       (PP_QOS_MAX_QUEUES   - 1)
 #define PP_QOS_MAX_CLUSTER_INDEX     (PP_QOS_MAX_CLUSTERS - 1)
 
 #define PP_QOS_Q_REALTIME_FLAG       (1<<0)
-#define PP_QOS_Q_NO_QOS_FLAG         (1<<1)
+#define PP_QOS_Q_DROP_EXCESSIVE_FLAG (1<<1)
+#define PP_QOS_Q_QDA_DISABLE_FLAG    (1<<2)
+#define PP_QOS_Q_LIMITED_FLAG        (1<<3)
+#define PP_QOS_Q_NO_QOS_FLAG         (1<<4)
 
 
 #define PP_QOS_ITERATION_TICK_USEC   (25)
@@ -141,6 +144,18 @@ typedef struct
 }
 PP_QOS_PROFILE_t;
 
+typedef struct
+{
+    Uint8             pid_id;
+    Uint8             num_of_priorities;          /* Number of priorities */
+    Uint32            egress_port_queue;          /* Egress queue number */
+    Uint32            egress_queue_depth_packets; /* Egress queue depth (packets) */
+    Uint32            egress_queue_depth_bytes;   /* Egress queue depth (bytes) */
+    Uint32            port_rate_limit_Mbps;       /* Rate limit (in Mbps)*/
+    Uint32            port_pps_limit;             /* PPS limit */
+}
+PP_QOS_PORT_SHAPER_t;
+
 /* QoS manager statistics */
 typedef struct
 {
@@ -152,6 +167,8 @@ typedef struct
     Uint8    private_queues_free_pool_cnt[AVALANCHE_PP_MAX_PID];
     Uint32   clusters_starvation_shared;
     Uint32   queues_starvation_shared;
+    Uint32   shapers_starvation;
+    Uint32   active_shapers;
 }
 PP_QOS_DB_Counters_t;
 
@@ -202,8 +219,13 @@ typedef struct
     Uint16                      egr_congst_thrsh_pkts3;     /* Egress Congestion Threshold Packets point 2  */
     Uint16                      egr_congst_thrsh_pkts4;     /* Egress Congestion Threshold Packets point 1  */
 
-    Uint32                      w14;                        /* Reserved */
-    Uint32                      w15;                        /* Reserved */
+    Uint16                      last_qda_cmd_pkt;
+    Uint16                      last_qda_cmd_bytes;
+
+    Uint8                       shaper_clst3;
+    Uint8                       shaper_clst2;
+    Uint8                       shaper_clst1;
+    Uint8                       shaper_clst0;
 
 }
 PP_QOS_FW_CLST_CFG_t;
@@ -313,7 +335,40 @@ PP_QOS_MGR_RET_e pp_qos_enable_psm(void);
  *  Returns PP_QOS_RC_SUCCESS if pass.
  */
 PP_QOS_MGR_RET_e pp_qos_disable_psm(void);
-
+/**
+ *  pp_qos_set_port_shaper - Config QoS shaper
+ *  @port_shaper: Port shaper configuration
+ *  @shaper_id: Pointer to return the new shaper ID
+ *  @shaper_in_q: Pointer to return the new ingress queues
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_set_port_shaper(PP_QOS_PORT_SHAPER_t * port_shaper, Uint8 * shaper_id, Uint8 * shaper_in_q);
+/**
+ *  pp_qos_free_port_shaper - Free/Delete QoS shaper
+ *  @shaper_id: Shaper ID
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_free_port_shaper(Uint8 shaper_id);
+/**
+ *  pp_qos_shaper_is_active - Check if shaper is active
+ *  @shaper_id: Shaper ID
+ *  @is_active: Pointer to return if active or not
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_shaper_is_active(Uint8 shaper_id, Bool *is_active);
+/**
+ *  pp_qos_get_port_shaper_cluster_config - Get the port shaper
+ *  cluster configuration
+ *  @shaper_id: Shaper ID
+ *  @clst_cfg: Pointer to return the cluster configuration
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_port_shaper_cluster_config(Uint8 shaper_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg);
+PP_QOS_MGR_RET_e pp_qos_set_port_shaper_cluster_config(Uint8 shaper_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg);
 
 /**************/
 /* Cluster    */
@@ -474,6 +529,7 @@ PP_QOS_MGR_RET_e pp_qos_free_queue(Uint8 phy_queue_id);
  *  Returns PP_QOS_RC_SUCCESS if pass.
  */
 PP_QOS_MGR_RET_e pp_qos_get_queue_config(Uint8 phy_queue_id, AVALANCHE_PP_QOS_QUEUE_t *queue_cfg);
+PP_QOS_MGR_RET_e pp_qos_update_queue_it_credits(Uint8 phy_queue_id, Uint32 pkt_credit, Uint32 bytes_credit);
 /**
  *  pp_qos_modify_active_queue - Modify properties for an active
  *  queue
@@ -506,7 +562,15 @@ PP_QOS_MGR_RET_e pp_qos_inc_session_cnt_for_queue(Uint8 phy_queue_id);
  *  Returns PP_QOS_RC_SUCCESS if pass.
  */
 PP_QOS_MGR_RET_e pp_qos_dec_session_cnt_for_queue(Uint8 phy_queue_id);
-
+/**
+ *  pp_qos_set_queue_shaper - Limit queue to fixed rate (in
+ *  MegaBitPerSec)
+ *  @phy_queue_id: Queue ID
+ *  @rate_in_mega_bits: Rate in MegaBitPerSec
+ * 
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_set_queue_shaper(Uint8 phy_queue_id, Uint32 rate_in_mega_bits);
 /**************/
 /* VPID       */
 /**************/
diff --git a/include/linux/avalanche/puma7/puma7_cppi_bmgr_pools.h b/include/linux/avalanche/puma7/puma7_cppi_bmgr_pools.h
new file mode 100755
index 0000000..ca0368c
--- /dev/null
+++ b/include/linux/avalanche/puma7/puma7_cppi_bmgr_pools.h
@@ -0,0 +1,75 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2008-2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+    Intel Corporation
+    2200 Mission College Blvd.
+    Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#define PAL_CPPI_PP_BMGR_POOL_LIST                                                                              \
+PAL_CPPI_BMGR_P_ADD(PAL_CPPI_PP_SHARED_RX_LOW_512B_BUFFER_POOL)                 /* PAL_CPPI_PP_BUFFER_POOL0  */ \
+PAL_CPPI_BMGR_P_ADD(PAL_CPPI_PP_SHARED_RX_LOW_2KB_BUFFER_POOL)                  /* PAL_CPPI_PP_BUFFER_POOL1  */ \
+PAL_CPPI_BMGR_P_ADD(PAL_CPPI_PP_SHARED_RX_LOW_4KB_BUFFER_POOL)                  /* PAL_CPPI_PP_BUFFER_POOL2  */ \
+PAL_CPPI_BMGR_P_ADD(PAL_CPPI_PP_SHARED_RX_HIGH_BUFFER_POOL)                     /* PAL_CPPI_PP_BUFFER_POOL3  */ \
+PAL_CPPI_BMGR_P_ADD(PAL_CPPI_PP_WIFI_RX_POOL)                                   /* PAL_CPPI_PP_BUFFER_POOL4  */ \
+PAL_CPPI_BMGR_P_ADD(PAL_CPPI_PP_WIFI_TX_POOL)                                   /* PAL_CPPI_PP_BUFFER_POOL5  */ \
+PAL_CPPI_BMGR_P_ADD(PAL_CPPI_PP_BUFFER_POOL6)                                   /* PAL_CPPI_PP_BUFFER_POOL6  */ \
+PAL_CPPI_BMGR_P_ADD(PAL_CPPI_PP_BUFFER_POOL7)                                   /* PAL_CPPI_PP_BUFFER_POOL7  */ \
+PAL_CPPI_BMGR_P_ADD(PAL_CPPI_PP_BUFFER_POOL8)                                   /* PAL_CPPI_PP_BUFFER_POOL8  */ \
+PAL_CPPI_BMGR_P_ADD(PAL_CPPI_PP_PACKET_RAM_512B_BUFFER_POOL)                    /* PAL_CPPI_PP_BUFFER_POOL9  */ \
+PAL_CPPI_BMGR_P_ADD(PAL_CPPI_PP_PACKET_RAM_2KB_BUFFER_POOL)                     /* PAL_CPPI_PP_BUFFER_POOL10 */ \
+PAL_CPPI_BMGR_P_ADD(PAL_CPPI_PP_VOICE_DSP_BUFFER_POOL)                          /* PAL_CPPI_PP_BUFFER_POOL11 */
+
diff --git a/include/linux/avalanche/puma7/puma7_cppi_gqmgr2_q.h b/include/linux/avalanche/puma7/puma7_cppi_gqmgr2_q.h
index 7847c4a..e099cf7 100755
--- a/include/linux/avalanche/puma7/puma7_cppi_gqmgr2_q.h
+++ b/include/linux/avalanche/puma7/puma7_cppi_gqmgr2_q.h
@@ -5,7 +5,7 @@
 
   GPL LICENSE SUMMARY
 
-  Copyright(c) 2014 Intel Corporation.
+  Copyright(c) 2014-2016 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of version 2 of the GNU General Public License as
@@ -371,7 +371,7 @@ PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_TX_Q6)
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_UNUSED_Q6)                                        /* PAL_CPPI_PP_QMGR_G2_Q308 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_TX_Q7)                                            /* PAL_CPPI_PP_QMGR_G2_Q309 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_UNUSED_Q7)                                        /* PAL_CPPI_PP_QMGR_G2_Q310 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q311)                                                 /* PAL_CPPI_PP_QMGR_G2_Q311 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SANITY_TESTS_INGRESS_Q)                               /* PAL_CPPI_PP_QMGR_G2_Q311 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q312)                                                 /* PAL_CPPI_PP_QMGR_G2_Q312 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q313)                                                 /* PAL_CPPI_PP_QMGR_G2_Q313 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q314)                                                 /* PAL_CPPI_PP_QMGR_G2_Q314 */\
@@ -552,13 +552,13 @@ PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_WIFI_FW_TX_INTERNAL_EMB_FD_Q_NUM)
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_WIFI_FW_RX_EMB_FD_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G2_Q489 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_VOICE_DSP_RX_EMB_FD_Q_NUM)                            /* PAL_CPPI_PP_QMGR_G2_Q490 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_VOICE_INFRA_RX_EMB_FD_Q_NUM)                          /* PAL_CPPI_PP_QMGR_G2_Q491 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q45)                                           /* PAL_CPPI_PP_QMGR_G2_Q492 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q46)                                           /* PAL_CPPI_PP_QMGR_G2_Q493 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q47)                                           /* PAL_CPPI_PP_QMGR_G2_Q494 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q48)                                           /* PAL_CPPI_PP_QMGR_G2_Q495 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q49)                                           /* PAL_CPPI_PP_QMGR_G2_Q496 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q50)                                           /* PAL_CPPI_PP_QMGR_G2_Q497 */\
-PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q51)                                           /* PAL_CPPI_PP_QMGR_G2_Q498 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_WIFI_FW_RX_REASSEMBLY_EMB_FD_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G2_Q492 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ARM_SHARED_LOW_INFRA_HOST_FD_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G2_Q493 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ARM_SHARED_HIGH_INFRA_HOST_FD_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G2_Q494 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ARM_HOST2PP_LOW_HOST_FD_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G2_Q495 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ARM_HOST2PP_HIGH_HOST_FD_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G2_Q496 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ARM_HOST2PP_LOW_TX_COMPLETE_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G2_Q497 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ARM_HOST2PP_HI_TX_COMPLETE_Q_NUM)                     /* PAL_CPPI_PP_QMGR_G2_Q498 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q52)                                           /* PAL_CPPI_PP_QMGR_G2_Q499 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q53)                                           /* PAL_CPPI_PP_QMGR_G2_Q500 */\
 PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q54)                                           /* PAL_CPPI_PP_QMGR_G2_Q501 */\
diff --git a/include/linux/avalanche/puma7/puma7_cppi_prv.h b/include/linux/avalanche/puma7/puma7_cppi_prv.h
index e3dfc15..64e6a3c 100755
--- a/include/linux/avalanche/puma7/puma7_cppi_prv.h
+++ b/include/linux/avalanche/puma7/puma7_cppi_prv.h
@@ -68,6 +68,7 @@
 #include "puma7_cppi_gqmgr2_q.h"
 #include "puma7_cppi_dsgqmgr_q.h"
 #include "puma7_cppi_usqmgr_q.h"
+#include "puma7_cppi_bmgr_pools.h"
 #ifndef CONFIG_ARM_AVALANCHE_SOC
 #include <linux/netip_mem_util.h>
 #endif
@@ -512,6 +513,12 @@ typedef enum PAL_CPPI_PP_DESC_REGIONs
 #define PAL_CPPI_PP_SHARED_LOW_INFRA_HOST_FD_DESC_COUNT                                     512
 #endif
 
+#if !defined(CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL) && defined(CONFIG_ARM_AVALANCHE_SOC)
+#define PAL_CPPI_PP_QMGR_G2_ARM_SHARED_LOW_INFRA_HOST_FD_DESC_COUNT                         64
+#define PAL_CPPI_PP_QMGR_G2_ARM_SHARED_HIGH_INFRA_HOST_FD_DESC_COUNT                        0
+#define PAL_CPPI_PP_QMGR_G2_ARM_HOST2PP_LOW_HOST_FD_DESC_COUNT                              64
+#define PAL_CPPI_PP_QMGR_G2_ARM_HOST2PP_HIGH_HOST_FD_DESC_COUNT                             0
+#endif
 
 #define PAL_CPPI_PP_DOCSIS_LOW_INFRA_HOST_FD_DESC_COUNT                                     128
 #define PAL_CPPI_PP_DOCSIS_HI_INFRA_HOST_FD_DESC_COUNT                                      64
@@ -636,12 +643,13 @@ typedef enum PAL_CPPI_PP_DESC_REGIONs
 
 #define PAL_CPPI_PP_WIFI_FW_TX_FD_BASE                                                      (IO_ADDRESS(0xF3508000))
 #define PAL_CPPI_PP_WIFI_FW_TX_INTERNAL_EMB_FD_DESC_COUNT                                   (128)
-#define PAL_CPPI_PP_WIFI_FW_RX_EMB_FD_DESC_COUNT                                            (16384) /* must be aligned to number of buffers allocated by app-cpu for wifi buffers pool */
+#define PAL_CPPI_PP_WIFI_FW_RX_EMB_FD_DESC_COUNT                                            (8192)  /* must be aligned to number of buffers allocated by app-cpu for wifi rx pool */
+#define PAL_CPPI_PP_WIFI_FW_RX_REASSEMBLY_EMB_FD_DESC_COUNT                                 (32)
 
 #ifdef CONFIG_MACH_PUMA7_BOARD
 #define PAL_CPPI_PP_HOST2PP_LOW_HOST_FD_DESC_COUNT                                          512
 #define PAL_CPPI_PP_HOST2PP_HI_HOST_FD_DESC_COUNT                                           64
-#define PAL_CPPI_PP_HOST2PP_LOW_INFRA_EMB_FD_DESC_COUNT                                     512
+#define PAL_CPPI_PP_HOST2PP_LOW_INFRA_EMB_FD_DESC_COUNT                                     2048
 #define PAL_CPPI_PP_HOST2PP_HI_INFRA_EMB_FD_DESC_COUNT                                      64
 #else
 #define PAL_CPPI_PP_HOST2PP_LOW_HOST_FD_DESC_COUNT                                          64
@@ -695,23 +703,12 @@ typedef enum PAL_CPPI_PP_DESC_REGIONs
 #define PAL_CPPI_PP_BUF_MGR                     0
 #define PAL_CPPI_PP_BUF_MGR_BASE                (IO_ADDRESS(0xF9180000))
 
+#undef PAL_CPPI_BMGR_P_ADD
+#define PAL_CPPI_BMGR_P_ADD(pNum)       pNum,
+
 typedef enum PAL_CPPI_PP_BUFFER_POOLs
 {
-    PAL_CPPI_PP_BUFFER_POOL0,
-
-    PAL_CPPI_PP_SHARED_RX_LOW_512B_BUFFER_POOL = PAL_CPPI_PP_BUFFER_POOL0,
-    PAL_CPPI_PP_SHARED_RX_LOW_2KB_BUFFER_POOL,
-    PAL_CPPI_PP_SHARED_RX_LOW_4KB_BUFFER_POOL,
-    PAL_CPPI_PP_SHARED_RX_HIGH_BUFFER_POOL,
-    PAL_CPPI_PP_WIFI_RX_TX_POOL,
-    PAL_CPPI_PP_BUFFER_POOL5,
-    PAL_CPPI_PP_BUFFER_POOL6,
-    PAL_CPPI_PP_BUFFER_POOL7,
-    PAL_CPPI_PP_BUFFER_POOL8,
-    PAL_CPPI_PP_PACKET_RAM_512B_BUFFER_POOL,
-    PAL_CPPI_PP_PACKET_RAM_2KB_BUFFER_POOL,
-    PAL_CPPI_PP_VOICE_DSP_BUFFER_POOL,
-
+    PAL_CPPI_PP_BMGR_POOL_LIST
     PAL_CPPI41_BMGR_MAX_POOLS
 }PAL_CPPI_PP_BUFFER_POOLs_e;
 
@@ -755,11 +752,11 @@ typedef enum PAL_CPPI_PP_BUFFER_POOLs
 
 #define PAL_CPPI_PP_BUFFER_POOL4_COUNT                              0
 #define PAL_CPPI_PP_BUFFER_POOL4_SIZE                               0
-#define PAL_CPPI_PP_WIFI_RX_TX_POOL_REF_CNT                         0
+#define PAL_CPPI_PP_WIFI_RX_POOL_REF_CNT                            0
 
 #define PAL_CPPI_PP_BUFFER_POOL5_COUNT                              0
 #define PAL_CPPI_PP_BUFFER_POOL5_SIZE                               0
-#define PAL_CPPI_PP_BUFFER_POOL5_REF_CNT                            0
+#define PAL_CPPI_PP_WIFI_TX_POOL_REF_CNT                            0
 
 #define PAL_CPPI_PP_BUFFER_POOL6_COUNT                              0
 #define PAL_CPPI_PP_BUFFER_POOL6_SIZE                               0
@@ -1532,17 +1529,17 @@ typedef enum PAL_CPPI_DSG_DMA_BLOCKS
 
     Channel Interrupt   Usage                                                   Channel Interrupt   Usage
     -------------------------------------------                                 -------------------------------------------
-    0       0           HOST to PP Tx Complete LOW                              0       0
+    0       0           HOST to PP Tx Complete LOW                              0       0           In Use
     1                   HOST to PP Tx Complete HIGH                             1
     -------------------------------------------                                 -------------------------------------------
-    2       1           MoCA RX                                                 2       1
+    2       1           MoCA RX                                                 2       1           Arm TX Complete
     3                                                                           3
     4                                                                           4
     5                                                                           5
     -------------------------------------------                                 -------------------------------------------
-    6       2           SGMII0 RX Low                                           6       2
+    6       2           SGMII0 RX Low                                           6       2           Encrypt
     -------------------------------------------                                 -------------------------------------------
-    7       3           SGMII0 RX High                                          7       3
+    7       3           SGMII0 RX High                                          7       3           Decrypt
     -------------------------------------------                                 -------------------------------------------
     8       4           SGMII1 RX Low                                           8       4           NP2APP RX
     -------------------------------------------                                 -------------------------------------------
@@ -1621,7 +1618,7 @@ typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD0_CHANNELS
     PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_25,                                                                       // 25
     PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_26,                                                                       // 26
     PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_27,                                                                       // 27
-    PAL_CPPI_PP_VOICE_RX_INTD0_ACC_CH_NUM,                                                                         // 28
+    PAL_CPPI_PP_VOICE_RX_INTD0_ACC_CH_NUM,                                                                          // 28
     PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_29,                                                                       // 29
     PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_30,                                                                       // 30
     PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_31,                                                                       // 31
@@ -1630,10 +1627,14 @@ typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD0_CHANNELS
 
 typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD1_CHANNELS
 {
-    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_0,                                                                        // 0
-    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_1,                                                                        // 1
-    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_2,                                                                        // 2
-    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_3,                                                                        // 3
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_0,                                                                        // 0 *** This INTD is already in use ***
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_1,                                                                        // 1 *** This INTD is already in use ***
+
+    PAL_CPPI_PP_ARM_HOST2PP_TX_COMPLETE_INTD1_ACC_CH_BASE,
+        PAL_CPPI_PP_ARM_HOST2PP_TX_COMPLETE_LOW_INTD1_ACC_CH_NUM = PAL_CPPI_PP_ARM_HOST2PP_TX_COMPLETE_INTD1_ACC_CH_BASE,   // 2
+        PAL_CPPI_PP_ARM_HOST2PP_TX_COMPLETE_HIGH_INTD1_ACC_CH_NUM,                                                          // 3
+    PAL_CPPI_PP_ARM_HOST2PP_TX_COMPLETE_INTD1_ACC_CH_LAST = PAL_CPPI_PP_ARM_HOST2PP_TX_COMPLETE_HIGH_INTD1_ACC_CH_NUM,
+        
     PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_4,                                                                        // 4
     PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_5,                                                                        // 5
     PAL_CPPI_PP_IPSEC_ENCRYPT_INTD1_ACC_CH_NUM,                                                                     // 6
@@ -1681,10 +1682,10 @@ typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD0_INTERRUPT_VECTORS
 
 typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD1_INTERRUPT_VECTORS
 {
-    PAL_CPPI_PP_RESERVED_INTD1_ACC_INTV_NUM_0,                                                                      // 0
-    PAL_CPPI_PP_RESERVED_INTD1_ACC_INTV_NUM_1,                                                                      // 1
-    PAL_CPPI_PP_IPSEC_ENCRYPT_INTD1_ACC_INTV_NUM,                                                                     // 2
-    PAL_CPPI_PP_IPSEC_DECRYPT_INTD1_ACC_INTV_NUM,                                                                    // 3
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_INTV_NUM_0,                                                                      // 0 *** This INTV is already in use ***
+    PAL_CPPI_PP_ARM_HOST2PP_TX_COMPLETE_INTD1_ACC_INTV_NUM,                                                         // 1
+    PAL_CPPI_PP_IPSEC_ENCRYPT_INTD1_ACC_INTV_NUM,                                                                   // 2
+    PAL_CPPI_PP_IPSEC_DECRYPT_INTD1_ACC_INTV_NUM,                                                                   // 3
     PAL_CPPI_PP_NP2APP_RX_INTD1_ACC_INTV_NUM,                                                                       // 4
     PAL_CPPI_PP_NP2APP_TX_COMPLETE_INTD1_ACC_INTV_NUM,                                                              // 5
     PAL_CPPI_PP_APP2NP_RX_INTD1_ACC_INTV_NUM,                                                                       // 6
@@ -1697,6 +1698,7 @@ typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD1_INTERRUPT_VECTORS
 }PAL_CPPI_PP_ACCUMULATOR_INTD1_INTERRUPT_VECTORS_e;
 
 #define PAL_CPPI41_WPD_ACC_INTV_NUM(devInstance)       (PAL_CPPI_PP_WiFi_0_INTD1_ACC_INTV_NUM + (devInstance))
+#define ARM_TX_COMPLETE_MAP_INTD1_VEC_TO_ACC_INT(irq)  (irq + PAL_CPPI_PP_ACCUMULATOR_INTD0_MAX_INTERRUPT_VECTORS)
 
 /**********************************************************************************************************************
 
@@ -1793,14 +1795,18 @@ typedef enum PAL_CPPI_PP_SOURCE_PORTS
 #define PAL_CPPI_PP_RGMII1_INFRA_DMA_CH_NUM(ch)                                (PAL_CPPI_PP_DMA10_RGMII1_LOW_INFRA_RX_CH + (ch))
 #define PAL_CPPI_PP_SGMII0_INFRA_DMA_CH_NUM(ch)                                (PAL_CPPI_PP_DMA10_SGMII0_LOW_INFRA_RX_CH + (ch))
 #define PAL_CPPI_PP_SGMII1_INFRA_DMA_CH_NUM(ch)                                (PAL_CPPI_PP_DMA10_SGMII1_LOW_INFRA_RX_CH + (ch))
+
+#if !defined(CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL) && defined(CONFIG_ARM_AVALANCHE_SOC)
+#define PAL_CPPI_PP_ATOM_INFRA_HOST_FD_Q_NUM(pri)                              ((pri) == 0 ? PAL_CPPI_PP_QMGR_G2_ARM_SHARED_LOW_INFRA_HOST_FD_Q_NUM : PAL_CPPI_PP_QMGR_G2_ATOM_HI_INFRA_HOST_FD_Q_NUM)
+#else
 #define PAL_CPPI_PP_ATOM_INFRA_HOST_FD_Q_NUM(pri)                              ((pri) == 0 ? PAL_CPPI_PP_QMGR_G2_SHARED_LOW_INFRA_HOST_FD_Q_NUM : PAL_CPPI_PP_QMGR_G2_ATOM_HI_INFRA_HOST_FD_Q_NUM)
+#endif
 #define PAL_CPPI_PP_RGMII0_INFRA_HOST_FD_Q_NUM(pri)                            ((pri) == 0 ? PAL_CPPI_PP_QMGR_G2_SHARED_LOW_INFRA_HOST_FD_Q_NUM : PAL_CPPI_PP_QMGR_G2_RGMII0_HI_INFRA_HOST_FD_Q_NUM)
 #define PAL_CPPI_PP_RGMII1_INFRA_HOST_FD_Q_NUM(pri)                            ((pri) == 0 ? PAL_CPPI_PP_QMGR_G2_SHARED_LOW_INFRA_HOST_FD_Q_NUM : PAL_CPPI_PP_QMGR_G2_RGMII1_HI_INFRA_HOST_FD_Q_NUM)
 #define PAL_CPPI_PP_SGMII0_INFRA_HOST_FD_Q_NUM(pri)                            ((pri) == 0 ? PAL_CPPI_PP_QMGR_G2_SHARED_LOW_INFRA_HOST_FD_Q_NUM : PAL_CPPI_PP_QMGR_G2_SGMII0_HI_INFRA_HOST_FD_Q_NUM)
 #define PAL_CPPI_PP_SGMII1_INFRA_HOST_FD_Q_NUM(pri)                            ((pri) == 0 ? PAL_CPPI_PP_QMGR_G2_SHARED_LOW_INFRA_HOST_FD_Q_NUM : PAL_CPPI_PP_QMGR_G2_SGMII1_HI_INFRA_HOST_FD_Q_NUM)
 #define PAL_CPPI_PP_WIFI_INFRA_HOST_FD_Q_NUM(pri)                              ((pri) == 0 ? PAL_CPPI_PP_QMGR_G2_SHARED_LOW_INFRA_HOST_FD_Q_NUM : PAL_CPPI_PP_QMGR_G2_WIFI_INFRA_HOST_RX_FD_Q_NUM)
 
-
 /* DOCSIS */
 #define PAL_CPPI_PP_DOCSIS_INFRA_INPUT_Q_NUM(pri)                               (PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_DOCSIS_LOW_Q_NUM + (2*(pri)))
 #define PAL_CPPI_PP_DOCSIS_HOST_RX_COMPLETE_Q_NUM(pri)                          (PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_DOCSIS_LOW_Q_NUM + (pri))
@@ -1830,10 +1836,22 @@ typedef enum PAL_CPPI_PP_SOURCE_PORTS
 #define PAL_CPPI_PP_HOST2PP_INFRA_EMB_FD_Q_NUM(pri)                             (PAL_CPPI_PP_QMGR_G2_HOST2PP_INFRA_LOW_EMB_FD_Q_NUM + (pri))
 #define PAL_CPPI_PP_HOST2PP_INFRA_DMA_CH_COUNT                                  (PAL_CPPI_PP_DMA11_HOST2PP_HIGH_INFRA_RX_CH - PAL_CPPI_PP_DMA11_HOST2PP_LOW_INFRA_RX_CH + 1)
 #define PAL_CPPI_PP_HOST2PP_INFRA_DMA_CH_NUM(ch)                                (PAL_CPPI_PP_DMA11_HOST2PP_LOW_INFRA_RX_CH + (ch))
+
+#if !defined(CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL) && defined(CONFIG_ARM_AVALANCHE_SOC)
+#define PAL_CPPI_PP_HOST2PP_TX_COMPLETE_Q_NUM(pri)                              (PAL_CPPI_PP_QMGR_G2_ARM_HOST2PP_LOW_TX_COMPLETE_Q_NUM + (pri))
+#else
 #define PAL_CPPI_PP_HOST2PP_TX_COMPLETE_Q_NUM(pri)                              (PAL_CPPI_PP_QMGR_G2_HOST2PP_LOW_TX_COMPLETE_Q_NUM + (pri))
+#endif
+
+#if !defined(CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL) && defined(CONFIG_ARM_AVALANCHE_SOC)
+#define PAL_CPPI_PP_HOST2PP_HOST_FD_Q_NUM(pri)                                  (PAL_CPPI_PP_QMGR_G2_ARM_HOST2PP_LOW_HOST_FD_Q_NUM + (pri))
+#define PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_NUM(pri)                         (PAL_CPPI_PP_ACC_INTD1_CH_TO_ACC_CH(PAL_CPPI_PP_ARM_HOST2PP_TX_COMPLETE_INTD1_ACC_CH_BASE + (pri)))
+#define PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_COUNT                            (PAL_CPPI_PP_ARM_HOST2PP_TX_COMPLETE_INTD1_ACC_CH_LAST - PAL_CPPI_PP_ARM_HOST2PP_TX_COMPLETE_INTD1_ACC_CH_BASE + 1)
+#else
 #define PAL_CPPI_PP_HOST2PP_HOST_FD_Q_NUM(pri)                                  (PAL_CPPI_PP_QMGR_G2_HOST2PP_LOW_HOST_FD_Q_NUM + (pri))
 #define PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_NUM(pri)                         (PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_CH_BASE + (pri))
 #define PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_COUNT                            (PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_CH_LAST - PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_CH_BASE + 1)
+#endif
 #define PAL_CPPI_NETDEV_BUILD_Q_INFO(qMgr, qNum)                                ( ((qMgr) << CPPI41_EM_PKTINFO_RETQMGR_SHIFT) | (qNum) )
 
 #ifdef CONFIG_MACH_PUMA7_FPGA
diff --git a/include/linux/avalanche/puma7/puma7_pp.h b/include/linux/avalanche/puma7/puma7_pp.h
index 43e8579..f8e315f 100755
--- a/include/linux/avalanche/puma7/puma7_pp.h
+++ b/include/linux/avalanche/puma7/puma7_pp.h
@@ -264,7 +264,8 @@ typedef enum {
     WIFI_DEV_STATE_INVALID,
     WIFI_DEV_STATSE_CNT
 } wifi_dev_state_e;
-#endif // defined(CONFIG_WIFI_PROXY) || defined(CONFIG_PPA_PUMA7)
+#endif
+
 
 /*************************************/
 /* PP Registers addresses and macros */
diff --git a/include/linux/avalanche/puma7/synopsys_gbe_interface.h b/include/linux/avalanche/puma7/synopsys_gbe_interface.h
index a3e84b5..823ddd7 100755
--- a/include/linux/avalanche/puma7/synopsys_gbe_interface.h
+++ b/include/linux/avalanche/puma7/synopsys_gbe_interface.h
@@ -7,7 +7,7 @@
  *
  * GPL LICENSE SUMMARY
  *
- *  Copyright(c) 2015 Intel Corporation.
+ *  Copyright(c) 2015-2016 Intel Corporation.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of version 2 of the GNU General Public License as
@@ -35,12 +35,19 @@
 
 #define __SYNOPSYS_GBE_INTERFACE_H__
 
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+#include "avalanche_pp_api.h"
+#else
+#include <linux/avalanche/generic/avalanche_pp_api.h>
+#endif
 
 typedef enum{
     DWC_ETH_QOS_INTEL_PRIVATE_CMD_START = 50,
     DWC_ETH_QOS_MUX_SET_CMD = DWC_ETH_QOS_INTEL_PRIVATE_CMD_START,
     DWC_ETH_QOS_MUX_GET_CMD,
-    DWC_ETH_QOS_MUX_SET_GBE_DBG_PRINT,
+    DWC_ETH_QOS_SET_GBE_DBG_PRINT,
+    DWC_ETH_QOS_UPDATE_LINK_STATUS_CHANGE,
+    DWC_ETH_QOS_SET_LINK_STATUS_CHANGE_DBG_PRINT_MODE,
     DWC_ETH_QOS_INTEL_PRIVATE_CMD_END
 }DWC_ETH_QOS_CMDS;
 
@@ -52,6 +59,13 @@ typedef enum
     DBG_PRINT_BOTH = DBG_PRINT_RX | DBG_PRINT_TX
 }e_print_dbg;
 
+typedef enum
+{
+    DBG_LINK_STATUS_FLAGS_NONE           = 0x00,
+    DBG_LINK_STATUS_FLAGS_CLI_CMD        = 0x01,
+    DBG_LINK_STATUS_FLAGS_IGNORE_TIMER   = 0x10,
+}e_link_status_flags;
+
 #define PRINT_DBG_PRINT_MODE(print_mode)\
         ((print_mode) == DBG_PRINT_NONE ? "Off" :\
         ((print_mode) == DBG_PRINT_RX   ? "Rx"  :\
@@ -64,18 +78,20 @@ typedef enum
  * sharing info through ioctl
  * */
 struct ifr_data_struct {
-	unsigned int flags;
-	unsigned int qInx; /* dma channel no to be configured */
-	unsigned int cmd;
+    unsigned int flags;
+    unsigned int qInx; /* dma channel no to be configured */
+    unsigned int cmd;
     unsigned int mdioNum;
     unsigned int param;
-	unsigned int context_setup;
-	unsigned int connected_speed;
-	unsigned int rwk_filter_values[DWC_ETH_QOS_RWK_FILTER_LENGTH];
-	unsigned int rwk_filter_length;
-	int command_error;
-	int test_done;
-	void *ptr;
+    unsigned int context_setup;
+    unsigned int connected_speed;
+    unsigned int connected_duplex;
+    char         devName[VPID_IF_NAME_SIZE];
+    unsigned int rwk_filter_values[DWC_ETH_QOS_RWK_FILTER_LENGTH];
+    unsigned int rwk_filter_length;
+    int command_error;
+    int test_done;
+    void *ptr;
 };
 
 #define NSGMII0_NAME         "nsgmii0"
diff --git a/include/linux/hw_mbox_defs.h b/include/linux/hw_mbox_defs.h
index 98dd923..07cadf5 100644
--- a/include/linux/hw_mbox_defs.h
+++ b/include/linux/hw_mbox_defs.h
@@ -881,11 +881,11 @@ typedef Uint8 __hwMbox_opcodeMessageSizeExceededAllowedSize[HW_MBOX_OPCODE_MINIM
 /*       |  CID  | Commander                           | Subject                             | HW_MBOX Channel Type     | SRAM size                 | */ \
 /*       |       | [hw_mbox_Masters_e]                 | [hw_mbox_Masters_e]                 | [hw_mbox_channel_type_e] | [Bytes]                   | */ \
 /*       +------------------------------------------------------------------------------------------------------------------------------------------+ */ \
-    ENTRY(    0  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_command          , 0                         )    \
+    ENTRY(    0  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_command          , 32                         )    \
     ENTRY(    1  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_PHY_CPU              , hw_mbox_command          , 32                        )    \
     ENTRY(    2  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_opcode           , 8                         )    \
     ENTRY(    3  , HW_MBOX_MASTER_BBU_C                , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8                         )    \
-    ENTRY(    4  , HW_MBOX_MASTER_PHY_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 608                       )    \
+    ENTRY(    4  , HW_MBOX_MASTER_PHY_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 656                       )    \
     ENTRY(    5  , HW_MBOX_MASTER_MOCA_C               , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8                         )    \
     ENTRY(    6  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_opcode           , 8                         )    \
     ENTRY(    7  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_APP_CPU              , hw_mbox_opcode           , HW_MBOX_NP_APP_SRAM_SIZE  )    \
diff --git a/include/linux/netip_subsystem.h b/include/linux/netip_subsystem.h
index 93f4eec..7626e21 100644
--- a/include/linux/netip_subsystem.h
+++ b/include/linux/netip_subsystem.h
@@ -96,6 +96,8 @@
 #define NETSS_DEV_VCODEC_MMIO_OFFSET  (0xF6000)
 #define NETSS_DEV_VCODEC_MMIO_SIZE    (0x150)
 
+#define NETSS_DEV_BOOT_RAM_MMIO_OFFSET  (0xFFF0000)
+#define NETSS_DEV_BOOT_RAM_MMIO_SIZE    (0x4000)
 
 #define NETSS_DEV_CLK_CTRL_MMIO_OFFSET (0xD0000)
 #define NETSS_DEV_CLK_CTRL_MMIO_SIZE (0x10000)
@@ -134,6 +136,7 @@ typedef enum {
    NETSS_DEV_TIMER2,
    NETSS_DEV_TDM2,
    NETSS_DEV_VCODEC,
+   NETSS_DEV_BOOT_RAM,
    NETSS_DEV_MAX
 }netss_dev_t;
 
@@ -200,6 +203,7 @@ int netss_device_get_info(netss_dev_t subdevice, netss_dev_info_t *mmio);
 void netss_interrupt_enable(netss_interrupt_t intrpt);
 void netss_interrupt_disable(netss_interrupt_t intrpt);
 void netss_interrupt_ack(netss_interrupt_t intrpt);
+unsigned int netss_subsystem_get_silicon_step(void);
 
 /**************************************************************************/
 /*! \fn int netss_power_state_change_callback_register(netss_dev_t subdevice 
diff --git a/include/linux/ti_hil.h b/include/linux/ti_hil.h
index a6681f9..ec83a09 100755
--- a/include/linux/ti_hil.h
+++ b/include/linux/ti_hil.h
@@ -237,6 +237,23 @@ struct hil_core_notifier_param
 /* Event generated when remove vpid */
 #define TI_PP_REMOVE_VPID       (TI_PP_GENERAL_EVENT + 0x2)
 
+/* Event generated when created session by sanity test module */
+#define TI_PP_TEST_SESSION       (TI_PP_GENERAL_EVENT + 0x3)
+
+/**************************************************************************
+ ********************* PP L2TPv3 Event Identifiers ************************
+ **************************************************************************/
+
+/* Base for all L2TPv3 PP Event identifiers. */
+#define TI_L2TP_EVENT                  0x90
+
+/* Event generated when a L2TPv3 session is created. */
+#define TI_L2TP_ENTRY_CREATED          (TI_L2TP_EVENT + 0x1)
+
+/* Event generated when a L2TPv3 session is deleted. */
+#define TI_L2TP_ENTRY_DELETED          (TI_L2TP_EVENT + 0x2)
+
+
 /* DOCSIS Packet processor start/delete session notification defines */
 #define TI_DOCSIS_PP_SESSION_TYPE_FORWARDING                    0x1
 #define TI_DOCSIS_PP_SESSION_TYPE_DISCARDING                    0x2
@@ -342,3 +359,5 @@ extern int ti_hil_delete_tunnel(void);
 #endif /*CONFIG_INTEL_PP_TUNNEL_SUPPORT*/
 #endif /*KERNEL*/
 #endif /* __TI_HIL_H__ */
+
+
diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c
index 6639bc2..ac6fe60 100644
--- a/net/l2tp/l2tp_core.c
+++ b/net/l2tp/l2tp_core.c
@@ -17,6 +17,10 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
+/*
+ * Includes Intel Corporation's changes/modifications dated: [10/03/2016].
+ * Changed/modified portions - Copyright Â© [2016], Intel Corporation.
+ */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
@@ -65,6 +69,10 @@
 
 #include "l2tp_core.h"
 
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+#include <linux/ti_hil.h>
+#endif
+
 #define L2TP_DRV_VERSION	"V2.0"
 
 /* L2TP header constants */
@@ -1856,6 +1864,11 @@ EXPORT_SYMBOL_GPL(__l2tp_session_unhash);
  */
 int l2tp_session_delete(struct l2tp_session *session)
 {
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+	/* For L2TPv3 - Generate the HIL Event indicating that the L2TPv3 session has been deleted. */
+	if (session->tunnel->version == L2TP_HDR_VER_3)
+		ti_hil_pp_event (TI_L2TP_ENTRY_DELETED, (void *)session);
+#endif// CONFIG_TI_PACKET_PROCESSOR
 	if (session->ref)
 		(*session->ref)(session);
 	__l2tp_session_unhash(session);
@@ -1970,8 +1983,14 @@ struct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunn
 		}
 
 		/* Ignore management session in session count value */
-		if (session->session_id != 0)
+		if (session->session_id != 0) {
 			atomic_inc(&l2tp_session_count);
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+			/* For L2TPv3 (PP does not support send_seq option) - Generate the HIL Event indicating that the L2TPv3 session has been created. */
+			if ((tunnel->version == L2TP_HDR_VER_3) && (!session->send_seq))
+				ti_hil_pp_event (TI_L2TP_ENTRY_CREATED, (void *)session);
+#endif// CONFIG_TI_PACKET_PROCESSOR
+		}
 	}
 
 	return session;
diff --git a/net/ti/pp/ti_hil_core.c b/net/ti/pp/ti_hil_core.c
old mode 100644
new mode 100755
-- 
2.10.1

