From cc84a206d4b092ff7bb8aa5b5617fb4cfe19e28a Mon Sep 17 00:00:00 2001
From: Andrei Danaila <andrei.danaila@intel.com>
Date: Wed, 5 Oct 2016 11:52:19 -0700
Subject: [PATCH 511/639] Revert "Forklift eMMC/SD driver from GMIN"

This reverts commit bb2bb648b2eaa4e4dd2ed359329a88afd39853a8.

Signed-off-by: Andrei Danaila <andrei.danaila@intel.com>
Signed-off-by: Pawan Gupta <pawan.kumarx.gupta@intel.com>
---
 drivers/mmc/card/block.c      | 603 +++--------------------------
 drivers/mmc/card/queue.c      | 216 +++++------
 drivers/mmc/card/queue.h      |  14 +-
 drivers/mmc/core/Kconfig      |  15 -
 drivers/mmc/core/bus.c        |  23 +-
 drivers/mmc/core/core.c       | 439 +++++++---------------
 drivers/mmc/core/core.h       |  11 +-
 drivers/mmc/core/debugfs.c    |  15 +-
 drivers/mmc/core/host.c       |  20 +-
 drivers/mmc/core/mmc.c        | 857 ++++++++++++++++--------------------------
 drivers/mmc/core/mmc_ops.c    |  96 ++---
 drivers/mmc/core/quirks.c     |  11 -
 drivers/mmc/core/sd.c         | 217 ++++-------
 drivers/mmc/core/sd.h         |   1 +
 drivers/mmc/core/sdio.c       | 247 ++++++------
 drivers/mmc/core/sdio_bus.c   |  48 ++-
 drivers/mmc/core/sdio_io.c    |  33 --
 drivers/mmc/core/sdio_irq.c   |  11 -
 drivers/mmc/core/sdio_ops.c   |  19 +-
 drivers/mmc/host/Kconfig      |  16 -
 drivers/mmc/host/sdhci-acpi.c | 118 +-----
 drivers/mmc/host/sdhci.c      | 455 ++++++----------------
 drivers/mmc/host/sdhci.h      |   8 +-
 include/linux/mmc/card.h      |  50 ++-
 include/linux/mmc/core.h      |  13 +-
 include/linux/mmc/host.h      |  67 +---
 include/linux/mmc/mmc.h       |  44 +--
 include/linux/mmc/sdhci.h     |   2 -
 include/linux/mmc/sdio_ids.h  |   9 -
 include/linux/wakelock.h      |  67 ----
 include/trace/events/mmc.h    |  91 -----
 31 files changed, 1059 insertions(+), 2777 deletions(-)
 delete mode 100644 include/linux/wakelock.h
 delete mode 100644 include/trace/events/mmc.h

diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 16bef51..f9ed35f 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -36,9 +36,6 @@
 #include <linux/compat.h>
 #include <linux/pm_runtime.h>
 
-#define CREATE_TRACE_POINTS
-#include <trace/events/mmc.h>
-
 #include <linux/mmc/ioctl.h>
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -111,7 +108,6 @@ struct mmc_blk_data {
 #define MMC_BLK_WRITE		BIT(1)
 #define MMC_BLK_DISCARD		BIT(2)
 #define MMC_BLK_SECDISCARD	BIT(3)
-#define MMC_BLK_CMDQ		BIT(4)
 
 	/*
 	 * Only set in main mmc_blk_data associated
@@ -122,7 +118,6 @@ struct mmc_blk_data {
 	struct device_attribute force_ro;
 	struct device_attribute power_ro_lock;
 	int	area_type;
-	struct mmc_queue	*mq_curr;
 };
 
 static DEFINE_MUTEX(open_lock);
@@ -140,10 +135,6 @@ static inline int mmc_blk_part_switch_to_up(struct mmc_card *card);
 static inline int mmc_blk_part_switch(struct mmc_card *card,
 				      struct mmc_blk_data *md);
 static int get_card_status(struct mmc_card *card, u32 *status, int retries);
-static int mmc_blk_issue_rw_rq(struct mmc_queue *mq,
-		struct request *rqc, bool urgent);
-static int mmc_blk_queue_cmdq_req(struct mmc_queue *mq,
-		struct mmc_queue_req *mqrq, unsigned long *);
 
 static inline void mmc_blk_clear_packed(struct mmc_queue_req *mqrq)
 {
@@ -175,7 +166,11 @@ static struct mmc_blk_data *mmc_blk_get(struct gendisk *disk)
 
 static inline int mmc_get_devidx(struct gendisk *disk)
 {
-	int devidx = disk->first_minor / perdev_minors;
+	int devmaj = MAJOR(disk_devt(disk));
+	int devidx = MINOR(disk_devt(disk)) / perdev_minors;
+
+	if (!devmaj)
+		devidx = disk->first_minor / perdev_minors;
 	return devidx;
 }
 
@@ -434,11 +429,9 @@ static int ioctl_do_sanitize(struct mmc_card *card)
 	pr_debug("%s: %s - SANITIZE IN PROGRESS...\n",
 		mmc_hostname(card->host), __func__);
 
-	trace_mmc_blk_erase_start(EXT_CSD_SANITIZE_START, 0, 0);
 	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 					EXT_CSD_SANITIZE_START, 1,
 					MMC_SANITIZE_REQ_TIMEOUT);
-	trace_mmc_blk_erase_end(EXT_CSD_SANITIZE_START, 0, 0);
 
 	if (err)
 		pr_err("%s: %s - EXT_CSD_SANITIZE_START failed. err=%d\n",
@@ -670,55 +663,6 @@ static inline int mmc_blk_part_switch(struct mmc_card *card,
 
 	if (mmc_card_mmc(card)) {
 		u8 part_config = card->ext_csd.part_config;
-		struct mmc_host *host = card->host;
-
-		/*
-		 * before switching partition, needs to make
-		 * sure there is no active transferring in previous
-		 * queue
-		 */
-
-		/*
-		 * Before swithcing the partition, need to do following
-		 * checks:
-		 * 1. there is no on going request in previous queue
-		 * 2. if switch to RPMB partition, CMDQ should be disabled
-		 * 3. if switch to other partition, CMDQ should be back to
-		 * previous status
-		 */
-		mmc_blk_issue_rw_rq(main_md->mq_curr, NULL, false);
-
-		if ((md->part_type != EXT_CSD_PART_CONFIG_USER) &&
-				card->ext_csd.cmdq_en) {
-			/* disable CMDQ mode */
-			ret = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-					EXT_CSD_CMDQ_MODE_EN,
-					EXT_CSD_CMDQ_MODE_OFF,
-					card->ext_csd.generic_cmd6_time);
-			if (ret)
-				return ret;
-			card->ext_csd.cmdq_en = 0;
-			pm_suspend_ignore_children(&host->class_dev, true);
-		} else if ((md->part_type == EXT_CSD_PART_CONFIG_USER) &&
-					card->ext_csd.cmdq_support &&
-				!card->ext_csd.cmdq_en) {
-			/* enable CMDQ mode */
-			ret = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-					EXT_CSD_CMDQ_MODE_EN,
-					EXT_CSD_CMDQ_MODE_ON,
-					card->ext_csd.generic_cmd6_time);
-			/*
-			 * if err during turning on CMDQ mode, continue with
-			 * CMDQ disabled mode
-			 */
-			if (!ret)
-				card->ext_csd.cmdq_en = 1;
-		}
-
-		if ((card->host->pm_caps & MMC_PM_TUNING_AFTER_RTRESUME) &&
-				card->ext_csd.cmdq_en)
-			pm_suspend_ignore_children(&card->host->class_dev,
-					false);
 
 		part_config &= ~EXT_CSD_PART_CONFIG_ACC_MASK;
 		part_config |= md->part_type;
@@ -733,7 +677,6 @@ static inline int mmc_blk_part_switch(struct mmc_card *card,
 	}
 
 	main_md->part_curr = md->part_type;
-	main_md->mq_curr = &md->queue;
 	return 0;
 }
 
@@ -841,22 +784,18 @@ static int mmc_blk_cmd_error(struct request *req, const char *name, int error,
 			req->rq_disk->disk_name, "timed out", name, status);
 
 		/* If the status cmd initially failed, retry the r/w cmd */
-		if (!status_valid) {
-			pr_err("%s: status not valid, retrying timeout\n", req->rq_disk->disk_name);
+		if (!status_valid)
 			return ERR_RETRY;
-		}
+
 		/*
 		 * If it was a r/w cmd crc error, or illegal command
 		 * (eg, issued in wrong state) then retry - we should
 		 * have corrected the state problem above.
 		 */
-		if (status & (R1_COM_CRC_ERROR | R1_ILLEGAL_COMMAND)) {
-			pr_err("%s: command error, retrying timeout\n", req->rq_disk->disk_name);
+		if (status & (R1_COM_CRC_ERROR | R1_ILLEGAL_COMMAND))
 			return ERR_RETRY;
-		}
 
 		/* Otherwise abort the command */
-		pr_err("%s: not retrying timeout\n", req->rq_disk->disk_name);
 		return ERR_ABORT;
 
 	default:
@@ -963,9 +902,8 @@ static int mmc_blk_cmd_recovery(struct mmc_card *card, struct request *req,
 	}
 
 	/* Check for set block count errors */
-	if (brq->precmd.error)
-		return mmc_blk_cmd_error(req, "SET_BLOCK_COUNT",
-				brq->precmd.error,
+	if (brq->sbc.error)
+		return mmc_blk_cmd_error(req, "SET_BLOCK_COUNT", brq->sbc.error,
 				prev_cmd_status_valid, status);
 
 	/* Check for r/w command errors */
@@ -1076,7 +1014,6 @@ out:
 		goto retry;
 	if (!err)
 		mmc_blk_reset_success(md, type);
-
 	blk_end_request(req, err, blk_rq_bytes(req));
 
 	return err ? 0 : 1;
@@ -1138,16 +1075,6 @@ retry:
 			goto out;
 	}
 
-
-
-	if (mmc_can_sanitize(card)) {
-		err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				 EXT_CSD_SANITIZE_START, 1, 0, false, false);
-		/* send status cmd to check */
-		if (!err)
-			err = mmc_busy_wait(card->host);
-	}
-
 out_retry:
 	if (err && !mmc_blk_reset(md, card->host, type))
 		goto retry;
@@ -1215,7 +1142,7 @@ static int mmc_blk_err_check(struct mmc_card *card,
 	int ecc_err = 0, gen_err = 0;
 
 	/*
-	 * precmd.error indicates a problem with the set block count
+	 * sbc.error indicates a problem with the set block count
 	 * command.  No data will have been transferred.
 	 *
 	 * cmd.error indicates a problem with the r/w command.  No
@@ -1224,7 +1151,7 @@ static int mmc_blk_err_check(struct mmc_card *card,
 	 * stop.error indicates a problem with the stop command.  Data
 	 * may have been transferred, or may still be transferring.
 	 */
-	if (brq->precmd.error || brq->cmd.error || brq->stop.error ||
+	if (brq->sbc.error || brq->cmd.error || brq->stop.error ||
 	    brq->data.error) {
 		switch (mmc_blk_cmd_recovery(card, req, brq, &ecc_err, &gen_err)) {
 		case ERR_RETRY:
@@ -1417,8 +1344,6 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 	bool do_rel_wr = (req->cmd_flags & REQ_FUA) &&
 		(rq_data_dir(req) == WRITE) &&
 		(md->flags & MMC_BLK_REL_WR);
-	bool cmdq_en  = card->ext_csd.cmdq_en ? true : false;
-	bool read = (rq_data_dir(req) == READ) ? true : false;
 
 	memset(brq, 0, sizeof(struct mmc_blk_request));
 	brq->mrq.cmd = &brq->cmd;
@@ -1427,15 +1352,12 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 	brq->cmd.arg = blk_rq_pos(req);
 	if (!mmc_card_blockaddr(card))
 		brq->cmd.arg <<= 9;
-	if (!cmdq_en)
-		brq->cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
-	else
-		brq->cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+	brq->cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
+	brq->data.blksz = 512;
 	brq->stop.opcode = MMC_STOP_TRANSMISSION;
 	brq->stop.arg = 0;
 	brq->stop.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
 	brq->data.blocks = blk_rq_sectors(req);
-	brq->data.blksz = 512;
 
 	/*
 	 * The block layer doesn't support all sector count
@@ -1455,19 +1377,17 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 			brq->data.blocks = 1;
 
 		/* Some controllers can't do multiblock reads due to hw bugs */
-		if (card->host->caps2 & MMC_CAP2_NO_MULTI_READ && read)
+		if (card->host->caps2 & MMC_CAP2_NO_MULTI_READ &&
+		    rq_data_dir(req) == READ)
 			brq->data.blocks = 1;
 	}
 
-	/* CMDQ doesn't require stop cmd, and use CMD45 for mrq.cmd */
-	if (cmdq_en) {
-		brq->mrq.stop = NULL;
-		readcmd = writecmd = MMC_QUE_TASK_ADDR;
-	} else if (brq->data.blocks > 1 || do_rel_wr) {
+	if (brq->data.blocks > 1 || do_rel_wr) {
 		/* SPI multiblock writes terminate using a special
 		 * token, not a STOP_TRANSMISSION request.
 		 */
-		if (!mmc_host_is_spi(card->host) || read)
+		if (!mmc_host_is_spi(card->host) ||
+		    rq_data_dir(req) == READ)
 			brq->mrq.stop = &brq->stop;
 		readcmd = MMC_READ_MULTIPLE_BLOCK;
 		writecmd = MMC_WRITE_MULTIPLE_BLOCK;
@@ -1476,8 +1396,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 		readcmd = MMC_READ_SINGLE_BLOCK;
 		writecmd = MMC_WRITE_BLOCK;
 	}
-
-	if (read) {
+	if (rq_data_dir(req) == READ) {
 		brq->cmd.opcode = readcmd;
 		brq->data.flags |= MMC_DATA_READ;
 	} else {
@@ -1507,7 +1426,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 	 * with Auto-CMD23 enhancements provided by some
 	 * hosts, means that the complexity of dealing
 	 * with this is best left to the host. If CMD23 is
-	 * supported by card and host, we'll fill precmd in and let
+	 * supported by card and host, we'll fill sbc in and let
 	 * the host deal with handling it correctly. This means
 	 * that for hosts that don't expose MMC_CAP_CMD23, no
 	 * change of behavior will be observed.
@@ -1515,43 +1434,16 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 	 * N.B: Some MMC cards experience perf degradation.
 	 * We'll avoid using CMD23-bounded multiblock writes for
 	 * these, while retaining features like reliable writes.
-	 *
-	 * If CMDQ is enabled, then we use CMD44 for precmd, and
-	 * CMD46/47 for postcmd
 	 */
-	if (cmdq_en) {
-		brq->precmd.opcode = MMC_QUE_TASK_PARAMS;
-		brq->precmd.arg = brq->data.blocks |
-			(do_rel_wr ? (1 << 31) : 0) |
-			(read ? (1 << 30) : 0) |
-			(do_data_tag ? (1 << 29) : 0) |
-			mqrq->task_id << 16;
-		brq->precmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
-		brq->mrq.precmd = &brq->precmd;
-
-		if (read)
-			brq->postcmd.opcode = MMC_EXECUTE_READ_TASK;
-		else
-			brq->postcmd.opcode = MMC_EXECUTE_WRITE_TASK;
-		brq->postcmd.arg = mqrq->task_id << 16;
-		brq->postcmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;
-		brq->mrq.postcmd = &brq->postcmd;
-
-		brq->cmd2.opcode = MMC_SEND_STATUS;
-		if (!mmc_host_is_spi(card->host))
-			brq->cmd2.arg = card->rca << 16 | 1 << 15;
-		brq->cmd2.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;
-		brq->mrq.cmd2 = &brq->cmd2;
-	} else if ((md->flags & MMC_BLK_CMD23) &&
-			mmc_op_multi(brq->cmd.opcode) &&
+	if ((md->flags & MMC_BLK_CMD23) && mmc_op_multi(brq->cmd.opcode) &&
 	    (do_rel_wr || !(card->quirks & MMC_QUIRK_BLK_NO_CMD23) ||
 	     do_data_tag)) {
-		brq->precmd.opcode = MMC_SET_BLOCK_COUNT;
-		brq->precmd.arg = brq->data.blocks |
+		brq->sbc.opcode = MMC_SET_BLOCK_COUNT;
+		brq->sbc.arg = brq->data.blocks |
 			(do_rel_wr ? (1 << 31) : 0) |
 			(do_data_tag ? (1 << 29) : 0);
-		brq->precmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
-		brq->mrq.precmd = &brq->precmd;
+		brq->sbc.flags = MMC_RSP_R1 | MMC_CMD_AC;
+		brq->mrq.sbc = &brq->sbc;
 	}
 
 	mmc_set_data_timeout(&brq->data, card);
@@ -1580,6 +1472,7 @@ static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,
 
 	mqrq->mmc_active.mrq = &brq->mrq;
 	mqrq->mmc_active.err_check = mmc_blk_err_check;
+
 	mmc_queue_bounce_pre(mqrq);
 }
 
@@ -1759,12 +1652,12 @@ static void mmc_blk_packed_hdr_wrq_prep(struct mmc_queue_req *mqrq,
 	memset(brq, 0, sizeof(struct mmc_blk_request));
 	brq->mrq.cmd = &brq->cmd;
 	brq->mrq.data = &brq->data;
-	brq->mrq.precmd = &brq->precmd;
+	brq->mrq.sbc = &brq->sbc;
 	brq->mrq.stop = &brq->stop;
 
-	brq->precmd.opcode = MMC_SET_BLOCK_COUNT;
-	brq->precmd.arg = MMC_CMD23_ARG_PACKED | (packed->blocks + hdr_blocks);
-	brq->precmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+	brq->sbc.opcode = MMC_SET_BLOCK_COUNT;
+	brq->sbc.arg = MMC_CMD23_ARG_PACKED | (packed->blocks + hdr_blocks);
+	brq->sbc.flags = MMC_RSP_R1 | MMC_CMD_AC;
 
 	brq->cmd.opcode = MMC_WRITE_MULTIPLE_BLOCK;
 	brq->cmd.arg = blk_rq_pos(req);
@@ -1892,7 +1785,7 @@ static void mmc_blk_revert_packed_req(struct mmc_queue *mq,
 	mmc_blk_clear_packed(mq_rq);
 }
 
-static int mmc_blk_issue_normal_rw_rq(struct mmc_queue *mq, struct request *rqc)
+static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)
 {
 	struct mmc_blk_data *md = mq->data;
 	struct mmc_card *card = md->queue.card;
@@ -1905,13 +1798,11 @@ static int mmc_blk_issue_normal_rw_rq(struct mmc_queue *mq, struct request *rqc)
 	const u8 packed_nr = 2;
 	u8 reqs = 0;
 
-	if (!rqc && !atomic_read(&mq->active_slots))
+	if (!rqc && !mq->mqrq_prev->req)
 		return 0;
 
-	if (rqc) {
+	if (rqc)
 		reqs = mmc_blk_prep_packed_list(mq, rqc);
-		atomic_inc(&mq->active_slots);
-	}
 
 	do {
 		if (rqc) {
@@ -1936,8 +1827,11 @@ static int mmc_blk_issue_normal_rw_rq(struct mmc_queue *mq, struct request *rqc)
 		} else
 			areq = NULL;
 		areq = mmc_start_req(card->host, areq, (int *) &status);
-		if (!areq)
+		if (!areq) {
+			if (status == MMC_BLK_NEW_REQUEST)
+				mq->flags |= MMC_QUEUE_NEW_REQUEST;
 			return 0;
+		}
 
 		mq_rq = container_of(areq, struct mmc_queue_req, mmc_active);
 		brq = &mq_rq->brq;
@@ -2047,9 +1941,6 @@ static int mmc_blk_issue_normal_rw_rq(struct mmc_queue *mq, struct request *rqc)
 		}
 	} while (ret);
 
-	clear_bit_unlock(mq_rq->task_id, &mq->cmdqslot);
-	atomic_dec(&mq->active_slots);
-
 	return 1;
 
  cmd_abort:
@@ -2062,15 +1953,12 @@ static int mmc_blk_issue_normal_rw_rq(struct mmc_queue *mq, struct request *rqc)
 			ret = blk_end_request(req, -EIO,
 					blk_rq_cur_bytes(req));
 	}
+
  start_new_req:
-	clear_bit_unlock(mq_rq->task_id, &mq->cmdqslot);
-	atomic_dec(&mq->active_slots);
 	if (rqc) {
 		if (mmc_card_removed(card)) {
 			rqc->cmd_flags |= REQ_QUIET;
 			blk_end_request_all(rqc, -EIO);
-			clear_bit_unlock(mq->mqrq_cur->task_id, &mq->cmdqslot);
-			atomic_dec(&mq->active_slots);
 		} else {
 			/*
 			 * If current request is packed, it needs to put back.
@@ -2087,374 +1975,7 @@ static int mmc_blk_issue_normal_rw_rq(struct mmc_queue *mq, struct request *rqc)
 	return 0;
 }
 
-static void mmc_blk_wait_cmdq_data(struct mmc_request *mrq)
-{
-	struct mmc_host		*host = mrq->host;
-	struct mmc_queue_req	*mqrq;
-	struct request		*req;
-	int error, bytes;
-	bool partial;
-
-	BUG_ON(!mrq->data);
-	BUG_ON(!host->areq);
-
-	mqrq = container_of(host->areq, struct mmc_queue_req, mmc_active);
-	req = mqrq->req;
-	/* Not sure if this req is successfully transferred, let's check! */
-	mqrq->mmc_active.success = false;
-	/* when it is done, clear cmdqslot */
-	mmc_queue_bounce_post(mqrq);
-	error = mrq->data->error;
-	bytes = mrq->data->bytes_xfered;
-	partial = (blk_rq_bytes(req) != bytes) ? true : false;
-	host->context_info.is_done_rcv = true;
-	wake_up_interruptible(&mrq->host->context_info.wait);
-	if (error) {
-		pr_err("%s: data err %d for id %d\n",
-				__func__, error, mqrq->task_id);
-	} else if (!partial) {
-		mqrq->mmc_active.success = true;
-		blk_end_request(req, 0, bytes);
-	}
-}
-
-static int mmc_blk_cmdq_check(struct mmc_card *card, unsigned long *status)
-{
-	struct mmc_command cmd = {0};
-	int err, retries = 3;
-
-	cmd.opcode = MMC_SEND_STATUS;
-	if (!mmc_host_is_spi(card->host))
-		cmd.arg = card->rca << 16 | 1 << 15;
-	cmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;
-	err = mmc_wait_for_cmd(card->host, &cmd, retries);
-	if (err == 0)
-		*status = (unsigned long)cmd.resp[0];
-	else
-		pr_err("%s: err %d\n", __func__, err);
-
-	return err;
-}
-
-/*
- * return:
- * 0 for success;
- * MMC_BLK_NEW_REQUEST: interrupted for fetching new request;
- * negative lavue: failure
- */
-static int mmc_blk_execute_cmdq(struct mmc_queue *mq,
-		unsigned long slots)
-{
-	struct mmc_card *card = mq->card;
-	struct mmc_blk_data *md = mq->data;
-	struct mmc_host *host = card->host;
-	struct mmc_async_req	*areq;
-	struct mmc_queue_req	*prev_mqrq;
-	int err, status = 0;
-	unsigned long id;
-	struct mmc_context_info *cntx;
-	cntx = &host->context_info;
-
-	do {
-		id = find_first_bit(&slots, mq->qdepth);
-		if (id < mq->qdepth)
-			areq = &mq->mqrq[id].mmc_active;
-		else
-			areq = NULL;
-
-		if (host->areq)
-			prev_mqrq = container_of(host->areq,
-					struct mmc_queue_req,
-					mmc_active);
-		else
-			prev_mqrq = NULL;
-
-		err = mmc_execute_cmdq(host, areq, &status);
-		if (prev_mqrq && (status == MMC_BLK_SUCCESS)) {
-			clear_bit_unlock(prev_mqrq->task_id, &mq->cmdqslot);
-			if (atomic_dec_and_test(&mq->active_slots))
-				cntx->is_cmdq_busy = false;
-		}
-		if (err)
-			return err;
-
-		if (host->areq && (host->areq == areq) &&
-				(atomic_read(&mq->active_slots) == 1))
-			cntx->is_last_cmdq = true;
-
-		switch (status) {
-		case MMC_BLK_SUCCESS:
-			mmc_blk_reset_success(md, MMC_BLK_CMDQ);
-			break;
-		case MMC_BLK_PARTIAL:
-			mmc_blk_reset_success(md, MMC_BLK_CMDQ);
-			/* re-queue */
-			BUG_ON(!prev_mqrq);
-			blk_end_request(prev_mqrq->req, 0,
-					prev_mqrq->brq.data.bytes_xfered);
-			err = mmc_blk_queue_cmdq_req(mq, prev_mqrq, NULL);
-			if (err)
-				return err;
-			break;
-		case MMC_BLK_NEW_REQUEST:
-			cntx->is_pending_cmdq = true;
-			return MMC_BLK_NEW_REQUEST;
-		default:
-			return -EIO;
-		}
-
-		/* this is just a flush operation */
-		if (!areq)
-			return 0;
-
-		__clear_bit(id, &slots);
-	} while (status);
-
-	return 0;
-}
-
-static int mmc_blk_flush_cmdq(struct mmc_queue *mq, bool urgent)
-{
-	int err;
-	unsigned long status;
-	struct mmc_host *host = mq->card->host;
-
-	if (!mq)
-		return 0;
-
-	if (host->context_info.is_pending_cmdq) {
-		host->context_info.is_pending_cmdq = false;
-		err = mmc_blk_execute_cmdq(mq, 0);
-		if (err)
-			return err;
-	}
-
-	while (mq->cmdqslot) {
-		/* last CMDQ data */
-		if (mq->card->host->context_info.is_last_cmdq)
-			return mmc_blk_execute_cmdq(mq, 0);
-
-		/*
-		 * send CMD13 to check QSR
-		 */
-		status = 0;
-		do {
-			err = mmc_blk_cmdq_check(mq->card, &status);
-			if (err)
-				return err;
-		} while (!status);
-		err = mmc_blk_execute_cmdq(mq, status);
-		if (err)
-			return err;
-
-		if (urgent)
-			return mmc_blk_execute_cmdq(mq, 0);
-	};
-
-	return 0;
-}
-
-static int mmc_blk_cmdq_data_err_check(struct mmc_card *card,
-		struct mmc_async_req *areq)
-{
-	struct mmc_queue_req *mqrq = container_of(areq, struct mmc_queue_req,
-						    mmc_active);
-	struct mmc_blk_request *brq = &mqrq->brq;
-	int err;
-
-	/* check card status */
-	if (brq->data.flags & MMC_DATA_WRITE) {
-		err = mmc_busy_wait(card->host);
-		if (err)
-			return MMC_BLK_ABORT;
-	}
-
-	if (areq->success)
-		return MMC_BLK_SUCCESS;
-
-	if (brq->data.error)
-		return MMC_BLK_ABORT;
-
-	if (blk_rq_bytes(mqrq->req) != brq->data.bytes_xfered)
-		return MMC_BLK_PARTIAL;
-
-	return MMC_BLK_SUCCESS;
-}
-
-static int mmc_blk_queue_cmdq_req(struct mmc_queue *mq,
-		struct mmc_queue_req *mqrq, unsigned long *status)
-{
-	struct mmc_card *card;
-	struct mmc_request mrq = {0};
-	struct mmc_async_req *areq;
-	int err;
-
-	if (!mq || !mqrq)
-		return -EPERM;
-
-	card = mq->card;
-	mmc_blk_rw_rq_prep(mqrq, card, 0, mq);
-
-	card->host->context_info.is_last_cmdq = false;
-	areq = &mqrq->mmc_active;
-	areq->mrq->host = card->host;
-	areq->mrq->done = mmc_blk_wait_cmdq_data;
-	areq->err_check = mmc_blk_cmdq_data_err_check;
-
-	mrq.precmd = areq->mrq->precmd;
-	mrq.cmd = areq->mrq->cmd;
-	if (status)
-		mrq.cmd2 = areq->mrq->cmd2;
-
-	mmc_wait_for_req(card->host, &mrq);
-	if (mrq.cmd->error) {
-		pr_err("%s: error %d for cmd %d\n", __func__,
-				mrq.cmd->error, mrq.cmd->opcode);
-		return mrq.cmd->error;
-	} else if (mrq.precmd->error) {
-		pr_err("%s: error %d for precmd %d\n", __func__,
-				mrq.cmd->error, mrq.cmd->opcode);
-		return mrq.precmd->error;
-	}
-
-	card->host->context_info.is_cmdq_busy = true;
-
-	if (card->host->context_info.is_pending_cmdq) {
-		card->host->context_info.is_pending_cmdq = false;
-		err = mmc_blk_execute_cmdq(mq, 0);
-		if (err && (err != MMC_BLK_NEW_REQUEST)) {
-			pr_err("%s: error %d when flushing pending data\n",
-					__func__, err);
-			return err;
-		}
-	}
-
-	if (status && mrq.cmd2)
-		*status = (unsigned long)mrq.cmd2->resp[0];
-
-	return 0;
-}
-
-static int mmc_blk_requeue_cmdq_reqs(struct mmc_host *host,
-		struct mmc_queue *mq)
-{
-	int err;
-	unsigned int slot;
-	unsigned long cmdqslot;
-
-	cmdqslot = mq->cmdqslot;
-
-	while (cmdqslot) {
-		slot = find_first_bit(&cmdqslot, mq->qdepth);
-		err = mmc_blk_queue_cmdq_req(mq, &mq->mqrq[slot], NULL);
-		if (err)
-			return err;
-		__clear_bit(slot, &cmdqslot);
-	};
-
-	return 0;
-}
-
-static void mmc_blk_discard_cmdq(struct mmc_card *card)
-{
-	struct mmc_command cmd = {0};
-
-	cmd.opcode = MMC_DISCARD_CMDQ;
-	cmd.arg = 1;
-	cmd.flags = MMC_RSP_R1B | MMC_CMD_AC;
-
-	mmc_wait_for_cmd(card->host, &cmd, 0);
-}
-
-static int mmc_blk_issue_cmdq_rw_rq(struct mmc_queue *mq,
-		struct request *rqc, bool urgent)
-{
-	struct mmc_card *card = mq->card;
-	struct mmc_blk_data *md = mq->data;
-	struct request *req;
-	int err, type = MMC_BLK_CMDQ;
-	unsigned long status = 0, i;
-
-flush:
-	if (!rqc) {
-		/* there are some CMDQ data pending, flush them */
-		err = mmc_blk_flush_cmdq(mq, urgent);
-		if (err && (err != MMC_BLK_NEW_REQUEST)) {
-			pr_err("%s: error %d when flushing cmdq\n", __func__,
-					err);
-			goto requeue;
-		}
-		return 0;
-	}
-
-	atomic_inc(&mq->active_slots);
-
-	if (mmc_blk_queue_cmdq_req(mq, mq->mqrq_cur, &status))
-		goto requeue;
-
-	if (!status)
-		return 0;
-recheck:
-	err = mmc_blk_execute_cmdq(mq, status);
-	if (!err || (err == MMC_BLK_NEW_REQUEST))
-		return 0;
-requeue:
-	/*
-	 * error handling
-	 */
-	pr_warn("%s: requeue happens\n", __func__);
-	if (card->host->areq)
-		mmc_blk_execute_cmdq(mq, 0);
-	BUG_ON(card->host->areq);
-	/*
-	 * discard the CMDQ
-	 */
-	mmc_blk_discard_cmdq(card);
-
-	if (!mmc_blk_reset(md, card->host, type)
-			&& !mmc_blk_requeue_cmdq_reqs(card->host, mq)) {
-		/* flush error handling */
-		if (!rqc)
-			goto flush;
-		/* normal cmdq error handling */
-		else {
-			if (mmc_blk_cmdq_check(card, &status))
-				goto requeue;
-			if (!status)
-				return 0;
-			goto recheck;
-		}
-	}
-
-	pr_err("%s: failed to recover eMMC\n", __func__);
-
-	while (mq->cmdqslot) {
-		i = find_first_bit(&mq->cmdqslot, mq->qdepth);
-		req = mq->mqrq[i].req;
-		blk_end_request(req, -EIO, blk_rq_bytes(req));
-		clear_bit_unlock(i, &mq->cmdqslot);
-		atomic_dec(&mq->active_slots);
-	};
-	BUG_ON(atomic_read(&mq->active_slots) != 0);
-	card->host->context_info.is_cmdq_busy = false;
-	card->host->context_info.is_last_cmdq = false;
-	return 0;
-}
-
-static int mmc_blk_issue_rw_rq(struct mmc_queue *mq,
-		struct request *rqc, bool urgent)
-{
-	struct mmc_blk_data *md = mq->data;
-	struct mmc_card *card = md->queue.card;
-
-	if (!card->ext_csd.cmdq_en)
-		return mmc_blk_issue_normal_rw_rq(mq, rqc);
-	else
-		return mmc_blk_issue_cmdq_rw_rq(mq, rqc, urgent);
-}
-
-static int mmc_blk_issue_rq(struct mmc_queue *mq,
-		struct request *req, bool urgent)
+static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 {
 	int ret;
 	struct mmc_blk_data *md = mq->data;
@@ -2463,11 +1984,7 @@ static int mmc_blk_issue_rq(struct mmc_queue *mq,
 	unsigned long flags;
 	unsigned int cmd_flags = req ? req->cmd_flags : 0;
 
-#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
-	if (mmc_bus_needs_resume(card->host))
-		mmc_resume_bus(card->host);
-#endif
-	if (!atomic_read(&mq->active_slots))
+	if (req && !mq->mqrq_prev->req)
 		/* claim host only for the first request */
 		mmc_get_card(card);
 
@@ -2480,10 +1997,11 @@ static int mmc_blk_issue_rq(struct mmc_queue *mq,
 		goto out;
 	}
 
+	mq->flags &= ~MMC_QUEUE_NEW_REQUEST;
 	if (cmd_flags & REQ_DISCARD) {
 		/* complete ongoing async transfer before issuing discard */
-		if (atomic_read(&mq->active_slots))
-			mmc_blk_issue_rw_rq(mq, NULL, urgent);
+		if (card->host->areq)
+			mmc_blk_issue_rw_rq(mq, NULL);
 		if (req->cmd_flags & REQ_SECURE &&
 			!(card->quirks & MMC_QUIRK_SEC_ERASE_TRIM_BROKEN))
 			ret = mmc_blk_issue_secdiscard_rq(mq, req);
@@ -2491,27 +2009,28 @@ static int mmc_blk_issue_rq(struct mmc_queue *mq,
 			ret = mmc_blk_issue_discard_rq(mq, req);
 	} else if (cmd_flags & REQ_FLUSH) {
 		/* complete ongoing async transfer before issuing flush */
-		if (atomic_read(&mq->active_slots))
-			mmc_blk_issue_rw_rq(mq, NULL, urgent);
+		if (card->host->areq)
+			mmc_blk_issue_rw_rq(mq, NULL);
 		ret = mmc_blk_issue_flush(mq, req);
 	} else {
-		if (!req && (atomic_read(&mq->active_slots) == 1)) {
+		if (!req && host->areq) {
 			spin_lock_irqsave(&host->context_info.lock, flags);
 			host->context_info.is_waiting_last_req = true;
 			spin_unlock_irqrestore(&host->context_info.lock, flags);
 		}
-		ret = mmc_blk_issue_rw_rq(mq, req, urgent);
+		ret = mmc_blk_issue_rw_rq(mq, req);
 	}
 
 out:
 	mmc_blk_part_switch_to_up(card);
 
-	if (!atomic_read(&mq->active_slots))
+	if ((!req && !(mq->flags & MMC_QUEUE_NEW_REQUEST)) ||
+	     (cmd_flags & MMC_REQ_SPECIAL_MASK))
 		/*
 		 * Release host when there are no more requests
 		 * and after special request(discard, flush) is done.
 		 * In case sepecial request, there is no reentry to
-		 * the 'mmc_blk_issue_rq'.
+		 * the 'mmc_blk_issue_rq' with 'mqrq_prev->req'.
 		 */
 		mmc_put_card(card);
 	return ret;
@@ -2589,7 +2108,6 @@ static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,
 	md->disk->queue = md->queue.queue;
 	md->disk->driverfs_dev = parent;
 	set_disk_ro(md->disk, md->read_only || default_ro);
-	md->disk->flags = GENHD_FL_EXT_DEVT;
 	if (area_type & MMC_BLK_DATA_AREA_RPMB)
 		md->disk->flags |= GENHD_FL_NO_PART_SCAN;
 
@@ -2670,8 +2188,6 @@ static struct mmc_blk_data *mmc_blk_alloc(struct mmc_card *card)
 
 	md = mmc_blk_alloc_req(card, &card->dev, size, false, NULL,
 					MMC_BLK_DATA_AREA_MAIN);
-	md->mq_curr = &md->queue;
-
 	return md;
 }
 
@@ -2850,12 +2366,11 @@ static const struct mmc_fixup blk_fixups[] =
 		  MMC_QUIRK_BLK_NO_CMD23),
 
 	/*
-	 * Some MMC cards need longer data read timeout than indicated in CSD.
+	 * Some Micron MMC cards needs longer data read timeout than
+	 * indicated in CSD.
 	 */
 	MMC_FIXUP(CID_NAME_ANY, CID_MANFID_MICRON, 0x200, add_quirk_mmc,
 		  MMC_QUIRK_LONG_READ_TIME),
-	MMC_FIXUP("008GE0", CID_MANFID_TOSHIBA, CID_OEMID_ANY, add_quirk_mmc,
-		  MMC_QUIRK_LONG_READ_TIME),
 
 	/*
 	 * On these Samsung MoviNAND parts, performing secure erase or
@@ -2909,9 +2424,6 @@ static int mmc_blk_probe(struct mmc_card *card)
 	mmc_set_drvdata(card, md);
 	mmc_fixup_device(card, blk_fixups);
 
-#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
-	mmc_set_bus_resume_policy(card->host, 1);
-#endif
 	if (mmc_add_disk(md))
 		goto out;
 
@@ -2930,10 +2442,6 @@ static int mmc_blk_probe(struct mmc_card *card)
 	if (card->type != MMC_TYPE_SD_COMBO) {
 		pm_runtime_set_active(&card->dev);
 		pm_runtime_enable(&card->dev);
-		if ((card->host->pm_caps & MMC_PM_TUNING_AFTER_RTRESUME) &&
-				card->ext_csd.cmdq_en)
-			pm_suspend_ignore_children(&card->host->class_dev,
-					false);
 	}
 
 	return 0;
@@ -2958,9 +2466,6 @@ static void mmc_blk_remove(struct mmc_card *card)
 	pm_runtime_put_noidle(&card->dev);
 	mmc_blk_remove_req(md);
 	mmc_set_drvdata(card, NULL);
-#ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
-	mmc_set_bus_resume_policy(card->host, 0);
-#endif
 }
 
 static int _mmc_blk_suspend(struct mmc_card *card)
@@ -2969,6 +2474,7 @@ static int _mmc_blk_suspend(struct mmc_card *card)
 	struct mmc_blk_data *md = mmc_get_drvdata(card);
 
 	if (md) {
+		pm_runtime_get_sync(&card->dev);
 		mmc_queue_suspend(&md->queue);
 		list_for_each_entry(part_md, &md->part, part) {
 			mmc_queue_suspend(&part_md->queue);
@@ -3003,6 +2509,7 @@ static int mmc_blk_resume(struct mmc_card *card)
 		list_for_each_entry(part_md, &md->part, part) {
 			mmc_queue_resume(&part_md->queue);
 		}
+		pm_runtime_put(&card->dev);
 	}
 	return 0;
 }
diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index f688dd4..e7e98eb 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -15,7 +15,6 @@
 #include <linux/freezer.h>
 #include <linux/kthread.h>
 #include <linux/scatterlist.h>
-#include <linux/dma-mapping.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -46,27 +45,6 @@ static int mmc_prep_request(struct request_queue *q, struct request *req)
 	return BLKPREP_OK;
 }
 
-static bool mmc_queue_get_free_slot(struct mmc_queue *mq,
-		unsigned long *free_slot)
-{
-	unsigned long slot;
-	int i;
-
-	if (!mq || !free_slot)
-		return false;
-
-	do {
-		slot = find_first_zero_bit(&mq->cmdqslot, mq->qdepth);
-		if (slot >= mq->qdepth)
-			return false;
-
-		i = test_and_set_bit_lock(slot, &mq->cmdqslot);
-	} while (i);
-
-	*free_slot = slot;
-	return true;
-}
-
 static int mmc_queue_thread(void *d)
 {
 	struct mmc_queue *mq = d;
@@ -77,28 +55,39 @@ static int mmc_queue_thread(void *d)
 	down(&mq->thread_sem);
 	do {
 		struct request *req = NULL;
-		unsigned long i;
+		struct mmc_queue_req *tmp;
+		unsigned int cmd_flags = 0;
 
 		spin_lock_irq(q->queue_lock);
 		set_current_state(TASK_INTERRUPTIBLE);
 		req = blk_fetch_request(q);
+		mq->mqrq_cur->req = req;
 		spin_unlock_irq(q->queue_lock);
 
-		/*
-		 * For the request which doesn't have data to transfer,
-		 * we don't need to allocate a mqrq slot for it as it doesn't
-		 * need the sg to map data
-		 */
-		if (req && !(req->cmd_flags & (REQ_DISCARD | REQ_FLUSH))) {
-			while (!mmc_queue_get_free_slot(mq, &i))
-				mq->issue_fn(mq, NULL, true);
-			mq->mqrq_cur = &mq->mqrq[i];
-			mq->mqrq_cur->req = req;
-		}
-
-		if (req || atomic_read(&mq->active_slots)) {
+		if (req || mq->mqrq_prev->req) {
 			set_current_state(TASK_RUNNING);
-			mq->issue_fn(mq, req, false);
+			cmd_flags = req ? req->cmd_flags : 0;
+			mq->issue_fn(mq, req);
+			if (mq->flags & MMC_QUEUE_NEW_REQUEST) {
+				mq->flags &= ~MMC_QUEUE_NEW_REQUEST;
+				continue; /* fetch again */
+			}
+
+			/*
+			 * Current request becomes previous request
+			 * and vice versa.
+			 * In case of special requests, current request
+			 * has been finished. Do not assign it to previous
+			 * request.
+			 */
+			if (cmd_flags & MMC_REQ_SPECIAL_MASK)
+				mq->mqrq_cur->req = NULL;
+
+			mq->mqrq_prev->brq.mrq.data = NULL;
+			mq->mqrq_prev->req = NULL;
+			tmp = mq->mqrq_prev;
+			mq->mqrq_prev = mq->mqrq_cur;
+			mq->mqrq_cur = tmp;
 		} else {
 			if (kthread_should_stop()) {
 				set_current_state(TASK_RUNNING);
@@ -136,7 +125,7 @@ static void mmc_request_fn(struct request_queue *q)
 	}
 
 	cntx = &mq->card->host->context_info;
-	if (atomic_read(&mq->active_slots)) {
+	if (!mq->mqrq_cur->req && mq->mqrq_prev->req) {
 		/*
 		 * New MMC request arrived when MMC thread may be
 		 * blocked on the previous request to be complete
@@ -148,7 +137,7 @@ static void mmc_request_fn(struct request_queue *q)
 			wake_up_interruptible(&cntx->wait);
 		}
 		spin_unlock_irqrestore(&cntx->lock, flags);
-	} else
+	} else if (!mq->mqrq_cur->req && !mq->mqrq_prev->req)
 		wake_up_process(mq->thread);
 }
 
@@ -202,33 +191,20 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,
 {
 	struct mmc_host *host = card->host;
 	u64 limit = BLK_BOUNCE_HIGH;
-	int ret, i = 0;
-	struct mmc_queue_req *mqrq = mq->mqrq;
+	int ret;
+	struct mmc_queue_req *mqrq_cur = &mq->mqrq[0];
+	struct mmc_queue_req *mqrq_prev = &mq->mqrq[1];
 
 	if (mmc_dev(host)->dma_mask && *mmc_dev(host)->dma_mask)
-		limit = (u64)dma_max_pfn(mmc_dev(host)) << PAGE_SHIFT;
+		limit = *mmc_dev(host)->dma_mask;
 
 	mq->card = card;
 	mq->queue = blk_init_queue(mmc_request_fn, lock);
 	if (!mq->queue)
 		return -ENOMEM;
 
-	if (card->ext_csd.cmdq_en)
-		mq->qdepth = card->ext_csd.cmdq_depth;
-	else
-		mq->qdepth = 2;
-
-	mq->mqrq = kzalloc(mq->qdepth * sizeof(struct mmc_queue_req),
-			GFP_KERNEL);
-	if (!mq->mqrq) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	mqrq = mq->mqrq;
-	for (i = mq->qdepth; i > 0; i--)
-		mqrq[i - 1].task_id = i - 1;
-
+	mq->mqrq_cur = mqrq_cur;
+	mq->mqrq_prev = mqrq_prev;
 	mq->queue->queuedata = mq;
 
 	blk_queue_prep_rq(mq->queue, mmc_prep_request);
@@ -250,50 +226,64 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,
 			bouncesz = host->max_blk_count * 512;
 
 		if (bouncesz > 512) {
-			for (i = 0; i < mq->qdepth; i++) {
-				mqrq[i].bounce_buf =
-					kmalloc(bouncesz, GFP_KERNEL);
-				if (!mqrq[i].bounce_buf)
-					break;
+			mqrq_cur->bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
+			if (!mqrq_cur->bounce_buf) {
+				pr_warning("%s: unable to "
+					"allocate bounce cur buffer\n",
+					mmc_card_name(card));
+			}
+			mqrq_prev->bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
+			if (!mqrq_prev->bounce_buf) {
+				pr_warning("%s: unable to "
+					"allocate bounce prev buffer\n",
+					mmc_card_name(card));
+				kfree(mqrq_cur->bounce_buf);
+				mqrq_cur->bounce_buf = NULL;
 			}
 		}
 
-		if (i != mq->qdepth) {
-			for (; i >= 0; i--) {
-				kfree(mqrq[i].bounce_buf);
-				mqrq[i].bounce_buf = NULL;
-			}
-		} else {
+		if (mqrq_cur->bounce_buf && mqrq_prev->bounce_buf) {
 			blk_queue_bounce_limit(mq->queue, BLK_BOUNCE_ANY);
 			blk_queue_max_hw_sectors(mq->queue, bouncesz / 512);
 			blk_queue_max_segments(mq->queue, bouncesz / 512);
 			blk_queue_max_segment_size(mq->queue, bouncesz);
 
-			for (i = 0; i < mq->qdepth; i++) {
-				mqrq[i].sg = mmc_alloc_sg(1, &ret);
-				if (ret)
-					goto cleanup_queue;
-				mqrq[i].bounce_sg =
-					mmc_alloc_sg(bouncesz / 512, &ret);
-				if (ret)
-					goto cleanup_queue;
-			}
+			mqrq_cur->sg = mmc_alloc_sg(1, &ret);
+			if (ret)
+				goto cleanup_queue;
+
+			mqrq_cur->bounce_sg =
+				mmc_alloc_sg(bouncesz / 512, &ret);
+			if (ret)
+				goto cleanup_queue;
+
+			mqrq_prev->sg = mmc_alloc_sg(1, &ret);
+			if (ret)
+				goto cleanup_queue;
+
+			mqrq_prev->bounce_sg =
+				mmc_alloc_sg(bouncesz / 512, &ret);
+			if (ret)
+				goto cleanup_queue;
 		}
 	}
 #endif
 
-	if (i == 0) {
+	if (!mqrq_cur->bounce_buf && !mqrq_prev->bounce_buf) {
 		blk_queue_bounce_limit(mq->queue, limit);
 		blk_queue_max_hw_sectors(mq->queue,
 			min(host->max_blk_count, host->max_req_size / 512));
 		blk_queue_max_segments(mq->queue, host->max_segs);
 		blk_queue_max_segment_size(mq->queue, host->max_seg_size);
 
-		for (i = 0; i < mq->qdepth; i++) {
-			mqrq[i].sg = mmc_alloc_sg(host->max_segs, &ret);
-			if (ret)
-				goto cleanup_queue;
-		}
+		mqrq_cur->sg = mmc_alloc_sg(host->max_segs, &ret);
+		if (ret)
+			goto cleanup_queue;
+
+
+		mqrq_prev->sg = mmc_alloc_sg(host->max_segs, &ret);
+		if (ret)
+			goto cleanup_queue;
 	}
 
 	sema_init(&mq->thread_sem, 1);
@@ -308,20 +298,22 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,
 
 	return 0;
  free_bounce_sg:
-	for (i = 0; i < mq->qdepth; i++) {
-		kfree(mqrq[i].bounce_sg);
-		mqrq[i].bounce_sg = NULL;
-	}
+	kfree(mqrq_cur->bounce_sg);
+	mqrq_cur->bounce_sg = NULL;
+	kfree(mqrq_prev->bounce_sg);
+	mqrq_prev->bounce_sg = NULL;
+
  cleanup_queue:
-	for (i = 0; i < mq->qdepth; i++) {
-		kfree(mqrq[i].sg);
-		mqrq[i].sg = NULL;
-		kfree(mqrq[i].bounce_buf);
-		mqrq[i].bounce_buf = NULL;
-	}
+	kfree(mqrq_cur->sg);
+	mqrq_cur->sg = NULL;
+	kfree(mqrq_cur->bounce_buf);
+	mqrq_cur->bounce_buf = NULL;
+
+	kfree(mqrq_prev->sg);
+	mqrq_prev->sg = NULL;
+	kfree(mqrq_prev->bounce_buf);
+	mqrq_prev->bounce_buf = NULL;
 
-	kfree(mq->mqrq);
-out:
 	blk_cleanup_queue(mq->queue);
 	return ret;
 }
@@ -330,7 +322,8 @@ void mmc_cleanup_queue(struct mmc_queue *mq)
 {
 	struct request_queue *q = mq->queue;
 	unsigned long flags;
-	int i;
+	struct mmc_queue_req *mqrq_cur = mq->mqrq_cur;
+	struct mmc_queue_req *mqrq_prev = mq->mqrq_prev;
 
 	/* Make sure the queue isn't suspended, as that will deadlock */
 	mmc_queue_resume(mq);
@@ -344,14 +337,23 @@ void mmc_cleanup_queue(struct mmc_queue *mq)
 	blk_start_queue(q);
 	spin_unlock_irqrestore(q->queue_lock, flags);
 
-	for (i = 0; i < mq->qdepth; i++) {
-		kfree(mq->mqrq[i].bounce_sg);
-		mq->mqrq[i].bounce_sg = NULL;
-		kfree(mq->mqrq[i].sg);
-		mq->mqrq[i].sg = NULL;
-		kfree(mq->mqrq[i].bounce_buf);
-		mq->mqrq[i].bounce_buf = NULL;
-	}
+	kfree(mqrq_cur->bounce_sg);
+	mqrq_cur->bounce_sg = NULL;
+
+	kfree(mqrq_cur->sg);
+	mqrq_cur->sg = NULL;
+
+	kfree(mqrq_cur->bounce_buf);
+	mqrq_cur->bounce_buf = NULL;
+
+	kfree(mqrq_prev->bounce_sg);
+	mqrq_prev->bounce_sg = NULL;
+
+	kfree(mqrq_prev->sg);
+	mqrq_prev->sg = NULL;
+
+	kfree(mqrq_prev->bounce_buf);
+	mqrq_prev->bounce_buf = NULL;
 
 	mq->card = NULL;
 }
@@ -363,9 +365,7 @@ int mmc_packed_init(struct mmc_queue *mq, struct mmc_card *card)
 	struct mmc_queue_req *mqrq_prev = &mq->mqrq[1];
 	int ret = 0;
 
-	/*
-	 * the qdepth for PACK CMD is 2
-	 */
+
 	mqrq_cur->packed = kzalloc(sizeof(struct mmc_packed), GFP_KERNEL);
 	if (!mqrq_cur->packed) {
 		pr_warn("%s: unable to allocate packed cmd for mqrq_cur\n",
diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h
index 739faa9..99e6521 100644
--- a/drivers/mmc/card/queue.h
+++ b/drivers/mmc/card/queue.h
@@ -8,10 +8,8 @@ struct task_struct;
 
 struct mmc_blk_request {
 	struct mmc_request	mrq;
-	struct mmc_command	precmd;
+	struct mmc_command	sbc;
 	struct mmc_command	cmd;
-	struct mmc_command	cmd2;
-	struct mmc_command	postcmd;
 	struct mmc_command	stop;
 	struct mmc_data		data;
 };
@@ -43,7 +41,6 @@ struct mmc_queue_req {
 	struct mmc_async_req	mmc_active;
 	enum mmc_packed_type	cmd_type;
 	struct mmc_packed	*packed;
-	int task_id;
 };
 
 struct mmc_queue {
@@ -52,15 +49,14 @@ struct mmc_queue {
 	struct semaphore	thread_sem;
 	unsigned int		flags;
 #define MMC_QUEUE_SUSPENDED	(1 << 0)
+#define MMC_QUEUE_NEW_REQUEST	(1 << 1)
 
-	int	(*issue_fn)(struct mmc_queue *, struct request *, bool);
+	int			(*issue_fn)(struct mmc_queue *, struct request *);
 	void			*data;
 	struct request_queue	*queue;
-	struct mmc_queue_req	*mqrq;
+	struct mmc_queue_req	mqrq[2];
 	struct mmc_queue_req	*mqrq_cur;
-	unsigned long		cmdqslot;
-	unsigned long		qdepth;
-	atomic_t		active_slots;
+	struct mmc_queue_req	*mqrq_prev;
 };
 
 extern int mmc_init_queue(struct mmc_queue *, struct mmc_card *, spinlock_t *,
diff --git a/drivers/mmc/core/Kconfig b/drivers/mmc/core/Kconfig
index ae10a37..269d072 100644
--- a/drivers/mmc/core/Kconfig
+++ b/drivers/mmc/core/Kconfig
@@ -26,18 +26,3 @@ config MMC_CLKGATE
 	  support handling this in order for it to be of any use.
 
 	  If unsure, say N.
-
-config MMC_EMBEDDED_SDIO
-	boolean "MMC embedded SDIO device support (EXPERIMENTAL)"
-	help
-	  If you say Y here, support will be added for embedded SDIO
-	  devices which do not contain the necessary enumeration
-	  support in hardware to be properly detected.
-
-config MMC_PARANOID_SD_INIT
-	bool "Enable paranoid SD card initialization (EXPERIMENTAL)"
-	help
-	  If you say Y here, the MMC layer will be extra paranoid
-	  about re-trying SD init requests. This can be a useful
-	  work-around for buggy controllers and hardware. Enable
-	  if you are experiencing issues with SD detection.
diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c
index 31f0668..4b2b6e7 100644
--- a/drivers/mmc/core/bus.c
+++ b/drivers/mmc/core/bus.c
@@ -27,7 +27,7 @@
 
 #define to_mmc_driver(d)	container_of(d, struct mmc_driver, drv)
 
-static ssize_t type_show(struct device *dev,
+static ssize_t mmc_type_show(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
 	struct mmc_card *card = mmc_dev_to_card(dev);
@@ -45,13 +45,11 @@ static ssize_t type_show(struct device *dev,
 		return -EFAULT;
 	}
 }
-static DEVICE_ATTR_RO(type);
 
-static struct attribute *mmc_dev_attrs[] = {
-	&dev_attr_type.attr,
-	NULL,
+static struct device_attribute mmc_dev_attrs[] = {
+	__ATTR(type, S_IRUGO, mmc_type_show, NULL),
+	__ATTR_NULL,
 };
-ATTRIBUTE_GROUPS(mmc_dev);
 
 /*
  * This currently matches any MMC driver to any MMC card - drivers
@@ -245,7 +243,7 @@ static const struct dev_pm_ops mmc_bus_pm_ops = {
 
 static struct bus_type mmc_bus_type = {
 	.name		= "mmc",
-	.dev_groups	= mmc_dev_groups,
+	.dev_attrs	= mmc_dev_attrs,
 	.match		= mmc_bus_match,
 	.uevent		= mmc_bus_uevent,
 	.probe		= mmc_bus_probe,
@@ -367,24 +365,23 @@ int mmc_add_card(struct mmc_card *card)
 		break;
 	}
 
-	if (mmc_card_uhs(card) &&
+	if (mmc_sd_card_uhs(card) &&
 		(card->sd_bus_speed < ARRAY_SIZE(uhs_speeds)))
 		uhs_bus_speed_mode = uhs_speeds[card->sd_bus_speed];
 
 	if (mmc_host_is_spi(card->host)) {
 		pr_info("%s: new %s%s%s card on SPI\n",
 			mmc_hostname(card->host),
-			mmc_card_hs(card) ? "high speed " : "",
-			mmc_card_ddr52(card) ? "DDR " : "",
+			mmc_card_highspeed(card) ? "high speed " : "",
+			mmc_card_ddr_mode(card) ? "DDR " : "",
 			type);
 	} else {
 		pr_info("%s: new %s%s%s%s%s card at address %04x\n",
 			mmc_hostname(card->host),
 			mmc_card_uhs(card) ? "ultra high speed " :
-			(mmc_card_hs(card) ? "high speed " : ""),
-			mmc_card_hs400(card) ? "HS400 " :
+			(mmc_card_highspeed(card) ? "high speed " : ""),
 			(mmc_card_hs200(card) ? "HS200 " : ""),
-			mmc_card_ddr52(card) ? "DDR " : "",
+			mmc_card_ddr_mode(card) ? "DDR " : "",
 			uhs_bus_speed_mode, type, card->rca);
 	}
 
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 1853463..9d3ad3e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -23,17 +23,11 @@
 #include <linux/log2.h>
 #include <linux/regulator/consumer.h>
 #include <linux/pm_runtime.h>
-#include <linux/pm_wakeup.h>
-#include <linux/pm_qos.h>
-#include <linux/intel_mid_pm.h>
 #include <linux/suspend.h>
 #include <linux/fault-inject.h>
 #include <linux/random.h>
 #include <linux/slab.h>
 #include <linux/of.h>
-#include <linux/wakelock.h>
-
-#include <trace/events/mmc.h>
 
 #include <linux/mmc/card.h>
 #include <linux/mmc/host.h>
@@ -64,7 +58,6 @@
 #define MMC_BKOPS_MAX_TIMEOUT	(4 * 60 * 1000) /* max time to wait in ms */
 
 static struct workqueue_struct *workqueue;
-static struct wake_lock mmc_delayed_work_wake_lock;
 static const unsigned freqs[] = { 400000, 300000, 200000, 100000 };
 
 /*
@@ -98,7 +91,6 @@ MODULE_PARM_DESC(
 static int mmc_schedule_delayed_work(struct delayed_work *work,
 				     unsigned long delay)
 {
-	wake_lock(&mmc_delayed_work_wake_lock);
 	return queue_delayed_work(workqueue, work, delay);
 }
 
@@ -147,47 +139,6 @@ static inline void mmc_should_fail_request(struct mmc_host *host,
 
 #endif /* CONFIG_FAIL_MMC_REQUEST */
 
-int mmc_busy_wait(struct mmc_host *host)
-{
-	unsigned long timeout;
-	struct mmc_command cmd = {0};
-	struct mmc_card *card;
-	int err;
-
-	if (!host || !host->card)
-		return 0;
-
-	card = host->card;
-	timeout = jiffies + msecs_to_jiffies(MMC_CORE_TIMEOUT_MS);
-	do {
-		memset(&cmd, 0, sizeof(struct mmc_command));
-		cmd.opcode = MMC_SEND_STATUS;
-		cmd.arg = card->rca << 16;
-		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
-		/* Do not retry else we can't see errors */
-		err = mmc_wait_for_cmd(host, &cmd, 0);
-		if (err || (cmd.resp[0] & 0xFDF92000)) {
-			pr_err("error %d requesting status %#x\n",
-				err, cmd.resp[0]);
-			return -EIO;
-		}
-
-		/* Timeout if the device never becomes ready for data and
-		 * never leaves the program state.
-		 */
-		if (time_after(jiffies, timeout)) {
-			pr_err("%s: Card stuck in programming state! %s\n",
-				mmc_hostname(host), __func__);
-			return -EIO;
-		}
-
-	} while (!(cmd.resp[0] & R1_READY_FOR_DATA) ||
-		 (R1_CURRENT_STATE(cmd.resp[0]) == R1_STATE_PRG));
-
-	return 0;
-}
-EXPORT_SYMBOL(mmc_busy_wait);
-
 /**
  *	mmc_request_done - finish processing an MMC request
  *	@host: MMC host which completed request
@@ -216,6 +167,8 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 	} else {
 		mmc_should_fail_request(host, mrq);
 
+		led_trigger_event(host->led, LED_OFF);
+
 		pr_debug("%s: req done (CMD%u): %d: %08x %08x %08x %08x\n",
 			mmc_hostname(host), cmd->opcode, err,
 			cmd->resp[0], cmd->resp[1],
@@ -225,7 +178,6 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 			pr_debug("%s:     %d bytes transferred: %d\n",
 				mmc_hostname(host),
 				mrq->data->bytes_xfered, mrq->data->error);
-			trace_mmc_blk_rw_end(cmd->opcode, cmd->arg, mrq->data);
 		}
 
 		if (mrq->stop) {
@@ -236,14 +188,6 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 				mrq->stop->resp[2], mrq->stop->resp[3]);
 		}
 
-		if (mmc_op_cmdq_execute_task(cmd->opcode) && !mrq->data) {
-			if (mrq->done)
-				mrq->done(mrq);
-			return;
-		}
-
-		led_trigger_event(host->led, LED_OFF);
-
 		if (mrq->done)
 			mrq->done(mrq);
 
@@ -253,21 +197,6 @@ void mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)
 
 EXPORT_SYMBOL(mmc_request_done);
 
-static void mmc_qos_update(struct mmc_host *host, struct mmc_request *mrq,
-				s32 new_value)
-{
-	if (!host || !host->qos || !mrq)
-		return;
-
-	if (host->card && mmc_card_mmc(host->card) && mrq->data) {
-		/* qos fixup only needed for write transactions */
-		if (mrq->data->flags & MMC_DATA_WRITE)
-			pm_qos_update_request(host->qos, new_value);
-	} else {
-		pm_qos_update_request(host->qos, new_value);
-	}
-}
-
 static void
 mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 {
@@ -276,10 +205,10 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 	struct scatterlist *sg;
 #endif
 
-	if (mrq->precmd) {
+	if (mrq->sbc) {
 		pr_debug("<%s: starting CMD%u arg %08x flags %08x>\n",
-			 mmc_hostname(host), mrq->precmd->opcode,
-			 mrq->precmd->arg, mrq->precmd->flags);
+			 mmc_hostname(host), mrq->sbc->opcode,
+			 mrq->sbc->arg, mrq->sbc->flags);
 	}
 
 	pr_debug("%s: starting CMD%u arg %08x flags %08x\n",
@@ -329,7 +258,6 @@ mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 	}
 	mmc_host_clk_hold(host);
 	led_trigger_event(host->led, LED_FULL);
-	mmc_qos_update(host, mrq, CSTATE_EXIT_LATENCY_C2);
 	host->ops->request(host, mrq);
 }
 
@@ -378,7 +306,7 @@ void mmc_start_bkops(struct mmc_card *card, bool from_exception)
 	}
 
 	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			EXT_CSD_BKOPS_START, 1, timeout, use_busy_signal, true);
+			EXT_CSD_BKOPS_START, 1, timeout, use_busy_signal);
 	if (err) {
 		pr_warn("%s: Error %d starting bkops\n",
 			mmc_hostname(card->host), err);
@@ -442,7 +370,6 @@ static int __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)
 {
 	init_completion(&mrq->completion);
 	mrq->done = mmc_wait_done;
-	mrq->host = host;
 	if (mmc_card_removed(host->card)) {
 		mrq->cmd->error = -ENOMEDIUM;
 		complete(&mrq->completion);
@@ -488,7 +415,6 @@ static int mmc_wait_for_data_req_done(struct mmc_host *host,
 			    mmc_card_removed(host->card)) {
 				err = host->areq->err_check(host->card,
 							    host->areq);
-				mmc_qos_update(host, mrq, PM_QOS_DEFAULT_VALUE);
 				break; /* return err */
 			} else {
 				pr_info("%s: req failed (CMD%u): %d, retrying...\n",
@@ -538,11 +464,8 @@ static void mmc_wait_for_req_done(struct mmc_host *host,
 			}
 		}
 		if (!cmd->error || !cmd->retries ||
-		    mmc_card_removed(host->card)) {
-			if (!mmc_op_cmdq_execute_task(cmd->opcode))
-				mmc_qos_update(host, mrq, PM_QOS_DEFAULT_VALUE);
+		    mmc_card_removed(host->card))
 			break;
-		}
 
 		pr_debug("%s: req failed (CMD%u): %d, retrying...\n",
 			 mmc_hostname(host), cmd->opcode, cmd->error);
@@ -640,12 +563,8 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 			mmc_start_bkops(host->card, true);
 	}
 
-	if (!err && areq) {
-		trace_mmc_blk_rw_start(areq->mrq->cmd->opcode,
-				       areq->mrq->cmd->arg,
-				       areq->mrq->data);
+	if (!err && areq)
 		start_err = __mmc_start_data_req(host, areq->mrq);
-	}
 
 	if (host->areq)
 		mmc_post_req(host, host->areq->mrq, 0);
@@ -665,51 +584,6 @@ struct mmc_async_req *mmc_start_req(struct mmc_host *host,
 }
 EXPORT_SYMBOL(mmc_start_req);
 
-int mmc_execute_cmdq(struct mmc_host *host,
-		struct mmc_async_req *areq,
-		int *status)
-{
-	struct mmc_request mrq = {0};
-	struct mmc_command cmd = {0};
-
-	*status = MMC_BLK_SUCCESS;
-
-	if (host->areq) {
-		*status = mmc_wait_for_data_req_done(host,
-				host->areq->mrq, areq);
-		switch (*status) {
-		case MMC_BLK_SUCCESS:
-		case MMC_BLK_PARTIAL:
-			host->areq = NULL;
-			break;
-		case MMC_BLK_NEW_REQUEST:
-			return 0;
-		default:
-			host->areq = NULL;
-			return -EIO;
-		}
-	}
-
-	host->areq = areq;
-	if (!host->areq)
-		return 0;
-	/*
-	 * If previous request is success, update host->areq
-	 */
-	memcpy(&cmd, areq->mrq->postcmd, sizeof(cmd));
-	mrq.cmd = &cmd;
-	mrq.data = areq->mrq->data;
-	/* CMD complete only */
-	mmc_wait_for_req(host, &mrq);
-	if (mrq.cmd->error) {
-		host->areq = NULL;
-		return mrq.cmd->error;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(mmc_execute_cmdq);
-
 /**
  *	mmc_wait_for_req - start a request and wait for completion
  *	@host: MMC host to start command
@@ -952,11 +826,11 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 	/*
 	 * Some cards require longer data read timeout than indicated in CSD.
 	 * Address this by setting the read timeout to a "reasonably high"
-	 * value. For the cards tested, 600ms has proven enough. If necessary,
+	 * value. For the cards tested, 300ms has proven enough. If necessary,
 	 * this value can be increased if other problematic cards require this.
 	 */
 	if (mmc_card_long_read_time(card) && data->flags & MMC_DATA_READ) {
-		data->timeout_ns = 600000000;
+		data->timeout_ns = 300000000;
 		data->timeout_clks = 0;
 	}
 
@@ -1066,6 +940,31 @@ int __mmc_claim_host(struct mmc_host *host, atomic_t *abort)
 EXPORT_SYMBOL(__mmc_claim_host);
 
 /**
+ *	mmc_try_claim_host - try exclusively to claim a host
+ *	@host: mmc host to claim
+ *
+ *	Returns %1 if the host is claimed, %0 otherwise.
+ */
+int mmc_try_claim_host(struct mmc_host *host)
+{
+	int claimed_host = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	if (!host->claimed || host->claimer == current) {
+		host->claimed = 1;
+		host->claimer = current;
+		host->claim_cnt += 1;
+		claimed_host = 1;
+	}
+	spin_unlock_irqrestore(&host->lock, flags);
+	if (host->ops->enable && claimed_host && host->claim_cnt == 1)
+		host->ops->enable(host);
+	return claimed_host;
+}
+EXPORT_SYMBOL(mmc_try_claim_host);
+
+/**
  *	mmc_release_host - release a host
  *	@host: mmc host to release
  *
@@ -1509,31 +1408,22 @@ u32 mmc_select_voltage(struct mmc_host *host, u32 ocr)
 {
 	int bit;
 
-	/*
-	 * Sanity check the voltages that the card claims to
-	 * support.
-	 */
-	if (ocr & 0x7F) {
-		dev_warn(mmc_dev(host),
-		"card claims to support voltages below defined range\n");
-		ocr &= ~0x7F;
-	}
-
 	ocr &= host->ocr_avail;
-	if (!ocr) {
-		dev_warn(mmc_dev(host), "no support for card's volts\n");
-		return 0;
-	}
 
-	if (host->caps2 & MMC_CAP2_FULL_PWR_CYCLE) {
-		bit = ffs(ocr) - 1;
+	bit = ffs(ocr);
+	if (bit) {
+		bit -= 1;
+
 		ocr &= 3 << bit;
-		mmc_power_cycle(host, ocr);
+
+		mmc_host_clk_hold(host);
+		host->ios.vdd = bit;
+		mmc_set_ios(host);
+		mmc_host_clk_release(host);
 	} else {
-		bit = fls(ocr) - 1;
-		ocr &= 3 << bit;
-		if (bit != host->ios.vdd)
-			dev_warn(mmc_dev(host), "exceeding card's volts\n");
+		pr_warning("%s: host doesn't support card's voltages\n",
+				mmc_hostname(host));
+		ocr = 0;
 	}
 
 	return ocr;
@@ -1558,7 +1448,7 @@ int __mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 
 }
 
-int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr)
+int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)
 {
 	struct mmc_command cmd = {0};
 	int err = 0;
@@ -1640,7 +1530,7 @@ power_cycle:
 	if (err) {
 		pr_debug("%s: Signal voltage switch failed, "
 			"power cycling card\n", mmc_hostname(host));
-		mmc_power_cycle(host, ocr);
+		mmc_power_cycle(host);
 	}
 
 	mmc_host_clk_release(host);
@@ -1681,8 +1571,10 @@ void mmc_set_driver_type(struct mmc_host *host, unsigned int drv_type)
  * If a host does all the power sequencing itself, ignore the
  * initial MMC_POWER_UP stage.
  */
-void mmc_power_up(struct mmc_host *host, u32 ocr)
+void mmc_power_up(struct mmc_host *host)
 {
+	int bit;
+
 	if (host->ios.power_mode == MMC_POWER_ON)
     {
 		return;
@@ -1690,7 +1582,13 @@ void mmc_power_up(struct mmc_host *host, u32 ocr)
 
 	mmc_host_clk_hold(host);
 
-	host->ios.vdd = fls(ocr) - 1;
+	/* If ocr is set, we use it */
+	if (host->ocr)
+		bit = ffs(host->ocr) - 1;
+	else
+		bit = fls(host->ocr_avail) - 1;
+
+	host->ios.vdd = bit;
 	if (mmc_host_is_spi(host))
 		host->ios.chip_select = MMC_CS_HIGH;
 	else
@@ -1736,6 +1634,13 @@ void mmc_power_off(struct mmc_host *host)
 	host->ios.clock = 0;
 	host->ios.vdd = 0;
 
+
+	/*
+	 * Reset ocr mask to be the highest possible voltage supported for
+	 * this mmc host. This value will be used at next power up.
+	 */
+	host->ocr = 1 << (fls(host->ocr_avail) - 1);
+
 	if (!mmc_host_is_spi(host)) {
 		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
 		host->ios.chip_select = MMC_CS_DONTCARE;
@@ -1755,16 +1660,12 @@ void mmc_power_off(struct mmc_host *host)
 	mmc_host_clk_release(host);
 }
 
-void mmc_power_cycle(struct mmc_host *host, u32 ocr)
+void mmc_power_cycle(struct mmc_host *host)
 {
 	mmc_power_off(host);
-	/*
-	 * Wait at least 1 ms according to SD spec
-	 * some of the SD card seems only 1ms is not enough,
-	 * change the actual delay to be 10ms for safe
-	 */
-	mmc_delay(10);
-	mmc_power_up(host, ocr);
+	/* Wait at least 1 ms according to SD spec */
+	mmc_delay(1);
+	mmc_power_up(host);
 }
 
 /*
@@ -1852,28 +1753,6 @@ void mmc_detach_bus(struct mmc_host *host)
 	mmc_bus_put(host);
 }
 
-static void _mmc_detect_change(struct mmc_host *host, unsigned long delay,
-				bool cd_irq)
-{
-#ifdef CONFIG_MMC_DEBUG
-	unsigned long flags;
-	spin_lock_irqsave(&host->lock, flags);
-	WARN_ON(host->removed);
-	spin_unlock_irqrestore(&host->lock, flags);
-#endif
-
-	/*
-	 * If the device is configured as wakeup, we prevent a new sleep for
-	 * 5 s to give provision for user space to consume the event.
-	 */
-	if (cd_irq && !(host->caps & MMC_CAP_NEEDS_POLL) &&
-		device_can_wakeup(mmc_dev(host)))
-		pm_wakeup_event(mmc_dev(host), 5000);
-
-	host->detect_change = 1;
-	mmc_schedule_delayed_work(&host->detect, delay);
-}
-
 /**
  *	mmc_detect_change - process change of state on a MMC socket
  *	@host: host which changed state.
@@ -1886,8 +1765,16 @@ static void _mmc_detect_change(struct mmc_host *host, unsigned long delay,
  */
 void mmc_detect_change(struct mmc_host *host, unsigned long delay)
 {
-	_mmc_detect_change(host, delay, true);
+#ifdef CONFIG_MMC_DEBUG
+	unsigned long flags;
+	spin_lock_irqsave(&host->lock, flags);
+	WARN_ON(host->removed);
+	spin_unlock_irqrestore(&host->lock, flags);
+#endif
+	host->detect_change = 1;
+	mmc_schedule_delayed_work(&host->detect, delay);
 }
+
 EXPORT_SYMBOL(mmc_detect_change);
 
 void mmc_init_erase(struct mmc_card *card)
@@ -1919,7 +1806,7 @@ void mmc_init_erase(struct mmc_card *card)
 		card->erase_shift = ffs(card->ssr.au) - 1;
 	} else if (card->ext_csd.hc_erase_size) {
 		card->pref_erase = card->ext_csd.hc_erase_size;
-	} else if (card->erase_size) {
+	} else {
 		sz = (card->csd.capacity << (card->csd.read_blkbits - 9)) >> 11;
 		if (sz < 128)
 			card->pref_erase = 512 * 1024 / 512;
@@ -1936,8 +1823,7 @@ void mmc_init_erase(struct mmc_card *card)
 			if (sz)
 				card->pref_erase += card->erase_size - sz;
 		}
-	} else
-		card->pref_erase = 0;
+	}
 }
 
 static unsigned int mmc_mmc_erase_timeout(struct mmc_card *card,
@@ -2044,13 +1930,9 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 {
 	struct mmc_command cmd = {0};
 	unsigned int qty = 0;
-	unsigned int fr, nr;
+	unsigned long timeout;
 	int err;
 
-	fr = from;
-	nr = to - from + 1;
-	trace_mmc_blk_erase_start(arg, fr, nr);
-
 	/*
 	 * qty is used to calculate the erase timeout which depends on how many
 	 * erase groups (or allocation units in SD terminology) are affected.
@@ -2113,16 +1995,8 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	memset(&cmd, 0, sizeof(struct mmc_command));
 	cmd.opcode = MMC_ERASE;
 	cmd.arg = arg;
-	if (card->host->caps2 & MMC_CAP2_POLL_R1B_BUSY) {
-		cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;
-		if (card->host->max_discard_to)
-			cmd.cmd_timeout_ms = card->host->max_discard_to - 1;
-		else
-			cmd.cmd_timeout_ms = mmc_erase_timeout(card, arg, qty);
-	} else {
-		cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
-		cmd.cmd_timeout_ms = mmc_erase_timeout(card, arg, qty);
-	}
+	cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
+	cmd.cmd_timeout_ms = mmc_erase_timeout(card, arg, qty);
 	err = mmc_wait_for_cmd(card->host, &cmd, 0);
 	if (err) {
 		pr_err("mmc_erase: erase error %d, status %#x\n",
@@ -2134,10 +2008,34 @@ static int mmc_do_erase(struct mmc_card *card, unsigned int from,
 	if (mmc_host_is_spi(card->host))
 		goto out;
 
-	err = mmc_busy_wait(card->host);
-out:
+	timeout = jiffies + msecs_to_jiffies(MMC_CORE_TIMEOUT_MS);
+	do {
+		memset(&cmd, 0, sizeof(struct mmc_command));
+		cmd.opcode = MMC_SEND_STATUS;
+		cmd.arg = card->rca << 16;
+		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+		/* Do not retry else we can't see errors */
+		err = mmc_wait_for_cmd(card->host, &cmd, 0);
+		if (err || (cmd.resp[0] & 0xFDF92000)) {
+			pr_err("error %d requesting status %#x\n",
+				err, cmd.resp[0]);
+			err = -EIO;
+			goto out;
+		}
+
+		/* Timeout if the device never becomes ready for data and
+		 * never leaves the program state.
+		 */
+		if (time_after(jiffies, timeout)) {
+			pr_err("%s: Card stuck in programming state! %s\n",
+				mmc_hostname(card->host), __func__);
+			err =  -EIO;
+			goto out;
+		}
 
-	trace_mmc_blk_erase_end(arg, fr, nr);
+	} while (!(cmd.resp[0] & R1_READY_FOR_DATA) ||
+		 (R1_CURRENT_STATE(cmd.resp[0]) == R1_STATE_PRG));
+out:
 	return err;
 }
 
@@ -2271,7 +2169,7 @@ static unsigned int mmc_do_calc_max_discard(struct mmc_card *card,
 {
 	struct mmc_host *host = card->host;
 	unsigned int max_discard, x, y, qty = 0, max_qty, timeout;
-	unsigned int last_timeout = 0, aligned_qty;
+	unsigned int last_timeout = 0;
 
 	if (card->erase_shift)
 		max_qty = UINT_MAX >> card->erase_shift;
@@ -2298,21 +2196,16 @@ static unsigned int mmc_do_calc_max_discard(struct mmc_card *card,
 	if (!qty)
 		return 0;
 
-	if (arg & MMC_TRIM_ARGS) {
-		if (qty == 1)
-			aligned_qty = 1;
-		else
-			aligned_qty = qty - 1;
-	} else
-		aligned_qty = qty;
+	if (qty == 1)
+		return 1;
 
 	/* Convert qty to sectors */
 	if (card->erase_shift)
-		max_discard = aligned_qty << card->erase_shift;
+		max_discard = --qty << card->erase_shift;
 	else if (mmc_card_sd(card))
 		max_discard = qty;
 	else
-		max_discard = aligned_qty * card->erase_size;
+		max_discard = --qty * card->erase_size;
 
 	return max_discard;
 }
@@ -2325,7 +2218,6 @@ unsigned int mmc_calc_max_discard(struct mmc_card *card)
 	if (!host->max_discard_to)
 		return UINT_MAX;
 
-
 	/*
 	 * Without erase_group_def set, MMC erase timeout depends on clock
 	 * frequence which can change.  In that case, the best choice is
@@ -2334,9 +2226,6 @@ unsigned int mmc_calc_max_discard(struct mmc_card *card)
 	if (mmc_card_mmc(card) && !(card->ext_csd.erase_group_def & 1))
 		return card->pref_erase;
 
-	if (host->caps2 & MMC_CAP2_POLL_R1B_BUSY)
-		return UINT_MAX;
-
 	max_discard = mmc_do_calc_max_discard(card, MMC_ERASE_ARG);
 	if (mmc_can_trim(card)) {
 		max_trim = mmc_do_calc_max_discard(card, MMC_TRIM_ARG);
@@ -2345,7 +2234,7 @@ unsigned int mmc_calc_max_discard(struct mmc_card *card)
 	} else if (max_discard < card->erase_size) {
 		max_discard = 0;
 	}
-	pr_info("%s: calculated max. discard sectors %u for timeout %u ms\n",
+	pr_debug("%s: calculated max. discard sectors %u for timeout %u ms\n",
 		 mmc_hostname(host), max_discard, host->max_discard_to);
 	return max_discard;
 }
@@ -2355,7 +2244,7 @@ int mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)
 {
 	struct mmc_command cmd = {0};
 
-	if (mmc_card_blockaddr(card) || mmc_card_ddr52(card))
+	if (mmc_card_blockaddr(card) || mmc_card_ddr_mode(card))
 		return 0;
 
 	cmd.opcode = MMC_SET_BLOCKLEN;
@@ -2418,14 +2307,6 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)
 		return -EOPNOTSUPP;
 
 	mmc_host_clk_hold(host);
-
-	/*
-	 * before HW reset card, cache needs to be flushed. Otherwise
-	 * the data in cache can be lost. But this flush may be failed
-	 * because card may be not in a good state
-	 */
-	mmc_cache_ctrl(host, 0);
-
 	mmc_set_clock(host, host->f_init);
 
 	host->ops->hw_reset(host);
@@ -2446,6 +2327,7 @@ static int mmc_do_hw_reset(struct mmc_host *host, int check)
 		}
 	}
 
+	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_DDR);
 	if (mmc_host_is_spi(host)) {
 		host->ios.chip_select = MMC_CS_HIGH;
 		host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
@@ -2482,7 +2364,7 @@ static int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)
 	pr_info("%s: %s: trying to init card at %u Hz\n",
 		mmc_hostname(host), __func__, host->f_init);
 #endif
-	mmc_power_up(host, host->ocr_avail);
+	mmc_power_up(host);
 
 	/*
 	 * Some eMMCs (with VCCQ always on) may not be reset after power up, so
@@ -2571,7 +2453,7 @@ int mmc_detect_card_removed(struct mmc_host *host)
 			 * rescan handle the card removal.
 			 */
 			cancel_delayed_work(&host->detect);
-			_mmc_detect_change(host, 0, false);
+			mmc_detect_change(host, 0);
 		}
 	}
 
@@ -2584,14 +2466,13 @@ void mmc_rescan(struct work_struct *work)
 	struct mmc_host *host =
 		container_of(work, struct mmc_host, detect.work);
 	int i;
-	bool extend_wakelock = false;
 
 	if (host->rescan_disable)
-		goto out;
+		return;
 
 	/* If there is a non-removable card registered, only scan once */
 	if ((host->caps & MMC_CAP_NONREMOVABLE) && host->rescan_entered)
-		goto out;
+		return;
 	host->rescan_entered = 1;
 
 	mmc_bus_get(host);
@@ -2606,12 +2487,6 @@ void mmc_rescan(struct work_struct *work)
 
 	host->detect_change = 0;
 
-	/* If the card was removed the bus will be marked
-	 * as dead - extend the wakelock so userspace
-	 * can respond */
-	if (host->bus_dead)
-		extend_wakelock = 1;
-
 	/*
 	 * Let mmc_bus_put() free the bus/bus_ops if we've found that
 	 * the card is no longer present.
@@ -2631,8 +2506,7 @@ void mmc_rescan(struct work_struct *work)
 	 */
 	mmc_bus_put(host);
 
-	if (!(host->caps & MMC_CAP_NONREMOVABLE) && host->ops->get_cd &&
-			host->ops->get_cd(host) == 0) {
+	if (host->ops->get_cd && host->ops->get_cd(host) == 0) {
 		mmc_claim_host(host);
 		mmc_power_off(host);
 		mmc_release_host(host);
@@ -2648,16 +2522,14 @@ void mmc_rescan(struct work_struct *work)
 		// currently initialized. Power up then power cycle the emmc/host to 
 		// ensure it is configured as it believes it is currently off and during
 		// the cycle, the off is ignored when it shouldn't be.
-		mmc_power_up(host, host->ocr_avail);
-		mmc_power_cycle(host, host->ocr_avail);
+		mmc_power_up(host);
+		mmc_power_cycle(host);
     }
 #endif
 
 	for (i = 0; i < ARRAY_SIZE(freqs); i++) {
-		if (!mmc_rescan_try_freq(host, max(freqs[i], host->f_min))) {
-			extend_wakelock = true;
+		if (!mmc_rescan_try_freq(host, max(freqs[i], host->f_min)))
 			break;
-		}
 		if (freqs[i] <= host->f_min)
 			break;
 	}
@@ -2665,10 +2537,6 @@ void mmc_rescan(struct work_struct *work)
 	mmc_release_host(host);
 
  out:
-	if (extend_wakelock)
-		wake_lock_timeout(&mmc_delayed_work_wake_lock, HZ / 2);
-	else
-		wake_unlock(&mmc_delayed_work_wake_lock);
 	if (host->caps & MMC_CAP_NEEDS_POLL)
 		mmc_schedule_delayed_work(&host->detect, HZ);
 }
@@ -2680,8 +2548,8 @@ void mmc_start_host(struct mmc_host *host)
 	if (host->caps2 & MMC_CAP2_NO_PRESCAN_POWERUP)
 		mmc_power_off(host);
 	else
-		mmc_power_up(host, host->ocr_avail);
-	_mmc_detect_change(host, 0, false);
+		mmc_power_up(host);
+	mmc_detect_change(host, 0);
 }
 
 void mmc_stop_host(struct mmc_host *host)
@@ -2738,11 +2606,6 @@ int mmc_power_save_host(struct mmc_host *host)
 
 	mmc_bus_put(host);
 
-	/*
-	 * disable cache before power off device
-	 */
-	mmc_cache_ctrl(host, 0);
-
 	mmc_power_off(host);
 
 	return ret;
@@ -2764,7 +2627,7 @@ int mmc_power_restore_host(struct mmc_host *host)
 		return -EINVAL;
 	}
 
-	mmc_power_up(host, host->card->ocr);
+	mmc_power_up(host);
 	ret = host->bus_ops->power_restore(host);
 
 	mmc_bus_put(host);
@@ -2820,22 +2683,8 @@ int mmc_cache_ctrl(struct mmc_host *host, u8 enable)
 
 		if (card->ext_csd.cache_ctrl ^ enable) {
 			timeout = enable ? card->ext_csd.generic_cmd6_time : 0;
-			if (enable)
-				err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-						EXT_CSD_CACHE_CTRL, enable,
-						timeout);
-			else {
-				/*
-				 * disable cache will cause flushing data to
-				 * non-volatile storage, so we may need to
-				 * check busy state here by polling card status
-				 */
-				err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-						EXT_CSD_CACHE_CTRL, enable,
-						timeout, false, false);
-				if (!err)
-					err = mmc_busy_wait(host);
-			}
+			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+					EXT_CSD_CACHE_CTRL, enable, timeout);
 			if (err)
 				pr_err("%s: cache %s error %d\n",
 						mmc_hostname(card->host),
@@ -2905,7 +2754,6 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 			break;
 
 		/* Calling bus_ops->remove() with a claimed host can deadlock */
-		mmc_cache_ctrl(host, 0);
 		host->bus_ops->remove(host);
 		mmc_claim_host(host);
 		mmc_detach_bus(host);
@@ -2921,7 +2769,7 @@ int mmc_pm_notify(struct notifier_block *notify_block,
 		spin_lock_irqsave(&host->lock, flags);
 		host->rescan_disable = 0;
 		spin_unlock_irqrestore(&host->lock, flags);
-		_mmc_detect_change(host, 0, false);
+		mmc_detect_change(host, 0);
 
 	}
 
@@ -2946,22 +2794,6 @@ void mmc_init_context_info(struct mmc_host *host)
 	init_waitqueue_head(&host->context_info.wait);
 }
 
-#ifdef CONFIG_MMC_EMBEDDED_SDIO
-void mmc_set_embedded_sdio_data(struct mmc_host *host,
-				struct sdio_cis *cis,
-				struct sdio_cccr *cccr,
-				struct sdio_embedded_func *funcs,
-				int num_funcs)
-{
-	host->embedded_sdio_data.cis = cis;
-	host->embedded_sdio_data.cccr = cccr;
-	host->embedded_sdio_data.funcs = funcs;
-	host->embedded_sdio_data.num_funcs = num_funcs;
-}
-
-EXPORT_SYMBOL(mmc_set_embedded_sdio_data);
-#endif
-
 static int __init mmc_init(void)
 {
 	int ret;
@@ -2970,9 +2802,6 @@ static int __init mmc_init(void)
 	if (!workqueue)
 		return -ENOMEM;
 
-	wake_lock_init(&mmc_delayed_work_wake_lock, WAKE_LOCK_SUSPEND,
-		       "mmc_delayed_work");
-
 	ret = mmc_register_bus();
 	if (ret)
 		goto destroy_workqueue;
@@ -2993,7 +2822,6 @@ unregister_bus:
 	mmc_unregister_bus();
 destroy_workqueue:
 	destroy_workqueue(workqueue);
-	wake_lock_destroy(&mmc_delayed_work_wake_lock);
 
 	return ret;
 }
@@ -3004,7 +2832,6 @@ static void __exit mmc_exit(void)
 	mmc_unregister_host_class();
 	mmc_unregister_bus();
 	destroy_workqueue(workqueue);
-	wake_lock_destroy(&mmc_delayed_work_wake_lock);
 }
 
 subsys_initcall(mmc_init);
diff --git a/drivers/mmc/core/core.h b/drivers/mmc/core/core.h
index b7584d8..5345d15 100644
--- a/drivers/mmc/core/core.h
+++ b/drivers/mmc/core/core.h
@@ -42,23 +42,22 @@ void mmc_set_ungated(struct mmc_host *host);
 void mmc_set_bus_mode(struct mmc_host *host, unsigned int mode);
 void mmc_set_bus_width(struct mmc_host *host, unsigned int width);
 u32 mmc_select_voltage(struct mmc_host *host, u32 ocr);
-int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage, u32 ocr);
+int mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage);
 int __mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage);
 void mmc_set_timing(struct mmc_host *host, unsigned int timing);
 void mmc_set_driver_type(struct mmc_host *host, unsigned int drv_type);
-void mmc_power_up(struct mmc_host *host, u32 ocr);
+void mmc_power_up(struct mmc_host *host);
 void mmc_power_off(struct mmc_host *host);
-void mmc_power_cycle(struct mmc_host *host, u32 ocr);
+void mmc_power_cycle(struct mmc_host *host);
 
 static inline void mmc_delay(unsigned int ms)
 {
 	if (ms < 1000 / HZ) {
 		cond_resched();
 		mdelay(ms);
-	} else if (ms < 20)
-		usleep_range(ms * 1000, (ms + 1) * 1000);
-	else
+	} else {
 		msleep(ms);
+	}
 }
 
 void mmc_rescan(struct work_struct *work);
diff --git a/drivers/mmc/core/debugfs.c b/drivers/mmc/core/debugfs.c
index 22f9106..54829c0 100644
--- a/drivers/mmc/core/debugfs.c
+++ b/drivers/mmc/core/debugfs.c
@@ -126,9 +126,6 @@ static int mmc_ios_show(struct seq_file *s, void *data)
 	case MMC_TIMING_SD_HS:
 		str = "sd high-speed";
 		break;
-	case MMC_TIMING_UHS_SDR25:
-		str = "sd uhs SDR25";
-		break;
 	case MMC_TIMING_UHS_SDR50:
 		str = "sd uhs SDR50";
 		break;
@@ -138,14 +135,8 @@ static int mmc_ios_show(struct seq_file *s, void *data)
 	case MMC_TIMING_UHS_DDR50:
 		str = "sd uhs DDR50";
 		break;
-	case MMC_TIMING_MMC_DDR52:
-		str = "mmc DDR52";
-		break;
 	case MMC_TIMING_MMC_HS200:
-		str = "mmc HS200";
-		break;
-	case MMC_TIMING_MMC_HS400:
-		str = "mmc HS400";
+		str = "mmc high-speed SDR200";
 		break;
 	default:
 		str = "invalid";
@@ -167,7 +158,7 @@ static int mmc_ios_show(struct seq_file *s, void *data)
 		str = "invalid";
 		break;
 	}
-	seq_printf(s, "signal voltage:\t%u (%s)\n", ios->signal_voltage, str);
+	seq_printf(s, "signal voltage:\t%u (%s)\n", ios->chip_select, str);
 
 	return 0;
 }
@@ -198,7 +189,7 @@ static int mmc_clock_opt_set(void *data, u64 val)
 	struct mmc_host *host = data;
 
 	/* We need this check due to input value is u64 */
-	if ((val > host->f_max) || (val < host->f_min))
+	if (val > host->f_max)
 		return -EINVAL;
 
 	mmc_claim_host(host);
diff --git a/drivers/mmc/core/host.c b/drivers/mmc/core/host.c
index eb1d039..49bc403 100644
--- a/drivers/mmc/core/host.c
+++ b/drivers/mmc/core/host.c
@@ -22,7 +22,6 @@
 #include <linux/leds.h>
 #include <linux/slab.h>
 #include <linux/suspend.h>
-#include <linux/pm_runtime.h>
 
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
@@ -40,15 +39,9 @@ static void mmc_host_classdev_release(struct device *dev)
 	kfree(host);
 }
 
-static const struct dev_pm_ops mmc_host_class_pm_ops = {
-	SET_RUNTIME_PM_OPS(pm_generic_runtime_suspend,
-			pm_generic_runtime_resume, NULL)
-};
-
 static struct class mmc_host_class = {
 	.name		= "mmc_host",
 	.dev_release	= mmc_host_classdev_release,
-	.pm		= &mmc_host_class_pm_ops,
 };
 
 int mmc_register_host_class(void)
@@ -539,15 +532,8 @@ int mmc_add_host(struct mmc_host *host)
 #endif
 	mmc_host_clk_sysfs_init(host);
 
-	/*
-	 * ignore the children by default
-	 */
-	pm_suspend_ignore_children(&host->class_dev, true);
-	pm_runtime_enable(&host->class_dev);
-
 	mmc_start_host(host);
-	if (!(host->pm_flags & MMC_PM_IGNORE_PM_NOTIFY))
-		register_pm_notifier(&host->pm_notify);
+	register_pm_notifier(&host->pm_notify);
 
 	return 0;
 }
@@ -564,9 +550,7 @@ EXPORT_SYMBOL(mmc_add_host);
  */
 void mmc_remove_host(struct mmc_host *host)
 {
-	if (!(host->pm_flags & MMC_PM_IGNORE_PM_NOTIFY))
-		unregister_pm_notifier(&host->pm_notify);
-
+	unregister_pm_notifier(&host->pm_notify);
 	mmc_stop_host(host);
 
 #ifdef CONFIG_DEBUG_FS
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 650e009..36d6701 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -13,7 +13,6 @@
 #include <linux/err.h>
 #include <linux/slab.h>
 #include <linux/stat.h>
-#include <linux/pm_runtime.h>
 
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
@@ -240,62 +239,31 @@ static int mmc_get_ext_csd(struct mmc_card *card, u8 **new_ext_csd)
 static void mmc_select_card_type(struct mmc_card *card)
 {
 	struct mmc_host *host = card->host;
-	u8 card_type = card->ext_csd.raw_card_type;
+	u8 card_type = card->ext_csd.raw_card_type & EXT_CSD_CARD_TYPE_MASK;
 	u32 caps = host->caps, caps2 = host->caps2;
-	unsigned int hs_max_dtr = 0, hs200_max_dtr = 0;
-	unsigned int avail_type = 0;
+	unsigned int hs_max_dtr = 0;
 
-	if (caps & MMC_CAP_MMC_HIGHSPEED &&
-	    card_type & EXT_CSD_CARD_TYPE_HS_26) {
+	if (card_type & EXT_CSD_CARD_TYPE_26)
 		hs_max_dtr = MMC_HIGH_26_MAX_DTR;
-		avail_type |= EXT_CSD_CARD_TYPE_HS_26;
-	}
 
 	if (caps & MMC_CAP_MMC_HIGHSPEED &&
-	    card_type & EXT_CSD_CARD_TYPE_HS_52) {
+			card_type & EXT_CSD_CARD_TYPE_52)
 		hs_max_dtr = MMC_HIGH_52_MAX_DTR;
-		avail_type |= EXT_CSD_CARD_TYPE_HS_52;
-	}
 
-	if (caps & MMC_CAP_1_8V_DDR &&
-	    card_type & EXT_CSD_CARD_TYPE_DDR_1_8V) {
+	if ((caps & MMC_CAP_1_8V_DDR &&
+			card_type & EXT_CSD_CARD_TYPE_DDR_1_8V) ||
+	    (caps & MMC_CAP_1_2V_DDR &&
+			card_type & EXT_CSD_CARD_TYPE_DDR_1_2V))
 		hs_max_dtr = MMC_HIGH_DDR_MAX_DTR;
-		avail_type |= EXT_CSD_CARD_TYPE_DDR_1_8V;
-	}
 
-	if (caps & MMC_CAP_1_2V_DDR &&
-	    card_type & EXT_CSD_CARD_TYPE_DDR_1_2V) {
-		hs_max_dtr = MMC_HIGH_DDR_MAX_DTR;
-		avail_type |= EXT_CSD_CARD_TYPE_DDR_1_2V;
-	}
-
-	if (caps2 & MMC_CAP2_HS200_1_8V_SDR &&
-	    card_type & EXT_CSD_CARD_TYPE_HS200_1_8V) {
-		hs200_max_dtr = MMC_HS200_MAX_DTR;
-		avail_type |= EXT_CSD_CARD_TYPE_HS200_1_8V;
-	}
-
-	if (caps2 & MMC_CAP2_HS200_1_2V_SDR &&
-	    card_type & EXT_CSD_CARD_TYPE_HS200_1_2V) {
-		hs200_max_dtr = MMC_HS200_MAX_DTR;
-		avail_type |= EXT_CSD_CARD_TYPE_HS200_1_2V;
-	}
-
-	if (caps2 & MMC_CAP2_HS400_1_8V &&
-	    card_type & EXT_CSD_CARD_TYPE_HS400_1_8V) {
-		hs200_max_dtr = MMC_HS200_MAX_DTR;
-		avail_type |= EXT_CSD_CARD_TYPE_HS400_1_8V;
-	}
-
-	if (caps2 & MMC_CAP2_HS400_1_2V &&
-	    card_type & EXT_CSD_CARD_TYPE_HS400_1_2V) {
-		hs200_max_dtr = MMC_HS200_MAX_DTR;
-		avail_type |= EXT_CSD_CARD_TYPE_HS400_1_2V;
-	}
+	if ((caps2 & MMC_CAP2_HS200_1_8V_SDR &&
+			card_type & EXT_CSD_CARD_TYPE_SDR_1_8V) ||
+	    (caps2 & MMC_CAP2_HS200_1_2V_SDR &&
+			card_type & EXT_CSD_CARD_TYPE_SDR_1_2V))
+		hs_max_dtr = MMC_HS200_MAX_DTR;
 
 	card->ext_csd.hs_max_dtr = hs_max_dtr;
-	card->ext_csd.hs200_max_dtr = hs200_max_dtr;
-	card->mmc_avail_type = avail_type;
+	card->ext_csd.card_type = card_type;
 }
 
 /*
@@ -355,8 +323,6 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 		ext_csd[EXT_CSD_ERASE_TIMEOUT_MULT];
 	card->ext_csd.raw_hc_erase_grp_size =
 		ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE];
-	card->ext_csd.part_set_complete =
-		ext_csd[EXT_CSD_PART_SET_COMPLETE];
 	if (card->ext_csd.rev >= 3) {
 		u8 sa_shift = ext_csd[EXT_CSD_S_A_TIMEOUT];
 		card->ext_csd.part_config = ext_csd[EXT_CSD_PART_CONFIG];
@@ -512,8 +478,6 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 			ext_csd[EXT_CSD_PWR_CL_DDR_52_195];
 		card->ext_csd.raw_pwr_cl_ddr_52_360 =
 			ext_csd[EXT_CSD_PWR_CL_DDR_52_360];
-		card->ext_csd.raw_pwr_cl_ddr_200_360 =
-			ext_csd[EXT_CSD_PWR_CL_DDR_200_360];
 	}
 
 	if (card->ext_csd.rev >= 5) {
@@ -605,20 +569,6 @@ static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)
 		card->ext_csd.data_sector_size = 512;
 	}
 
-	if (card->ext_csd.rev >= 7) {
-		/* check CQ capability */
-		if (ext_csd[EXT_CSD_CMDQ_SUPPORT] &&
-				ext_csd[EXT_CSD_CMDQ_DEPTH]) {
-			card->ext_csd.cmdq_support =
-				ext_csd[EXT_CSD_CMDQ_SUPPORT];
-			card->ext_csd.cmdq_depth = ext_csd[EXT_CSD_CMDQ_DEPTH];
-			if (card->ext_csd.cmdq_depth <= 2) {
-				card->ext_csd.cmdq_support = 0;
-				card->ext_csd.cmdq_depth = 0;
-			}
-		}
-	}
-
 out:
 	return err;
 }
@@ -694,10 +644,7 @@ static int mmc_compare_ext_csds(struct mmc_card *card, unsigned bus_width)
 		(card->ext_csd.raw_pwr_cl_ddr_52_195 ==
 			bw_ext_csd[EXT_CSD_PWR_CL_DDR_52_195]) &&
 		(card->ext_csd.raw_pwr_cl_ddr_52_360 ==
-			bw_ext_csd[EXT_CSD_PWR_CL_DDR_52_360]) &&
-		(card->ext_csd.raw_pwr_cl_ddr_200_360 ==
-			bw_ext_csd[EXT_CSD_PWR_CL_DDR_200_360]));
-
+			bw_ext_csd[EXT_CSD_PWR_CL_DDR_52_360]));
 	if (err)
 		err = -EINVAL;
 
@@ -720,13 +667,11 @@ MMC_DEV_ATTR(name, "%s\n", card->cid.prod_name);
 MMC_DEV_ATTR(oemid, "0x%04x\n", card->cid.oemid);
 MMC_DEV_ATTR(prv, "0x%x\n", card->cid.prv);
 MMC_DEV_ATTR(serial, "0x%08x\n", card->cid.serial);
-MMC_DEV_ATTR(enhanced_area_offset, "%lld\n",
+MMC_DEV_ATTR(enhanced_area_offset, "%llu\n",
 		card->ext_csd.enhanced_area_offset);
-MMC_DEV_ATTR(enhanced_area_size, "%d KBytes\n",
-		card->ext_csd.enhanced_area_size);
+MMC_DEV_ATTR(enhanced_area_size, "%u\n", card->ext_csd.enhanced_area_size);
 MMC_DEV_ATTR(raw_rpmb_size_mult, "%#x\n", card->ext_csd.raw_rpmb_size_mult);
 MMC_DEV_ATTR(rel_sectors, "%#x\n", card->ext_csd.rel_sectors);
-MMC_DEV_ATTR(cmdq_en, "%#x\n", card->ext_csd.cmdq_en);
 
 static struct attribute *mmc_std_attrs[] = {
 	&dev_attr_cid.attr,
@@ -745,7 +690,6 @@ static struct attribute *mmc_std_attrs[] = {
 	&dev_attr_enhanced_area_size.attr,
 	&dev_attr_raw_rpmb_size_mult.attr,
 	&dev_attr_rel_sectors.attr,
-	&dev_attr_cmdq_en.attr,
 	NULL,
 };
 
@@ -768,13 +712,17 @@ static struct device_type mmc_type = {
  * extended CSD register, select it by executing the
  * mmc_switch command.
  */
-static int __mmc_select_powerclass(struct mmc_card *card,
-				   unsigned int bus_width)
+static int mmc_select_powerclass(struct mmc_card *card,
+		unsigned int bus_width)
 {
-	struct mmc_host *host = card->host;
-	struct mmc_ext_csd *ext_csd = &card->ext_csd;
-	unsigned int pwrclass_val = 0;
 	int err = 0;
+	unsigned int pwrclass_val = 0;
+	struct mmc_host *host;
+
+	BUG_ON(!card);
+
+	host = card->host;
+	BUG_ON(!host);
 
 	/* Power class selection is supported for versions >= 4.0 */
 	if (card->csd.mmca_vsn < CSD_SPEC_VER_4)
@@ -786,14 +734,14 @@ static int __mmc_select_powerclass(struct mmc_card *card,
 
 	switch (1 << host->ios.vdd) {
 	case MMC_VDD_165_195:
-		if (host->ios.clock <= MMC_HIGH_26_MAX_DTR)
-			pwrclass_val = ext_csd->raw_pwr_cl_26_195;
-		else if (host->ios.clock <= MMC_HIGH_52_MAX_DTR)
+		if (host->ios.clock <= 26000000)
+			pwrclass_val = card->ext_csd.raw_pwr_cl_26_195;
+		else if	(host->ios.clock <= 52000000)
 			pwrclass_val = (bus_width <= EXT_CSD_BUS_WIDTH_8) ?
-				ext_csd->raw_pwr_cl_52_195 :
-				ext_csd->raw_pwr_cl_ddr_52_195;
-		else if (host->ios.clock <= MMC_HS200_MAX_DTR)
-			pwrclass_val = ext_csd->raw_pwr_cl_200_195;
+				card->ext_csd.raw_pwr_cl_52_195 :
+				card->ext_csd.raw_pwr_cl_ddr_52_195;
+		else if (host->ios.clock <= 200000000)
+			pwrclass_val = card->ext_csd.raw_pwr_cl_200_195;
 		break;
 	case MMC_VDD_27_28:
 	case MMC_VDD_28_29:
@@ -804,16 +752,14 @@ static int __mmc_select_powerclass(struct mmc_card *card,
 	case MMC_VDD_33_34:
 	case MMC_VDD_34_35:
 	case MMC_VDD_35_36:
-		if (host->ios.clock <= MMC_HIGH_26_MAX_DTR)
-			pwrclass_val = ext_csd->raw_pwr_cl_26_360;
-		else if (host->ios.clock <= MMC_HIGH_52_MAX_DTR)
+		if (host->ios.clock <= 26000000)
+			pwrclass_val = card->ext_csd.raw_pwr_cl_26_360;
+		else if	(host->ios.clock <= 52000000)
 			pwrclass_val = (bus_width <= EXT_CSD_BUS_WIDTH_8) ?
-				ext_csd->raw_pwr_cl_52_360 :
-				ext_csd->raw_pwr_cl_ddr_52_360;
-		else if (host->ios.clock <= MMC_HS200_MAX_DTR)
-			pwrclass_val = (bus_width == EXT_CSD_DDR_BUS_WIDTH_8) ?
-				ext_csd->raw_pwr_cl_ddr_200_360 :
-				ext_csd->raw_pwr_cl_200_360;
+				card->ext_csd.raw_pwr_cl_52_360 :
+				card->ext_csd.raw_pwr_cl_ddr_52_360;
+		else if (host->ios.clock <= 200000000)
+			pwrclass_val = card->ext_csd.raw_pwr_cl_200_360;
 		break;
 	default:
 		pr_warning("%s: Voltage range not supported "
@@ -839,79 +785,40 @@ static int __mmc_select_powerclass(struct mmc_card *card,
 	return err;
 }
 
-static int mmc_select_powerclass(struct mmc_card *card)
-{
-	struct mmc_host *host = card->host;
-	u32 bus_width, ext_csd_bits;
-	int err, ddr;
-
-	/* Power class selection is supported for versions >= 4.0 */
-	if (card->csd.mmca_vsn < CSD_SPEC_VER_4)
-		return 0;
-
-	bus_width = host->ios.bus_width;
-	/* Power class values are defined only for 4/8 bit bus */
-	if (bus_width == MMC_BUS_WIDTH_1)
-		return 0;
-
-	ddr = card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_52;
-	if (ddr)
-		ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?
-			EXT_CSD_DDR_BUS_WIDTH_8 : EXT_CSD_DDR_BUS_WIDTH_4;
-	else
-		ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?
-			EXT_CSD_BUS_WIDTH_8 :  EXT_CSD_BUS_WIDTH_4;
-
-	err = __mmc_select_powerclass(card, ext_csd_bits);
-	if (err)
-		pr_warn("%s: power class selection to bus width %d ddr %d failed\n",
-			mmc_hostname(host), 1 << bus_width, ddr);
-
-	return err;
-}
-
-/*
- * Set the bus speed for the selected speed mode.
- */
-static void mmc_set_bus_speed(struct mmc_card *card)
-{
-	unsigned int max_dtr = (unsigned int)-1;
-
-	if ((mmc_card_hs200(card) || mmc_card_hs400(card)) &&
-	     max_dtr > card->ext_csd.hs200_max_dtr)
-		max_dtr = card->ext_csd.hs200_max_dtr;
-	else if (mmc_card_hs(card) && max_dtr > card->ext_csd.hs_max_dtr)
-		max_dtr = card->ext_csd.hs_max_dtr;
-	else if (max_dtr > card->csd.max_dtr)
-		max_dtr = card->csd.max_dtr;
-
-	mmc_set_clock(card->host, max_dtr);
-}
-
 /*
- * Select the bus width amoung 4-bit and 8-bit(SDR).
- * If the bus width is changed successfully, return the selected width value.
- * Zero is returned instead of error value if the wide width is not supported.
+ * Selects the desired buswidth and switch to the HS200 mode
+ * if bus width set without error
  */
-static int mmc_select_bus_width(struct mmc_card *card)
+static int mmc_select_hs200(struct mmc_card *card)
 {
+	int idx, err = -EINVAL;
+	struct mmc_host *host;
 	static unsigned ext_csd_bits[] = {
-		EXT_CSD_BUS_WIDTH_8,
 		EXT_CSD_BUS_WIDTH_4,
+		EXT_CSD_BUS_WIDTH_8,
 	};
 	static unsigned bus_widths[] = {
-		MMC_BUS_WIDTH_8,
 		MMC_BUS_WIDTH_4,
+		MMC_BUS_WIDTH_8,
 	};
-	struct mmc_host *host = card->host;
-	unsigned idx, bus_width = 0;
-	int err = 0;
 
-	if ((card->csd.mmca_vsn < CSD_SPEC_VER_4) &&
-	    !(host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA)))
-		return 0;
+	BUG_ON(!card);
+
+	host = card->host;
 
-	idx = (host->caps & MMC_CAP_8_BIT_DATA) ? 0 : 1;
+	if (card->ext_csd.card_type & EXT_CSD_CARD_TYPE_SDR_1_2V &&
+			host->caps2 & MMC_CAP2_HS200_1_2V_SDR)
+		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
+
+	if (err && card->ext_csd.card_type & EXT_CSD_CARD_TYPE_SDR_1_8V &&
+			host->caps2 & MMC_CAP2_HS200_1_8V_SDR)
+		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
+
+	/* If fails try again during next card power cycle */
+	if (err)
+		goto err;
+
+	idx = (host->caps & MMC_CAP_8_BIT_DATA) ? 1 : 0;
 
 	/*
 	 * Unlike SD, MMC cards dont have a configuration register to notify
@@ -919,7 +826,8 @@ static int mmc_select_bus_width(struct mmc_card *card)
 	 * the supported bus width or compare the ext csd values of current
 	 * bus width and ext csd values of 1 bit mode read earlier.
 	 */
-	for (; idx < ARRAY_SIZE(bus_widths); idx++) {
+	for (; idx >= 0; idx--) {
+
 		/*
 		 * Host is capable of 8bit transfer, then switch
 		 * the device to work in 8bit transfer mode. If the
@@ -934,277 +842,25 @@ static int mmc_select_bus_width(struct mmc_card *card)
 		if (err)
 			continue;
 
-		bus_width = bus_widths[idx];
-		mmc_set_bus_width(host, bus_width);
+		mmc_set_bus_width(card->host, bus_widths[idx]);
 
-		/*
-		 * If controller can't handle bus width test,
-		 * compare ext_csd previously read in 1 bit mode
-		 * against ext_csd at new bus width
-		 */
 		if (!(host->caps & MMC_CAP_BUS_WIDTH_TEST))
-			err = mmc_compare_ext_csds(card, bus_width);
+			err = mmc_compare_ext_csds(card, bus_widths[idx]);
 		else
-			err = mmc_bus_test(card, bus_width);
-
-		if (!err) {
-			err = bus_width;
+			err = mmc_bus_test(card, bus_widths[idx]);
+		if (!err)
 			break;
-		} else {
-			pr_warn("%s: switch to bus width %d failed\n",
-				mmc_hostname(host), ext_csd_bits[idx]);
-		}
 	}
 
-	return err;
-}
-
-/*
- * Switch to the high-speed mode
- */
-static int mmc_select_hs(struct mmc_card *card)
-{
-	int err;
-
-	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS,
-			   card->ext_csd.generic_cmd6_time);
-	if (!err)
-		mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
-
-	return err;
-}
-
-/*
- * Activate wide bus and DDR if supported.
- */
-static int mmc_select_hs_ddr(struct mmc_card *card)
-{
-	struct mmc_host *host = card->host;
-	u32 bus_width, ext_csd_bits;
-	int err = 0;
-
-	if (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_52))
-		return 0;
-
-	bus_width = host->ios.bus_width;
-	if (bus_width == MMC_BUS_WIDTH_1)
-		return 0;
-
-	ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?
-		EXT_CSD_DDR_BUS_WIDTH_8 : EXT_CSD_DDR_BUS_WIDTH_4;
-
-	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			EXT_CSD_BUS_WIDTH,
-			ext_csd_bits,
-			card->ext_csd.generic_cmd6_time);
-	if (err) {
-		pr_warn("%s: switch to bus width %d ddr failed\n",
-			mmc_hostname(host), 1 << bus_width);
-		return err;
-	}
-
-	/*
-	 * eMMC cards can support 3.3V to 1.2V i/o (vccq)
-	 * signaling.
-	 *
-	 * EXT_CSD_CARD_TYPE_DDR_1_8V means 3.3V or 1.8V vccq.
-	 *
-	 * 1.8V vccq at 3.3V core voltage (vcc) is not required
-	 * in the JEDEC spec for DDR.
-	 *
-	 * Even (e)MMC card can support 3.3v to 1.2v vccq, but not all
-	 * host controller can support this, like some of the SDHCI
-	 * controller which connect to an eMMC device. Some of these
-	 * host controller still needs to use 1.8v vccq for supporting
-	 * DDR mode.
-	 *
-	 * So the sequence will be:
-	 * if (host and device can both support 1.2v IO)
-	 *	use 1.2v IO;
-	 * else if (host and device can both support 1.8v IO)
-	 * 	use 1.8v IO;
-	 * so if host and device can only support 3.3v IO, this is the
-	 * last choice.
-	 *
-	 * WARNING: eMMC rules are NOT the same as SD DDR
-	 */
-	err = -EINVAL;
-	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_2V)
-		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
-
-	if (err && (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_8V))
-		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
-
-	/* make sure vccq is 3.3v after switching disaster */
-	if (err)
-		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330);
-
+	/* switch to HS200 mode if bus width set successfully */
 	if (!err)
-		mmc_set_timing(host, MMC_TIMING_MMC_DDR52);
-
-	return err;
-}
-
-static int mmc_select_hs400(struct mmc_card *card)
-{
-	struct mmc_host *host = card->host;
-	int err = 0;
-
-	/*
-	 * HS400 mode requires 8-bit bus width
-	 */
-	if (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&
-	      host->ios.bus_width == MMC_BUS_WIDTH_8))
-		return 0;
-
-	/*
-	 * Before switching to dual data rate operation for HS400,
-	 * it is required to convert from HS200 mode to HS mode.
-	 */
-	mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
-	mmc_set_bus_speed(card);
-
-	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS,
-			   card->ext_csd.generic_cmd6_time);
-	if (err) {
-		pr_warn("%s: switch to high-speed from hs200 failed, err:%d\n",
-			mmc_hostname(host), err);
-		return err;
-	}
-
-	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			 EXT_CSD_BUS_WIDTH,
-			 EXT_CSD_DDR_BUS_WIDTH_8,
-			 card->ext_csd.generic_cmd6_time);
-	if (err) {
-		pr_warn("%s: switch to bus width for hs400 failed, err:%d\n",
-			mmc_hostname(host), err);
-		return err;
-	}
-
-	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS400,
-			   card->ext_csd.generic_cmd6_time);
-	if (err) {
-		pr_warn("%s: switch to hs400 failed, err:%d\n",
-			 mmc_hostname(host), err);
-		return err;
-	}
-
-	mmc_set_timing(host, MMC_TIMING_MMC_HS400);
-	mmc_set_bus_speed(card);
-
-	return 0;
-}
-
-/*
- * For device supporting HS200 mode, the following sequence
- * should be done before executing the tuning process.
- * 1. set the desired bus width(4-bit or 8-bit, 1-bit is not supported)
- * 2. switch to HS200 mode
- * 3. set the clock to > 52Mhz and <=200MHz
- */
-static int mmc_select_hs200(struct mmc_card *card)
-{
-	struct mmc_host *host = card->host;
-	int err = -EINVAL;
-
-	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_2V)
-		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);
-
-	if (err && card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_8V)
-		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
-
-	/* If fails try again during next card power cycle */
-	if (err)
-		goto err;
-
-	/*
-	 * Set the bus width(4 or 8) with host's support and
-	 * switch to HS200 mode if bus width is set successfully.
-	 */
-	err = mmc_select_bus_width(card);
-	if (!IS_ERR_VALUE(err)) {
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				 EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS200, 0);
-		if (!err)
-			mmc_set_timing(host, MMC_TIMING_MMC_HS200);
-	}
+				 EXT_CSD_HS_TIMING, 2, 0);
 err:
 	return err;
 }
 
 /*
- * Activate High Speed or HS200 mode if supported.
- */
-static int mmc_select_timing(struct mmc_card *card)
-{
-	int err = 0;
-
-	if ((card->csd.mmca_vsn < CSD_SPEC_VER_4 &&
-	     card->ext_csd.hs_max_dtr == 0))
-		goto bus_speed;
-
-	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200)
-		err = mmc_select_hs200(card);
-	else if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS)
-		err = mmc_select_hs(card);
-
-	if (err && err != -EBADMSG)
-		return err;
-
-	if (err) {
-		pr_warn("%s: switch to %s failed\n",
-			mmc_card_hs(card) ? "high-speed" :
-			(mmc_card_hs200(card) ? "hs200" : ""),
-			mmc_hostname(card->host));
-		err = 0;
-	}
-
-bus_speed:
-	/*
-	 * Set the bus speed to the selected bus timing.
-	 * If timing is not selected, backward compatible is the default.
-	 */
-	mmc_set_bus_speed(card);
-	return err;
-}
-
-/*
- * Execute tuning sequence to seek the proper bus operating
- * conditions for HS200 and HS400, which sends CMD21 to the device.
- */
-static int mmc_hs200_tuning(struct mmc_card *card)
-{
-	struct mmc_host *host = card->host;
-	int err = 0;
-
-	/*
-	 * Timing should be adjusted to the HS400 target
-	 * operation frequency for tuning process
-	 */
-	if (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&
-	    host->ios.bus_width == MMC_BUS_WIDTH_8)
-		if (host->ops->prepare_hs400_tuning)
-			host->ops->prepare_hs400_tuning(host, &host->ios);
-
-	if (host->ops->execute_tuning) {
-		mmc_host_clk_hold(host);
-		err = host->ops->execute_tuning(host,
-				MMC_SEND_TUNING_BLOCK_HS200);
-		mmc_host_clk_release(host);
-
-		if (err)
-			pr_warn("%s: tuning execution failed\n",
-				mmc_hostname(host));
-	}
-
-	return err;
-}
-
-/*
  * Handle the detection and initialisation of a card.
  *
  * In the case of a resume, "oldcard" will contain the card
@@ -1214,8 +870,9 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	struct mmc_card *oldcard)
 {
 	struct mmc_card *card;
-	int err;
+	int err, ddr = 0;
 	u32 cid[4];
+	unsigned int max_dtr;
 	u32 rocr;
 	u8 *ext_csd = NULL;
 
@@ -1276,7 +933,6 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 			goto err;
 		}
 
-		card->ocr = ocr;
 		card->type = MMC_TYPE_MMC;
 		card->rca = 1;
 		memcpy(card->raw_cid, cid, sizeof(card->raw_cid));
@@ -1346,7 +1002,7 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	 * If enhanced_area_en is TRUE, host needs to enable ERASE_GRP_DEF
 	 * bit.  This bit will be lost every time after a reset or power off.
 	 */
-	if (card->ext_csd.enhanced_area_en || card->ext_csd.part_set_complete ||
+	if (card->ext_csd.enhanced_area_en ||
 	    (card->ext_csd.rev >= 3 && (host->caps2 & MMC_CAP2_HC_ERASE_SZ))) {
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 				 EXT_CSD_ERASE_GROUP_DEF, 1,
@@ -1364,7 +1020,6 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 			 */
 			card->ext_csd.enhanced_area_offset = -EINVAL;
 			card->ext_csd.enhanced_area_size = -EINVAL;
-			card->ext_csd.erase_group_def = 0;
 		} else {
 			card->ext_csd.erase_group_def = 1;
 			/*
@@ -1408,34 +1063,209 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	}
 
 	/*
-	 * Select timing interface
+	 * Activate high speed (if supported)
 	 */
-	err = mmc_select_timing(card);
-	if (err)
-		goto free_card;
+	if (card->ext_csd.hs_max_dtr != 0) {
+		err = 0;
+		if (card->ext_csd.hs_max_dtr > 52000000 &&
+		    host->caps2 & MMC_CAP2_HS200)
+			err = mmc_select_hs200(card);
+		else if	(host->caps & MMC_CAP_MMC_HIGHSPEED)
+			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+					 EXT_CSD_HS_TIMING, 1,
+					 card->ext_csd.generic_cmd6_time);
+
+		if (err && err != -EBADMSG)
+			goto free_card;
 
+		if (err) {
+			pr_warning("%s: switch to highspeed failed\n",
+			       mmc_hostname(card->host));
+			err = 0;
+		} else {
+			if (card->ext_csd.hs_max_dtr > 52000000 &&
+			    host->caps2 & MMC_CAP2_HS200) {
+				mmc_card_set_hs200(card);
+				mmc_set_timing(card->host,
+					       MMC_TIMING_MMC_HS200);
+			} else {
+				mmc_card_set_highspeed(card);
+				mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
+			}
+		}
+	}
+
+	/*
+	 * Compute bus speed.
+	 */
+	max_dtr = (unsigned int)-1;
+
+	if (mmc_card_highspeed(card) || mmc_card_hs200(card)) {
+		if (max_dtr > card->ext_csd.hs_max_dtr)
+			max_dtr = card->ext_csd.hs_max_dtr;
+		if (mmc_card_highspeed(card) && (max_dtr > 52000000))
+			max_dtr = 52000000;
+	} else if (max_dtr > card->csd.max_dtr) {
+		max_dtr = card->csd.max_dtr;
+	}
+
+	mmc_set_clock(host, max_dtr);
+
+	/*
+	 * Indicate DDR mode (if supported).
+	 */
+	if (mmc_card_highspeed(card)) {
+		if ((card->ext_csd.card_type & EXT_CSD_CARD_TYPE_DDR_1_8V)
+			&& ((host->caps & (MMC_CAP_1_8V_DDR |
+			     MMC_CAP_UHS_DDR50))
+				== (MMC_CAP_1_8V_DDR | MMC_CAP_UHS_DDR50)))
+				ddr = MMC_1_8V_DDR_MODE;
+		else if ((card->ext_csd.card_type & EXT_CSD_CARD_TYPE_DDR_1_2V)
+			&& ((host->caps & (MMC_CAP_1_2V_DDR |
+			     MMC_CAP_UHS_DDR50))
+				== (MMC_CAP_1_2V_DDR | MMC_CAP_UHS_DDR50)))
+				ddr = MMC_1_2V_DDR_MODE;
+	}
+
+	/*
+	 * Indicate HS200 SDR mode (if supported).
+	 */
 	if (mmc_card_hs200(card)) {
-		err = mmc_hs200_tuning(card);
-		if (err)
-			goto err;
+		u32 ext_csd_bits;
+		u32 bus_width = card->host->ios.bus_width;
 
-		err = mmc_select_hs400(card);
-		if (err)
+		/*
+		 * For devices supporting HS200 mode, the bus width has
+		 * to be set before executing the tuning function. If
+		 * set before tuning, then device will respond with CRC
+		 * errors for responses on CMD line. So for HS200 the
+		 * sequence will be
+		 * 1. set bus width 4bit / 8 bit (1 bit not supported)
+		 * 2. switch to HS200 mode
+		 * 3. set the clock to > 52Mhz <=200MHz and
+		 * 4. execute tuning for HS200
+		 */
+		if ((host->caps2 & MMC_CAP2_HS200) &&
+		    card->host->ops->execute_tuning) {
+			mmc_host_clk_hold(card->host);
+			err = card->host->ops->execute_tuning(card->host,
+				MMC_SEND_TUNING_BLOCK_HS200);
+			mmc_host_clk_release(card->host);
+		}
+		if (err) {
+			pr_warning("%s: tuning execution failed\n",
+				   mmc_hostname(card->host));
 			goto err;
-	} else if (mmc_card_hs(card)) {
-		/* Select the desired bus width optionally */
-		err = mmc_select_bus_width(card);
-		if (!IS_ERR_VALUE(err)) {
-			err = mmc_select_hs_ddr(card);
-			if (err)
-				goto err;
 		}
+
+		ext_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?
+				EXT_CSD_BUS_WIDTH_8 : EXT_CSD_BUS_WIDTH_4;
+		err = mmc_select_powerclass(card, ext_csd_bits);
+		if (err)
+			pr_warning("%s: power class selection to bus width %d"
+				   " failed\n", mmc_hostname(card->host),
+				   1 << bus_width);
 	}
 
 	/*
-	 * Choose the power class with selected bus interface
+	 * Activate wide bus and DDR (if supported).
 	 */
-	mmc_select_powerclass(card);
+	if (!mmc_card_hs200(card) &&
+	    (card->csd.mmca_vsn >= CSD_SPEC_VER_4) &&
+	    (host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA))) {
+		static unsigned ext_csd_bits[][2] = {
+			{ EXT_CSD_BUS_WIDTH_8, EXT_CSD_DDR_BUS_WIDTH_8 },
+			{ EXT_CSD_BUS_WIDTH_4, EXT_CSD_DDR_BUS_WIDTH_4 },
+			{ EXT_CSD_BUS_WIDTH_1, EXT_CSD_BUS_WIDTH_1 },
+		};
+		static unsigned bus_widths[] = {
+			MMC_BUS_WIDTH_8,
+			MMC_BUS_WIDTH_4,
+			MMC_BUS_WIDTH_1
+		};
+		unsigned idx, bus_width = 0;
+
+		if (host->caps & MMC_CAP_8_BIT_DATA)
+			idx = 0;
+		else
+			idx = 1;
+		for (; idx < ARRAY_SIZE(bus_widths); idx++) {
+			bus_width = bus_widths[idx];
+			if (bus_width == MMC_BUS_WIDTH_1)
+				ddr = 0; /* no DDR for 1-bit width */
+			err = mmc_select_powerclass(card, ext_csd_bits[idx][0]);
+			if (err)
+				pr_warning("%s: power class selection to "
+					   "bus width %d failed\n",
+					   mmc_hostname(card->host),
+					   1 << bus_width);
+
+			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+					 EXT_CSD_BUS_WIDTH,
+					 ext_csd_bits[idx][0],
+					 card->ext_csd.generic_cmd6_time);
+			if (!err) {
+				mmc_set_bus_width(card->host, bus_width);
+
+				/*
+				 * If controller can't handle bus width test,
+				 * compare ext_csd previously read in 1 bit mode
+				 * against ext_csd at new bus width
+				 */
+				if (!(host->caps & MMC_CAP_BUS_WIDTH_TEST))
+					err = mmc_compare_ext_csds(card,
+						bus_width);
+				else
+					err = mmc_bus_test(card, bus_width);
+				if (!err)
+					break;
+			}
+		}
+
+		if (!err && ddr) {
+			err = mmc_select_powerclass(card, ext_csd_bits[idx][1]);
+			if (err)
+				pr_warning("%s: power class selection to "
+					   "bus width %d ddr %d failed\n",
+					   mmc_hostname(card->host),
+					   1 << bus_width, ddr);
+
+			err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+					 EXT_CSD_BUS_WIDTH,
+					 ext_csd_bits[idx][1],
+					 card->ext_csd.generic_cmd6_time);
+		}
+		if (err) {
+			pr_warning("%s: switch to bus width %d ddr %d "
+				"failed\n", mmc_hostname(card->host),
+				1 << bus_width, ddr);
+			goto free_card;
+		} else if (ddr) {
+			/*
+			 * eMMC cards can support 3.3V to 1.2V i/o (vccq)
+			 * signaling.
+			 *
+			 * EXT_CSD_CARD_TYPE_DDR_1_8V means 3.3V or 1.8V vccq.
+			 *
+			 * 1.8V vccq at 3.3V core voltage (vcc) is not required
+			 * in the JEDEC spec for DDR.
+			 *
+			 * Do not force change in vccq since we are obviously
+			 * working and no change to vccq is needed.
+			 *
+			 * WARNING: eMMC rules are NOT the same as SD DDR
+			 */
+			if (ddr == MMC_1_2V_DDR_MODE) {
+				err = __mmc_set_signal_voltage(host,
+					MMC_SIGNAL_VOLTAGE_120);
+				if (err)
+					goto err;
+			}
+			mmc_card_set_ddr_mode(card);
+			mmc_set_timing(card->host, MMC_TIMING_UHS_DDR50);
+			mmc_set_bus_width(card->host, bus_width);
+		}
+	}
 
 	/*
 	 * Enable HPI feature (if supported)
@@ -1481,36 +1311,12 @@ static int mmc_init_card(struct mmc_host *host, u32 ocr,
 	}
 
 	/*
-	 * enable Command queue if supported
-	 */
-	if (card->ext_csd.cmdq_support &&
-			(host->caps2 & MMC_CAP2_CAN_DO_CMDQ)) {
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				EXT_CSD_CMDQ_MODE_EN,
-				EXT_CSD_CMDQ_MODE_ON,
-				card->ext_csd.generic_cmd6_time);
-		if (err && err != -EBADMSG)
-			goto free_card;
-		if (err) {
-			pr_warn("%s: Enabling CMDQ failed\n",
-				mmc_hostname(card->host));
-			card->ext_csd.cmdq_en = 0;
-			card->ext_csd.cmdq_depth = 0;
-			err = 0;
-		} else
-			card->ext_csd.cmdq_en = 1;
-	}
-
-	/*
 	 * The mandatory minimum values are defined for packed command.
 	 * read: 5, write: 3
-	 * disable packed CMD feature if CMDQ is enabled
-	 * CMDQ has better performance
 	 */
 	if (card->ext_csd.max_packed_writes >= 3 &&
 	    card->ext_csd.max_packed_reads >= 5 &&
-	    (host->caps2 & MMC_CAP2_PACKED_CMD) &&
-	    !card->ext_csd.cmdq_en) {
+	    host->caps2 & MMC_CAP2_PACKED_CMD) {
 		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
 				EXT_CSD_EXP_EVENTS_CTRL,
 				EXT_CSD_PACKED_EVENT_EN,
@@ -1597,9 +1403,9 @@ static int mmc_poweroff_notify(struct mmc_card *card, unsigned int notify_type)
 	if (notify_type == EXT_CSD_POWER_OFF_LONG)
 		timeout = card->ext_csd.power_off_longtime;
 
-	err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-			EXT_CSD_POWER_OFF_NOTIFICATION,
-			notify_type, timeout, true, false);
+	err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+			 EXT_CSD_POWER_OFF_NOTIFICATION,
+			 notify_type, timeout);
 	if (err)
 		pr_err("%s: Power Off Notification timed out, %u\n",
 		       mmc_hostname(card->host), timeout);
@@ -1670,9 +1476,6 @@ static int _mmc_suspend(struct mmc_host *host, bool is_suspend)
 
 	mmc_claim_host(host);
 
-	if (mmc_card_suspended(host->card))
-		goto out;
-
 	if (mmc_card_doing_bkops(host->card)) {
 		err = mmc_stop_bkops(host->card);
 		if (err)
@@ -1690,94 +1493,53 @@ static int _mmc_suspend(struct mmc_host *host, bool is_suspend)
 		err = mmc_sleep(host);
 	else if (!mmc_host_is_spi(host))
 		err = mmc_deselect_cards(host);
+	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_200);
 
-	if (!err) {
+	if (!err)
 		mmc_power_off(host);
-		mmc_card_set_suspended(host->card);
-	}
 out:
 	mmc_release_host(host);
 	return err;
 }
 
 /*
- * Suspend callback
+ * Suspend callback from host.
  */
 static int mmc_suspend(struct mmc_host *host)
 {
-	int err;
-
-	err = _mmc_suspend(host, true);
-	if (!err) {
-		pm_runtime_disable(&host->card->dev);
-		pm_runtime_set_suspended(&host->card->dev);
-	}
+	return _mmc_suspend(host, true);
+}
 
-	return err;
+/*
+ * Shutdown callback
+ */
+static int mmc_shutdown(struct mmc_host *host)
+{
+	return _mmc_suspend(host, false);
 }
 
 /*
+ * Resume callback from host.
+ *
  * This function tries to determine if the same card is still present
  * and, if so, restore all state to it.
  */
-static int _mmc_resume(struct mmc_host *host)
+static int mmc_resume(struct mmc_host *host)
 {
-	int err = 0;
+	int err;
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
-
-	if (!mmc_card_suspended(host->card))
-		goto out;
-
-	mmc_power_up(host, host->card->ocr);
-	err = mmc_init_card(host, host->card->ocr, host->card);
-	mmc_card_clr_suspended(host->card);
-
-out:
+	mmc_power_up(host);
+	mmc_select_voltage(host, host->ocr);
+	err = mmc_init_card(host, host->ocr, host->card);
 	mmc_release_host(host);
-	return err;
-}
-
-/*
- * Shutdown callback
- */
-static int mmc_shutdown(struct mmc_host *host)
-{
-	int err = 0;
-
-	/*
-	 * In a specific case for poweroff notify, we need to resume the card
-	 * before we can shutdown it properly.
-	 */
-	if (mmc_can_poweroff_notify(host->card) &&
-		!(host->caps2 & MMC_CAP2_FULL_PWR_CYCLE))
-		err = _mmc_resume(host);
-
-	if (!err)
-		err = _mmc_suspend(host, false);
 
 	return err;
 }
 
-/*
- * Callback for resume.
- */
-static int mmc_resume(struct mmc_host *host)
-{
-	int err = 0;
-
-	if (!(host->caps & MMC_CAP_RUNTIME_RESUME)) {
-		err = _mmc_resume(host);
-		pm_runtime_set_active(&host->card->dev);
-		pm_runtime_mark_last_busy(&host->card->dev);
-	}
-	pm_runtime_enable(&host->card->dev);
-
-	return err;
-}
 
 /*
  * Callback for runtime_suspend.
@@ -1789,11 +1551,18 @@ static int mmc_runtime_suspend(struct mmc_host *host)
 	if (!(host->caps & MMC_CAP_AGGRESSIVE_PM))
 		return 0;
 
-	err = _mmc_suspend(host, true);
-	if (err)
+	mmc_claim_host(host);
+
+	err = mmc_suspend(host);
+	if (err) {
 		pr_err("%s: error %d doing aggessive suspend\n",
 			mmc_hostname(host), err);
+		goto out;
+	}
+	mmc_power_off(host);
 
+out:
+	mmc_release_host(host);
 	return err;
 }
 
@@ -1804,14 +1573,18 @@ static int mmc_runtime_resume(struct mmc_host *host)
 {
 	int err;
 
-	if (!(host->caps & (MMC_CAP_AGGRESSIVE_PM | MMC_CAP_RUNTIME_RESUME)))
+	if (!(host->caps & MMC_CAP_AGGRESSIVE_PM))
 		return 0;
 
-	err = _mmc_resume(host);
+	mmc_claim_host(host);
+
+	mmc_power_up(host);
+	err = mmc_resume(host);
 	if (err)
 		pr_err("%s: error %d doing aggessive resume\n",
 			mmc_hostname(host), err);
 
+	mmc_release_host(host);
 	return 0;
 }
 
@@ -1819,8 +1592,9 @@ static int mmc_power_restore(struct mmc_host *host)
 {
 	int ret;
 
+	host->card->state &= ~(MMC_STATE_HIGHSPEED | MMC_STATE_HIGHSPEED_200);
 	mmc_claim_host(host);
-	ret = mmc_init_card(host, host->card->ocr, host->card);
+	ret = mmc_init_card(host, host->ocr, host->card);
 	mmc_release_host(host);
 
 	return ret;
@@ -1865,7 +1639,7 @@ static void mmc_attach_bus_ops(struct mmc_host *host)
 int mmc_attach_mmc(struct mmc_host *host)
 {
 	int err;
-	u32 ocr, rocr;
+	u32 ocr;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
@@ -1891,12 +1665,23 @@ int mmc_attach_mmc(struct mmc_host *host)
 			goto err;
 	}
 
-	rocr = mmc_select_voltage(host, ocr);
+	/*
+	 * Sanity check the voltages that the card claims to
+	 * support.
+	 */
+	if (ocr & 0x7F) {
+		pr_warning("%s: card claims to support voltages "
+		       "below the defined range. These will be ignored.\n",
+		       mmc_hostname(host));
+		ocr &= ~0x7F;
+	}
+
+	host->ocr = mmc_select_voltage(host, ocr);
 
 	/*
 	 * Can we support the voltage of the card?
 	 */
-	if (!rocr) {
+	if (!host->ocr) {
 		err = -EINVAL;
 		goto err;
 	}
@@ -1904,7 +1689,7 @@ int mmc_attach_mmc(struct mmc_host *host)
 	/*
 	 * Detect and init the card.
 	 */
-	err = mmc_init_card(host, rocr, NULL);
+	err = mmc_init_card(host, host->ocr, NULL);
 	if (err)
 		goto err;
 
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index e5b5eeb..ef18348 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -23,40 +23,6 @@
 
 #define MMC_OPS_TIMEOUT_MS	(10 * 60 * 1000) /* 10 minute timeout */
 
-static inline int __mmc_send_status(struct mmc_card *card, u32 *status,
-				    bool ignore_crc)
-{
-	int err;
-	struct mmc_command cmd = {0};
-
-	BUG_ON(!card);
-	BUG_ON(!card->host);
-
-	cmd.opcode = MMC_SEND_STATUS;
-	if (!mmc_host_is_spi(card->host))
-		cmd.arg = card->rca << 16;
-	cmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;
-	if (ignore_crc)
-		cmd.flags &= ~MMC_RSP_CRC;
-
-	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
-	if (err)
-		return err;
-
-	/* NOTE: callers are required to understand the difference
-	 * between "native" and SPI format status words!
-	 */
-	if (status)
-		*status = cmd.resp[0];
-
-	return 0;
-}
-
-int mmc_send_status(struct mmc_card *card, u32 *status)
-{
-	return __mmc_send_status(card, status, false);
-}
-
 static int _mmc_select_card(struct mmc_host *host, struct mmc_card *card)
 {
 	int err;
@@ -404,18 +370,16 @@ int mmc_spi_set_crc(struct mmc_host *host, int use_crc)
  *	@timeout_ms: timeout (ms) for operation performed by register write,
  *                   timeout of zero implies maximum possible timeout
  *	@use_busy_signal: use the busy signal as response type
- *	@send_status: send status cmd to poll for busy
  *
  *	Modifies the EXT_CSD register for selected card.
  */
 int __mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,
-		unsigned int timeout_ms, bool use_busy_signal, bool send_status)
+	       unsigned int timeout_ms, bool use_busy_signal)
 {
 	int err;
 	struct mmc_command cmd = {0};
 	unsigned long timeout;
-	u32 status = 0;
-	bool ignore_crc = false;
+	u32 status;
 
 	BUG_ON(!card);
 	BUG_ON(!card->host);
@@ -444,37 +408,17 @@ int __mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,
 	if (!use_busy_signal)
 		return 0;
 
-	/*
-	 * Must check status to be sure of no errors
-	 * If CMD13 is to check the busy completion of the timing change,
-	 * disable the check of CRC error.
-	 */
-	if (index == EXT_CSD_HS_TIMING &&
-	    !(card->host->caps & MMC_CAP_WAIT_WHILE_BUSY))
-		ignore_crc = true;
-
+	/* Must check status to be sure of no errors */
 	timeout = jiffies + msecs_to_jiffies(MMC_OPS_TIMEOUT_MS);
 	do {
-		if (send_status) {
-			err = __mmc_send_status(card, &status, ignore_crc);
-			if (err)
-				return err;
-		}
+		err = mmc_send_status(card, &status);
+		if (err)
+			return err;
 		if (card->host->caps & MMC_CAP_WAIT_WHILE_BUSY)
 			break;
 		if (mmc_host_is_spi(card->host))
 			break;
 
-		/*
-		 * We are not allowed to issue a status command and the host
-		 * does'nt support MMC_CAP_WAIT_WHILE_BUSY, then we can only
-		 * rely on waiting for the stated timeout to be sufficient.
-		 */
-		if (!send_status) {
-			mmc_delay(timeout_ms);
-			return 0;
-		}
-
 		/* Timeout if the device never leaves the program state. */
 		if (time_after(jiffies, timeout)) {
 			pr_err("%s: Card stuck in programming state! %s\n",
@@ -501,10 +445,36 @@ EXPORT_SYMBOL_GPL(__mmc_switch);
 int mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,
 		unsigned int timeout_ms)
 {
-	return __mmc_switch(card, set, index, value, timeout_ms, true, true);
+	return __mmc_switch(card, set, index, value, timeout_ms, true);
 }
 EXPORT_SYMBOL_GPL(mmc_switch);
 
+int mmc_send_status(struct mmc_card *card, u32 *status)
+{
+	int err;
+	struct mmc_command cmd = {0};
+
+	BUG_ON(!card);
+	BUG_ON(!card->host);
+
+	cmd.opcode = MMC_SEND_STATUS;
+	if (!mmc_host_is_spi(card->host))
+		cmd.arg = card->rca << 16;
+	cmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;
+
+	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
+	if (err)
+		return err;
+
+	/* NOTE: callers are required to understand the difference
+	 * between "native" and SPI format status words!
+	 */
+	if (status)
+		*status = cmd.resp[0];
+
+	return 0;
+}
+
 static int
 mmc_send_bus_test(struct mmc_card *card, struct mmc_host *host, u8 opcode,
 		  u8 len)
diff --git a/drivers/mmc/core/quirks.c b/drivers/mmc/core/quirks.c
index a96b8d6..06ee1ae 100644
--- a/drivers/mmc/core/quirks.c
+++ b/drivers/mmc/core/quirks.c
@@ -13,7 +13,6 @@
 #include <linux/kernel.h>
 #include <linux/export.h>
 #include <linux/mmc/card.h>
-#include <linux/mmc/sdio_ids.h>
 
 #ifndef SDIO_VENDOR_ID_TI
 #define SDIO_VENDOR_ID_TI		0x0097
@@ -31,10 +30,6 @@
 #define SDIO_DEVICE_ID_STE_CW1200	0x2280
 #endif
 
-#ifndef SDIO_DEVICE_ID_MARVELL_8797_F0
-#define SDIO_DEVICE_ID_MARVELL_8797_F0	0x9128
-#endif
-
 /*
  * This hook just adds a quirk for all sdio devices
  */
@@ -63,12 +58,6 @@ static const struct mmc_fixup mmc_fixup_methods[] = {
 	SDIO_FIXUP(SDIO_VENDOR_ID_STE, SDIO_DEVICE_ID_STE_CW1200,
 		   add_quirk, MMC_QUIRK_BROKEN_BYTE_MODE_512),
 
-	SDIO_FIXUP(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8797_F0,
-		   add_quirk, MMC_QUIRK_BROKEN_IRQ_POLLING),
-
-	SDIO_FIXUP(SDIO_VENDOR_ID_BROADCOM, SDIO_ANY_ID,
-		   add_quirk, MMC_QUIRK_NO_TUNING_IN_SLEEP),
-
 	END_FIXUP
 };
 
diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
index 6edcc38..06da060 100644
--- a/drivers/mmc/core/sd.c
+++ b/drivers/mmc/core/sd.c
@@ -14,7 +14,6 @@
 #include <linux/sizes.h>
 #include <linux/slab.h>
 #include <linux/stat.h>
-#include <linux/pm_runtime.h>
 
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
@@ -729,7 +728,6 @@ int mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)
 	int err;
 	u32 max_current;
 	int retries = 10;
-	u32 pocr = ocr;
 
 try_again:
 	if (!retries) {
@@ -782,8 +780,7 @@ try_again:
 	 */
 	if (!mmc_host_is_spi(host) && rocr &&
 	   ((*rocr & 0x41000000) == 0x41000000)) {
-		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
-					pocr);
+		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
 		if (err == -EAGAIN) {
 			retries--;
 			goto try_again;
@@ -823,9 +820,6 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 	bool reinit)
 {
 	int err;
-#ifdef CONFIG_MMC_PARANOID_SD_INIT
-	int retries;
-#endif
 
 	if (!reinit) {
 		/*
@@ -852,26 +846,7 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 		/*
 		 * Fetch switch information from card.
 		 */
-#ifdef CONFIG_MMC_PARANOID_SD_INIT
-		for (retries = 1; retries <= 3; retries++) {
-			err = mmc_read_switch(card);
-			if (!err) {
-				if (retries > 1) {
-					printk(KERN_WARNING
-					       "%s: recovered\n", 
-					       mmc_hostname(host));
-				}
-				break;
-			} else {
-				printk(KERN_WARNING
-				       "%s: read switch failed (attempt %d)\n",
-				       mmc_hostname(host), retries);
-			}
-		}
-#else
 		err = mmc_read_switch(card);
-#endif
-
 		if (err)
 			return err;
 	}
@@ -917,7 +892,7 @@ unsigned mmc_sd_get_max_clock(struct mmc_card *card)
 {
 	unsigned max_dtr = (unsigned int)-1;
 
-	if (mmc_card_hs(card)) {
+	if (mmc_card_highspeed(card)) {
 		if (max_dtr > card->sw_caps.hs_max_dtr)
 			max_dtr = card->sw_caps.hs_max_dtr;
 	} else if (max_dtr > card->csd.max_dtr) {
@@ -927,6 +902,12 @@ unsigned mmc_sd_get_max_clock(struct mmc_card *card)
 	return max_dtr;
 }
 
+void mmc_sd_go_highspeed(struct mmc_card *card)
+{
+	mmc_card_set_highspeed(card);
+	mmc_set_timing(card->host, MMC_TIMING_SD_HS);
+}
+
 /*
  * Handle the detection and initialisation of a card.
  *
@@ -961,7 +942,6 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		if (IS_ERR(card))
 			return PTR_ERR(card);
 
-		card->ocr = ocr;
 		card->type = MMC_TYPE_SD;
 		memcpy(card->raw_cid, cid, sizeof(card->raw_cid));
 	}
@@ -1001,13 +981,16 @@ static int mmc_sd_init_card(struct mmc_host *host, u32 ocr,
 		err = mmc_sd_init_uhs_card(card);
 		if (err)
 			goto free_card;
+
+		/* Card is an ultra-high-speed card */
+		mmc_card_set_uhs(card);
 	} else {
 		/*
 		 * Attempt to change to high-speed (if supported)
 		 */
 		err = mmc_sd_switch_hs(card);
 		if (err > 0)
-			mmc_set_timing(card->host, MMC_TIMING_SD_HS);
+			mmc_sd_go_highspeed(card);
 		else if (err)
 			goto free_card;
 
@@ -1064,10 +1047,7 @@ static int mmc_sd_alive(struct mmc_host *host)
  */
 static void mmc_sd_detect(struct mmc_host *host)
 {
-	int err = 0;
-#ifdef CONFIG_MMC_PARANOID_SD_INIT
-	int retries = 5;
-#endif
+	int err;
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
@@ -1077,23 +1057,7 @@ static void mmc_sd_detect(struct mmc_host *host)
 	/*
 	 * Just check if our card has been removed.
 	 */
-#ifdef CONFIG_MMC_PARANOID_SD_INIT
-	while(retries) {
-		err = mmc_send_status(host->card, NULL);
-		if (err) {
-			retries--;
-			udelay(5);
-			continue;
-		}
-		break;
-	}
-	if (!retries) {
-		printk(KERN_ERR "%s(%s): Unable to re-detect card (%d)\n",
-		       __func__, mmc_hostname(host), err);
-	}
-#else
 	err = _mmc_detect_card_removed(host);
-#endif
 
 	mmc_put_card(host->card);
 
@@ -1107,7 +1071,10 @@ static void mmc_sd_detect(struct mmc_host *host)
 	}
 }
 
-static int _mmc_sd_suspend(struct mmc_host *host)
+/*
+ * Suspend callback from host.
+ */
+static int mmc_sd_suspend(struct mmc_host *host)
 {
 	int err = 0;
 
@@ -1115,96 +1082,34 @@ static int _mmc_sd_suspend(struct mmc_host *host)
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
-
-	if (mmc_card_suspended(host->card))
-		goto out;
-
 	if (!mmc_host_is_spi(host))
 		err = mmc_deselect_cards(host);
-
-	if (!err) {
+	host->card->state &= ~MMC_STATE_HIGHSPEED;
+	if (!err)
 		mmc_power_off(host);
-		mmc_card_set_suspended(host->card);
-	}
-
-out:
 	mmc_release_host(host);
-	return err;
-}
-
-/*
- * Callback for suspend
- */
-static int mmc_sd_suspend(struct mmc_host *host)
-{
-	int err;
-
-	err = _mmc_sd_suspend(host);
-	if (!err) {
-		pm_runtime_disable(&host->card->dev);
-		pm_runtime_set_suspended(&host->card->dev);
-	}
 
 	return err;
 }
 
 /*
+ * Resume callback from host.
+ *
  * This function tries to determine if the same card is still present
  * and, if so, restore all state to it.
  */
-static int _mmc_sd_resume(struct mmc_host *host)
+static int mmc_sd_resume(struct mmc_host *host)
 {
-	int err = 0;
-#ifdef CONFIG_MMC_PARANOID_SD_INIT
-	int retries;
-#endif
+	int err;
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
 
 	mmc_claim_host(host);
-
-	if (!mmc_card_suspended(host->card))
-		goto out;
-
-	mmc_power_up(host, host->card->ocr);
-#ifdef CONFIG_MMC_PARANOID_SD_INIT
-	retries = 5;
-	while (retries) {
-		err = mmc_sd_init_card(host, host->card->ocr, host->card);
-
-		if (err) {
-			printk(KERN_ERR "%s: Re-init card rc = %d (retries = %d)\n",
-			       mmc_hostname(host), err, retries);
-			mdelay(5);
-			retries--;
-			continue;
-		}
-		break;
-	}
-#else
-	err = mmc_sd_init_card(host, host->card->ocr, host->card);
-#endif
-	mmc_card_clr_suspended(host->card);
-
-out:
+	mmc_power_up(host);
+	mmc_select_voltage(host, host->ocr);
+	err = mmc_sd_init_card(host, host->ocr, host->card);
 	mmc_release_host(host);
-	return err;
-}
-
-/*
- * Callback for resume
- */
-static int mmc_sd_resume(struct mmc_host *host)
-{
-	int err = 0;
-
-	if (!(host->caps & MMC_CAP_RUNTIME_RESUME)) {
-		err = _mmc_sd_resume(host);
-		pm_runtime_set_active(&host->card->dev);
-		pm_runtime_mark_last_busy(&host->card->dev);
-	}
-	pm_runtime_enable(&host->card->dev);
 
 	return err;
 }
@@ -1219,11 +1124,18 @@ static int mmc_sd_runtime_suspend(struct mmc_host *host)
 	if (!(host->caps & MMC_CAP_AGGRESSIVE_PM))
 		return 0;
 
-	err = _mmc_sd_suspend(host);
-	if (err)
+	mmc_claim_host(host);
+
+	err = mmc_sd_suspend(host);
+	if (err) {
 		pr_err("%s: error %d doing aggessive suspend\n",
 			mmc_hostname(host), err);
+		goto out;
+	}
+	mmc_power_off(host);
 
+out:
+	mmc_release_host(host);
 	return err;
 }
 
@@ -1234,14 +1146,18 @@ static int mmc_sd_runtime_resume(struct mmc_host *host)
 {
 	int err;
 
-	if (!(host->caps & (MMC_CAP_AGGRESSIVE_PM | MMC_CAP_RUNTIME_RESUME)))
+	if (!(host->caps & MMC_CAP_AGGRESSIVE_PM))
 		return 0;
 
-	err = _mmc_sd_resume(host);
+	mmc_claim_host(host);
+
+	mmc_power_up(host);
+	err = mmc_sd_resume(host);
 	if (err)
 		pr_err("%s: error %d doing aggessive resume\n",
 			mmc_hostname(host), err);
 
+	mmc_release_host(host);
 	return 0;
 }
 
@@ -1249,8 +1165,9 @@ static int mmc_sd_power_restore(struct mmc_host *host)
 {
 	int ret;
 
+	host->card->state &= ~MMC_STATE_HIGHSPEED;
 	mmc_claim_host(host);
-	ret = mmc_sd_init_card(host, host->card->ocr, host->card);
+	ret = mmc_sd_init_card(host, host->ocr, host->card);
 	mmc_release_host(host);
 
 	return ret;
@@ -1295,10 +1212,7 @@ static void mmc_sd_attach_bus_ops(struct mmc_host *host)
 int mmc_attach_sd(struct mmc_host *host)
 {
 	int err;
-	u32 ocr, rocr;
-#ifdef CONFIG_MMC_PARANOID_SD_INIT
-	int retries;
-#endif
+	u32 ocr;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
@@ -1322,12 +1236,31 @@ int mmc_attach_sd(struct mmc_host *host)
 			goto err;
 	}
 
-	rocr = mmc_select_voltage(host, ocr);
+	/*
+	 * Sanity check the voltages that the card claims to
+	 * support.
+	 */
+	if (ocr & 0x7F) {
+		pr_warning("%s: card claims to support voltages "
+		       "below the defined range. These will be ignored.\n",
+		       mmc_hostname(host));
+		ocr &= ~0x7F;
+	}
+
+	if ((ocr & MMC_VDD_165_195) &&
+	    !(host->ocr_avail_sd & MMC_VDD_165_195)) {
+		pr_warning("%s: SD card claims to support the "
+		       "incompletely defined 'low voltage range'. This "
+		       "will be ignored.\n", mmc_hostname(host));
+		ocr &= ~MMC_VDD_165_195;
+	}
+
+	host->ocr = mmc_select_voltage(host, ocr);
 
 	/*
 	 * Can we support the voltage(s) of the card(s)?
 	 */
-	if (!rocr) {
+	if (!host->ocr) {
 		err = -EINVAL;
 		goto err;
 	}
@@ -1335,27 +1268,9 @@ int mmc_attach_sd(struct mmc_host *host)
 	/*
 	 * Detect and init the card.
 	 */
-#ifdef CONFIG_MMC_PARANOID_SD_INIT
-	retries = 5;
-	while (retries) {
-		err = mmc_sd_init_card(host, rocr, NULL);
-		if (err) {
-			retries--;
-			continue;
-		}
-		break;
-	}
-
-	if (!retries) {
-		printk(KERN_ERR "%s: mmc_sd_init_card() failure (err = %d)\n",
-		       mmc_hostname(host), err);
-		goto err;
-	}
-#else
-	err = mmc_sd_init_card(host, rocr, NULL);
+	err = mmc_sd_init_card(host, host->ocr, NULL);
 	if (err)
 		goto err;
-#endif
 
 	mmc_release_host(host);
 	err = mmc_add_card(host->card);
diff --git a/drivers/mmc/core/sd.h b/drivers/mmc/core/sd.h
index aab824a..4b34b24 100644
--- a/drivers/mmc/core/sd.h
+++ b/drivers/mmc/core/sd.h
@@ -12,5 +12,6 @@ int mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,
 	bool reinit);
 unsigned mmc_sd_get_max_clock(struct mmc_card *card);
 int mmc_sd_switch_hs(struct mmc_card *card);
+void mmc_sd_go_highspeed(struct mmc_card *card);
 
 #endif
diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c
index b7ad2ad..80d89cff 100644
--- a/drivers/mmc/core/sdio.c
+++ b/drivers/mmc/core/sdio.c
@@ -10,7 +10,6 @@
  */
 
 #include <linux/err.h>
-#include <linux/module.h>
 #include <linux/pm_runtime.h>
 
 #include <linux/mmc/host.h>
@@ -29,10 +28,6 @@
 #include "sdio_ops.h"
 #include "sdio_cis.h"
 
-#ifdef CONFIG_MMC_EMBEDDED_SDIO
-#include <linux/mmc/sdio_ids.h>
-#endif
-
 static int sdio_read_fbr(struct sdio_func *func)
 {
 	int ret;
@@ -368,7 +363,7 @@ static unsigned mmc_sdio_get_max_clock(struct mmc_card *card)
 {
 	unsigned max_dtr;
 
-	if (mmc_card_hs(card)) {
+	if (mmc_card_highspeed(card)) {
 		/*
 		 * The SDIO specification doesn't mention how
 		 * the CIS transfer speed register relates to
@@ -598,28 +593,23 @@ static int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,
 	struct mmc_card *card;
 	int err;
 	int retries = 10;
-	u32 rocr = 0;
-	u32 ocr_card = ocr;
 
 	BUG_ON(!host);
 	WARN_ON(!host->claimed);
 
-	/* to query card if 1.8V signalling is supported */
-	if (mmc_host_uhs(host))
-		ocr |= R4_18V_PRESENT;
-
 try_again:
 	if (!retries) {
 		pr_warning("%s: Skipping voltage switch\n",
 				mmc_hostname(host));
 		ocr &= ~R4_18V_PRESENT;
+		host->ocr &= ~R4_18V_PRESENT;
 	}
 
 	/*
 	 * Inform the card of the voltage
 	 */
 	if (!powered_resume) {
-		err = mmc_send_io_op_cond(host, ocr, &rocr);
+		err = mmc_send_io_op_cond(host, host->ocr, &ocr);
 		if (err)
 			goto err;
 	}
@@ -642,8 +632,8 @@ try_again:
 		goto err;
 	}
 
-	if ((rocr & R4_MEMORY_PRESENT) &&
-	    mmc_sd_get_cid(host, ocr & rocr, card->raw_cid, NULL) == 0) {
+	if ((ocr & R4_MEMORY_PRESENT) &&
+	    mmc_sd_get_cid(host, host->ocr & ocr, card->raw_cid, NULL) == 0) {
 		card->type = MMC_TYPE_SD_COMBO;
 
 		if (oldcard && (oldcard->type != MMC_TYPE_SD_COMBO ||
@@ -673,9 +663,8 @@ try_again:
 	 * systems that claim 1.8v signalling in fact do not support
 	 * it.
 	 */
-	if (!powered_resume && (rocr & ocr & R4_18V_PRESENT)) {
-		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
-					ocr);
+	if (!powered_resume && (ocr & R4_18V_PRESENT) && mmc_host_uhs(host)) {
+		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);
 		if (err == -EAGAIN) {
 			sdio_reset(host);
 			mmc_go_idle(host);
@@ -685,10 +674,12 @@ try_again:
 			goto try_again;
 		} else if (err) {
 			ocr &= ~R4_18V_PRESENT;
+			host->ocr &= ~R4_18V_PRESENT;
 		}
 		err = 0;
 	} else {
 		ocr &= ~R4_18V_PRESENT;
+		host->ocr &= ~R4_18V_PRESENT;
 	}
 
 	/*
@@ -738,41 +729,26 @@ try_again:
 		mmc_set_clock(host, card->cis.max_dtr);
 
 		if (card->cccr.high_speed) {
+			mmc_card_set_highspeed(card);
 			mmc_set_timing(card->host, MMC_TIMING_SD_HS);
 		}
 
 		goto finish;
 	}
 
-#ifdef CONFIG_MMC_EMBEDDED_SDIO
-	if (host->embedded_sdio_data.cccr)
-		memcpy(&card->cccr, host->embedded_sdio_data.cccr, sizeof(struct sdio_cccr));
-	else {
-#endif
-		/*
-		 * Read the common registers.
-		 */
-		err = sdio_read_cccr(card,  ocr);
-		if (err)
-			goto remove;
-#ifdef CONFIG_MMC_EMBEDDED_SDIO
-	}
-#endif
+	/*
+	 * Read the common registers.
+	 */
+	err = sdio_read_cccr(card, ocr);
+	if (err)
+		goto remove;
 
-#ifdef CONFIG_MMC_EMBEDDED_SDIO
-	if (host->embedded_sdio_data.cis)
-		memcpy(&card->cis, host->embedded_sdio_data.cis, sizeof(struct sdio_cis));
-	else {
-#endif
-		/*
-		 * Read the common CIS tuples.
-		 */
-		err = sdio_read_common_cis(card);
-		if (err)
-			goto remove;
-#ifdef CONFIG_MMC_EMBEDDED_SDIO
-	}
-#endif
+	/*
+	 * Read the common CIS tuples.
+	 */
+	err = sdio_read_common_cis(card);
+	if (err)
+		goto remove;
 
 	if (oldcard) {
 		int same = (card->cis.vendor == oldcard->cis.vendor &&
@@ -783,7 +759,6 @@ try_again:
 
 		card = oldcard;
 	}
-	card->ocr = ocr_card;
 	mmc_fixup_device(card, NULL);
 
 	if (card->type == MMC_TYPE_SD_COMBO) {
@@ -812,13 +787,16 @@ try_again:
 		err = mmc_sdio_init_uhs_card(card);
 		if (err)
 			goto remove;
+
+		/* Card is an ultra-high-speed card */
+		mmc_card_set_uhs(card);
 	} else {
 		/*
 		 * Switch to high-speed (if supported).
 		 */
 		err = sdio_enable_hs(card);
 		if (err > 0)
-			mmc_set_timing(card->host, MMC_TIMING_SD_HS);
+			mmc_sd_go_highspeed(card);
 		else if (err)
 			goto remove;
 
@@ -960,21 +938,40 @@ static int mmc_sdio_pre_suspend(struct mmc_host *host)
  */
 static int mmc_sdio_suspend(struct mmc_host *host)
 {
-	if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
+	int i, err = 0;
+
+	for (i = 0; i < host->card->sdio_funcs; i++) {
+		struct sdio_func *func = host->card->sdio_func[i];
+		if (func && sdio_func_present(func) && func->dev.driver) {
+			const struct dev_pm_ops *pmops = func->dev.driver->pm;
+			err = pmops->suspend(&func->dev);
+			if (err)
+				break;
+		}
+	}
+	while (err && --i >= 0) {
+		struct sdio_func *func = host->card->sdio_func[i];
+		if (func && sdio_func_present(func) && func->dev.driver) {
+			const struct dev_pm_ops *pmops = func->dev.driver->pm;
+			pmops->resume(&func->dev);
+		}
+	}
+
+	if (!err && mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
 		mmc_claim_host(host);
 		sdio_disable_wide(host->card);
 		mmc_release_host(host);
 	}
 
-	if (!mmc_card_keep_power(host))
+	if (!err && !mmc_card_keep_power(host))
 		mmc_power_off(host);
 
-	return 0;
+	return err;
 }
 
 static int mmc_sdio_resume(struct mmc_host *host)
 {
-	int err = 0;
+	int i, err = 0;
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
@@ -984,7 +981,8 @@ static int mmc_sdio_resume(struct mmc_host *host)
 
 	/* Restore power if needed */
 	if (!mmc_card_keep_power(host)) {
-		mmc_power_up(host, host->card->ocr);
+		mmc_power_up(host);
+		mmc_select_voltage(host, host->ocr);
 		/*
 		 * Tell runtime PM core we just powered up the card,
 		 * since it still believes the card is powered off.
@@ -1002,7 +1000,7 @@ static int mmc_sdio_resume(struct mmc_host *host)
 	if (mmc_card_is_removable(host) || !mmc_card_keep_power(host)) {
 		sdio_reset(host);
 		mmc_go_idle(host);
-		err = mmc_sdio_init_card(host, host->card->ocr, host->card,
+		err = mmc_sdio_init_card(host, host->ocr, host->card,
 					mmc_card_keep_power(host));
 	} else if (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host)) {
 		/* We may have switched to 1-bit mode during suspend */
@@ -1017,6 +1015,24 @@ static int mmc_sdio_resume(struct mmc_host *host)
 		wake_up_process(host->sdio_irq_thread);
 	mmc_release_host(host);
 
+	/*
+	 * If the card looked to be the same as before suspending, then
+	 * we proceed to resume all card functions.  If one of them returns
+	 * an error then we simply return that error to the core and the
+	 * card will be redetected as new.  It is the responsibility of
+	 * the function driver to perform further tests with the extra
+	 * knowledge it has of the card to confirm the card is indeed the
+	 * same as before suspending (same MAC address for network cards,
+	 * etc.) and return an error otherwise.
+	 */
+	for (i = 0; !err && i < host->card->sdio_funcs; i++) {
+		struct sdio_func *func = host->card->sdio_func[i];
+		if (func && sdio_func_present(func) && func->dev.driver) {
+			const struct dev_pm_ops *pmops = func->dev.driver->pm;
+			err = pmops->resume(&func->dev);
+		}
+	}
+
 	host->pm_flags &= ~MMC_PM_KEEP_POWER;
 	return err;
 }
@@ -1024,6 +1040,7 @@ static int mmc_sdio_resume(struct mmc_host *host)
 static int mmc_sdio_power_restore(struct mmc_host *host)
 {
 	int ret;
+	u32 ocr;
 
 	BUG_ON(!host);
 	BUG_ON(!host->card);
@@ -1045,17 +1062,32 @@ static int mmc_sdio_power_restore(struct mmc_host *host)
 	 * for OLPC SD8686 (which expects a [CMD5,5,3,7] init sequence), and
 	 * harmless in other situations.
 	 *
+	 * With these steps taken, mmc_select_voltage() is also required to
+	 * restore the correct voltage setting of the card.
 	 */
 
 	sdio_reset(host);
 	mmc_go_idle(host);
 	mmc_send_if_cond(host, host->ocr_avail);
 
-	ret = mmc_send_io_op_cond(host, 0, NULL);
+	ret = mmc_send_io_op_cond(host, 0, &ocr);
 	if (ret)
 		goto out;
 
-	ret = mmc_sdio_init_card(host, host->card->ocr, host->card,
+	if (host->ocr_avail_sdio)
+		host->ocr_avail = host->ocr_avail_sdio;
+
+	host->ocr = mmc_select_voltage(host, ocr & ~0x7F);
+	if (!host->ocr) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (mmc_host_uhs(host))
+		/* to query card if 1.8V signalling is supported */
+		host->ocr |= R4_18V_PRESENT;
+
+	ret = mmc_sdio_init_card(host, host->ocr, host->card,
 				mmc_card_keep_power(host));
 	if (!ret && host->sdio_irqs)
 		mmc_signal_sdio_irq(host);
@@ -1076,7 +1108,7 @@ static int mmc_sdio_runtime_suspend(struct mmc_host *host)
 static int mmc_sdio_runtime_resume(struct mmc_host *host)
 {
 	/* Restore power and re-initialize. */
-	mmc_power_up(host, host->card->ocr);
+	mmc_power_up(host);
 	return mmc_sdio_power_restore(host);
 }
 
@@ -1099,7 +1131,7 @@ static const struct mmc_bus_ops mmc_sdio_ops = {
 int mmc_attach_sdio(struct mmc_host *host)
 {
 	int err, i, funcs;
-	u32 ocr, rocr;
+	u32 ocr;
 	struct mmc_card *card;
 
 	BUG_ON(!host);
@@ -1113,13 +1145,23 @@ int mmc_attach_sdio(struct mmc_host *host)
 	if (host->ocr_avail_sdio)
 		host->ocr_avail = host->ocr_avail_sdio;
 
+	/*
+	 * Sanity check the voltages that the card claims to
+	 * support.
+	 */
+	if (ocr & 0x7F) {
+		pr_warning("%s: card claims to support voltages "
+		       "below the defined range. These will be ignored.\n",
+		       mmc_hostname(host));
+		ocr &= ~0x7F;
+	}
 
-	rocr = mmc_select_voltage(host, ocr);
+	host->ocr = mmc_select_voltage(host, ocr);
 
 	/*
 	 * Can we support the voltage(s) of the card(s)?
 	 */
-	if (!rocr) {
+	if (!host->ocr) {
 		err = -EINVAL;
 		goto err;
 	}
@@ -1127,10 +1169,22 @@ int mmc_attach_sdio(struct mmc_host *host)
 	/*
 	 * Detect and init the card.
 	 */
-	err = mmc_sdio_init_card(host, rocr, NULL, 0);
-	if (err)
-		goto err;
+	if (mmc_host_uhs(host))
+		/* to query card if 1.8V signalling is supported */
+		host->ocr |= R4_18V_PRESENT;
 
+	err = mmc_sdio_init_card(host, host->ocr, NULL, 0);
+	if (err) {
+		if (err == -EAGAIN) {
+			/*
+			 * Retry initialization with S18R set to 0.
+			 */
+			host->ocr &= ~R4_18V_PRESENT;
+			err = mmc_sdio_init_card(host, host->ocr, NULL, 0);
+		}
+		if (err)
+			goto err;
+	}
 	card = host->card;
 
 	/*
@@ -1157,36 +1211,14 @@ int mmc_attach_sdio(struct mmc_host *host)
 	funcs = (ocr & 0x70000000) >> 28;
 	card->sdio_funcs = 0;
 
-#ifdef CONFIG_MMC_EMBEDDED_SDIO
-	if (host->embedded_sdio_data.funcs)
-		card->sdio_funcs = funcs = host->embedded_sdio_data.num_funcs;
-#endif
-
 	/*
 	 * Initialize (but don't add) all present functions.
 	 */
 	for (i = 0; i < funcs; i++, card->sdio_funcs++) {
-#ifdef CONFIG_MMC_EMBEDDED_SDIO
-		if (host->embedded_sdio_data.funcs) {
-			struct sdio_func *tmp;
-
-			tmp = sdio_alloc_func(host->card);
-			if (IS_ERR(tmp))
-				goto remove;
-			tmp->num = (i + 1);
-			card->sdio_func[i] = tmp;
-			tmp->class = host->embedded_sdio_data.funcs[i].f_class;
-			tmp->max_blksize = host->embedded_sdio_data.funcs[i].f_maxblksize;
-			tmp->vendor = card->cis.vendor;
-			tmp->device = card->cis.device;
-		} else {
-#endif
-			err = sdio_init_func(host->card, i + 1);
-			if (err)
-				goto remove;
-#ifdef CONFIG_MMC_EMBEDDED_SDIO
-		}
-#endif
+		err = sdio_init_func(host->card, i + 1);
+		if (err)
+			goto remove;
+
 		/*
 		 * Enable Runtime PM for this func (if supported)
 		 */
@@ -1234,40 +1266,3 @@ err:
 	return err;
 }
 
-int sdio_reset_comm(struct mmc_card *card)
-{
-	struct mmc_host *host = card->host;
-	u32 ocr;
-	u32 rocr;
-	int err;
-
-	printk("%s():\n", __func__);
-	mmc_claim_host(host);
-
-	mmc_go_idle(host);
-
-	mmc_set_clock(host, host->f_min);
-
-	err = mmc_send_io_op_cond(host, 0, &ocr);
-	if (err)
-		goto err;
-
-	rocr = mmc_select_voltage(host, ocr);
-	if (!rocr) {
-		err = -EINVAL;
-		goto err;
-	}
-
-	err = mmc_sdio_init_card(host, rocr, card, 0);
-	if (err)
-		goto err;
-
-	mmc_release_host(host);
-	return 0;
-err:
-	printk("%s: Error resetting SDIO communications (%d)\n",
-	       mmc_hostname(host), err);
-	mmc_release_host(host);
-	return err;
-}
-EXPORT_SYMBOL(sdio_reset_comm);
diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c
index bf9417c..6d67492 100644
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@ -25,10 +25,6 @@
 #include "sdio_cis.h"
 #include "sdio_bus.h"
 
-#ifdef CONFIG_MMC_EMBEDDED_SDIO
-#include <linux/mmc/host.h>
-#endif
-
 /* show configuration fields */
 #define sdio_config_attr(field, format_string)				\
 static ssize_t								\
@@ -38,8 +34,7 @@ field##_show(struct device *dev, struct device_attribute *attr, char *buf)				\
 									\
 	func = dev_to_sdio_func (dev);					\
 	return sprintf (buf, format_string, func->field);		\
-}									\
-static DEVICE_ATTR_RO(field)
+}
 
 sdio_config_attr(class, "0x%02x\n");
 sdio_config_attr(vendor, "0x%04x\n");
@@ -52,16 +47,14 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 	return sprintf(buf, "sdio:c%02Xv%04Xd%04X\n",
 			func->class, func->vendor, func->device);
 }
-static DEVICE_ATTR_RO(modalias);
-
-static struct attribute *sdio_dev_attrs[] = {
-	&dev_attr_class.attr,
-	&dev_attr_vendor.attr,
-	&dev_attr_device.attr,
-	&dev_attr_modalias.attr,
-	NULL,
+
+static struct device_attribute sdio_dev_attrs[] = {
+	__ATTR_RO(class),
+	__ATTR_RO(vendor),
+	__ATTR_RO(device),
+	__ATTR_RO(modalias),
+	__ATTR_NULL,
 };
-ATTRIBUTE_GROUPS(sdio_dev);
 
 static const struct sdio_device_id *sdio_match_one(struct sdio_func *func,
 	const struct sdio_device_id *id)
@@ -201,8 +194,20 @@ static int sdio_bus_remove(struct device *dev)
 
 #ifdef CONFIG_PM
 
+#ifdef CONFIG_PM_SLEEP
+static int pm_no_operation(struct device *dev)
+{
+	/*
+	 * Prevent the PM core from calling SDIO device drivers' suspend
+	 * callback routines, which it is not supposed to do, by using this
+	 * empty function as the bus type suspend callaback for SDIO.
+	 */
+	return 0;
+}
+#endif
+
 static const struct dev_pm_ops sdio_bus_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(pm_generic_suspend, pm_generic_resume)
+	SET_SYSTEM_SLEEP_PM_OPS(pm_no_operation, pm_no_operation)
 	SET_RUNTIME_PM_OPS(
 		pm_generic_runtime_suspend,
 		pm_generic_runtime_resume,
@@ -220,7 +225,7 @@ static const struct dev_pm_ops sdio_bus_pm_ops = {
 
 static struct bus_type sdio_bus_type = {
 	.name		= "sdio",
-	.dev_groups	= sdio_dev_groups,
+	.dev_attrs	= sdio_dev_attrs,
 	.match		= sdio_bus_match,
 	.uevent		= sdio_bus_uevent,
 	.probe		= sdio_bus_probe,
@@ -265,14 +270,7 @@ static void sdio_release_func(struct device *dev)
 {
 	struct sdio_func *func = dev_to_sdio_func(dev);
 
-#ifdef CONFIG_MMC_EMBEDDED_SDIO
-	/*
-	 * If this device is embedded then we never allocated
-	 * cis tables for this func
-	 */
-	if (!func->card->host->embedded_sdio_data.funcs)
-#endif
-		sdio_free_func_cis(func);
+	sdio_free_func_cis(func);
 
 	kfree(func->info);
 
diff --git a/drivers/mmc/core/sdio_io.c b/drivers/mmc/core/sdio_io.c
index 8fdeb07..78cb4d5 100644
--- a/drivers/mmc/core/sdio_io.c
+++ b/drivers/mmc/core/sdio_io.c
@@ -384,39 +384,6 @@ u8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret)
 EXPORT_SYMBOL_GPL(sdio_readb);
 
 /**
- *	sdio_readb_ext - read a single byte from a SDIO function
- *	@func: SDIO function to access
- *	@addr: address to read
- *	@err_ret: optional status value from transfer
- *	@in: value to add to argument
- *
- *	Reads a single byte from the address space of a given SDIO
- *	function. If there is a problem reading the address, 0xff
- *	is returned and @err_ret will contain the error code.
- */
-unsigned char sdio_readb_ext(struct sdio_func *func, unsigned int addr,
-	int *err_ret, unsigned in)
-{
-	int ret;
-	unsigned char val;
-
-	BUG_ON(!func);
-
-	if (err_ret)
-		*err_ret = 0;
-
-	ret = mmc_io_rw_direct(func->card, 0, func->num, addr, (u8)in, &val);
-	if (ret) {
-		if (err_ret)
-			*err_ret = ret;
-		return 0xFF;
-	}
-
-	return val;
-}
-EXPORT_SYMBOL_GPL(sdio_readb_ext);
-
-/**
  *	sdio_writeb - write a single byte to a SDIO function
  *	@func: SDIO function to access
  *	@b: byte to write
diff --git a/drivers/mmc/core/sdio_irq.c b/drivers/mmc/core/sdio_irq.c
index aaa9046..3d8ceb4 100644
--- a/drivers/mmc/core/sdio_irq.c
+++ b/drivers/mmc/core/sdio_irq.c
@@ -53,17 +53,6 @@ static int process_sdio_pending_irqs(struct mmc_host *host)
 		return ret;
 	}
 
-	if (pending && mmc_card_broken_irq_polling(card) &&
-	    !(host->caps & MMC_CAP_SDIO_IRQ)) {
-		unsigned char dummy;
-
-		/* A fake interrupt could be created when we poll SDIO_CCCR_INTx
-		 * register with a Marvell SD8797 card. A dummy CMD52 read to
-		 * function 0 register 0xff can avoid this.
-		 */
-		mmc_io_rw_direct(card, 0, 0, 0xff, 0, &dummy);
-	}
-
 	count = 0;
 	for (i = 1; i <= 7; i++) {
 		if (pending & (1 << i)) {
diff --git a/drivers/mmc/core/sdio_ops.c b/drivers/mmc/core/sdio_ops.c
index cf2593c..62508b4 100644
--- a/drivers/mmc/core/sdio_ops.c
+++ b/drivers/mmc/core/sdio_ops.c
@@ -84,24 +84,11 @@ static int mmc_io_rw_direct_host(struct mmc_host *host, int write, unsigned fn,
 	cmd.arg |= (write && out) ? 0x08000000 : 0x00000000;
 	cmd.arg |= addr << 9;
 	cmd.arg |= in;
-	if (host->card && (host->card->quirks & MMC_QUIRK_NO_TUNING_IN_SLEEP))
-		cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_AC |
-			MMC_SKIP_TUNING;
-	else
-		cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_AC;
+	cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_AC;
 
 	err = mmc_wait_for_cmd(host, &cmd, 0);
-	if (err) {
-		if (err != -ETIMEDOUT && (cmd.flags & MMC_SKIP_TUNING)) {
-			cmd.error = 0;
-			/* retry with doing tuning first */
-			cmd.flags &= ~MMC_SKIP_TUNING;
-			err = mmc_wait_for_cmd(host, &cmd, 0);
-			if (err)
-				return err;
-		} else
-			return err;
-	}
+	if (err)
+		return err;
 
 	if (mmc_host_is_spi(host)) {
 		/* host driver already reported errors */
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 74e02aa..ef73cb6 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -94,22 +94,6 @@ config MMC_SDHCI_ACPI
 
 	  If unsure, say N.
 
-config MMC_SDHCI_ACPI_FORCE_POWER_ON
-	bool "Force Power On through ACPI methods"
-	depends on X86_PUMA7
-	depends on MMC_SDHCI_ACPI
-	help
-	  This forces the controller and all connected devices to
-	  power on before probing. This is done using ACPI.
-
-	  Some devices may have separate enabling lines that are
-	  controlled through GPIO. By calling the ACPI _PS0 method,
-	  these devices will be powered on and enabled before
-	  probing. This is to ensure all devices connected can be
-	  seen by the controller.
-
-	  If unsure, say N.
-
 config MMC_SDHCI_PLTFM
 	tristate "SDHCI platform and OF driver helper"
 	depends on MMC_SDHCI
diff --git a/drivers/mmc/host/sdhci-acpi.c b/drivers/mmc/host/sdhci-acpi.c
index f8eeeb2..657bb87 100644
--- a/drivers/mmc/host/sdhci-acpi.c
+++ b/drivers/mmc/host/sdhci-acpi.c
@@ -37,13 +37,11 @@
 #include <linux/acpi_gpio.h>
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
-#include <linux/pm_qos.h>
 #include <linux/delay.h>
 
 #include <linux/mmc/host.h>
 #include <linux/mmc/pm.h>
 #include <linux/mmc/sdhci.h>
-#include <linux/mmc/slot-gpio.h>
 
 #include "sdhci.h"
 
@@ -73,8 +71,6 @@ struct sdhci_acpi_slot {
 	unsigned int	caps2;
 	mmc_pm_flag_t	pm_caps;
 	unsigned int	flags;
-	int (*probe_slot) (struct platform_device *);
-	int (*remove_slot)(struct platform_device *);
 };
 
 struct sdhci_acpi_host {
@@ -82,7 +78,6 @@ struct sdhci_acpi_host {
 	const struct sdhci_acpi_slot	*slot;
 	struct platform_device		*pdev;
 	bool				use_runtime_pm;
-	unsigned int			autosuspend_delay;
 };
 
 static inline bool sdhci_acpi_flag(struct sdhci_acpi_host *c, unsigned int flag)
@@ -162,73 +157,12 @@ static const struct sdhci_acpi_chip sdhci_acpi_chip_int_puma7_emmc = {
 	.ops = &sdhci_acpi_ops_int_puma7_emmc,
 };
 
-/*
- * This probe slot routine is being added to address an issue on the host
- * controller's IP where hangs will occur of the platform enters a C state
- * below C2 while there is an outstanding write transaction. This is observed
- * on Baytrail based platforms, and should only be enabled on platforms with
- * host controller IP blocks that exhibit this.  We're calling based on the
- * ACPI-ID of the IP block.
- */
-static int sdhci_acpi_probe_slot(struct platform_device *pdev)
-{
-	struct sdhci_acpi_host *c = platform_get_drvdata(pdev);
-	struct sdhci_host *host;
-
-	if (!c || !c->host)
-		return 0;
-
-	host = c->host;
-	host->mmc->qos = kzalloc(sizeof(struct pm_qos_request), GFP_KERNEL);
-	pm_qos_add_request(host->mmc->qos, PM_QOS_CPU_DMA_LATENCY,
-					PM_QOS_DEFAULT_VALUE);
-
-	return 0;
-}
-
-static int sdhci_acpi_sdio_probe_slot(struct platform_device *pdev)
-{
-	struct sdhci_acpi_host *c = platform_get_drvdata(pdev);
-
-	if (!c || !c->host)
-		return 0;
-
-	/* increase the auto suspend delay for SDIO to be 500ms.
-	 * It can fix some latency issues after enabling rpm.
-	 */
-	c->autosuspend_delay = 500;
-
-	return sdhci_acpi_probe_slot(pdev);
-}
-
-static int sdhci_acpi_remove_slot(struct platform_device *pdev)
-{
-	struct sdhci_acpi_host *c = platform_get_drvdata(pdev);
-	struct sdhci_host *host;
-
-	if (!c || !c->host)
-		return 0;
-
-	host = c->host;
-
-	if (host->mmc && host->mmc->qos)
-		kfree(host->mmc->qos);
-
-	return 0;
-}
-
 static const struct sdhci_acpi_slot sdhci_acpi_slot_int_emmc = {
 	.chip    = &sdhci_acpi_chip_int,
-	.caps    = MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE | MMC_CAP_HW_RESET
-		| MMC_CAP_1_8V_DDR,
-	.caps2   = MMC_CAP2_HC_ERASE_SZ | MMC_CAP2_POLL_R1B_BUSY |
-		MMC_CAP2_CACHE_CTRL | MMC_CAP2_HS200_1_8V_SDR |
-		MMC_CAP2_CAN_DO_CMDQ,
+	.caps    = MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE | MMC_CAP_HW_RESET,
+	.caps2   = MMC_CAP2_HC_ERASE_SZ,
 	.flags   = SDHCI_ACPI_RUNTIME_PM,
-	.quirks2 = SDHCI_QUIRK2_TUNING_POLL | SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
-	.pm_caps = MMC_PM_TUNING_AFTER_RTRESUME,
-	.probe_slot = sdhci_acpi_probe_slot,
-	.remove_slot = sdhci_acpi_remove_slot,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
 };
 
 static const struct sdhci_acpi_slot sdhci_acpi_slot_int_puma7_emmc1 = {
@@ -258,21 +192,15 @@ static const struct sdhci_acpi_slot sdhci_acpi_slot_int_puma7_emmc2 = {
 
 static const struct sdhci_acpi_slot sdhci_acpi_slot_int_sdio = {
 	.quirks  = SDHCI_QUIRK_BROKEN_CARD_DETECTION,
-	.quirks2 = SDHCI_QUIRK2_HOST_OFF_CARD_ON |
-		   SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
-		   SDHCI_QUIRK2_FAKE_VDD,
+	.quirks2 = SDHCI_QUIRK2_HOST_OFF_CARD_ON,
 	.caps    = MMC_CAP_NONREMOVABLE | MMC_CAP_POWER_OFF_CARD,
 	.flags   = SDHCI_ACPI_RUNTIME_PM,
 	.pm_caps = MMC_PM_KEEP_POWER,
-	.probe_slot = sdhci_acpi_sdio_probe_slot,
-	.remove_slot = sdhci_acpi_remove_slot,
 };
 
 static const struct sdhci_acpi_slot sdhci_acpi_slot_int_sd = {
 	.flags   = SDHCI_ACPI_SD_CD | SDHCI_ACPI_RUNTIME_PM,
-	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
-	.probe_slot = sdhci_acpi_probe_slot,
-	.remove_slot = sdhci_acpi_remove_slot,
+	.quirks2 = SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON,
 };
 
 struct sdhci_acpi_uid_slot {
@@ -289,7 +217,7 @@ static const struct sdhci_acpi_uid_slot sdhci_acpi_uids[] = {
 	{ "80862B95" , "1" , &sdhci_acpi_slot_int_puma7_emmc2 },
 	{ "80862B96" , "1" , &sdhci_acpi_slot_int_sd   },
 	{ "INT33BB"  , "2" , &sdhci_acpi_slot_int_sdio },
-	{ "INT33BB"  , "3" , &sdhci_acpi_slot_int_sd   },
+	{ "INT33BB"  , "3" , &sdhci_acpi_slot_int_sd },
 	{ "INT33C6"  , NULL, &sdhci_acpi_slot_int_sdio },
 	{ "INT3436"  , NULL, &sdhci_acpi_slot_int_sdio },
 	{ "INT344D"  , NULL, &sdhci_acpi_slot_int_sdio },
@@ -401,7 +329,7 @@ static int sdhci_acpi_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	acpi_handle handle = ACPI_HANDLE(dev);
-	struct acpi_device *device, *child;
+	struct acpi_device *device;
 	struct sdhci_acpi_host *c;
 	struct sdhci_host *host;
 	struct resource *iomem;
@@ -412,13 +340,6 @@ static int sdhci_acpi_probe(struct platform_device *pdev)
 	if (acpi_bus_get_device(handle, &device))
 		return -ENODEV;
 
-	if (IS_ENABLED(CONFIG_MMC_SDHCI_ACPI_FORCE_POWER_ON)) {
-		/* Power on the SDHCI controller and its children */
-		acpi_device_fix_up_power(device);
-		list_for_each_entry(child, &device->children, node)
-			acpi_device_fix_up_power(child);
-	}
-
 	if (acpi_bus_get_status(device) || !device->status.present)
 		return -ENODEV;
 
@@ -446,7 +367,6 @@ static int sdhci_acpi_probe(struct platform_device *pdev)
 	c->slot = sdhci_acpi_get_slot(handle, hid);
 	c->pdev = pdev;
 	c->use_runtime_pm = sdhci_acpi_flag(c, SDHCI_ACPI_RUNTIME_PM);
-	c->autosuspend_delay = 0;
 
 	platform_set_drvdata(pdev, c);
 
@@ -471,17 +391,11 @@ static int sdhci_acpi_probe(struct platform_device *pdev)
 			dma_mask = DMA_BIT_MASK(32);
 		}
 
-		err = dma_coerce_mask_and_coherent(dev, dma_mask);
-		if (err)
-			goto err_free;
+		dev->dma_mask = &dev->coherent_dma_mask;
+		dev->coherent_dma_mask = dma_mask;
 	}
 
 	if (c->slot) {
-		if (c->slot->probe_slot) {
-			err = c->slot->probe_slot(pdev);
-			if (err)
-				goto err_free;
-		}
 		if (c->slot->chip) {
 			host->ops            = c->slot->chip->ops;
 			host->quirks        |= c->slot->chip->quirks;
@@ -516,7 +430,7 @@ static int sdhci_acpi_probe(struct platform_device *pdev)
 #endif
 	
 	if (err)
-		goto remove_slot;
+		goto err_free;
 
 	if (sdhci_acpi_flag(c, SDHCI_ACPI_SD_CD)) {
 		if (sdhci_acpi_add_own_cd(dev, gpio, host->mmc))
@@ -525,19 +439,14 @@ static int sdhci_acpi_probe(struct platform_device *pdev)
 
 	if (c->use_runtime_pm) {
 		pm_runtime_set_active(dev);
-		if (c->autosuspend_delay)
-			pm_runtime_set_autosuspend_delay(dev, c->autosuspend_delay);
-		else
-			pm_runtime_set_autosuspend_delay(dev, 50);
+		pm_suspend_ignore_children(dev, 1);
+		pm_runtime_set_autosuspend_delay(dev, 50);
 		pm_runtime_use_autosuspend(dev);
 		pm_runtime_enable(dev);
 	}
 
 	return 0;
 
-remove_slot:
-	if (c->slot && c->slot->remove_slot)
-		c->slot->remove_slot(pdev);
 err_free:
 	sdhci_free_host(c->host);
 	return err;
@@ -555,9 +464,6 @@ static int sdhci_acpi_remove(struct platform_device *pdev)
 		pm_runtime_put_noidle(dev);
 	}
 
-	if (c->slot && c->slot->remove_slot)
-		c->slot->remove_slot(pdev);
-
 	dead = (sdhci_readl(c->host, SDHCI_INT_STATUS) == ~0);
 	sdhci_remove_host(c->host, dead);
 	sdhci_free_host(c->host);
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 76f00a1..c37f9b7 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -28,7 +28,6 @@
 #include <linux/mmc/mmc.h>
 #include <linux/mmc/host.h>
 #include <linux/mmc/card.h>
-#include <linux/mmc/sdio.h>
 #include <linux/mmc/slot-gpio.h>
 #ifdef CONFIG_HW_MUTEXES
 #include <linux/hw_mutex.h>
@@ -52,6 +51,7 @@ static unsigned int debug_quirks2;
 
 static void sdhci_finish_data(struct sdhci_host *);
 
+static void sdhci_send_command(struct sdhci_host *, struct mmc_command *);
 static void sdhci_finish_command(struct sdhci_host *);
 static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode);
 static void sdhci_tuning_timer(unsigned long data);
@@ -81,51 +81,51 @@ static void sdhci_runtime_pm_bus_off(struct sdhci_host *host)
 
 static void sdhci_dumpregs(struct sdhci_host *host)
 {
-	pr_err(DRIVER_NAME ": =========== REGISTER DUMP (%s)===========\n",
+	pr_debug(DRIVER_NAME ": =========== REGISTER DUMP (%s)===========\n",
 		mmc_hostname(host->mmc));
 
-	pr_err(DRIVER_NAME ": Sys addr: 0x%08x | Version:  0x%08x\n",
+	pr_debug(DRIVER_NAME ": Sys addr: 0x%08x | Version:  0x%08x\n",
 		sdhci_readl(host, SDHCI_DMA_ADDRESS),
 		sdhci_readw(host, SDHCI_HOST_VERSION));
-	pr_err(DRIVER_NAME ": Blk size: 0x%08x | Blk cnt:  0x%08x\n",
+	pr_debug(DRIVER_NAME ": Blk size: 0x%08x | Blk cnt:  0x%08x\n",
 		sdhci_readw(host, SDHCI_BLOCK_SIZE),
 		sdhci_readw(host, SDHCI_BLOCK_COUNT));
-	pr_err(DRIVER_NAME ": Argument: 0x%08x | Trn mode: 0x%08x\n",
+	pr_debug(DRIVER_NAME ": Argument: 0x%08x | Trn mode: 0x%08x\n",
 		sdhci_readl(host, SDHCI_ARGUMENT),
 		sdhci_readw(host, SDHCI_TRANSFER_MODE));
-	pr_err(DRIVER_NAME ": Present:  0x%08x | Host ctl: 0x%08x\n",
+	pr_debug(DRIVER_NAME ": Present:  0x%08x | Host ctl: 0x%08x\n",
 		sdhci_readl(host, SDHCI_PRESENT_STATE),
 		sdhci_readb(host, SDHCI_HOST_CONTROL));
-	pr_err(DRIVER_NAME ": Power:    0x%08x | Blk gap:  0x%08x\n",
+	pr_debug(DRIVER_NAME ": Power:    0x%08x | Blk gap:  0x%08x\n",
 		sdhci_readb(host, SDHCI_POWER_CONTROL),
 		sdhci_readb(host, SDHCI_BLOCK_GAP_CONTROL));
-	pr_err(DRIVER_NAME ": Wake-up:  0x%08x | Clock:    0x%08x\n",
+	pr_debug(DRIVER_NAME ": Wake-up:  0x%08x | Clock:    0x%08x\n",
 		sdhci_readb(host, SDHCI_WAKE_UP_CONTROL),
 		sdhci_readw(host, SDHCI_CLOCK_CONTROL));
-	pr_err(DRIVER_NAME ": Timeout:  0x%08x | Int stat: 0x%08x\n",
+	pr_debug(DRIVER_NAME ": Timeout:  0x%08x | Int stat: 0x%08x\n",
 		sdhci_readb(host, SDHCI_TIMEOUT_CONTROL),
 		sdhci_readl(host, SDHCI_INT_STATUS));
-	pr_err(DRIVER_NAME ": Int enab: 0x%08x | Sig enab: 0x%08x\n",
+	pr_debug(DRIVER_NAME ": Int enab: 0x%08x | Sig enab: 0x%08x\n",
 		sdhci_readl(host, SDHCI_INT_ENABLE),
 		sdhci_readl(host, SDHCI_SIGNAL_ENABLE));
-	pr_err(DRIVER_NAME ": AC12 err: 0x%08x | Slot int: 0x%08x\n",
+	pr_debug(DRIVER_NAME ": AC12 err: 0x%08x | Slot int: 0x%08x\n",
 		sdhci_readw(host, SDHCI_ACMD12_ERR),
 		sdhci_readw(host, SDHCI_SLOT_INT_STATUS));
-	pr_err(DRIVER_NAME ": Caps:     0x%08x | Caps_1:   0x%08x\n",
+	pr_debug(DRIVER_NAME ": Caps:     0x%08x | Caps_1:   0x%08x\n",
 		sdhci_readl(host, SDHCI_CAPABILITIES),
 		sdhci_readl(host, SDHCI_CAPABILITIES_1));
-	pr_err(DRIVER_NAME ": Cmd:      0x%08x | Max curr: 0x%08x\n",
+	pr_debug(DRIVER_NAME ": Cmd:      0x%08x | Max curr: 0x%08x\n",
 		sdhci_readw(host, SDHCI_COMMAND),
 		sdhci_readl(host, SDHCI_MAX_CURRENT));
-	pr_err(DRIVER_NAME ": Host ctl2: 0x%08x\n",
+	pr_debug(DRIVER_NAME ": Host ctl2: 0x%08x\n",
 		sdhci_readw(host, SDHCI_HOST_CONTROL2));
 
 	if (host->flags & SDHCI_USE_ADMA)
-		pr_err(DRIVER_NAME ": ADMA Err: 0x%08x | ADMA Ptr: 0x%08x\n",
+		pr_debug(DRIVER_NAME ": ADMA Err: 0x%08x | ADMA Ptr: 0x%08x\n",
 		       readl(host->ioaddr + SDHCI_ADMA_ERROR),
 		       readl(host->ioaddr + SDHCI_ADMA_ADDRESS));
 
-	pr_err(DRIVER_NAME ": ===========================================\n");
+	pr_debug(DRIVER_NAME ": ===========================================\n");
 }
 
 /*****************************************************************************\
@@ -210,7 +210,7 @@ static void sdhci_reset(struct sdhci_host *host, u8 mask)
 	}
 
 	/* Wait max 100 ms */
-	timeout = 10000;
+	timeout = 100;
 
 	/* hw clears the bit when it's done */
 	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
@@ -221,7 +221,7 @@ static void sdhci_reset(struct sdhci_host *host, u8 mask)
 			return;
 		}
 		timeout--;
-		udelay(10);
+		mdelay(1);
 	}
 
 	if (host->ops->platform_reset_exit)
@@ -736,6 +736,8 @@ static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_command *cmd)
 	struct mmc_data *data = cmd->data;
 	int ret;
 
+	WARN_ON(host->data);
+
 	if (data || (cmd->flags & MMC_RSP_BUSY)) {
 		count = sdhci_calc_timeout(host, cmd);
 		sdhci_writeb(host, count, SDHCI_TIMEOUT_CONTROL);
@@ -744,8 +746,6 @@ static void sdhci_prepare_data(struct sdhci_host *host, struct mmc_command *cmd)
 	if (!data)
 		return;
 
-	WARN_ON(host->data);
-
 	/* Sanity checks */
 	BUG_ON(data->blksz * data->blocks > 524288);
 	BUG_ON(data->blksz > host->mmc->max_blk_size);
@@ -901,32 +901,23 @@ static void sdhci_set_transfer_mode(struct sdhci_host *host,
 	u16 mode;
 	struct mmc_data *data = cmd->data;
 
-	if (data == NULL) {
-		/* clear Auto CMD settings for no data CMDs */
-		mode = sdhci_readw(host, SDHCI_TRANSFER_MODE);
-		sdhci_writew(host, mode & ~(SDHCI_TRNS_AUTO_CMD12 |
-				SDHCI_TRNS_AUTO_CMD23), SDHCI_TRANSFER_MODE);
+	if (data == NULL)
 		return;
-	}
 
 	WARN_ON(!host->data);
 
 	mode = SDHCI_TRNS_BLK_CNT_EN;
-	if (mmc_op_cmdq_execute_task(cmd->opcode) && (data->blocks > 1))
-		mode |= SDHCI_TRNS_MULTI;
-	else if (mmc_op_multi(cmd->opcode) || (data->blocks > 1)) {
+	if (mmc_op_multi(cmd->opcode) || data->blocks > 1) {
 		mode |= SDHCI_TRNS_MULTI;
 		/*
 		 * If we are sending CMD23, CMD12 never gets sent
 		 * on successful completion (so no Auto-CMD12).
 		 */
-		if (!host->mrq->precmd && (host->flags & SDHCI_AUTO_CMD12))
+		if (!host->mrq->sbc && (host->flags & SDHCI_AUTO_CMD12))
 			mode |= SDHCI_TRNS_AUTO_CMD12;
-		else if (host->mrq->precmd && (host->flags &
-					SDHCI_AUTO_CMD23)) {
+		else if (host->mrq->sbc && (host->flags & SDHCI_AUTO_CMD23)) {
 			mode |= SDHCI_TRNS_AUTO_CMD23;
-			sdhci_writel(host, host->mrq->precmd->arg,
-					SDHCI_ARGUMENT2);
+			sdhci_writel(host, host->mrq->sbc->arg, SDHCI_ARGUMENT2);
 		}
 	}
 
@@ -976,7 +967,7 @@ static void sdhci_finish_data(struct sdhci_host *host)
 	 */
 	if (data->stop &&
 	    (data->error ||
-	     !host->mrq->precmd)) {
+	     !host->mrq->sbc)) {
 
 		/*
 		 * The controller needs a reset of internal state machines
@@ -988,15 +979,11 @@ static void sdhci_finish_data(struct sdhci_host *host)
 		}
 
 		sdhci_send_command(host, data->stop);
-	} else {
-		if (host->mmc->context_info.is_cmdq_busy)
-			tasklet_schedule(&host->finish_async_data_tasklet);
-		else
-			tasklet_schedule(&host->finish_tasklet);
-	}
+	} else
+		tasklet_schedule(&host->finish_tasklet);
 }
 
-void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
+static void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 {
 	int flags;
 	u32 mask;
@@ -1005,7 +992,7 @@ void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 	WARN_ON(host->cmd);
 
 	/* Wait max 10 ms */
-	timeout = 1000;
+	timeout = 10;
 
 	mask = SDHCI_CMD_INHIBIT;
 	if ((cmd->data != NULL) || (cmd->flags & MMC_RSP_BUSY))
@@ -1026,18 +1013,12 @@ void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 			return;
 		}
 		timeout--;
-		udelay(10);
+		mdelay(1);
 	}
 
-	timeout = jiffies;
-	if (!cmd->data && cmd->cmd_timeout_ms > 9000)
-		timeout += DIV_ROUND_UP(cmd->cmd_timeout_ms, 1000) * HZ + HZ;
-	else
-		timeout += 10 * HZ;
-	mod_timer(&host->timer, timeout);
+	mod_timer(&host->timer, jiffies + 10 * HZ);
 
 	host->cmd = cmd;
-	host->busy_handle = 0;
 
 	sdhci_prepare_data(host, cmd);
 
@@ -1072,15 +1053,8 @@ void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 	    cmd->opcode == MMC_SEND_TUNING_BLOCK_HS200)
 		flags |= SDHCI_CMD_DATA;
 
-	/* CMD46/47 doesn't wait for data */
-	if (mmc_op_cmdq_execute_task(cmd->opcode)) {
-		cmd->data = NULL;
-		host->mrq->data = NULL;
-	}
-
 	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->opcode, flags), SDHCI_COMMAND);
 }
-EXPORT_SYMBOL_GPL(sdhci_send_command);
 
 static void sdhci_finish_command(struct sdhci_host *host)
 {
@@ -1107,12 +1081,9 @@ static void sdhci_finish_command(struct sdhci_host *host)
 	host->cmd->error = 0;
 
 	/* Finished CMD23, now send actual command. */
-	if (host->cmd == host->mrq->precmd) {
+	if (host->cmd == host->mrq->sbc) {
 		host->cmd = NULL;
 		sdhci_send_command(host, host->mrq->cmd);
-	} else if ((host->cmd == host->mrq->cmd) && host->mrq->cmd2) {
-		host->cmd = NULL;
-		sdhci_send_command(host, host->mrq->cmd2);
 	} else {
 
 		/* Processed actual command. */
@@ -1148,9 +1119,6 @@ static u16 sdhci_get_preset_value(struct sdhci_host *host)
 	case SDHCI_CTRL_UHS_DDR50:
 		preset = sdhci_readw(host, SDHCI_PRESET_FOR_DDR50);
 		break;
-	case SDHCI_CTRL_MMC_HS400:
-		preset = sdhci_readw(host, SDHCI_PRESET_FOR_HS400);
-		break;
 	default:
 		pr_warn("%s: Invalid UHS-I mode selected\n",
 			mmc_hostname(host->mmc));
@@ -1256,7 +1224,7 @@ clock_set:
 	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
 
 	/* Wait max 20 ms */
-	timeout = 2000;
+	timeout = 20;
 	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
 		& SDHCI_CLOCK_INT_STABLE)) {
 		if (timeout == 0) {
@@ -1266,7 +1234,7 @@ clock_set:
 			return;
 		}
 		timeout--;
-		udelay(10);
+		mdelay(1);
 	}
 
 	clk |= SDHCI_CLOCK_CARD_EN;
@@ -1367,11 +1335,7 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 
 	sdhci_runtime_pm_get(host);
 
-	if (host->mmc->caps & MMC_CAP_NONREMOVABLE)
-		present = 1;
-	else
-		present = mmc_gpio_get_cd(host->mmc);
-
+	present = mmc_gpio_get_cd(host->mmc);
 
 	spin_lock_irqsave(&host->lock, flags);
 
@@ -1385,7 +1349,7 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	 * Ensure we don't send the STOP for non-SET_BLOCK_COUNTED
 	 * requests if Auto-CMD12 is enabled.
 	 */
-	if (!mrq->precmd && (host->flags & SDHCI_AUTO_CMD12)) {
+	if (!mrq->sbc && (host->flags & SDHCI_AUTO_CMD12)) {
 		if (mrq->stop) {
 			mrq->data->stop = NULL;
 			mrq->stop = NULL;
@@ -1423,29 +1387,13 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 		 * tuning procedure before sending command.
 		 */
 		if ((host->flags & SDHCI_NEEDS_RETUNING) &&
-		    !(present_state & (SDHCI_DOING_WRITE | SDHCI_DOING_READ)) &&
-		    (present_state & SDHCI_DATA_0_LVL_MASK)) {
+		    !(present_state & (SDHCI_DOING_WRITE | SDHCI_DOING_READ))) {
 			if (mmc->card) {
-				if (mrq->cmd->flags & MMC_SKIP_TUNING)
-					goto end_tuning;
-				if ((mmc->card->ext_csd.part_config & 0x07) ==
-					EXT_CSD_PART_CONFIG_ACC_RPMB)
-					goto end_tuning;
-				/* don't do tuning when cmdq is not empty */
-				if (mmc->context_info.is_cmdq_busy)
-					goto end_tuning;
 				/* eMMC uses cmd21 but sd and sdio use cmd19 */
 				tuning_opcode =
 					mmc->card->type == MMC_TYPE_MMC ?
 					MMC_SEND_TUNING_BLOCK_HS200 :
 					MMC_SEND_TUNING_BLOCK;
-
-				/* Here we need to set the host->mrq to NULL,
-				 * in case the pending finish_tasklet
-				 * finishes it incorrectly.
-				 */
-				host->mrq = NULL;
-
 				spin_unlock_irqrestore(&host->lock, flags);
 				sdhci_execute_tuning(mmc, tuning_opcode);
 				spin_lock_irqsave(&host->lock, flags);
@@ -1455,37 +1403,12 @@ static void sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)
 			}
 		}
 
-end_tuning:
-		if (!(sdhci_readw(host, SDHCI_CLOCK_CONTROL) &
-					SDHCI_CLOCK_CARD_EN)) {
-			/*
-			 * SD bus clock is stopped. no interrupts will be
-			 * generate in this case.
-			 */
-			pr_warn("%s:%s: SD bus clock not enabled for CMD %d\n",
-					__func__, mmc_hostname(mmc),
-					host->mrq->cmd->opcode);
-			pr_warn("%s:%s: host->pwr 0x%x, host->clock %d\n",
-					__func__, mmc_hostname(mmc),
-					host->pwr, host->clock);
-			host->mrq->cmd->error = -EIO;
-			tasklet_schedule(&host->finish_tasklet);
-			goto out;
-		}
-
-		if (mrq->precmd) {
-			if (mrq->precmd->opcode == 23) {
-				if (!(host->flags & SDHCI_AUTO_CMD23))
-					sdhci_send_command(host, mrq->precmd);
-				else
-					sdhci_send_command(host, mrq->cmd);
-			} else
-				sdhci_send_command(host, mrq->precmd);
-		} else
+		if (mrq->sbc && !(host->flags & SDHCI_AUTO_CMD23))
+			sdhci_send_command(host, mrq->sbc);
+		else
 			sdhci_send_command(host, mrq->cmd);
 	}
 
-out:
 	mmiowb();
 	spin_unlock_irqrestore(&host->lock, flags);
 }
@@ -1515,8 +1438,7 @@ static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
 	}
 
 	if (host->version >= SDHCI_SPEC_300 &&
-		(ios->power_mode == MMC_POWER_UP) &&
-		!(host->quirks2 & SDHCI_QUIRK2_PRESET_VALUE_BROKEN))
+		(ios->power_mode == MMC_POWER_UP))
 		sdhci_enable_preset_value(host, false);
 
 	sdhci_set_clock(host, ios->clock);
@@ -1526,37 +1448,6 @@ static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
 	else
 		vdd_bit = sdhci_set_power(host, ios->vdd);
 
-	/*
-	 * some controller is not able to set the power control register
-	 * after resuming from low power mode, and need some cycles to
-	 * make sure the bus power can be turned on.
-	 */
-	if (host->pwr) {
-		u32 timeout = 2000; /* 2s */
-		u8 pwr = sdhci_readb(host, SDHCI_POWER_CONTROL);
-		if (!(pwr & SDHCI_POWER_ON)) {
-			do {
-				pwr |= SDHCI_POWER_ON;
-				sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
-				sdhci_readl(host, SDHCI_PRESENT_STATE),
-				spin_unlock_irqrestore(&host->lock, flags);
-				/*
-				 * breaking lock here so we can sleep is ok as
-				 * this happens only on startup and resume code
-				 * paths and the mmc cannot be reentered
-				 */
-				usleep_range(1000, 1100);
-				spin_lock_irqsave(&host->lock, flags);
-				timeout--;
-				pwr = sdhci_readb(host, SDHCI_POWER_CONTROL);
-			} while (!(pwr & SDHCI_POWER_ON) && timeout);
-			if (!timeout)
-				pr_warn("%s %s: bus power is not stable\n",
-						__func__,
-						mmc_hostname(host->mmc));
-		}
-	}
-
 	if (host->vmmc && vdd_bit != -1) {
 		spin_unlock_irqrestore(&host->lock, flags);
 		mmc_regulator_set_ocr(host->mmc, host->vmmc, vdd_bit);
@@ -1603,9 +1494,7 @@ static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
 		u16 clk, ctrl_2;
 
 		/* In case of UHS-I modes, set High Speed Enable */
-		if ((ios->timing == MMC_TIMING_MMC_HS400) ||
-		    (ios->timing == MMC_TIMING_MMC_HS200) ||
-		    (ios->timing == MMC_TIMING_MMC_DDR52) ||
+		if ((ios->timing == MMC_TIMING_MMC_HS200) ||
 		    (ios->timing == MMC_TIMING_UHS_SDR50) ||
 		    (ios->timing == MMC_TIMING_UHS_SDR104) ||
 		    (ios->timing == MMC_TIMING_UHS_DDR50) ||
@@ -1657,9 +1546,7 @@ static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
 			ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
 			/* Select Bus Speed Mode for host */
 			ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
-			if (ios->timing == MMC_TIMING_MMC_HS400)
-				ctrl_2 |= SDHCI_CTRL_MMC_HS400;
-			else if ((ios->timing == MMC_TIMING_MMC_HS200) ||
+			if ((ios->timing == MMC_TIMING_MMC_HS200) ||
 			    (ios->timing == MMC_TIMING_UHS_SDR104))
 				ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
 			else if (ios->timing == MMC_TIMING_UHS_SDR12)
@@ -1668,8 +1555,7 @@ static void sdhci_do_set_ios(struct sdhci_host *host, struct mmc_ios *ios)
 				ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
 			else if (ios->timing == MMC_TIMING_UHS_SDR50)
 				ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
-			else if ((ios->timing == MMC_TIMING_UHS_DDR50) ||
-				 (ios->timing == MMC_TIMING_MMC_DDR52))
+			else if (ios->timing == MMC_TIMING_UHS_DDR50)
 				ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
 			sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
 		}
@@ -1885,7 +1771,7 @@ static int sdhci_do_start_signal_voltage_switch(struct sdhci_host *host,
 		sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
 
 		if (host->vqmmc) {
-			ret = regulator_set_voltage(host->vqmmc, 3300000, 3600000);
+			ret = regulator_set_voltage(host->vqmmc, 2700000, 3600000);
 			if (ret) {
 				pr_warning("%s: Switching to 3.3V signalling voltage "
 						" failed\n", mmc_hostname(host->mmc));
@@ -1907,7 +1793,7 @@ static int sdhci_do_start_signal_voltage_switch(struct sdhci_host *host,
 	case MMC_SIGNAL_VOLTAGE_180:
 		if (host->vqmmc) {
 			ret = regulator_set_voltage(host->vqmmc,
-					1800000, 1950000);
+					1700000, 1950000);
 			if (ret) {
 				pr_warning("%s: Switching to 1.8V signalling voltage "
 						" failed\n", mmc_hostname(host->mmc));
@@ -1983,14 +1869,15 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 	u16 ctrl;
 	u32 ier;
 	int tuning_loop_counter = MAX_TUNING_LOOP;
+	unsigned long timeout;
 	int err = 0;
 	bool requires_tuning_nonuhs = false;
-	unsigned long flags;
 
 	host = mmc_priv(mmc);
 
 	sdhci_runtime_pm_get(host);
-	spin_lock_irqsave(&host->lock, flags);
+	disable_irq(host->irq);
+	spin_lock(&host->lock);
 
 	ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
 
@@ -2001,31 +1888,21 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 	 * If the Host Controller supports the HS200 mode then the
 	 * tuning function has to be executed.
 	 */
-	if ((((ctrl & SDHCI_CTRL_UHS_MASK) == SDHCI_CTRL_UHS_SDR50) &&
-	    (host->flags & SDHCI_SDR50_NEEDS_TUNING) &&
-	    (mmc->ios.timing == MMC_TIMING_UHS_SDR50)) ||
-	     ((host->flags & SDHCI_SDR104_NEEDS_TUNING) &&
-	      ((mmc->ios.timing == MMC_TIMING_MMC_HS200) ||
-	      (mmc->ios.timing == MMC_TIMING_MMC_HS400))) ||
-	       mmc->ios.timing == MMC_TIMING_UHS_SDR104)
+	if (((ctrl & SDHCI_CTRL_UHS_MASK) == SDHCI_CTRL_UHS_SDR50) &&
+	    (host->flags & SDHCI_SDR50_NEEDS_TUNING ||
+	     host->flags & SDHCI_SDR104_NEEDS_TUNING))
 		requires_tuning_nonuhs = true;
 
 	if (((ctrl & SDHCI_CTRL_UHS_MASK) == SDHCI_CTRL_UHS_SDR104) ||
 	    requires_tuning_nonuhs)
 		ctrl |= SDHCI_CTRL_EXEC_TUNING;
 	else {
-		spin_unlock_irqrestore(&host->lock, flags);
+		spin_unlock(&host->lock);
+		enable_irq(host->irq);
 		sdhci_runtime_pm_put(host);
 		return 0;
 	}
 
-	if (host->ops->platform_execute_tuning) {
-		spin_unlock_irqrestore(&host->lock, flags);
-		err = host->ops->platform_execute_tuning(host, opcode);
-		sdhci_runtime_pm_put(host);
-		return err;
-	}
-
 	sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
 
 	/*
@@ -2045,10 +1922,14 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 	 * Issue CMD19 repeatedly till Execute Tuning is set to 0 or the number
 	 * of loops reaches 40 times or a timeout of 150ms occurs.
 	 */
+	timeout = 150;
 	do {
 		struct mmc_command cmd = {0};
 		struct mmc_request mrq = {NULL};
 
+		if (!tuning_loop_counter && !timeout)
+			break;
+
 		cmd.opcode = opcode;
 		cmd.arg = 0;
 		cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
@@ -2056,9 +1937,6 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 		cmd.data = NULL;
 		cmd.error = 0;
 
-		if (tuning_loop_counter-- == 0)
-			break;
-
 		mrq.cmd = &cmd;
 		host->mrq = &mrq;
 
@@ -2092,27 +1970,15 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 		host->cmd = NULL;
 		host->mrq = NULL;
 
-		if (unlikely(host->quirks2 & SDHCI_QUIRK2_TUNING_POLL)) {
-			unsigned long timeout = jiffies + msecs_to_jiffies(150);
-			do {
-				unsigned int intmask =
-					sdhci_readl(host, SDHCI_INT_STATUS);
-				if (!(intmask & SDHCI_INT_DATA_AVAIL))
-					continue;
-				host->tuning_done = 1;
-				sdhci_writel(host,
-						intmask & SDHCI_INT_DATA_AVAIL,
-						SDHCI_INT_STATUS);
-				break;
-			} while (!time_after(jiffies, timeout));
-		} else {
-			spin_unlock_irqrestore(&host->lock, flags);
-			/* Wait for Buffer Read Ready interrupt */
-			wait_event_interruptible_timeout(host->buf_ready_int,
-						(host->tuning_done == 1),
-						msecs_to_jiffies(50));
-			spin_lock_irqsave(&host->lock, flags);
-		}
+		spin_unlock(&host->lock);
+		enable_irq(host->irq);
+
+		/* Wait for Buffer Read Ready interrupt */
+		wait_event_interruptible_timeout(host->buf_ready_int,
+					(host->tuning_done == 1),
+					msecs_to_jiffies(50));
+		disable_irq(host->irq);
+		spin_lock(&host->lock);
 
 		if (!host->tuning_done) {
 			pr_info(DRIVER_NAME ": Timeout waiting for "
@@ -2124,9 +1990,6 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 			ctrl &= ~SDHCI_CTRL_EXEC_TUNING;
 			sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
 
-			sdhci_reset(host, SDHCI_RESET_CMD);
-			sdhci_reset(host, SDHCI_RESET_DATA);
-
 			err = -EIO;
 			goto out;
 		}
@@ -2134,25 +1997,25 @@ static int sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)
 		host->tuning_done = 0;
 
 		ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
-
-		/* eMMC spec does not require a delay between tuning cycles */
-		if (opcode == MMC_SEND_TUNING_BLOCK)
-			mdelay(1);
+		tuning_loop_counter--;
+		timeout--;
+		mdelay(1);
 	} while (ctrl & SDHCI_CTRL_EXEC_TUNING);
 
 	/*
 	 * The Host Driver has exhausted the maximum number of loops allowed,
 	 * so use fixed sampling frequency.
 	 */
-	if (tuning_loop_counter < 0) {
+	if (!tuning_loop_counter || !timeout) {
 		ctrl &= ~SDHCI_CTRL_TUNED_CLK;
 		sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
-		err = -EIO;
-	}
-	if (!(ctrl & SDHCI_CTRL_TUNED_CLK)) {
-		pr_info(DRIVER_NAME ": Tuning procedure"
-			" failed, falling back to fixed sampling"
-			" clock\n");
+	} else {
+		if (!(ctrl & SDHCI_CTRL_TUNED_CLK)) {
+			pr_info(DRIVER_NAME ": Tuning procedure"
+				" failed, falling back to fixed sampling"
+				" clock\n");
+			err = -EIO;
+		}
 	}
 
 out:
@@ -2169,14 +2032,12 @@ out:
 			host->tuning_count * HZ);
 		/* Tuning mode 1 limits the maximum data length to 4MB */
 		mmc->max_blk_count = (4 * 1024 * 1024) / mmc->max_blk_size;
-	} else if (err && host->mmc->card && (host->mmc->card->quirks &
-				MMC_QUIRK_NO_TUNING_IN_SLEEP)) {
-		pr_debug("%s: will do retuning\n", mmc_hostname(host->mmc));
-	} else if (host->flags & SDHCI_USING_RETUNING_TIMER) {
+	} else {
 		host->flags &= ~SDHCI_NEEDS_RETUNING;
 		/* Reload the new initial value for timer */
-		mod_timer(&host->tuning_timer, jiffies +
-			  host->tuning_count * HZ);
+		if (host->tuning_mode == SDHCI_TUNING_MODE_1)
+			mod_timer(&host->tuning_timer, jiffies +
+				host->tuning_count * HZ);
 	}
 
 	/*
@@ -2191,7 +2052,8 @@ out:
 		err = 0;
 
 	sdhci_clear_set_irqs(host, SDHCI_INT_DATA_AVAIL, ier);
-	spin_unlock_irqrestore(&host->lock, flags);
+	spin_unlock(&host->lock);
+	enable_irq(host->irq);
 	sdhci_runtime_pm_put(host);
 
 	return err;
@@ -2282,7 +2144,7 @@ static void sdhci_tasklet_card(unsigned long param)
 	mmc_detect_change(host->mmc, msecs_to_jiffies(200));
 }
 
-static void sdhci_tasklet_finish_async_data(unsigned long param)
+static void sdhci_tasklet_finish(unsigned long param)
 {
 	struct sdhci_host *host;
 	unsigned long flags;
@@ -2296,71 +2158,14 @@ static void sdhci_tasklet_finish_async_data(unsigned long param)
          * If this tasklet gets rescheduled while running, it will
          * be run again afterwards but without any active request.
          */
-	if (!host->mmc->areq || !host->mmc->areq->mrq->data) {
+	if (!host->mrq) {
 		spin_unlock_irqrestore(&host->lock, flags);
 		return;
 	}
 
 	del_timer(&host->timer);
 
-	mrq = host->mmc->areq->mrq;
-
-	/*
-	 * The controller needs a reset of internal state machines
-	 * upon error conditions.
-	 */
-	if (!(host->flags & SDHCI_DEVICE_DEAD) &&
-	    ((mrq->data && mrq->data->error) ||
-	     (host->quirks & SDHCI_QUIRK_RESET_AFTER_REQUEST))) {
-
-		/* Some controllers need this kick or reset won't work here */
-		if (host->quirks & SDHCI_QUIRK_CLOCK_BEFORE_RESET)
-			/* This is to force an update */
-			sdhci_update_clock(host);
-
-		sdhci_reset(host, SDHCI_RESET_DATA);
-	}
-
-	host->data = NULL;
-
-#ifndef SDHCI_USE_LEDS_CLASS
-	sdhci_deactivate_led(host);
-#endif
-	mmiowb();
-	spin_unlock_irqrestore(&host->lock, flags);
-
-	mmc_request_done(host->mmc, mrq);
-
-	sdhci_runtime_pm_put(host);
-}
-
-static void sdhci_tasklet_finish(unsigned long param)
-{
-	struct sdhci_host *host;
-	unsigned long flags;
-	struct mmc_request *mrq;
-	int opcode;
-
-	host = (struct sdhci_host *)param;
-
-	spin_lock_irqsave(&host->lock, flags);
-
-	/*
-	 * If this tasklet gets rescheduled while running, it will
-	 * be run again afterwards but without any active request.
-	 */
-	if (!host->mrq) {
-		spin_unlock_irqrestore(&host->lock, flags);
-		return;
-	}
-
 	mrq = host->mrq;
-	BUG_ON(!mrq->cmd);
-	opcode = mrq->cmd->opcode;
-
-	/* for CMD46/47, doesn't delete timer */
-	if (!mmc_op_cmdq_execute_task(opcode))
-		del_timer(&host->timer);
 
 	/*
 	 * The controller needs a reset of internal state machines
@@ -2381,31 +2186,21 @@ static void sdhci_tasklet_finish(unsigned long param)
 		   controllers do not like that. */
 		sdhci_reset(host, SDHCI_RESET_CMD);
 		sdhci_reset(host, SDHCI_RESET_DATA);
-		/* clear data as DATA is reset */
-		host->data = NULL;
 	}
 
 	host->mrq = NULL;
 	host->cmd = NULL;
+	host->data = NULL;
 
-	/* CMD46/47 sill have pending data */
-	if (!mmc_op_cmdq_execute_task(opcode)) {
 #ifndef SDHCI_USE_LEDS_CLASS
-		sdhci_deactivate_led(host);
+	sdhci_deactivate_led(host);
 #endif
-	}
 
 	mmiowb();
 	spin_unlock_irqrestore(&host->lock, flags);
 
 	mmc_request_done(host->mmc, mrq);
-
-	/*
-	 * host will be put in D0i3 when pending data is done
-	 * for CMD46/47
-	 */
-	if (!mmc_op_cmdq_execute_task(opcode))
-		sdhci_runtime_pm_put(host);
+	sdhci_runtime_pm_put(host);
 }
 
 static void sdhci_timeout_timer(unsigned long data)
@@ -2497,12 +2292,8 @@ static void sdhci_cmd_irq(struct sdhci_host *host, u32 intmask)
 		if (host->cmd->data)
 			DBG("Cannot wait for busy signal when also "
 				"doing a data transfer");
-		else if (!(host->quirks & SDHCI_QUIRK_NO_BUSY_IRQ)
-				&& !host->busy_handle) {
-			/* Mark that command complete before busy is ended */
-			host->busy_handle = 1;
+		else if (!(host->quirks & SDHCI_QUIRK_NO_BUSY_IRQ))
 			return;
-		}
 
 		/* The controller does not support the end-of-busy IRQ,
 		 * fall through and take the SDHCI_INT_RESPONSE */
@@ -2565,15 +2356,7 @@ static void sdhci_data_irq(struct sdhci_host *host, u32 intmask)
 		 */
 		if (host->cmd && (host->cmd->flags & MMC_RSP_BUSY)) {
 			if (intmask & SDHCI_INT_DATA_END) {
-				/*
-				 * Some cards handle busy-end interrupt
-				 * before the command completed, so make
-				 * sure we do things in the proper order.
-				 */
-				if (host->busy_handle)
-					sdhci_finish_command(host);
-				else
-					host->busy_handle = 1;
+				sdhci_finish_command(host);
 				return;
 			}
 		}
@@ -2636,16 +2419,16 @@ static void sdhci_data_irq(struct sdhci_host *host, u32 intmask)
 		}
 
 		if (intmask & SDHCI_INT_DATA_END) {
-			if (!host->mmc->context_info.is_cmdq_busy &&
-					host->cmd) {
+			if (host->cmd) {
 				/*
 				 * Data managed to finish before the
 				 * command completed. Make sure we do
 				 * things in the proper order.
 				 */
 				host->data_early = 1;
-			} else
+			} else {
 				sdhci_finish_data(host);
+			}
 		}
 	}
 }
@@ -2677,7 +2460,9 @@ static irqreturn_t sdhci_irq(int irq, void *dev_id)
 
 	if (host->runtime_suspended) {
 		spin_unlock(&host->lock);
-		return IRQ_NONE;
+		pr_warning("%s: got irq while runtime suspended\n",
+		       mmc_hostname(host->mmc));
+		return IRQ_HANDLED;
 	}
 
 	intmask = sdhci_readl(host, SDHCI_INT_STATUS);
@@ -2753,14 +2538,6 @@ again:
 	result = IRQ_HANDLED;
 
 	intmask = sdhci_readl(host, SDHCI_INT_STATUS);
-
-	/*
-	 * If we know we'll call the driver to signal SDIO IRQ, disregard
-	 * further indications of Card Interrupt in the status to avoid a
-	 * needless loop.
-	 */
-	if (cardint)
-		intmask &= ~SDHCI_INT_CARD_INT;
 	if (intmask && --max_loops)
 		goto again;
 out:
@@ -2816,6 +2593,8 @@ EXPORT_SYMBOL_GPL(sdhci_disable_irq_wakeups);
 
 int sdhci_suspend_host(struct sdhci_host *host)
 {
+	int ret;
+
 	if (host->ops->platform_suspend)
 		host->ops->platform_suspend(host);
 
@@ -2827,6 +2606,19 @@ int sdhci_suspend_host(struct sdhci_host *host)
 		host->flags &= ~SDHCI_NEEDS_RETUNING;
 	}
 
+	ret = mmc_suspend_host(host->mmc);
+	if (ret) {
+		if (host->flags & SDHCI_USING_RETUNING_TIMER) {
+			host->flags |= SDHCI_NEEDS_RETUNING;
+			mod_timer(&host->tuning_timer, jiffies +
+					host->tuning_count * HZ);
+		}
+
+		sdhci_enable_card_detection(host);
+
+		return ret;
+	}
+
 	if (!device_may_wakeup(mmc_dev(host->mmc))) {
 		sdhci_mask_irqs(host, SDHCI_INT_ALL_MASK);
 		free_irq(host->irq, host);
@@ -2834,14 +2626,14 @@ int sdhci_suspend_host(struct sdhci_host *host)
 		sdhci_enable_irq_wakeups(host);
 		enable_irq_wake(host->irq);
 	}
-	return 0;
+	return ret;
 }
 
 EXPORT_SYMBOL_GPL(sdhci_suspend_host);
 
 int sdhci_resume_host(struct sdhci_host *host)
 {
-	int ret = 0;
+	int ret;
 
 	if (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA)) {
 		if (host->ops->enable_dma)
@@ -2870,6 +2662,7 @@ int sdhci_resume_host(struct sdhci_host *host)
 		mmiowb();
 	}
 
+	ret = mmc_resume_host(host->mmc);
 	sdhci_enable_card_detection(host);
 
 	if (host->ops->platform_resume)
@@ -3282,12 +3075,8 @@ int sdhci_add_host(struct sdhci_host *host)
 		/* SD3.0: SDR104 is supported so (for eMMC) the caps2
 		 * field can be promoted to support HS200.
 		 */
-		if (!(host->quirks2 & SDHCI_QUIRK2_BROKEN_HS200)) {
+		if (!(host->quirks2 & SDHCI_QUIRK2_BROKEN_HS200))
 			mmc->caps2 |= MMC_CAP2_HS200;
-			if (!host->vqmmc || !regulator_is_supported_voltage
-					(host->vqmmc, 1100000, 1300000))
-				mmc->caps2 &= ~MMC_CAP2_HS200_1_2V_SDR;
-		}
 	} else if (caps[1] & SDHCI_SUPPORT_SDR50)
 		mmc->caps |= MMC_CAP_UHS_SDR50;
 
@@ -3300,7 +3089,7 @@ int sdhci_add_host(struct sdhci_host *host)
 		host->flags |= SDHCI_SDR50_NEEDS_TUNING;
 
 	/* Does the host need tuning for SDR104 / HS200? */
-	if (mmc->caps2 & (MMC_CAP2_HS200 | MMC_CAP2_HS400))
+	if (mmc->caps2 & MMC_CAP2_HS200)
 		host->flags |= SDHCI_SDR104_NEEDS_TUNING;
 
 	/* Driver Type(s) (A, C, D) supported by the host */
@@ -3365,7 +3154,7 @@ int sdhci_add_host(struct sdhci_host *host)
 	 */
 	max_current_caps = sdhci_readl(host, SDHCI_MAX_CURRENT);
 	if (!max_current_caps && host->vmmc) {
-		int curr = regulator_get_current_limit(host->vmmc);
+		u32 curr = regulator_get_current_limit(host->vmmc);
 		if (curr > 0) {
 
 			/* convert to SDHCI_MAX_CURRENT format */
@@ -3380,10 +3169,6 @@ int sdhci_add_host(struct sdhci_host *host)
 		}
 	}
 
-	if (host->quirks2 & SDHCI_QUIRK2_FAKE_VDD)
-		caps[0] |= SDHCI_CAN_VDD_330 | SDHCI_CAN_VDD_300 |
-			SDHCI_CAN_VDD_180;
-
 	if (caps[0] & SDHCI_CAN_VDD_330) {
 		ocr_avail |= MMC_VDD_32_33 | MMC_VDD_33_34;
 
@@ -3494,8 +3279,6 @@ int sdhci_add_host(struct sdhci_host *host)
 		sdhci_tasklet_card, (unsigned long)host);
 	tasklet_init(&host->finish_tasklet,
 		sdhci_tasklet_finish, (unsigned long)host);
-	tasklet_init(&host->finish_async_data_tasklet,
-		sdhci_tasklet_finish_async_data, (unsigned long)host);
 
 	setup_timer(&host->timer, sdhci_timeout_timer, (unsigned long)host);
 
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index e5da1ef..e899931 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -73,7 +73,6 @@
 #define  SDHCI_WRITE_PROTECT	0x00080000
 #define  SDHCI_DATA_LVL_MASK	0x00F00000
 #define   SDHCI_DATA_LVL_SHIFT	20
-#define   SDHCI_DATA_0_LVL_MASK	0x00100000
 
 #define SDHCI_HOST_CONTROL	0x28
 #define  SDHCI_CTRL_LED		0x01
@@ -162,8 +161,7 @@
 #define   SDHCI_CTRL_UHS_SDR50		0x0002
 #define   SDHCI_CTRL_UHS_SDR104		0x0003
 #define   SDHCI_CTRL_UHS_DDR50		0x0004
-#define   SDHCI_CTRL_HS_SDR200		SDHCI_CTRL_UHS_SDR104
-#define   SDHCI_CTRL_MMC_HS400		0x0005
+#define   SDHCI_CTRL_HS_SDR200		0x0005 /* reserved value in SDIO spec */
 #define  SDHCI_CTRL_VDD_180		0x0008
 #define  SDHCI_CTRL_DRV_TYPE_MASK	0x0030
 #define   SDHCI_CTRL_DRV_TYPE_B		0x0000
@@ -237,7 +235,6 @@
 #define SDHCI_PRESET_FOR_SDR50 0x6A
 #define SDHCI_PRESET_FOR_SDR104        0x6C
 #define SDHCI_PRESET_FOR_DDR50 0x6E
-#define SDHCI_PRESET_FOR_HS400 0x74
 #define SDHCI_PRESET_DRV_MASK  0xC000
 #define SDHCI_PRESET_DRV_SHIFT  14
 #define SDHCI_PRESET_CLKGEN_SEL_MASK   0x400
@@ -292,7 +289,6 @@ struct sdhci_ops {
 	unsigned int    (*get_ro)(struct sdhci_host *host);
 	void	(*platform_reset_enter)(struct sdhci_host *host, u8 mask);
 	void	(*platform_reset_exit)(struct sdhci_host *host, u8 mask);
-	int	(*platform_execute_tuning)(struct sdhci_host *host, u32 opcode);
 	int	(*set_uhs_signaling)(struct sdhci_host *host, unsigned int uhs);
 	void	(*hw_reset)(struct sdhci_host *host);
 	void	(*platform_suspend)(struct sdhci_host *host);
@@ -398,8 +394,6 @@ static inline void *sdhci_priv(struct sdhci_host *host)
 extern void sdhci_card_detect(struct sdhci_host *host);
 extern int sdhci_add_host(struct sdhci_host *host);
 extern void sdhci_remove_host(struct sdhci_host *host, int dead);
-extern void sdhci_send_command(struct sdhci_host *host,
-				struct mmc_command *cmd);
 
 #ifdef CONFIG_PM
 extern int sdhci_suspend_host(struct sdhci_host *host);
diff --git a/include/linux/mmc/card.h b/include/linux/mmc/card.h
index 316a8a1..842de3e 100644
--- a/include/linux/mmc/card.h
+++ b/include/linux/mmc/card.h
@@ -63,12 +63,12 @@ struct mmc_ext_csd {
 	unsigned int            power_off_longtime;     /* Units: ms */
 	u8			power_off_notification;	/* state */
 	unsigned int		hs_max_dtr;
-	unsigned int		hs200_max_dtr;
 #define MMC_HIGH_26_MAX_DTR	26000000
 #define MMC_HIGH_52_MAX_DTR	52000000
 #define MMC_HIGH_DDR_MAX_DTR	52000000
 #define MMC_HS200_MAX_DTR	200000000
 	unsigned int		sectors;
+	unsigned int		card_type;
 	unsigned int		hc_erase_size;		/* In sectors */
 	unsigned int		hc_erase_timeout;	/* In milliseconds */
 	unsigned int		sec_trim_mult;	/* Secure trim multiplier  */
@@ -88,7 +88,6 @@ struct mmc_ext_csd {
 	unsigned int		boot_ro_lock;		/* ro lock support */
 	bool			boot_ro_lockable;
 	u8			raw_exception_status;	/* 54 */
-	u8			part_set_complete;	/* 155 */
 	u8			raw_partition_support;	/* 160 */
 	u8			raw_rpmb_size_mult;	/* 168 */
 	u8			raw_erased_mem_count;	/* 181 */
@@ -111,15 +110,11 @@ struct mmc_ext_csd {
 	u8			raw_pwr_cl_200_360;	/* 237 */
 	u8			raw_pwr_cl_ddr_52_195;	/* 238 */
 	u8			raw_pwr_cl_ddr_52_360;	/* 239 */
-	u8			raw_pwr_cl_ddr_200_360;	/* 253 */
 	u8			raw_bkops_status;	/* 246 */
 	u8			raw_sectors[4];		/* 212 - 4 bytes */
 
 	unsigned int            feature_support;
 #define MMC_DISCARD_FEATURE	BIT(0)                  /* CMD38 feature */
-	u8			cmdq_support;		/* 308 */
-	bool			cmdq_en;
-	u8			cmdq_depth;		/* 307 */
 };
 
 struct sd_scr {
@@ -199,7 +194,6 @@ struct sdio_cis {
 };
 
 struct mmc_host;
-struct mmc_ios;
 struct sdio_func;
 struct sdio_func_tuple;
 
@@ -218,12 +212,11 @@ enum mmc_blk_status {
 };
 
 /* The number of MMC physical partitions.  These consist of:
- * boot partitions (2), general purpose partitions (4) and
- * RPMB partition (1) in MMC v4.4.
+ * boot partitions (2), general purpose partitions (4) in MMC v4.4.
  */
 #define MMC_NUM_BOOT_PARTITION	2
 #define MMC_NUM_GP_PARTITION	4
-#define MMC_NUM_PHY_PARTITION	7
+#define MMC_NUM_PHY_PARTITION	6
 #define MAX_MMC_PART_NAME_LEN	20
 
 /*
@@ -247,7 +240,6 @@ struct mmc_part {
 struct mmc_card {
 	struct mmc_host		*host;		/* the host this device belongs to */
 	struct device		dev;		/* the device */
-	u32			ocr;		/* the current OCR setting */
 	unsigned int		rca;		/* relative card address of device */
 	unsigned int		type;		/* card type */
 #define MMC_TYPE_MMC		0		/* MMC card */
@@ -257,11 +249,14 @@ struct mmc_card {
 	unsigned int		state;		/* (our) card state */
 #define MMC_STATE_PRESENT	(1<<0)		/* present in sysfs */
 #define MMC_STATE_READONLY	(1<<1)		/* card is read-only */
-#define MMC_STATE_BLOCKADDR	(1<<2)		/* card uses block-addressing */
-#define MMC_CARD_SDXC		(1<<3)		/* card is SDXC */
-#define MMC_CARD_REMOVED	(1<<4)		/* card has been removed */
-#define MMC_STATE_DOING_BKOPS	(1<<5)		/* card is doing BKOPS */
-#define MMC_STATE_SUSPENDED	(1<<6)		/* card is suspended */
+#define MMC_STATE_HIGHSPEED	(1<<2)		/* card is in high speed mode */
+#define MMC_STATE_BLOCKADDR	(1<<3)		/* card uses block-addressing */
+#define MMC_STATE_HIGHSPEED_DDR (1<<4)		/* card is in high speed mode */
+#define MMC_STATE_ULTRAHIGHSPEED (1<<5)		/* card is in ultra high speed mode */
+#define MMC_CARD_SDXC		(1<<6)		/* card is SDXC */
+#define MMC_CARD_REMOVED	(1<<7)		/* card has been removed */
+#define MMC_STATE_HIGHSPEED_200	(1<<8)		/* card is in HS200 mode */
+#define MMC_STATE_DOING_BKOPS	(1<<10)		/* card is doing BKOPS */
 	unsigned int		quirks; 	/* card quirks */
 #define MMC_QUIRK_LENIENT_FN0	(1<<0)		/* allow SDIO FN0 writes outside of the VS CCCR range */
 #define MMC_QUIRK_BLKSZ_FOR_BYTE_MODE (1<<1)	/* use func->cur_blksize */
@@ -274,11 +269,9 @@ struct mmc_card {
 #define MMC_QUIRK_INAND_CMD38	(1<<6)		/* iNAND devices have broken CMD38 */
 #define MMC_QUIRK_BLK_NO_CMD23	(1<<7)		/* Avoid CMD23 for regular multiblock */
 #define MMC_QUIRK_BROKEN_BYTE_MODE_512 (1<<8)	/* Avoid sending 512 bytes in */
-						/* byte mode */
 #define MMC_QUIRK_LONG_READ_TIME (1<<9)		/* Data read time > CSD says */
 #define MMC_QUIRK_SEC_ERASE_TRIM_BROKEN (1<<10)	/* Skip secure for erase/trim */
-#define MMC_QUIRK_BROKEN_IRQ_POLLING	(1<<11)	/* Polling SDIO_CCCR_INTx could create a fake interrupt */
-#define MMC_QUIRK_NO_TUNING_IN_SLEEP	(1<<12) /* no tuning before sdio card is wakeup */
+						/* byte mode */
 
 	unsigned int		erase_size;	/* erase size in sectors */
  	unsigned int		erase_shift;	/* if erase unit is power 2 */
@@ -305,7 +298,6 @@ struct mmc_card {
 	struct sdio_func_tuple	*tuples;	/* unknown common tuples */
 
 	unsigned int		sd_bus_speed;	/* Bus Speed Mode set for the card */
-	unsigned int		mmc_avail_type;	/* supported device type by both host and card */
 
 	struct dentry		*debugfs_root;
 	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */
@@ -423,21 +415,28 @@ static inline void __maybe_unused remove_quirk(struct mmc_card *card, int data)
 
 #define mmc_card_present(c)	((c)->state & MMC_STATE_PRESENT)
 #define mmc_card_readonly(c)	((c)->state & MMC_STATE_READONLY)
+#define mmc_card_highspeed(c)	((c)->state & MMC_STATE_HIGHSPEED)
+#define mmc_card_hs200(c)	((c)->state & MMC_STATE_HIGHSPEED_200)
 #define mmc_card_blockaddr(c)	((c)->state & MMC_STATE_BLOCKADDR)
+#define mmc_card_ddr_mode(c)	((c)->state & MMC_STATE_HIGHSPEED_DDR)
+#define mmc_card_uhs(c)		((c)->state & MMC_STATE_ULTRAHIGHSPEED)
+#define mmc_sd_card_uhs(c)	((c)->state & MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_ext_capacity(c) ((c)->state & MMC_CARD_SDXC)
 #define mmc_card_removed(c)	((c) && ((c)->state & MMC_CARD_REMOVED))
 #define mmc_card_doing_bkops(c)	((c)->state & MMC_STATE_DOING_BKOPS)
-#define mmc_card_suspended(c)	((c)->state & MMC_STATE_SUSPENDED)
 
 #define mmc_card_set_present(c)	((c)->state |= MMC_STATE_PRESENT)
 #define mmc_card_set_readonly(c) ((c)->state |= MMC_STATE_READONLY)
+#define mmc_card_set_highspeed(c) ((c)->state |= MMC_STATE_HIGHSPEED)
+#define mmc_card_set_hs200(c)	((c)->state |= MMC_STATE_HIGHSPEED_200)
 #define mmc_card_set_blockaddr(c) ((c)->state |= MMC_STATE_BLOCKADDR)
+#define mmc_card_set_ddr_mode(c) ((c)->state |= MMC_STATE_HIGHSPEED_DDR)
+#define mmc_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
+#define mmc_sd_card_set_uhs(c) ((c)->state |= MMC_STATE_ULTRAHIGHSPEED)
 #define mmc_card_set_ext_capacity(c) ((c)->state |= MMC_CARD_SDXC)
 #define mmc_card_set_removed(c) ((c)->state |= MMC_CARD_REMOVED)
 #define mmc_card_set_doing_bkops(c)	((c)->state |= MMC_STATE_DOING_BKOPS)
 #define mmc_card_clr_doing_bkops(c)	((c)->state &= ~MMC_STATE_DOING_BKOPS)
-#define mmc_card_set_suspended(c) ((c)->state |= MMC_STATE_SUSPENDED)
-#define mmc_card_clr_suspended(c) ((c)->state &= ~MMC_STATE_SUSPENDED)
 
 /*
  * Quirk add/remove for MMC products.
@@ -503,11 +502,6 @@ static inline int mmc_card_long_read_time(const struct mmc_card *c)
 	return c->quirks & MMC_QUIRK_LONG_READ_TIME;
 }
 
-static inline int mmc_card_broken_irq_polling(const struct mmc_card *c)
-{
-	return c->quirks & MMC_QUIRK_BROKEN_IRQ_POLLING;
-}
-
 #define mmc_card_name(c)	((c)->cid.prod_name)
 #define mmc_card_id(c)		(dev_name(&(c)->dev))
 
diff --git a/include/linux/mmc/core.h b/include/linux/mmc/core.h
index 3a07de3..da51bec 100644
--- a/include/linux/mmc/core.h
+++ b/include/linux/mmc/core.h
@@ -40,8 +40,6 @@ struct mmc_command {
 #define MMC_RSP_SPI_B4	(1 << 9)		/* four data bytes */
 #define MMC_RSP_SPI_BUSY (1 << 10)		/* card may send busy */
 
-#define MMC_SKIP_TUNING (1 << 11)		/* skip tuning for this cmd */
-
 /*
  * These are the native response types, and correspond to valid bit
  * patterns of the above flags.  One additional valid pattern
@@ -129,10 +127,8 @@ struct mmc_data {
 
 struct mmc_host;
 struct mmc_request {
-	struct mmc_command	*precmd;
+	struct mmc_command	*sbc;		/* SET_BLOCK_COUNT for multiblock */
 	struct mmc_command	*cmd;
-	struct mmc_command	*postcmd;
-	struct mmc_command	*cmd2;
 	struct mmc_data		*data;
 	struct mmc_command	*stop;
 
@@ -148,7 +144,6 @@ extern int mmc_stop_bkops(struct mmc_card *);
 extern int mmc_read_bkops_status(struct mmc_card *);
 extern struct mmc_async_req *mmc_start_req(struct mmc_host *,
 					   struct mmc_async_req *, int *);
-extern int mmc_execute_cmdq(struct mmc_host *, struct mmc_async_req *, int *);
 extern int mmc_interrupt_hpi(struct mmc_card *);
 extern void mmc_wait_for_req(struct mmc_host *, struct mmc_request *);
 extern int mmc_wait_for_cmd(struct mmc_host *, struct mmc_command *, int);
@@ -156,8 +151,7 @@ extern int mmc_app_cmd(struct mmc_host *, struct mmc_card *);
 extern int mmc_wait_for_app_cmd(struct mmc_host *, struct mmc_card *,
 	struct mmc_command *, int);
 extern void mmc_start_bkops(struct mmc_card *card, bool from_exception);
-extern int __mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int, bool,
-			bool);
+extern int __mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int, bool);
 extern int mmc_switch(struct mmc_card *, u8, u8, u8, unsigned int);
 extern int mmc_send_ext_csd(struct mmc_card *card, u8 *ext_csd);
 
@@ -194,6 +188,7 @@ extern unsigned int mmc_align_data_size(struct mmc_card *, unsigned int);
 
 extern int __mmc_claim_host(struct mmc_host *host, atomic_t *abort);
 extern void mmc_release_host(struct mmc_host *host);
+extern int mmc_try_claim_host(struct mmc_host *host);
 
 extern void mmc_get_card(struct mmc_card *card);
 extern void mmc_put_card(struct mmc_card *card);
@@ -217,6 +212,4 @@ struct device_node;
 extern u32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max);
 extern int mmc_of_parse_voltage(struct device_node *np, u32 *mask);
 
-extern int mmc_busy_wait(struct mmc_host *host);
-
 #endif /* LINUX_MMC_CORE_H */
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 18304d5..98e6516 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -15,10 +15,8 @@
 #include <linux/sched.h>
 #include <linux/device.h>
 #include <linux/fault-inject.h>
-#include <linux/pm_qos.h>
 
 #include <linux/mmc/core.h>
-#include <linux/mmc/card.h>
 #include <linux/mmc/pm.h>
 
 struct mmc_ios {
@@ -60,9 +58,13 @@ struct mmc_ios {
 #define MMC_TIMING_UHS_SDR50	5
 #define MMC_TIMING_UHS_SDR104	6
 #define MMC_TIMING_UHS_DDR50	7
-#define MMC_TIMING_MMC_DDR52	8
-#define MMC_TIMING_MMC_HS200	9
-#define MMC_TIMING_MMC_HS400	10
+#define MMC_TIMING_MMC_HS200	8
+
+#define MMC_SDR_MODE		0
+#define MMC_1_2V_DDR_MODE	1
+#define MMC_1_8V_DDR_MODE	2
+#define MMC_1_2V_SDR_MODE	3
+#define MMC_1_8V_SDR_MODE	4
 
 	unsigned char	signal_voltage;		/* signalling voltage (1.8V or 3.3V) */
 
@@ -134,9 +136,6 @@ struct mmc_host_ops {
 
 	/* The tuning command opcode value is different for SD and eMMC cards */
 	int	(*execute_tuning)(struct mmc_host *host, u32 opcode);
-
-	/* Prepare HS400 target operating frequency depending host driver */
-	int	(*prepare_hs400_tuning)(struct mmc_host *host, struct mmc_ios *ios);
 	int	(*select_drive_strength)(unsigned int max_dtr, int host_drv, int card_drv);
 	void	(*hw_reset)(struct mmc_host *host);
 	void	(*card_event)(struct mmc_host *host);
@@ -148,7 +147,6 @@ struct device;
 struct mmc_async_req {
 	/* active mmc request */
 	struct mmc_request	*mrq;
-	bool	success;
 	/*
 	 * Check error status of completed mmc request.
 	 * Returns 0 if success otherwise non zero.
@@ -186,9 +184,6 @@ struct mmc_context_info {
 	bool			is_done_rcv;
 	bool			is_new_req;
 	bool			is_waiting_last_req;
-	bool			is_last_cmdq;
-	bool			is_cmdq_busy;
-	bool			is_pending_cmdq;
 	wait_queue_head_t	wait;
 	spinlock_t		lock;
 };
@@ -323,6 +318,7 @@ struct mmc_host {
 	spinlock_t		lock;		/* lock for claim and bus ops */
 
 	struct mmc_ios		ios;		/* current io bus settings */
+	u32			ocr;		/* the current OCR setting */
 
 	/* group bitfields together to minimize padding */
 	unsigned int		use_spi_crc:1;
@@ -375,17 +371,6 @@ struct mmc_host {
 
 	unsigned int		slotno;	/* used for sdio acpi binding */
 
-#ifdef CONFIG_MMC_EMBEDDED_SDIO
-	struct {
-		struct sdio_cis			*cis;
-		struct sdio_cccr		*cccr;
-		struct sdio_embedded_func	*funcs;
-		int				num_funcs;
-	} embedded_sdio_data;
-#endif
-
-	struct pm_qos_request *qos;
-
 	unsigned long		private[0] ____cacheline_aligned;
 };
 
@@ -395,14 +380,6 @@ void mmc_remove_host(struct mmc_host *);
 void mmc_free_host(struct mmc_host *);
 int mmc_of_parse(struct mmc_host *host);
 
-#ifdef CONFIG_MMC_EMBEDDED_SDIO
-extern void mmc_set_embedded_sdio_data(struct mmc_host *host,
-				       struct sdio_cis *cis,
-				       struct sdio_cccr *cccr,
-				       struct sdio_embedded_func *funcs,
-				       int num_funcs);
-#endif
-
 static inline void *mmc_priv(struct mmc_host *host)
 {
 	return (void *)host->private;
@@ -519,32 +496,4 @@ static inline unsigned int mmc_host_clk_rate(struct mmc_host *host)
 	return host->ios.clock;
 }
 #endif
-
-static inline int mmc_card_hs(struct mmc_card *card)
-{
-	return card->host->ios.timing == MMC_TIMING_SD_HS ||
-		card->host->ios.timing == MMC_TIMING_MMC_HS;
-}
-
-static inline int mmc_card_uhs(struct mmc_card *card)
-{
-	return card->host->ios.timing >= MMC_TIMING_UHS_SDR12 &&
-		card->host->ios.timing <= MMC_TIMING_UHS_DDR50;
-}
-
-static inline bool mmc_card_hs200(struct mmc_card *card)
-{
-	return card->host->ios.timing == MMC_TIMING_MMC_HS200;
-}
-
-static inline bool mmc_card_ddr52(struct mmc_card *card)
-{
-	return card->host->ios.timing == MMC_TIMING_MMC_DDR52;
-}
-
-static inline bool mmc_card_hs400(struct mmc_card *card)
-{
-	return card->host->ios.timing == MMC_TIMING_MMC_HS400;
-}
-
 #endif /* LINUX_MMC_HOST_H */
diff --git a/include/linux/mmc/mmc.h b/include/linux/mmc/mmc.h
index 655dc30..6515cc75 100644
--- a/include/linux/mmc/mmc.h
+++ b/include/linux/mmc/mmc.h
@@ -84,25 +84,12 @@
 #define MMC_APP_CMD              55   /* ac   [31:16] RCA        R1  */
 #define MMC_GEN_CMD              56   /* adtc [0] RD/WR          R1  */
 
-/* class 11 */
-#define MMC_QUE_TASK_PARAMS	44	/* ac R1 */
-#define MMC_QUE_TASK_ADDR	45	/* ac R1 */
-#define MMC_EXECUTE_READ_TASK	46	/* adtc R1 */
-#define MMC_EXECUTE_WRITE_TASK	47	/* adtc R1 */
-#define MMC_DISCARD_CMDQ	48	/* ac R1B */
-
 static inline bool mmc_op_multi(u32 opcode)
 {
 	return opcode == MMC_WRITE_MULTIPLE_BLOCK ||
 	       opcode == MMC_READ_MULTIPLE_BLOCK;
 }
 
-static inline bool mmc_op_cmdq_execute_task(u32 opcode)
-{
-	return opcode == MMC_EXECUTE_READ_TASK ||
-		opcode == MMC_EXECUTE_WRITE_TASK;
-}
-
 /*
  * MMC_SWITCH argument format:
  *
@@ -285,7 +272,6 @@ struct _mmc_csd {
  * EXT_CSD fields
  */
 
-#define EXT_CSD_CMDQ_MODE_EN		15	/* R/W/E_P */
 #define EXT_CSD_FLUSH_CACHE		32      /* W */
 #define EXT_CSD_CACHE_CTRL		33      /* R/W */
 #define EXT_CSD_POWER_OFF_NOTIFICATION	34	/* R/W */
@@ -295,7 +281,6 @@ struct _mmc_csd {
 #define EXT_CSD_EXP_EVENTS_CTRL		56	/* R/W, 2 bytes */
 #define EXT_CSD_DATA_SECTOR_SIZE	61	/* R */
 #define EXT_CSD_GP_SIZE_MULT		143	/* R/W */
-#define EXT_CSD_PART_SET_COMPLETE	155	/* R/W */
 #define EXT_CSD_PARTITION_ATTRIBUTE	156	/* R/W */
 #define EXT_CSD_PARTITION_SUPPORT	160	/* RO */
 #define EXT_CSD_HPI_MGMT		161	/* R/W */
@@ -340,9 +325,6 @@ struct _mmc_csd {
 #define EXT_CSD_POWER_OFF_LONG_TIME	247	/* RO */
 #define EXT_CSD_GENERIC_CMD6_TIME	248	/* RO */
 #define EXT_CSD_CACHE_SIZE		249	/* RO, 4 bytes */
-#define EXT_CSD_PWR_CL_DDR_200_360	253	/* RO */
-#define EXT_CSD_CMDQ_SUPPORT		308	/* RO */
-#define EXT_CSD_CMDQ_DEPTH		307	/* RO */
 #define EXT_CSD_TAG_UNIT_SIZE		498	/* RO */
 #define EXT_CSD_DATA_TAG_SUPPORT	499	/* RO */
 #define EXT_CSD_MAX_PACKED_WRITES	500	/* RO */
@@ -373,25 +355,18 @@ struct _mmc_csd {
 #define EXT_CSD_CMD_SET_SECURE		(1<<1)
 #define EXT_CSD_CMD_SET_CPSECURE	(1<<2)
 
-#define EXT_CSD_CARD_TYPE_HS_26	(1<<0)	/* Card can run at 26MHz */
-#define EXT_CSD_CARD_TYPE_HS_52	(1<<1)	/* Card can run at 52MHz */
-#define EXT_CSD_CARD_TYPE_HS	(EXT_CSD_CARD_TYPE_HS_26 | \
-				 EXT_CSD_CARD_TYPE_HS_52)
+#define EXT_CSD_CARD_TYPE_26	(1<<0)	/* Card can run at 26MHz */
+#define EXT_CSD_CARD_TYPE_52	(1<<1)	/* Card can run at 52MHz */
+#define EXT_CSD_CARD_TYPE_MASK	0x3F	/* Mask out reserved bits */
 #define EXT_CSD_CARD_TYPE_DDR_1_8V  (1<<2)   /* Card can run at 52MHz */
 					     /* DDR mode @1.8V or 3V I/O */
 #define EXT_CSD_CARD_TYPE_DDR_1_2V  (1<<3)   /* Card can run at 52MHz */
 					     /* DDR mode @1.2V I/O */
 #define EXT_CSD_CARD_TYPE_DDR_52       (EXT_CSD_CARD_TYPE_DDR_1_8V  \
 					| EXT_CSD_CARD_TYPE_DDR_1_2V)
-#define EXT_CSD_CARD_TYPE_HS200_1_8V	(1<<4)	/* Card can run at 200MHz */
-#define EXT_CSD_CARD_TYPE_HS200_1_2V	(1<<5)	/* Card can run at 200MHz */
+#define EXT_CSD_CARD_TYPE_SDR_1_8V	(1<<4)	/* Card can run at 200MHz */
+#define EXT_CSD_CARD_TYPE_SDR_1_2V	(1<<5)	/* Card can run at 200MHz */
 						/* SDR mode @1.2V I/O */
-#define EXT_CSD_CARD_TYPE_HS200		(EXT_CSD_CARD_TYPE_HS200_1_8V | \
-					 EXT_CSD_CARD_TYPE_HS200_1_2V)
-#define EXT_CSD_CARD_TYPE_HS400_1_8V	(1<<6)	/* Card can run at 200MHz DDR, 1.8V */
-#define EXT_CSD_CARD_TYPE_HS400_1_2V	(1<<7)	/* Card can run at 200MHz DDR, 1.2V */
-#define EXT_CSD_CARD_TYPE_HS400		(EXT_CSD_CARD_TYPE_HS400_1_8V | \
-					 EXT_CSD_CARD_TYPE_HS400_1_2V)
 
 #define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
@@ -399,11 +374,6 @@ struct _mmc_csd {
 #define EXT_CSD_DDR_BUS_WIDTH_4	5	/* Card is in 4 bit DDR mode */
 #define EXT_CSD_DDR_BUS_WIDTH_8	6	/* Card is in 8 bit DDR mode */
 
-#define EXT_CSD_TIMING_BC	0	/* Backwards compatility */
-#define EXT_CSD_TIMING_HS	1	/* High speed */
-#define EXT_CSD_TIMING_HS200	2	/* HS200 */
-#define EXT_CSD_TIMING_HS400	3	/* HS400 */
-
 #define EXT_CSD_SEC_ER_EN	BIT(0)
 #define EXT_CSD_SEC_BD_BLK_EN	BIT(2)
 #define EXT_CSD_SEC_GB_CL_EN	BIT(4)
@@ -440,10 +410,6 @@ struct _mmc_csd {
  */
 #define EXT_CSD_BKOPS_LEVEL_2		0x2
 
-/* CMDQ enable level */
-#define EXT_CSD_CMDQ_MODE_OFF		0
-#define EXT_CSD_CMDQ_MODE_ON		1
-
 /*
  * MMC_SWITCH access modes
  */
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index ecc1235..6020d39 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -161,7 +161,6 @@ struct sdhci_host {
 	struct mmc_command *cmd;	/* Current command */
 	struct mmc_data *data;	/* Current data request */
 	unsigned int data_early:1;	/* Data finished before cmd */
-	unsigned int busy_handle:1;	/* Handling the order of Busy-end */
 
 	struct sg_mapping_iter sg_miter;	/* SG state for PIO */
 	unsigned int blocks;	/* remaining PIO blocks */
@@ -176,7 +175,6 @@ struct sdhci_host {
 
 	struct tasklet_struct card_tasklet;	/* Tasklet structures */
 	struct tasklet_struct finish_tasklet;
-	struct tasklet_struct finish_async_data_tasklet;
 
 	struct timer_list timer;	/* Timer for timeouts */
 
diff --git a/include/linux/mmc/sdio_ids.h b/include/linux/mmc/sdio_ids.h
index d883662..9f03fee 100644
--- a/include/linux/mmc/sdio_ids.h
+++ b/include/linux/mmc/sdio_ids.h
@@ -23,15 +23,6 @@
 /*
  * Vendors and devices.  Sort key: vendor first, device next.
  */
-#define SDIO_VENDOR_ID_BROADCOM			0x02d0
-#define SDIO_DEVICE_ID_BROADCOM_43143		43143
-#define SDIO_DEVICE_ID_BROADCOM_43241		0x4324
-#define SDIO_DEVICE_ID_BROADCOM_4329		0x4329
-#define SDIO_DEVICE_ID_BROADCOM_4330		0x4330
-#define SDIO_DEVICE_ID_BROADCOM_4334		0x4334
-#define SDIO_DEVICE_ID_BROADCOM_4335_4339	0x4335
-#define SDIO_DEVICE_ID_BROADCOM_43362		43362
-
 #define SDIO_VENDOR_ID_INTEL			0x0089
 #define SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX	0x1402
 #define SDIO_DEVICE_ID_INTEL_IWMC3200WIFI	0x1403
diff --git a/include/linux/wakelock.h b/include/linux/wakelock.h
deleted file mode 100644
index f4a698a..0000000
--- a/include/linux/wakelock.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/* include/linux/wakelock.h
- *
- * Copyright (C) 2007-2012 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifndef _LINUX_WAKELOCK_H
-#define _LINUX_WAKELOCK_H
-
-#include <linux/ktime.h>
-#include <linux/device.h>
-
-/* A wake_lock prevents the system from entering suspend or other low power
- * states when active. If the type is set to WAKE_LOCK_SUSPEND, the wake_lock
- * prevents a full system suspend.
- */
-
-enum {
-	WAKE_LOCK_SUSPEND, /* Prevent suspend */
-	WAKE_LOCK_TYPE_COUNT
-};
-
-struct wake_lock {
-	struct wakeup_source ws;
-};
-
-static inline void wake_lock_init(struct wake_lock *lock, int type,
-				  const char *name)
-{
-	wakeup_source_init(&lock->ws, name);
-}
-
-static inline void wake_lock_destroy(struct wake_lock *lock)
-{
-	wakeup_source_trash(&lock->ws);
-}
-
-static inline void wake_lock(struct wake_lock *lock)
-{
-	__pm_stay_awake(&lock->ws);
-}
-
-static inline void wake_lock_timeout(struct wake_lock *lock, long timeout)
-{
-	__pm_wakeup_event(&lock->ws, jiffies_to_msecs(timeout));
-}
-
-static inline void wake_unlock(struct wake_lock *lock)
-{
-	__pm_relax(&lock->ws);
-}
-
-static inline int wake_lock_active(struct wake_lock *lock)
-{
-	return lock->ws.active;
-}
-
-#endif
diff --git a/include/trace/events/mmc.h b/include/trace/events/mmc.h
deleted file mode 100644
index 82b368d..0000000
--- a/include/trace/events/mmc.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (C) 2013 Google, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#undef TRACE_SYSTEM
-#define TRACE_SYSTEM mmc
-
-#if !defined(_TRACE_MMC_H) || defined(TRACE_HEADER_MULTI_READ)
-#define _TRACE_MMC_H
-
-#include <linux/tracepoint.h>
-#include <linux/mmc/mmc.h>
-#include <linux/mmc/core.h>
-
-/*
- * Unconditional logging of mmc block erase operations,
- * including cmd, address, size
- */
-DECLARE_EVENT_CLASS(mmc_blk_erase_class,
-	TP_PROTO(unsigned int cmd, unsigned int addr, unsigned int size),
-	TP_ARGS(cmd, addr, size),
-	TP_STRUCT__entry(
-		__field(unsigned int, cmd)
-		__field(unsigned int, addr)
-		__field(unsigned int, size)
-	),
-	TP_fast_assign(
-		__entry->cmd = cmd;
-		__entry->addr = addr;
-		__entry->size = size;
-	),
-	TP_printk("cmd=%u,addr=0x%08x,size=0x%08x",
-		  __entry->cmd, __entry->addr, __entry->size)
-);
-
-DEFINE_EVENT(mmc_blk_erase_class, mmc_blk_erase_start,
-	TP_PROTO(unsigned int cmd, unsigned int addr, unsigned int size),
-	TP_ARGS(cmd, addr, size));
-
-DEFINE_EVENT(mmc_blk_erase_class, mmc_blk_erase_end,
-	TP_PROTO(unsigned int cmd, unsigned int addr, unsigned int size),
-	TP_ARGS(cmd, addr, size));
-
-/*
- * Logging of start of read or write mmc block operation,
- * including cmd, address, size
- */
-DECLARE_EVENT_CLASS(mmc_blk_rw_class,
-	TP_PROTO(unsigned int cmd, unsigned int addr, struct mmc_data *data),
-	TP_ARGS(cmd, addr, data),
-	TP_STRUCT__entry(
-		__field(unsigned int, cmd)
-		__field(unsigned int, addr)
-		__field(unsigned int, size)
-	),
-	TP_fast_assign(
-		__entry->cmd = cmd;
-		__entry->addr = addr;
-		__entry->size = data->blocks;
-	),
-	TP_printk("cmd=%u,addr=0x%08x,size=0x%08x",
-		  __entry->cmd, __entry->addr, __entry->size)
-);
-
-DEFINE_EVENT_CONDITION(mmc_blk_rw_class, mmc_blk_rw_start,
-	TP_PROTO(unsigned int cmd, unsigned int addr, struct mmc_data *data),
-	TP_ARGS(cmd, addr, data),
-	TP_CONDITION(((cmd == MMC_READ_MULTIPLE_BLOCK) ||
-		      (cmd == MMC_WRITE_MULTIPLE_BLOCK)) &&
-		      data));
-
-DEFINE_EVENT_CONDITION(mmc_blk_rw_class, mmc_blk_rw_end,
-	TP_PROTO(unsigned int cmd, unsigned int addr, struct mmc_data *data),
-	TP_ARGS(cmd, addr, data),
-	TP_CONDITION(((cmd == MMC_READ_MULTIPLE_BLOCK) ||
-		      (cmd == MMC_WRITE_MULTIPLE_BLOCK)) &&
-		      data));
-#endif /* _TRACE_MMC_H */
-
-/* This part must be outside protection */
-#include <trace/define_trace.h>
-- 
2.10.1

