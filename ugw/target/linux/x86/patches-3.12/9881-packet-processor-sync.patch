diff -Naur a/arch/x86/Kconfig b/arch/x86/Kconfig
--- a/arch/x86/Kconfig	2017-10-11 10:16:36.249077000 +0530
+++ b/arch/x86/Kconfig	2017-10-11 09:35:36.668830000 +0530
@@ -457,52 +457,6 @@
         ---help---
           Exposes sysfs interface to get and set NET-IP subsystem attributes.
 
-config NETIP_SERVICES_ON_ATOM
-    bool "Net IP services controlled by Atom SW components"
-        depends on NET_SUBSYSTEM
-        ---help---
-          Enables including of Net IP services in configure message that are
-          running on Atom.
-
-
-#
-# WiFi Proxy network device driver configuration
-#
-
-menu "Intel Puma7 WiFi proxy support"
-config WIFI_PROXY
-        bool "WiFi proxy network device driver"
-        default n
-        depends on X86_PUMA7 && INTEL_KERNEL_PP_DRIVER_LOCAL
-        ---help---
-          If PP to WiFi devices communication is needed
-          then select yes.
-          else, select no.
-
-config WIFI_PROXY_DEBUG
-        bool "Enable WiFi proxy FW debugging"
-        default n
-        depends on WIFI_PROXY
-        ---help---
-          Enable WiFi proxy FW debugging
-
-config WIFI_PROXY_DEBUG_BUFF_SIZE
-        int "Debug buffer size, number of debug messages"
-        default 256
-        depends on WIFI_PROXY_DEBUG
-        ---help---
-          Configure extra shared memory for debugging, default 2MB for PUMA6_SOC, 512KB for PUMA5_SOC
-
-config WIFI_PROXY_EMULATOR
-        tristate "WiFi proxy emulator"
-        default n
-        depends on WIFI_PROXY_DEBUG
-        ---help---
-          If wifi proxy emulator is needed
-          then select yes.
-          else, select no.
-endmenu
-
 menu "Intel Puma7 LitePath Support"
     config PPA_PUMA7
        bool "Configures Partial Offload feature in LitePath"
@@ -513,27 +467,16 @@
           This feature turns on the LitePath support logic for
           WiFi Access Point driver that wishes to use Partial
           Offload feature.
-    config WIFI_MUX
-       tristate "Enable WiFi Mux driver."
-       depends on PPA_PUMA7
-       default n
-       ---help---
-          Builds WiFi Mux driver, which is interface between datapipe
-          and wifi litepath abstraction layer, used by datapipe driver to
-          bypass the first wifi packet from linux network stack thereby
-          reducing the load on host CPU.
-    config CONNECT_ADP_WIFI_MUX
-       bool "Connect Datapipe driver with Wifi Mux driver."
-       depends on WIFI_MUX
-       default n
-       ---help---
-          Register Datapipe driver with Wifi Mux driver. ADP driver
-          and WiFi Mux drivers are connected only when the Gateway
-          is on Atom CPU. This enables the Datapipe driver to register
-          callbacks that can be called from WiFi Mux driver to send
-          and receive network packets.
 endmenu
 
+config NET_SUBSYSTEM_SNOOPED_MODE
+    bool "Net IP controller support for HW managed cache coherency"
+        depends on NET_SUBSYSTEM
+        default n
+        ---help---
+          select this to enable net ip snooped mode - cache coherency
+          automatically managed by the net ip hw.
+
 config AVALANCHE_INTD_APPCPU
 	bool "avalance intd interrupt controller support for Intel CE2600 platform"
         depends on X86_PUMA7 || X86_PUMA6
@@ -549,21 +492,14 @@
 	  This is the cppi41 on appcpu support for Intel CE2600 platform.
 
 menu  "Intel PUMA7 AVALANCHE support"
-    config ARM_AVALANCHE_PDSP
-        bool "PDSP General Driver"
-        default y
-    config ARM_AVALANCHE_PDSP_PP
+		config ARM_AVALANCHE_PDSP
+			bool "PDSP General Driver"
+			default y
+		config ARM_AVALANCHE_PDSP_PP
         bool "TI Packet processor support for net-infra structure"
         depends on X86_PUMA7
-        depends on ARM_AVALANCHE_PDSP
-        default n
-    config INTEL_KERNEL_SKB_COOKIE
-        bool "Support Aggregated SKB Cookie"
-	depends on TI_PACKET_PROCESSOR
+				depends on ARM_AVALANCHE_PDSP
         default n
-        ---help---
-	  Allow support of the aggregated cookie inside SKB
-
     config X86_AVALANCHE_SOC
         bool "Packet processor data pipe support"
         depends on TI_PACKET_PROCESSOR
@@ -573,7 +509,6 @@
 	  X86_AVALANCHE_SOC implements packet processing features
 	  used by the Puma7 SoC.
 	  Package is part of the P7 platform packet processing capabilities.
-
 endmenu
 
 choice
diff -Naur a/arch/x86/NetIP_SubSystem/avalanche_intc.c b/arch/x86/NetIP_SubSystem/avalanche_intc.c
--- a/arch/x86/NetIP_SubSystem/avalanche_intc.c	2017-10-11 10:16:36.066068000 +0530
+++ b/arch/x86/NetIP_SubSystem/avalanche_intc.c	2017-10-11 09:35:36.459841000 +0530
@@ -95,6 +95,8 @@
     return((unsigned char )( irq / NUM_INTS_PER_REG ));
 }
 
+/*added newly*/
+
 int avalanche_intc_set_interrupt_type( unsigned int irq,
                                        unsigned char  int_type)
 {
diff -Naur a/arch/x86/NetIP_SubSystem/netip_mem_util.c b/arch/x86/NetIP_SubSystem/netip_mem_util.c
--- a/arch/x86/NetIP_SubSystem/netip_mem_util.c	2017-10-11 10:16:36.064062000 +0530
+++ b/arch/x86/NetIP_SubSystem/netip_mem_util.c	2017-10-11 09:35:36.454818000 +0530
@@ -66,10 +66,6 @@
 #include <asm/cacheflush.h>
 #include <linux/netip_mem_util.h>
 #include <linux/netip_subsystem.h>
-#include <linux/avalanche/generic/cppi41_hw_mbox_if.h>
-#include <linux/avalanche/puma7/puma7_npcpu_appcpu_defs.h>
-#include <linux/hw_mbox_defs.h>
-#include <linux/hw_mailbox.h>
 #include "netip_subsystem_config.h"
 
 /*************************************************************************/
@@ -79,16 +75,9 @@
 
 /* following address are for debug use will be removed in final solution */
 /* After final solution following address range will go in exact map for descriptors in shared memory */
-
-/* MMIO information for Atom only configuration */
-#define NPCPU_DESCRIPTOR_MEM_BASE (0xFC00000)
-#define NPCPU_DESCRIPTOR_MEM_SIZE (0xBF00000 - 0x100000)
-
-static phys_addr_t npcpu_descriptor_physical_mem_base;
-static size_t npcpu_descriptor_physical_mem_size;
-static void *npcpu_descriptor_virtual_mem_base;
-
-#define NPCPU_DESCRIPTOR_MAX_PHYSICAL_MEM_SIZE  (0x10000000)
+#define NPCPU_DESCRIPTOR_PHYSICAL_MEM_BASE  0xFC00000
+#define NPCPU_DESCRIPTOR_PHYSICAL_MEM_SIZE  (0xBF00000 - 0x100000)
+void *NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE = NULL;
 
 struct netip_mem_rgion_device {
     netss_dev_t subdevice;
@@ -99,30 +88,6 @@
     char* name;
 };
 
-struct netip_mem_rgion_cppi_bPool {
-    void *virtual_base_address;
-    bool ioremapped;
-    size_t npcpu_pool_physical_mem_size;
-    phys_addr_t npcpu_pool_physical_mem_base;
-    char* name;
-};
-
-static struct netip_mem_rgion_cppi_bPool mem_util_cppi_bPool[] =
-{
-    {NULL, false, 0, 0, "PAL_CPPI_PP_SHARED_RX_LOW_512B_BUFFER_POOL"},
-    {NULL, false, 0, 0, "PAL_CPPI_PP_SHARED_RX_LOW_2KB_BUFFER_POOL"},
-    {NULL, false, 0, 0, "PAL_CPPI_PP_SHARED_RX_LOW_4KB_BUFFER_POOL"},
-    {NULL, false, 0, 0, "PAL_CPPI_PP_SHARED_RX_HIGH_BUFFER_POOL"},
-    {NULL, false, 0, 0, "PAL_CPPI_PP_WIFI_RX_POOL"},
-    {NULL, false, 0, 0, "PAL_CPPI_PP_WIFI_TX_POOL"},
-    {NULL, false, 0, 0, "PAL_CPPI_PP_BUFFER_POOL6"},
-    {NULL, false, 0, 0, "PAL_CPPI_PP_BUFFER_POOL7"},
-    {NULL, false, 0, 0, "PAL_CPPI_PP_BUFFER_POOL8"},
-    {NULL, false, 0, 0, "PAL_CPPI_PP_PACKET_RAM_512B_BUFFER_POOL"},
-    {NULL, false, 0, 0, "PAL_CPPI_PP_PACKET_RAM_2KB_BUFFER_POOL"},
-    {NULL, false, 0, 0, "PAL_CPPI_PP_VOICE_DSP_BUFFER_POOL"},
-};
-
 static struct netip_mem_rgion_device mem_util_dev[] =
 {
     {NETSS_DEV_PACKET_PROCESSOR1, NULL, false, 0xF3000000, NULL, "NETSS_DEV_PACKET_PROCESSOR1"},
@@ -146,199 +111,54 @@
     {NETSS_DEV_BOOT_RAM, NULL, false, 0xFFFF0000, NULL, "NETSS_DEV_BOOT_RAM"},
 };
 
-/**************** Local functions Declarations*****************/
-static void _netip_memmap_cleanup_bPools(void);
-/*************************************************************/
-
 int netip_memmap_init(void)
 {
-	int i, ret = 0, hw_mbox_ret = 0;
-	netss_dev_info_t mmio_dev_info;
-	u64 npcpu_rpc_phys_addr = 0;
-	u64 npcpu_rpc_mem_size = 0;
-	phys_addr_t max_phys_addr = 0;
-
-	Cppi41HwMboxOffChipMemInfoReplyMsg_t off_chip_reply;
-	size_t dataLen = sizeof(Cppi41HwMboxOffChipMemInfoReplyMsg_t);
-
-	if(!netss_driver_ready()) {
-		pr_err("netss driver is not ready!\n");
-		return -ENODEV;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(mem_util_dev); i++) {
-		if (mem_util_dev[i].ioremapped) {
-			/* Already mapped */
-			continue;
-		}
-		if (netss_device_get_info(mem_util_dev[i].subdevice,
-					 &mmio_dev_info)) {
-			pr_err("Get device info failed for region %s\n",
-					 mem_util_dev[i].name);
-			ret = -EINVAL;
-			continue;
-		}
-
-		mem_util_dev[i].arm_end_address =
-			mem_util_dev[i].arm_start_address + mmio_dev_info.size;
-		mem_util_dev[i].virtual_base_address =
-			ioremap_nocache(mmio_dev_info.base, mmio_dev_info.size);
-
-		if (mem_util_dev[i].virtual_base_address) {
-			mem_util_dev[i].ioremapped = true;
-		} else {
-			pr_err("ioremap failed for region %s\n",
-					mem_util_dev[i].name);
-			ret = -ENOMEM;
-		}
-	}
-
-	if (npcpu_descriptor_virtual_mem_base != NULL)
-	{
-		pr_info("netip_memmap_init: npcpu_descriptor_virtual_mem_base already mapped\n");
-		return 0;
-	}
-
-#ifdef CONFIG_NPCPU_HARDCODED_OFFCHIP_INFO
-	npcpu_descriptor_physical_mem_base = NPCPU_DESCRIPTOR_MEM_BASE;
-	npcpu_descriptor_physical_mem_size = NPCPU_DESCRIPTOR_MEM_SIZE;
-#else
-	pr_info("netip_memmap_init: Request offChip information from NPCPU\n");
-
-	/* Request offChip information from NPCPU */
-	off_chip_reply.cmd =
-		cpu_to_be32(CPPI41_HWMBOX_CMD_GET_OFFCHIP_MEM_INFO_REPLY);
-	off_chip_reply.length = 0;
-	off_chip_reply.off_chip_phy_addr = 0;
-
-	if(hwMbox_isReady()) {
-		pr_err("HW mailbox isn't ready yet.");
-		return -ENODEV;
-	}
-
-	hw_mbox_ret = hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU,
-			NPCPU_APPCPU_HW_MBOX_TAG_CPPI41_MBX,
-			(uint8_t *)&off_chip_reply,
-			dataLen,
-			dataLen,
-			&dataLen);
-	if(hw_mbox_ret) {
-		pr_err("HW mailbox hwMbox_sendOpcode failed (retCode =%d).",
-			hw_mbox_ret);
-		return -ECOMM;
-	}
-
-	npcpu_rpc_phys_addr = be32_to_cpu(off_chip_reply.off_chip_phy_addr);
-	npcpu_rpc_mem_size = be32_to_cpu(off_chip_reply.length);
-
-	max_phys_addr = sizeof(phys_addr_t) > 4 ? U64_MAX : U32_MAX;
-
-	if (!npcpu_rpc_phys_addr || !npcpu_rpc_mem_size  ||
-	    (npcpu_rpc_mem_size > NPCPU_DESCRIPTOR_MAX_PHYSICAL_MEM_SIZE) ||
-	    (npcpu_rpc_phys_addr > (max_phys_addr - npcpu_rpc_mem_size))) {
-		pr_err("Offchip info is out of bounds.");
-		return -EINVAL;
-	}
-	/* We can now absorb these addresses in their correct types */
-	npcpu_descriptor_physical_mem_base = npcpu_rpc_phys_addr;
-	npcpu_descriptor_physical_mem_size = npcpu_rpc_mem_size;
-
-	pr_info("netip_memmap_init: received offChip base addr %llx len 0x%zx\n",
-			npcpu_descriptor_physical_mem_base,
-			npcpu_descriptor_physical_mem_size);
-#endif
-
-	npcpu_descriptor_virtual_mem_base = ioremap_nocache(
-			npcpu_descriptor_physical_mem_base,
-			npcpu_descriptor_physical_mem_size);
-	if(!npcpu_descriptor_virtual_mem_base) {
-		pr_err("NPCPU_VIRTUAL_MEM_BASE IOREMAP error \n");
-		return -ENOMEM;
-	}
-
-	netss_bootcfg_init();
-#ifdef CONFIG_NET_SUBSYSTEM_SNOOPED_MODE
-	netss_enable_snooped_mode();
-#endif
-
-	return ret;
-}
-EXPORT_SYMBOL(netip_memmap_init);
-
-int netip_memmap_cppi_bPool(unsigned int pool)
-{
-    int ret = 0, hw_mbox_ret = 0;
-    u64 npcpu_rpc_phys_addr = 0;
-    u64 npcpu_rpc_mem_size = 0;
-    phys_addr_t max_phys_addr = 0;
-
-    Cppi41HwMboxCppiBpoolMemInfoGetMsg_t   off_chip_get;
-    Cppi41HwMboxCppiBpoolMemInfoReplyMsg_t *off_chip_reply;
+    int i, ret = 0;
+    netss_dev_info_t mmio_dev_info;
 
-    size_t dataLen = sizeof(Cppi41HwMboxCppiBpoolMemInfoGetMsg_t); // Size should be the same as Cppi41HwMboxCppiBpoolMemInfoReplyMsg_t
-
-    if (mem_util_cppi_bPool[pool].virtual_base_address != NULL)
-    {
-        pr_info("netip_memmap_cppi_bPool: virtual_mem_base of %s already mapped\n",
-                mem_util_cppi_bPool[pool].name);
-        return 0;
+    if(!netss_driver_ready()) {
+        pr_err("netss driver is not ready!\n");
+        return -1;
     }
-    /* Un-map other pools if mapped */
-    _netip_memmap_cleanup_bPools();
 
-    pr_info("netip_memmap_cppi_bPool: Request offChip bPool information from NPCPU\n");
-
-    /* Request offChip information from NPCPU */
-    off_chip_get.cmd = cpu_to_be32(CPPI41_HWMBOX_CMD_GET_BPOOL_MEM_INFO_REPLY);
-    off_chip_get.pool = cpu_to_be32(pool);
-
-    if(hwMbox_isReady()) {
-        pr_err("HW mailbox isn't ready yet.");
-        return -ENODEV;
-    }
+    for (i=0; i < ARRAY_SIZE(mem_util_dev); i++) {
+        if (mem_util_dev[i].ioremapped) {
+            /* Already mapped */
+            continue;
+        }
+        if (netss_device_get_info(mem_util_dev[i].subdevice, &mmio_dev_info)) {
+            pr_err("Get device info failed for region %s\n", mem_util_dev[i].name);
+            ret = -2;
+            continue;
+        }
 
-    hw_mbox_ret = hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU,
-            NPCPU_APPCPU_HW_MBOX_TAG_CPPI41_MBX,
-            (uint8_t *)&off_chip_get,
-            dataLen,
-            dataLen,
-            &dataLen);
-    if(hw_mbox_ret) {
-        pr_err("HW mailbox hwMbox_sendOpcode failed (retCode =%d).",
-            hw_mbox_ret);
-        return -ECOMM;
+        mem_util_dev[i].arm_end_address = mem_util_dev[i].arm_start_address + mmio_dev_info.size;
+        mem_util_dev[i].virtual_base_address = ioremap_nocache(mmio_dev_info.base, mmio_dev_info.size);
+        if (mem_util_dev[i].virtual_base_address) {
+                mem_util_dev[i].ioremapped = true;
+        } else {
+            pr_err("ioremap failed for region %s\n", mem_util_dev[i].name);
+            ret = -2;
+        }
     }
 
-    off_chip_reply = (Cppi41HwMboxCppiBpoolMemInfoReplyMsg_t*)(&off_chip_get); // The reply is recieved from HW mailbox
-
-    npcpu_rpc_phys_addr = be32_to_cpu(off_chip_reply->off_chip_phy_addr);
-    npcpu_rpc_mem_size = be32_to_cpu(off_chip_reply->length);
+    if (NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE != NULL)
+	return ret;
 
-    max_phys_addr = sizeof(phys_addr_t) > 4 ? U64_MAX : U32_MAX;
+    NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE = (void *)ioremap_nocache(NPCPU_DESCRIPTOR_PHYSICAL_MEM_BASE, NPCPU_DESCRIPTOR_PHYSICAL_MEM_SIZE);
+    if(!NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE) {
+        pr_err(" NPCPU_VIRTUAL_MEM_BASE IOREMAP  error \n");
+        return -2;
+    }
 
-    /* We can now absorb these addresses in their correct types */
+    netss_bootcfg_init();
+#ifdef CONFIG_NET_SUBSYSTEM_SNOOPED_MODE
+    netss_enable_snooped_mode();
+#endif
 
-    mem_util_cppi_bPool[pool].npcpu_pool_physical_mem_base = npcpu_rpc_phys_addr;
-    mem_util_cppi_bPool[pool].npcpu_pool_physical_mem_size = npcpu_rpc_mem_size;
-
-    pr_info("netip_memmap_cppi_bPool: received offChip base addr %llx len 0x%zx\n",
-            mem_util_cppi_bPool[pool].npcpu_pool_physical_mem_base,
-            mem_util_cppi_bPool[pool].npcpu_pool_physical_mem_size);
-    printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
-    printk("!!!!!!!!!!!!! Mapping %010dB chunk of memory for buffer pool %02d !!!!!!!!!!!!!\n",
-           mem_util_cppi_bPool[pool].npcpu_pool_physical_mem_size, pool);
-    printk("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
-    mem_util_cppi_bPool[pool].virtual_base_address = ioremap_nocache(
-            mem_util_cppi_bPool[pool].npcpu_pool_physical_mem_base,
-            mem_util_cppi_bPool[pool].npcpu_pool_physical_mem_size);
-    if(!mem_util_cppi_bPool[pool].virtual_base_address) {
-        pr_err("NPCPU_VIRTUAL_MEM_BASE IOREMAP error \n");
-        return -ENOMEM;
-    }
-    mem_util_cppi_bPool[pool].ioremapped = true;
     return ret;
 }
-EXPORT_SYMBOL(netip_memmap_cppi_bPool);
+EXPORT_SYMBOL(netip_memmap_init);
 
 void netip_memmap_cleanup(void)
 {
@@ -346,10 +166,10 @@
 
     pr_info("cleaningup mapped descriptor memory \n");
 
-    if(npcpu_descriptor_virtual_mem_base)
+    if(NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE)
     {
-        iounmap(npcpu_descriptor_virtual_mem_base);
-        npcpu_descriptor_virtual_mem_base = NULL;
+        iounmap(NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE);
+        NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE = NULL;
     }
     for (i=0; i < ARRAY_SIZE(mem_util_dev); i++) {
         if(mem_util_dev[i].ioremapped) {
@@ -358,72 +178,39 @@
             mem_util_dev[i].virtual_base_address = NULL;
         }
     }
-    _netip_memmap_cleanup_bPools();
 
 }
 EXPORT_SYMBOL(netip_memmap_cleanup);
 
-void netip_memmap_cleanup_bPools(void)
-{
-    _netip_memmap_cleanup_bPools();
-}
-EXPORT_SYMBOL(netip_memmap_cleanup_bPools);
-
 void *netip_mmio_to_virtual(unsigned long netip_phys_addr)
 {
-	unsigned long offset = 0;
-	int i;
+    unsigned long offset = 0;
+    int i;
 
-	if((netip_phys_addr >= npcpu_descriptor_physical_mem_base) &&
-	   (netip_phys_addr < (npcpu_descriptor_physical_mem_base +
-			       npcpu_descriptor_physical_mem_size))) {
-		offset = (netip_phys_addr - npcpu_descriptor_physical_mem_base);
-		pr_debug("netip_phys_addr=%lx virt_addr=%p offset=%lx\n",
-			netip_phys_addr,
-			npcpu_descriptor_virtual_mem_base + offset,
-			offset);
-		return (void *)(npcpu_descriptor_virtual_mem_base + offset);
-	}
-    for (i=0; i < ARRAY_SIZE(mem_util_cppi_bPool); i++)
-    {
-        if (!mem_util_cppi_bPool[i].ioremapped)
-            continue;
+    if( (netip_phys_addr >= NPCPU_DESCRIPTOR_PHYSICAL_MEM_BASE) && (netip_phys_addr < (NPCPU_DESCRIPTOR_PHYSICAL_MEM_BASE + NPCPU_DESCRIPTOR_PHYSICAL_MEM_SIZE))) {
+        offset = (netip_phys_addr - NPCPU_DESCRIPTOR_PHYSICAL_MEM_BASE);
+        pr_debug(" netip_phys_addr=%p virt_addr=%p offset=%x\n", netip_phys_addr, (NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE + offset), offset);
+        return (void *)(NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE + offset);
+    }
 
-        if (netip_phys_addr > mem_util_cppi_bPool[i].npcpu_pool_physical_mem_base + mem_util_cppi_bPool[i].npcpu_pool_physical_mem_size)
-            continue;
+    for (i=0; i < ARRAY_SIZE(mem_util_dev); i++) {
 
-        if (netip_phys_addr < mem_util_cppi_bPool[i].npcpu_pool_physical_mem_base)
+        if (!mem_util_dev[i].ioremapped)
             continue;
 
-        offset = netip_phys_addr - mem_util_cppi_bPool[i].npcpu_pool_physical_mem_base;
-
-        pr_debug("Physical to virtual (buffer pool) called netip_phys_addr=%p virt _addr=%p offset=%x\n",
-            netip_phys_addr, (mem_util_cppi_bPool[i].virtual_base_address + offset), offset);
+        if (netip_phys_addr > mem_util_dev[i].arm_end_address)
+            continue;
 
-        return (mem_util_cppi_bPool[i].virtual_base_address + offset);
+        if (netip_phys_addr < mem_util_dev[i].arm_start_address)
+            continue;
 
+        offset = netip_phys_addr - mem_util_dev[i].arm_start_address;
+        pr_debug("Physical to virtual called netip_phys_addr=%p virt _addr=%p offset=%x\n", netip_phys_addr, (mem_util_dev[i].virtual_base_address + offset), offset);
+        return (mem_util_dev[i].virtual_base_address + offset);
     }
-	for (i=0; i < ARRAY_SIZE(mem_util_dev); i++) {
-
-		if (!mem_util_dev[i].ioremapped)
-			continue;
-
-		if (netip_phys_addr > mem_util_dev[i].arm_end_address)
-			continue;
 
-		if (netip_phys_addr < mem_util_dev[i].arm_start_address)
-			continue;
-
-		offset = netip_phys_addr - mem_util_dev[i].arm_start_address;
-		pr_debug("Physical to virtual called netip_phys_addr=%p virt _addr=%p offset=%x\n",
-			netip_phys_addr,
-			(mem_util_dev[i].virtual_base_address + offset),
-			offset);
-		return (mem_util_dev[i].virtual_base_address + offset);
-	}
-
-	pr_debug("%s:%d: No region found for 0x%p, return as Kernel map instead\n", __func__, __LINE__, netip_phys_addr);
-	return phys_to_virt(netip_phys_addr);
+    pr_debug("%s:%d: No region found for 0x%p, return as Kernel map instead\n", __func__, __LINE__, netip_phys_addr);
+    return phys_to_virt(netip_phys_addr);
 }
 EXPORT_SYMBOL(netip_mmio_to_virtual);
 
@@ -432,31 +219,12 @@
     unsigned long offset = 0;
     int i;
 
-    if( (virt_addr >= npcpu_descriptor_virtual_mem_base) &&
-	(virt_addr < (npcpu_descriptor_virtual_mem_base +
-		      npcpu_descriptor_physical_mem_size))) {
-	offset = virt_addr - npcpu_descriptor_virtual_mem_base;
-	pr_debug("virt_addr=%p phys_addr=0x%llx offset=%lx\n",
-				virt_addr,
-				npcpu_descriptor_physical_mem_base + offset,
-				offset);
-        return (void*)(npcpu_descriptor_physical_mem_base + offset);
+    if( (virt_addr >= NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE) && (virt_addr < ((unsigned long)NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE + (unsigned long)NPCPU_DESCRIPTOR_PHYSICAL_MEM_SIZE))) {
+        offset = (virt_addr - NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE);
+        pr_debug("virt_addr=%p phys_addr=%p offset=%x\n",virt_addr,(NPCPU_DESCRIPTOR_PHYSICAL_MEM_BASE + offset),offset);
+        return (void*)(NPCPU_DESCRIPTOR_PHYSICAL_MEM_BASE + offset);
     }
-    for (i=0; i < ARRAY_SIZE(mem_util_cppi_bPool); i++)
-    {
-        if (!mem_util_cppi_bPool[i].ioremapped)
-            continue;
-
-        if (virt_addr > mem_util_cppi_bPool[i].virtual_base_address + mem_util_cppi_bPool[i].npcpu_pool_physical_mem_size)
-            continue;
 
-        if (virt_addr < mem_util_cppi_bPool[i].virtual_base_address)
-            continue;
-
-        offset = virt_addr - mem_util_cppi_bPool[i].virtual_base_address;
-        pr_debug("Virtual to physical (buffer pool called virtual address=%p phy_addr=%p  offset=%x\n", virt_addr, (mem_util_cppi_bPool[i].npcpu_pool_physical_mem_base + offset), offset);
-        return (mem_util_cppi_bPool[i].npcpu_pool_physical_mem_base + offset);
-    }
     for (i=0; i < ARRAY_SIZE(mem_util_dev); i++) {
 
         if (!mem_util_dev[i].ioremapped)
@@ -483,21 +251,3 @@
 	clflush_cache_range(bufptr, size);
 }
 EXPORT_SYMBOL(cache_flush_buffer);
-
-/* Un-map regions which were mapped for CPPI buffer pools*/
-static void _netip_memmap_cleanup_bPools(void)
-{
-    int i;
-
-    pr_info("cleaningup mapped buffer pools memory \n");
-
-    for (i=0; i < ARRAY_SIZE(mem_util_cppi_bPool); i++)
-    {
-        if(mem_util_cppi_bPool[i].ioremapped)
-        {
-            iounmap(mem_util_cppi_bPool[i].virtual_base_address);
-            mem_util_cppi_bPool[i].ioremapped = false;
-            mem_util_cppi_bPool[i].virtual_base_address = NULL;
-        }
-    }
-}
diff -Naur a/arch/x86/NetIP_SubSystem/netip_subsystem_config.c b/arch/x86/NetIP_SubSystem/netip_subsystem_config.c
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_config.c	2017-10-11 10:16:36.062074000 +0530
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_config.c	2017-10-11 09:35:36.452830000 +0530
@@ -31,7 +31,6 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include "netip_subsystem_defs.h"
-#include "netip_subsystem_config.h"
 
 #define NETSS_DEV_BOOTCFG_BASE    0xF00C0000
 #define NETSS_SILICON_STEPPING         0xFFFF3FF4
@@ -48,6 +47,8 @@
 #define DOCSIS_FUSE_1               (0x0148)
 #define DISABLE_IPSEC_BIT_OFFSET    (24)
 
+extern struct net_subsystem_drv_data *pnetss_drv_data;
+
 static bool snooped_en = false;
 static struct proc_dir_entry *g_netss_subsystem_proc_dir;
 
@@ -168,101 +169,96 @@
 }
 
 /* SATT configuration*/
-#define SATT_HOST_INDEX_MIN            (5)
-#define SATT_HOST_INDEX_MAX            (8)
+#define SATT_HOST_INDEX_MIN		(5)
+#define SATT_HOST_INDEX_MAX		(8)
 
-#define SATT_BASE_OFF                  (0x1000)
-#define SATT_SAP_SIZE_MAX              (32 << 21)
-#define SATT_N_ENTRY_OFF               (0x20)
+#define SATT_BASE_OFF			(0x1000)
+#define SATT_SAP_SIZE_MAX		(32 << 21)
+#define SATT_N_ENTRY_OFF		(0x20)
 
-#define SATT2_CTRL_BRG_BA_MSB_SHIFT    (8)
-#define SATT2_CTRL_BRG_BA_MSB_MASK     (0xF)
+#define SATT2_CTRL_BRG_BA_MSB_SHIFT	(8)
+#define SATT2_CTRL_BRG_BA_MSB_MASK	(0xF)
 
 /* target field in SATT_N ctrl register, shift, mask and val */
-#define SATT_NTARGET_IOSF_PRIMARY_VAL  (0x4)
-#define SATT_N_CTRL_TARGET_SHIFT       (0x1)
-#define SATT_N_CTRL_TARGET_MASK                (0x7)
+#define SATT_NTARGET_IOSF_PRIMARY_VAL	(0x4)
+#define SATT_N_CTRL_TARGET_SHIFT	(0x1)
+#define SATT_N_CTRL_TARGET_MASK		(0x7)
 
 /* SATT_N register offsets */
-#define SATT_N_CTRL_OFF                        (0x0)
-#define SATT_N_SAP_BA_OFF              (0x4)
-#define SATT_N_SAP_SIZE_OFF            (0x8)
-#define SATT_N_BRG_BA_OFF              (0xC)
+#define SATT_N_CTRL_OFF			(0x0)
+#define SATT_N_SAP_BA_OFF		(0x4)
+#define SATT_N_SAP_SIZE_OFF		(0x8)
+#define SATT_N_BRG_BA_OFF		(0xC)
 
 /* SATT_N register addresses */
-#define SATT_N_BASE(idx)               (SATT_BASE_OFF + ((idx) * SATT_N_ENTRY_OFF))
-#define SATT_N_CTRL(idx)               (SATT_N_BASE(idx) + SATT_N_CTRL_OFF)
-#define SATT_N_SAP_BA(idx)             (SATT_N_BASE(idx) + SATT_N_SAP_BA_OFF)
-#define SATT_N_SAP_SIZE(idx)           (SATT_N_BASE(idx) + SATT_N_SAP_SIZE_OFF)
-#define SATT_N_BRG_BA(idx)             (SATT_N_BASE(idx) + SATT_N_BRG_BA_OFF)
+#define SATT_N_BASE(idx)		(SATT_BASE_OFF + ((idx) * SATT_N_ENTRY_OFF))
+#define SATT_N_CTRL(idx)		(SATT_N_BASE(idx) + SATT_N_CTRL_OFF)
+#define SATT_N_SAP_BA(idx)		(SATT_N_BASE(idx) + SATT_N_SAP_BA_OFF)
+#define SATT_N_SAP_SIZE(idx)		(SATT_N_BASE(idx) + SATT_N_SAP_SIZE_OFF)
+#define SATT_N_BRG_BA(idx)		(SATT_N_BASE(idx) + SATT_N_BRG_BA_OFF)
 
 void netss_sattn_reg_write(unsigned long off, uint32_t val)
 {
-       __raw_writel(val, pnetss_drv_data->bridge_reg_base + off);
+	__raw_writel(val, pnetss_drv_data->bridge_reg_base + off);
 }
 
 uint32_t netss_sattn_reg_read(unsigned long off)
 {
-       return __raw_readl(pnetss_drv_data->bridge_reg_base + off);
+	return __raw_readl(pnetss_drv_data->bridge_reg_base + off);
 }
 
 int netss_sattn_iosf_prim_set(int idx, phys_addr_t brg_ba,
-                             uint32_t sap_size)
+			      uint32_t sap_size)
 {
-       uint32_t lo32 = lower_32_bits(brg_ba);
-       uint32_t hi32 = upper_32_bits(brg_ba);
-       uint32_t ctrl;
+	uint32_t lo32 = lower_32_bits(brg_ba);
+	uint32_t hi32 = upper_32_bits(brg_ba);
+	uint32_t ctrl;
 
-       if (!pnetss_drv_data->netss_driver_initialized)
-               return -EBUSY;
+	if (!pnetss_drv_data->netss_driver_initialized)
+		return -EBUSY;
 
-       /* ATOM cpu controls 4 entries */
-       if ((idx < SATT_HOST_INDEX_MIN) || (idx > SATT_HOST_INDEX_MAX))
-               return -EINVAL;
+	/* ATOM cpu controls 4 entries */
+	if ((idx < SATT_HOST_INDEX_MIN) || (idx > SATT_HOST_INDEX_MAX))
+		return -EINVAL;
 
-       /* SATT is limited to 36 Bits */
-       if (hi32 & ~0xF)
-               return -EINVAL;
+	/* SATT is limited to 36 Bits */
+	if (hi32 & ~0xF)
+		return -EINVAL;
 
-       /* SATT has to be 16Byte aligned */
-       if (lo32 & 0xF)
-               return -EINVAL;
+	/* SATT has to be 16Byte aligned */
+	if (lo32 & 0xF)
+		return -EINVAL;
 
-       /* SATT range has to be 4Bytes aligned */
-       if (sap_size & 0x3)
-               return -EINVAL;
+	/* SATT range has to be 4Bytes aligned */
+	if (sap_size & 0x3)
+		return -EINVAL;
 
-       /* SATT is limited to 64 MB range*/
-       if (sap_size > SATT_SAP_SIZE_MAX)
-               return -EINVAL;
+	/* SATT is limited to 32 MB range*/
+	if (sap_size > SATT_SAP_SIZE_MAX)
+		return -EINVAL;
 
-       ctrl = netss_sattn_reg_read(SATT_N_CTRL(idx));
+	ctrl = netss_sattn_reg_read(SATT_N_CTRL(idx));
 
-       ctrl &= ~(SATT2_CTRL_BRG_BA_MSB_MASK << SATT2_CTRL_BRG_BA_MSB_SHIFT);
-       ctrl |= hi32 << SATT2_CTRL_BRG_BA_MSB_SHIFT;
+	ctrl &= ~(SATT2_CTRL_BRG_BA_MSB_MASK << SATT2_CTRL_BRG_BA_MSB_SHIFT);
+	ctrl |= hi32 << SATT2_CTRL_BRG_BA_MSB_SHIFT;
 
-       ctrl &= ~(SATT_N_CTRL_TARGET_MASK << SATT_N_CTRL_TARGET_SHIFT);
-       ctrl |= (SATT_NTARGET_IOSF_PRIMARY_VAL << SATT_N_CTRL_TARGET_SHIFT);
+	ctrl &= ~(SATT_N_CTRL_TARGET_MASK << SATT_N_CTRL_TARGET_SHIFT);
+	ctrl |= (SATT_NTARGET_IOSF_PRIMARY_VAL << SATT_N_CTRL_TARGET_SHIFT);
 
-       netss_sattn_reg_write(SATT_N_SAP_SIZE(idx), sap_size);
-       netss_sattn_reg_write(SATT_N_BRG_BA(idx), lo32);
-       netss_sattn_reg_write(SATT_N_CTRL(idx), ctrl);
+	netss_sattn_reg_write(SATT_N_SAP_SIZE(idx), sap_size);
+	netss_sattn_reg_write(SATT_N_BRG_BA(idx), lo32);
+	netss_sattn_reg_write(SATT_N_CTRL(idx), ctrl);
 
-       return 0;
+	return 0;
 }
-
 EXPORT_SYMBOL(netss_sattn_iosf_prim_set);
 
 void netss_sattn_get(int idx, uint32_t *ctrl, uint32_t *sap_ba,
-                   uint32_t *sap_size, uint32_t *brg_ba)
+		    uint32_t *sap_size, uint32_t *brg_ba)
 {
-
-       BUG_ON(!ctrl || !sap_ba || !sap_size || !brg_ba);
-
-       *ctrl = netss_sattn_reg_read(SATT_N_CTRL(idx));
-       *sap_ba = netss_sattn_reg_read(SATT_N_SAP_BA(idx));
-       *sap_size = netss_sattn_reg_read(SATT_N_SAP_SIZE(idx));
-       *brg_ba = netss_sattn_reg_read(SATT_N_BRG_BA(idx));
+	*ctrl = netss_sattn_reg_read(SATT_N_CTRL(idx));
+	*sap_ba = netss_sattn_reg_read(SATT_N_SAP_BA(idx));
+	*sap_size = netss_sattn_reg_read(SATT_N_SAP_SIZE(idx));
+	*brg_ba = netss_sattn_reg_read(SATT_N_BRG_BA(idx));
 }
 EXPORT_SYMBOL(netss_sattn_get);
-
diff -Naur a/arch/x86/NetIP_SubSystem/netip_subsystem_config.h b/arch/x86/NetIP_SubSystem/netip_subsystem_config.h
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_config.h	2017-10-11 10:16:36.061068000 +0530
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_config.h	2017-10-11 09:35:36.451812000 +0530
@@ -32,6 +32,4 @@
 void netss_bootcfg_init(void);
 void netss_enable_snooped_mode(void);
 
-extern struct net_subsystem_drv_data *pnetss_drv_data;
-
 #endif
diff -Naur a/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c b/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c	2017-10-11 10:16:36.058063000 +0530
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c	2017-10-11 09:35:36.448812000 +0530
@@ -57,14 +57,8 @@
 #endif
 int docsis_chan_cfg = 0;
 int  cm_mode = 0;
-int RCE_Floor = 2;
+int RCE_Floor = 0;
 int RCE_Filter = 0;
-#ifdef CONFIG_NETIP_SERVICES_ON_ATOM
-bool sgmii0_on_atom = true;
-bool sgmii1_on_atom = true;
-bool rgmii2_on_atom = true;
-bool rgmii3_on_atom = true;
-#endif
 
 static const struct pci_device_id net_subsystem_pci_tbl[] = {
         { PCI_DEVICE( 0x8086, NET_SUBSYTEM_DEV_ID), .driver_data = 0 },
@@ -76,12 +70,6 @@
 module_param(cm_mode, int, (S_IRUSR | S_IWUSR ));
 module_param(RCE_Floor, int, (S_IRUSR | S_IWUSR ));
 module_param(RCE_Filter, int, (S_IRUSR | S_IWUSR ));
-#ifdef CONFIG_NETIP_SERVICES_ON_ATOM
-module_param(sgmii0_on_atom, bool, (S_IRUSR | S_IWUSR ));
-module_param(sgmii1_on_atom, bool, (S_IRUSR | S_IWUSR ));
-module_param(rgmii2_on_atom, bool, (S_IRUSR | S_IWUSR ));
-module_param(rgmii3_on_atom, bool, (S_IRUSR | S_IWUSR ));
-#endif
 
 MODULE_DEVICE_TABLE(pci, net_subsystem_pci_tbl);
 /*This function creates boot handshake thread */
@@ -101,27 +89,20 @@
    return ((unsigned char)(irq / NUM_ARM11_INTR_PER_REG));
 }
 
-static inline void __netss_interrupt_ack(netss_interrupt_t intrpt)
-{
-   __raw_writel((1<<intrpt), pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IIR_OFFSET);
-}
-
 void netss_interrupt_register(netss_interrupt_t intrpt, int arm11_int_id, netss_interrupt_info_t *irq_info)
 {
-   unsigned int reg_indx = 0;
-   unsigned int irq_bit  = 0;
-   unsigned long flags;
-   /*GBE does not register its ISR */
-   if(intrpt >= (NETSS_INTERUPT_MAX-1))
-   {
-      printk(KERN_WARNING "Registering for Invalid NETIP interrupt %d\n", intrpt);
-      return;
-   }
-
-   spin_lock_irqsave(&pnetss_drv_data->irq_lock, flags);
+    unsigned int reg_indx = 0;
+    unsigned int irq_bit  = 0;
 
-   if(intrpt != NETSS_INTERUPT_ARM11)
-   {
+    spin_lock(&pnetss_drv_data->irq_lock);
+    if(intrpt > NETSS_INTERUPT_MAX)
+    {
+        printk("Registering for Invalid NETIP interrupt %d\n", intrpt);
+        spin_unlock(&pnetss_drv_data->irq_lock);
+        return;
+    }
+    if(intrpt != NETSS_INTERUPT_ARM11)
+    {
         pnetss_drv_data->irqs[intrpt].func = irq_info->func;
         pnetss_drv_data->irqs[intrpt].args = irq_info->args;
     }
@@ -137,7 +118,7 @@
             if(pnetss_drv_data->pending_interrupts & (1<<intrpt))
             {
                 irq_info->func(pnetss_drv_data->irq_num, irq_info->args);
-                __netss_interrupt_ack(intrpt);
+                netss_interrupt_ack(intrpt);
                 pnetss_drv_data->pending_interrupts &= ~(1<<intrpt);
                 NETSS_DBG_PRINT("Cleared pending interrupt for device %d IIR %08x pending %08x\n", intrpt,
                                  __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IIR_OFFSET),
@@ -156,7 +137,7 @@
                  *For ARM11 interrupt bundle this might hvae got cleared by some other irq handle */
                 if( __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IIR_OFFSET) & (1<<intrpt))
                 {
-                    __netss_interrupt_ack(intrpt);
+                    netss_interrupt_ack(intrpt);
                 }
                 pnetss_drv_data->pending_arm11_interrupts[reg_indx] &= ~(1 << irq_bit);
                 NETSS_DBG_PRINT("Cleared pending interrupt for armm11 %d IIR %08x pending %08x\n", arm11_int_id,
@@ -165,7 +146,7 @@
             }
         }
     }
-    spin_unlock_irqrestore(&pnetss_drv_data->irq_lock, flags);
+    spin_unlock(&pnetss_drv_data->irq_lock);
 }
 
 EXPORT_SYMBOL(netss_interrupt_register);
@@ -355,11 +337,6 @@
          mmio->size = NETSS_DEV_BOOT_RAM_MMIO_SIZE;
          ret = 0;
       break;
-      case NETSS_DEV_PWM:
-         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_PWM_MMIO_OFFSET;
-         mmio->size = NETSS_DEV_PWM_MMIO_SIZE;
-         ret = 0;
-      break;
       default:
          ret = -1;
    }
@@ -363,14 +345,13 @@
 
 EXPORT_SYMBOL(netss_device_get_info);
 
-void __netss_interrupt_enable(netss_interrupt_t intrpt)
+void netss_interrupt_enable(netss_interrupt_t intrpt)
 {
-   if(intrpt >= NETSS_INTERUPT_MAX)
+   if(intrpt > NETSS_INTERUPT_MAX)
    {
-      printk(KERN_WARNING "Invalid NetIP interrupt %d\n", intrpt);
+      printk("Invalid NetIP interrupt %d\n", intrpt);
       return;
    }
-
    if(!(pnetss_drv_data->ier_reg & (1 << intrpt))) {
       pnetss_drv_data->ier_reg |= (1<<intrpt);
       __raw_writel(pnetss_drv_data->ier_reg, pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IER_OFFSET);
@@ -381,49 +362,16 @@
       __raw_writel(pnetss_drv_data->imr_reg, pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IMR_OFFSET);
       NETSS_DBG_PRINT(KERN_INFO "Unmasking NetIP subdevice %d IMR reg = %x\n", __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IMR_OFFSET));
    }
-
-}
-/* Exported temporarly for cppp driver */
-EXPORT_SYMBOL(__netss_interrupt_enable);
-
-/**************************************************************************/
-/*! \fn void netss_interrupt_enable(netss_interrupt_t intrpt)
- **************************************************************************
- *  \brief NetSS driver API to enable NET IP interrupts to be seen in NETIP
- *         bridge. This API should be only called while opening/loading
- *         or while resuming of the respective NetIP sub device driver
- *         module. This API should not be called from the sub device driver
- *         ISR and if it wants to switch to polling mode and wants to do
- *         disable/enable interrupts it should do that by disabling/enabling
- *         its source of interrupts.
- *  \param[in] intrpt - Enum netss_interrupt_t of NETIP interrupt. 
- *  \return void.
- **************************************************************************/
-void netss_interrupt_enable(netss_interrupt_t intrpt)
-{
-   unsigned long flags;
-
-   if(intrpt >= NETSS_INTERUPT_MAX)
-   {
-      printk(KERN_WARNING "Invalid NetIP interrupt %d\n", intrpt);
-      return;
-   }
-   spin_lock_irqsave(&pnetss_drv_data->irq_lock, flags);
-
-   __netss_interrupt_enable(intrpt);
-
-   spin_unlock_irqrestore(&pnetss_drv_data->irq_lock, flags);
 }
 EXPORT_SYMBOL(netss_interrupt_enable);
 
-void __netss_interrupt_disable(netss_interrupt_t intrpt)
+void netss_interrupt_disable(netss_interrupt_t intrpt)
 {
-   if(intrpt >= NETSS_INTERUPT_MAX)
+   if(intrpt > NETSS_INTERUPT_MAX)
    {
-      printk(KERN_WARNING "Invalid NetIP interrupt %d\n", intrpt);
+      printk("Invalid NetIP interrupt %d\n", intrpt);
       return;
    }
-   
    if(pnetss_drv_data->ier_reg & (1 << intrpt)) {
       pnetss_drv_data->ier_reg &= ~(1<<intrpt);
       __raw_writel(pnetss_drv_data->ier_reg, pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IER_OFFSET);
@@ -434,52 +382,19 @@
       __raw_writel(pnetss_drv_data->imr_reg, pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IMR_OFFSET);
       NETSS_DBG_PRINT(KERN_INFO "Masking NetIP subdevice %d IMR reg = %x\n", __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IMR_OFFSET));
    }
-
-}
-/* Exported temporarly for cppp driver */
-EXPORT_SYMBOL(__netss_interrupt_disable);
-
-/**************************************************************************/
-/*! \fn void netss_interrupt_disable(netss_interrupt_t intrpt)
- **************************************************************************
- *  \brief NetSS driver API to enable NET IP interrupts to be seen in NETIP
- *         bridge. This API should be only called while closing/unloading
- *         or while suspending of the respective NetIP sub device driver
- *         module. This API should not be called from the sub device driver
- *         ISR and if it wants to switch to polling mode and wants to do
- *         disable/enable interrupts it should do that by disabling/enabling
- *         its source of interrupts. 
- *  \param[in] intrpt - Enum netss_interrupt_t of NETIP interrupt. 
- *  \return void.
- **************************************************************************/
-void netss_interrupt_disable(netss_interrupt_t intrpt)
-{
-   unsigned long flags;
-
-   if(intrpt >= NETSS_INTERUPT_MAX)
-   {
-      printk(KERN_WARNING "Invalid NetIP interrupt %d\n", intrpt);
-      return;
-   }
-
-   spin_lock_irqsave(&pnetss_drv_data->irq_lock, flags);
-
-   __netss_interrupt_disable(intrpt);
-
-   spin_unlock_irqrestore(&pnetss_drv_data->irq_lock, flags);
 }
 EXPORT_SYMBOL(netss_interrupt_disable);
 
 void netss_interrupt_ack(netss_interrupt_t intrpt)
 {
-   if(intrpt >= NETSS_INTERUPT_MAX)
+   uint32_t reg_val;
+   if(intrpt > NETSS_INTERUPT_MAX)
    {
-      printk(KERN_WARNING "Invalid NetIP interrupt %d\n", intrpt);
+      printk("Invalid NetIP interrupt %d\n", intrpt);
       return;
    }
-
-   __netss_interrupt_ack(intrpt);
-
+   reg_val = __raw_readl(pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IIR_OFFSET);
+   __raw_writel((reg_val & (1<<intrpt)), pnetss_drv_data->bridge_reg_base + NETIP_BRIDGE_IIR_OFFSET);
 }
 EXPORT_SYMBOL(netss_interrupt_ack);
 
@@ -550,7 +465,7 @@
     }
     /* Acknowledge the interrupts that are processed */
     if(ack_intr != 0) {
-        __raw_writel(ack_intr, pnet_ss->bridge_reg_base + NETIP_BRIDGE_IIR_OFFSET);
+        __raw_writel(reg_val|ack_intr, pnet_ss->bridge_reg_base + NETIP_BRIDGE_IIR_OFFSET);
     }
 
     ret = IRQ_HANDLED;

diff -Naur a/arch/x86/NetIP_SubSystem/netip_subsystem_pm.c b/arch/x86/NetIP_SubSystem/netip_subsystem_pm.c
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_pm.c	2017-10-11 10:16:36.056062000 +0530
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_pm.c	2017-10-11 09:35:36.445833000 +0530
@@ -3,7 +3,7 @@
  *
  *  GPL LICENSE SUMMARY
  *
- *  Copyright(c) 2015-2017 Intel Corporation. All rights reserved.
+ *  Copyright(c) 2015-2016 Intel Corporation. All rights reserved.
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of version 2 of the GNU General Public License as
@@ -36,41 +36,23 @@
 #include <linux/netip_subsystem.h>
 #include <linux/delay.h>
 #include <linux/timer.h>
-#include <linux/byteorder/generic.h>
 #include "netip_subsystem_defs.h"
 #include "netip_subsystem_pm.h"
 #include "netip_subsystem_sysfs.h"
-#include <linux/netdevice.h>
-#include <acpi/acpi_bus.h>
-
-#define NETIP_CRU0_MOD_STATE_OFFSET (0)
-#define NETIP_CRU0_MOD_STATUS_OFFSET (4)
-#define NETIP_CRU0_ENABLE (3)
-
-#define NETIP_DEV_CLASS "NETIP_SUBSYSTEM"
-#define NETIP_DEV_NAME  "80862be9"
-#define PUMA_ACPI_NOTIFY_NETIP_HANDSHAKE_DONE 0xA4
 
+#define CLK_CTRL_CRU0_OFFSET (0)
 
 extern int docsis_chan_cfg;
 extern int cm_mode;
 extern int RCE_Floor;
 extern int RCE_Filter;
-#ifdef CONFIG_NETIP_SERVICES_ON_ATOM
-extern bool sgmii0_on_atom;
-extern bool sgmii1_on_atom;
-extern bool rgmii2_on_atom;
-extern bool rgmii3_on_atom;
-#endif
 
 void netss_sysfs_clean_up(uint32_t available_services);
 
 int __netss_set_service_level(uint32_t level);
 
-int netss_notify_netip_power_state_to_child_drivers(netss_power_state_t state);
 /*External variables */
 extern struct net_subsystem_drv_data *pnetss_drv_data;
-extern struct net_device *g_netss_netdev;
 
 #define NETSS_PM_PRINT(fmt, args...) \
 do { \
@@ -78,13 +60,11 @@
       printk(KERN_INFO fmt, ##args); \
 } while(0)
 
-#define IS_SERVICE_RESOURCE_TO_BE_CONTROLLED(id)  ( ( (id == NETSS_SERVICE_ID_EXSW) || \
-						      (id == NETSS_SERVICE_ID_SFP) || \
-                                                      (id == NETSS_SERVICE_ID_SGMII1_BARE) || \
-                                                      (id == NETSS_SERVICE_ID_ETHPHY) || \
-                                                      (id == NETSS_SERVICE_ID_RGMII3_BARE) || \
-                                                      (id == NETSS_SERVICE_ID_SGMII0_BARE) || \
-                                                      (id == NETSS_SERVICE_ID_RGMII2_BARE) ) ? 1 : 0)
+#define IS_SERVICE_RESOURCE_TO_BE_CONTROLLED(id)  ( ( (id == NETSS_SERVICE_ID_SGMII0) || \
+                                                      (id == NETSS_SERVICE_ID_SGMII1) || \
+                                                      (id == NETSS_SERVICE_ID_RGMII2) || \
+                                                      (id == NETSS_SERVICE_ID_RGMII3) || \
+                                                      (id == NETSS_SERVICE_ID_EXSW) ) ? 1 : 0)
 
 /** Global variables */
 netss_sysfs_attributes_info_t g_netss_sysfs_attributes_info;
@@ -145,14 +125,6 @@
 /**Need to notify once whether internal BBU is on or off */
 static bool g_acpi_notified_bbu_status = false;
 
-/* Forces not to send service request untill power manger
- * has set the service level */
-static bool g_service_level_initialized = false;
-
-/* Number of NetIP services on ATtom
- * Currently hard coding it for xGMII 4 interfaces */
-static int g_netip_services_on_atom = 4;
-
 /**
  * puma_netip_notify_state() - invoke to update the state of NETIP
  * @state: state of NETIP, 0 - Active, 1 - BBU, 2 - Standby, 3 - Deep standby
@@ -172,153 +144,20 @@
          Bits 28-31 do not represent a valid service.
          Bit 2 is unused.
          Bit 3 indicates on-battery status. */
-   g_netss_sysfs_attributes_info.service_status = 0xFFFFFFF3;
-   g_netss_sysfs_attributes_info.service_level = 0xFFFFFFF0;
+   g_netss_sysfs_attributes_info.service_status = 0xAFFFFFF3;
+   g_netss_sysfs_attributes_info.service_level = 0xAFFFFFF0;
    g_netss_sysfs_attributes_info.service_ready = 0x0;
-   g_netss_sysfs_attributes_info.port_mapping = 0xFFFFFFFF;
-}
-
-static uint8_t mapid_to_interfaceid(uint8_t map_id)
-{
-   int i = 0;
-   uint8_t interface_id = 0;
-   netss_sysfs_attributes_info_t *sysfs = &g_netss_sysfs_attributes_info;
-
-   for (i = 0; i < MAX_BOARD_INTERFACES; i++)
-   {
-      if ( map_id == ((sysfs->port_mapping >> (i*8)) & 0xFF))
-      {
-         NETSS_PM_PRINT("Match found at %d, map id %d\n", i, map_id);
-         break;
-      }
-   }
-
-   if (i == 0)
-   {
-      interface_id = NETSS_BRD_INTRFC_SGMII0;
-   }
-   else if (i == 1)
-   {
-      interface_id = NETSS_BRD_INTRFC_SGMII1;
-   }
-   else if (i == 2)
-   {
-      interface_id = NETSS_BRD_INTRFC_RGMII2;
-   }
-   else if (i == 3)
-   {
-      interface_id = NETSS_BRD_INTRFC_RGMII3;
-   }
-   NETSS_PM_PRINT("map id %d intrfc id %d i=%d\n", map_id, interface_id, i);
-   return interface_id;
-}
-
-/* port map ids shared between Arm's PM SRV and Atom's NetSS driver
-   NETSS_PORTMAP_BARE = 0,
-   NETSS_PORTMAP_EXSW = 1,
-   NETSS_PORTMAP_ETHPHY = 2,
-   NETSS_PORTMAP_SFP = 3
-*/
-static uint8_t get_interface_id(uint8_t service_id)
-{
-   uint8_t interface_id = 0;
-   switch (service_id)
-   {
-      case NETSS_SERVICE_ID_EXSW:
-         interface_id = mapid_to_interfaceid(NETSS_PORTMAP_EXSW);
-      break;
-      case NETSS_SERVICE_ID_SFP:
-         interface_id = mapid_to_interfaceid(NETSS_PORTMAP_SFP);
-      break;
-      case NETSS_SERVICE_ID_SGMII1_BARE:
-         interface_id = NETSS_BRD_INTRFC_SGMII1;
-      break;
-      case NETSS_SERVICE_ID_ETHPHY:
-         interface_id = mapid_to_interfaceid(NETSS_PORTMAP_ETHPHY);
-      break;
-      case NETSS_SERVICE_ID_RGMII3_BARE:
-         interface_id = NETSS_BRD_INTRFC_RGMII3;
-      break;
-      case NETSS_SERVICE_ID_SGMII0_BARE:
-         interface_id = NETSS_BRD_INTRFC_SGMII0;
-      break;
-      case NETSS_SERVICE_ID_RGMII2_BARE:
-         interface_id = NETSS_BRD_INTRFC_RGMII2;
-      break;
-      default:
-      break;
-   };
-   return interface_id;
-}
-static uint8_t map_id_to_service_id(uint8_t idx, uint8_t map_id)
-{
-   uint8_t service_id = 0;
-
-   if (map_id == NETSS_PORTMAP_BARE) {
-      if (idx == 0)
-         service_id = NETSS_SERVICE_ID_SGMII0_BARE;
-      else if (idx == 1)
-         service_id = NETSS_SERVICE_ID_SGMII1_BARE;
-      else if (idx == 2)
-         service_id = NETSS_SERVICE_ID_RGMII2_BARE;
-      else if (idx == 3)
-         service_id = NETSS_SERVICE_ID_RGMII3_BARE;
-   } else if (map_id == NETSS_PORTMAP_EXSW) {
-      service_id = NETSS_SERVICE_ID_EXSW;
-   } else if (map_id == NETSS_PORTMAP_ETHPHY) {
-      service_id = NETSS_SERVICE_ID_ETHPHY;
-   } else if (map_id == NETSS_PORTMAP_SFP) {
-      service_id = NETSS_SERVICE_ID_SFP;
-   }
-   return service_id;
-}
-
-/* port map ids shared between Arm's PM SRV and Atom's NetSS driver
-   NETSS_PORTMAP_BARE = 0,
-   NETSS_PORTMAP_EXSW = 1,
-   NETSS_PORTMAP_ETHPHY = 2,
-   NETSS_PORTMAP_SFP = 3
-*/
-static uint8_t get_service_id(uint8_t interface_id)
-{
-   uint8_t service_id = 0;
-   uint8_t map_id = 0;
-   netss_sysfs_attributes_info_t *sysfs = &g_netss_sysfs_attributes_info;
-   switch (interface_id)
-   {
-      case NETSS_BRD_INTRFC_SGMII0:
-        map_id = sysfs->port_mapping & 0xFF;
-        service_id = map_id_to_service_id(0, map_id);
-      break;
-      case NETSS_BRD_INTRFC_SGMII1:
-        map_id = (sysfs->port_mapping >> 8) & 0xFF;
-        service_id = map_id_to_service_id(1, map_id);
-      break;
-      case NETSS_BRD_INTRFC_RGMII2:
-        map_id = (sysfs->port_mapping >> 16) & 0xFF;
-        service_id = map_id_to_service_id(2, map_id);
-      break;
-      case NETSS_BRD_INTRFC_RGMII3:
-        map_id = (sysfs->port_mapping >> 24) & 0xFF;
-        service_id = map_id_to_service_id(3, map_id);
-      break;
-      default:
-      break;
-   }
-   NETSS_PM_PRINT("Interface id=%d Service ID=%d\n", interface_id, service_id);
-   return service_id;
 }
 
 static void netss_handle_resource_power_state(uint8_t service_id, uint8_t state)
 {
    struct acpi_object_list input;
    union acpi_object in_params[2];
-   int interface_id = (int)get_interface_id(service_id);
 
    input.count = 2;
    input.pointer = in_params;
    in_params[0].type = ACPI_TYPE_INTEGER;
-   in_params[0].integer.value = interface_id;
+   in_params[0].integer.value = service_id;
    in_params[1].type = ACPI_TYPE_INTEGER;
    in_params[1].integer.value = state;
    if(pnetss_drv_data->acpi_h == NULL)
@@ -328,12 +167,11 @@
    else
    {
       /** call ACPI function from here to power on/off of the resource associated with the service */
-      NETSS_PM_PRINT("Changing the resource power state of interface id %d service id %d state %d\n", interface_id, service_id, state);
+      NETSS_PM_PRINT("Changing the resource power state of service id %d state %d\n", service_id, state);
       acpi_evaluate_object(pnetss_drv_data->acpi_h, "SRPS", &input, NULL);
    }
    return;
 }
-
 static void netss_indicate_bbu_service_level(uint8_t level)
 {
    struct acpi_object_list input;
@@ -358,34 +196,6 @@
       }
    }
 }
-
-static void netss_send_port_mapping(uint32_t port_mapping)
-{
-   struct acpi_object_list input;
-   union acpi_object in_params[4];
-
-   input.count = 4;
-   input.pointer = in_params;
-   in_params[0].type = ACPI_TYPE_INTEGER;
-   in_params[0].integer.value = port_mapping & 0xFF;
-   in_params[1].type = ACPI_TYPE_INTEGER;
-   in_params[1].integer.value = (port_mapping >> 8) & 0xFF;
-   in_params[2].type = ACPI_TYPE_INTEGER;
-   in_params[2].integer.value = (port_mapping >> 16) & 0xFF;
-   in_params[3].type = ACPI_TYPE_INTEGER;
-   in_params[3].integer.value = (port_mapping >> 24) & 0xFF;
-   if(pnetss_drv_data->acpi_h == NULL)
-   {
-      printk("NetIP acpi handle is NULL \n");
-   }
-   else
-   {
-      /** Pass the port mapping to ACPI */
-      NETSS_PM_PRINT("Passing the port mapping to ACPI %08X\n", port_mapping);
-      acpi_evaluate_object(pnetss_drv_data->acpi_h, "gmap", &input, NULL);
-   }
-   return;
-}
 static void netss_pm_timeout_handler (unsigned long data)
 {
    printk("IT APPEARS THAT ATOM NOT RECEIVING MSGS FROM NETIP \n");
@@ -411,20 +221,14 @@
                               Uint8 *dataBuf, Uint32 dataLen,
                               Uint32 *token)
 {
-   int i = 0;
-   int ret = 0;
+   int i=0;
    char *msg_name = "unknown";
    mutex_lock(&pnetss_drv_data->netip_msg.lock);
    memcpy(pnetss_drv_data->netip_msg.payload, dataBuf, dataLen);
    pnetss_drv_data->netip_msg.len = dataLen;
    pnetss_drv_data->netip_msg.type = dataBuf[0];
    /*Wake up thread, cleanup sysfs attributes */
-   if(pnetss_drv_data->netip_msg.type == NETSS_OPCODE_PORT_MAPPING)
-   {
-      g_netip_msg = 4;
-      msg_name = "Port Mapping";
-   }
-   else if(pnetss_drv_data->netip_msg.type == NETSS_OPCODE_NETIP_PROPERTIES)
+   if(pnetss_drv_data->netip_msg.type == NETSS_OPCODE_NETIP_PROPERTIES)
    {
       g_netip_msg = 1;
       msg_name = "Properties";
@@ -439,10 +243,6 @@
       g_netip_msg = 3;
       msg_name = "Service Request Reply";
    }
-   else
-   {
-      ret = -1;
-   }
    NETSS_PM_PRINT("NetIP Msg recvd: %s\n", msg_name);
    for(i=0; i<dataLen; i++)
    {
@@ -456,7 +256,7 @@
 
    mutex_unlock(&pnetss_drv_data->netip_msg.lock);
    wake_up_all(&waitForNetIPMsgWQ);
-   return ret;
+   return 0;
 }
 
 static void netss_send_reply_ack(void)
@@ -478,35 +278,6 @@
    return;
 }
 
-/** Port Mapping message format
- * ---------------------------
- * |   Opcode - 4bytes       |
- * |-------------------------|
- * |-------------------------|
- * |port mapping indices     |
- * |IDX0  |IDX1  |IDX2 |IDX3 |
- * |-------------------------|
- * |-------------------------|
- * |           0             | 1, 2, 3 or 4 terminating bytes
- * |-------------------------|
- */
-static void ness_process_port_mapping_msg(void)
-{
-	uint8_t *data = (uint8_t  *)(&pnetss_drv_data->netip_msg.payload[4]);
-	netss_sysfs_attributes_info_t *sysfs = &g_netss_sysfs_attributes_info;
-	int i = 0;
-
-	sysfs->port_mapping = 0;
-	for (i = 0; i < MAX_BOARD_INTERFACES; i++)
-		sysfs->port_mapping |= data[i] << (i*8);
-
-	NETSS_PM_PRINT("Netss port mapping = %08X\n", sysfs->port_mapping);
-
-	netss_send_port_mapping(sysfs->port_mapping);
-
-	return;
-
-}
 /** NetIP properties message format
  * ---------------------------
  * |   Opcode - 4bytes       |
@@ -579,71 +350,34 @@
 {
    int i, j=0, ret;
    //uint32_t docsis_channels = 0xF0F00000; /*Mask indicating the channels numbers configured as docsis channels */
-   netss_configure_msg_t *cfg_msg;
-   uint8_t *msg;
+   netss_configure_msg_t cfg_msg;
+   uint8_t *msg= (uint8_t *)(&cfg_msg);
    uint32_t reply_len;
-   int msg_len;
-   int services_offset = sizeof(netss_configure_msg_t);
-   uint8_t service_id;
-
-   msg_len = sizeof(netss_configure_msg_t);
-
-#ifdef CONFIG_NETIP_SERVICES_ON_ATOM
-   msg_len += g_netip_services_on_atom;
-   msg_len = ((msg_len + 3) & ~3);
-#endif
-   cfg_msg = kzalloc(msg_len, GFP_KERNEL);
-   if(!cfg_msg)
-   {
-       printk(KERN_ERR "Failed to alloc memory for configure msg!\n");
-       return;
-   }
-   msg = (uint8_t *)cfg_msg;
-   cfg_msg->hdr.opcode = NETSS_OPCODE_CONFIGURE;
+
+   /*clear the message */
+   memset(&cfg_msg, 0, sizeof(netss_configure_msg_t));
+   cfg_msg.hdr.opcode = NETSS_OPCODE_CONFIGURE;
 
    /*These values should be read from platfom config files
     *for now writing some default values  */
    for(i=0; i < 32; i++)
    {
       if(docsis_chan_cfg & (1 << i)) {
-         cfg_msg->docsis_chan[j] = i+1;
+         cfg_msg.docsis_chan[j] = i+1;
          j++;
       }
    }
    /*Just write 0 to terminate the list */
    if(j < 32) {
-      cfg_msg->docsis_chan[j] = 0;
+      cfg_msg.docsis_chan[j] = 0;
    }
 
-   cfg_msg->cm_mode = cm_mode;
-   cfg_msg->RCE_floor = RCE_Floor;
-   cfg_msg->RCE_filter = RCE_Filter;
-
-#ifdef CONFIG_NETIP_SERVICES_ON_ATOM
-   msg += services_offset;
-
-   /**Get the service ID connected at sgmii0 */
-   service_id = get_service_id(NETSS_BRD_INTRFC_SGMII0);
-   if (sgmii0_on_atom && service_id)
-      *msg++ = service_id;
-   /**Get the service ID connected at sgmii1 */
-   service_id = get_service_id(NETSS_BRD_INTRFC_SGMII1);
-   if (sgmii1_on_atom && service_id)
-      *msg++ = service_id;
-   /**Get the service ID connected at rgmii2 */
-   service_id = get_service_id(NETSS_BRD_INTRFC_RGMII2);
-   if (rgmii2_on_atom && service_id)
-      *msg++ = service_id;
-   /**Get the service ID connected at rgmii3 */
-   service_id = get_service_id(NETSS_BRD_INTRFC_RGMII3);
-   if (rgmii3_on_atom && service_id)
-      *msg++ = service_id;
-
-   msg = (uint8_t *)cfg_msg;
-#endif
+   cfg_msg.cm_mode = cm_mode;
+   cfg_msg.RCE_floor = RCE_Floor;
+   cfg_msg.RCE_filter = RCE_Filter;
 
    NETSS_PM_PRINT("configure Msg:");
-   for(i=0; i<msg_len; i++)
+   for(i=0; i<sizeof(netss_configure_msg_t); i++)
    {
       if(i%4 == 0)
       {
@@ -652,12 +386,11 @@
       NETSS_PM_PRINT("%2x\t", msg[i]);
    }
    NETSS_PM_PRINT("\n============================\n");
-   ret = hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU, 0, (uint8_t*)cfg_msg, msg_len, msg_len, &reply_len);
+   ret = hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU, 0, (uint8_t*)&cfg_msg, sizeof(netss_configure_msg_t), sizeof(netss_configure_msg_t), &reply_len);
    if(ret)
    {
        printk(KERN_ERR "Send configure message failed ret %d \n", ret);
    }
-   kfree(cfg_msg);
    /**Add some debug message on success */
    return;
 }
@@ -768,23 +501,11 @@
    {
       NETSS_PM_PRINT("services_change requested = %X change complete %X service status = %X\n", g_netip_services_change_requested, g_netip_services_change_complete, sysfs_info->service_status);
    }
-
-   /*This part of the code updates the overall system state and should be exceuted on two condtions
-    *1. During boot, i.e before dual boot hand shake, after all the available service status are recieved
-    * and the service request replies received for all the ready services.
-    *2. After boot, i.e dual boot handshake, power manager might have requested state change in that
-    *case check if all change requests are completed with replies.
-    **/
-   if( (!g_netss_boot_handshake_done && (g_netip_services_status_received  == g_netip_services_available) &&
-                                        (g_netip_services_status_ready == g_netip_services_init_complete)) ||
+   /*If we have received service request replies for all the services we requested */
+   if( (!g_netss_boot_handshake_done && (g_netip_services_status_ready == g_netip_services_init_complete)) ||
        (g_netss_boot_handshake_done && (g_netip_services_change_complete == g_netip_services_change_requested)) )
    {
-      uint32_t temp = NETSS_POWER_LEVEL_ENABLE;
-      /**This is before dualboot handshake is done, system boot*/
-      if (g_current_netip_power_state != NETSS_POWER_LEVEL_INVALID)
-      {
-         temp = g_current_netip_power_state;
-      }
+      uint32_t temp = g_current_netip_power_state;
       g_current_netip_power_state = service_msg->netip_level;
 
       if(g_timer_created)
@@ -793,7 +514,6 @@
           * a service_request change initiated by user after dualboot handshake */
          del_timer_sync(&netss_pm_timer);
       }
-
       /**update the status vector with battery status */
       if(g_onBattery)
       {
@@ -810,34 +530,29 @@
       }
       if(g_current_netip_power_state == NETSS_POWER_LEVEL_DEEP_STANDBY)
       {
+#ifdef CONFIG_PM_RUNTIME
 	 /**We are not suspending meaning not clocking gating etc,  but doing a netip soft off */
-         if(sysfs_info->netip_soft_off)
-         {
-            /**Notify the NetIP power state to all child drivers */
-            netss_notify_netip_power_state_to_child_drivers(NETSS_NETIP_POWER_STATE_OFF);
+	 if(sysfs_info->netip_soft_off)
+	 {
 	    /**Indicate that netip_soft_off exectution is complete, as we got reply for all service requests */
-            sysfs_info->netip_soft_off = 0;
-            sysfs_notify(&g_netss_netdev->dev.kobj, NULL, "netip_soft_off");
-            /**Indicate that netip is in soft off state */
-            g_is_netip_in_soft_off_state = true;
+	    sysfs_info->netip_soft_off = 0;
+	    /**Indicate that netip is in soft off state */
+	    g_is_netip_in_soft_off_state = true;
 	 }
 	 else
 	 {
-#ifdef CONFIG_PM_RUNTIME
 	    /**Let the usage counter go to zero */
 	    pm_runtime_put(&pnetss_drv_data->dev->dev);
-#endif
 	 }
+#endif
       }
       else if (g_current_netip_power_state == NETSS_POWER_LEVEL_ENABLE && temp == NETSS_POWER_LEVEL_DEEP_STANDBY)
       {
-         /**NetIP came out of soft off state to active */
-         if(g_is_netip_in_soft_off_state)
+	 /**NetIP came out of soft off state to active */
+	 if(g_is_netip_in_soft_off_state)
 	 {
-            /**Notify the NetIP power state to all child drivers */
-            netss_notify_netip_power_state_to_child_drivers(NETSS_NETIP_POWER_STATE_ACTIVE);
-            g_is_netip_in_soft_off_state = false;
-         }
+	    g_is_netip_in_soft_off_state = false;
+	 }
       }
 
       if(temp < g_current_netip_power_state && g_current_netip_power_state != NETSS_POWER_LEVEL_DEEP_STANDBY)
@@ -888,18 +603,15 @@
 }
 
 
-static bool netss_request_for_service_level_change(int index, uint32_t level)
+static bool netss_request_for_service_level_change(int index)
 {
    bool add_service_to_msg = false;
    uint32_t service_mask = (1 << (index - 1));
-   uint32_t status = g_netss_sysfs_attributes_info.service_status;
    if(g_netip_services_status_ready & service_mask) {
       if(g_netss_boot_handshake_done)
          add_service_to_msg = !(g_netip_services_change_requested & service_mask);
       else
-         add_service_to_msg = !(g_netip_services_init_complete & service_mask) ||
-                               (NETSS_GET_SERVICE_POWER_LEVEL(index, status) !=
-                                NETSS_GET_SERVICE_POWER_LEVEL(index, level));
+         add_service_to_msg = !(g_netip_services_init_complete & service_mask);
    }
    return add_service_to_msg;
 }
@@ -926,12 +638,10 @@
  * |15:14|   6    | BBU     10 - Reserved      |
  * |17:16|   7    | Wifi    11 - Off           |
  * |19:18|   8    | ExSw                       |
- * |21:20|   9    | SFP                        |
- * |23:22|  10    | SGMII1_BARE                |
- * |25:24|  11    | ETHPHY                     |
- * |27:26|  12    | RGMII3_BARE                |
- * |29:28|  13    | SGMII0_BARE                |
- * |31:30|  14    | RGMII2_BARE                |
+ * |21:20|   9    | SGMII0                     |
+ * |23:22|  10    | SGMII1                     |
+ * |25:24|  11    | RGMII2                     |
+ * |27:26|  12    | RGMII3                     |
  * ---------------------------------------------
  */
 /** service request/reply message format
@@ -966,7 +676,6 @@
    netss_service_request_msg_t *service_msg = NULL;
    uint8_t *msg;
    uint32_t service_msg_len;
-   uint16_t service_count = 0;
 
    /*Need one service for null termination */
    service_msg_len = sizeof(netss_service_request_msg_t)+((g_num_netip_services_status_ready+1)*sizeof(netss_service_status_t));
@@ -991,13 +700,8 @@
       }
 
       for(i = NETSS_SERVICE_ID_DOCSIS; i < NETSS_SERVICE_ID_MAX; i++) {
-         if(netss_request_for_service_level_change(i, service_level)) {
+         if(netss_request_for_service_level_change(i)) {
             uint32_t level = NETSS_GET_SERVICE_POWER_LEVEL(i, service_level);
-            service_count++;
-            if (service_count > g_num_netip_services_status_ready) {
-               printk(KERN_ERR "Allocated memory for %d services only\n", g_num_netip_services_status_ready);
-               break;
-            }
             if(level == NETSS_SERVICE_POWER_LEVEL_RESERVED) {
                NETSS_PM_PRINT("ERROR Cannot set service id %d to level %d\n", i, NETSS_SERVICE_POWER_LEVEL_RESERVED);
             } else {
@@ -1123,13 +827,7 @@
       NETSS_PM_PRINT("Message from NetIP %d opcode %d \n", g_netip_msg, pnetss_drv_data->netip_msg.type);
       /*Acquire sysfs lock */
       mutex_lock(&g_netss_sysfs_attributes_info.lock);
-      if(pnetss_drv_data->netip_msg.type == NETSS_OPCODE_PORT_MAPPING) {
-         /*send reply*/
-         netss_send_reply_ack();
-         /*process netip properties message */
-         ness_process_port_mapping_msg();
-
-      } else if(pnetss_drv_data->netip_msg.type == NETSS_OPCODE_NETIP_PROPERTIES) {
+      if(pnetss_drv_data->netip_msg.type == NETSS_OPCODE_NETIP_PROPERTIES) {
          /*send reply*/
          netss_send_reply_ack();
          /*process netip properties message */
@@ -1147,7 +845,7 @@
          netss_send_reply_ack();
          /*process service status message */
          ness_process_service_status_msg();
-         if(!g_netip_service_request_reply_pending && g_service_level_initialized)
+         if(!g_netip_service_request_reply_pending)
          {
             /* send service request message */
             netss_send_service_request_msg(g_netss_sysfs_attributes_info.service_level);
@@ -1174,8 +872,6 @@
                if(g_netip_services_status_received  == g_netip_services_available)
                {
                   g_netss_boot_handshake_done = true;
-                  acpi_bus_generate_netlink_event(NETIP_DEV_CLASS, NETIP_DEV_NAME,
-					PUMA_ACPI_NOTIFY_NETIP_HANDSHAKE_DONE, 0);
 
                   printk("Dual boot handshake is done services available %08X init complete %08X\n", g_netip_services_available, g_netip_services_init_complete);
 #ifdef CONFIG_PM_RUNTIME
@@ -1183,10 +879,18 @@
                   /**Count is already one so dont increament */
                   //pm_runtime_get_noresume(&pnetss_drv_data->dev->dev);
 #endif
+                  if(g_onBattery)
+                  {
+                     puma_netip_notify_state(1);
+                  }
+                  else
+                  {
+                     puma_netip_notify_state(0);
+                  }
                }
                else
                {
-                  NETSS_PM_PRINT("Status of all services not recvd Available %X status recvd %X\n", g_netip_services_available, g_netip_services_status_received);
+                  NETSS_PM_PRINT("Status of all services not recvd Available %X status recvd %X\n", g_netip_services_status_received, g_netip_services_available);
                }
             }
          }
@@ -1269,9 +973,6 @@
 	case NETSS_BOOT_HANDSHAKE_DONE_ATTR:
 		value = g_netss_boot_handshake_done;
 		break;
-	case NETSS_PORT_MAPPING_ATTR:
-		value = g_netss_sysfs_attributes_info.port_mapping;
-		break;
 	default:
 		pr_err("Attempting to get an invalid attribute ID!\n");
 	}
@@ -1389,60 +1090,26 @@
 			 */
 			ret = netss_send_service_request_msg(level);
 		}
-	} else {
-		g_service_level_initialized = true;
-		/* If not even one service is ready,
-		 * netss_configure_and_setup_netip_services
-		 * will send the service request
-		 */
-		if (g_netip_services_status_ready)
-			ret = netss_send_service_request_msg(level);
+	} else if (g_netss_sysfs_attributes_info.netip_soft_off) {
+		ret = netss_send_service_request_msg(level);
 	}
 
 	return ret;
 }
 
-/** Enable NetIP when on == true, otherwisedisable */
-static int netss_modify_netip_cru_mod_state(bool on)
+int netss_turn_off_netip_clock(void)
 {
-   netss_dev_info_t netip_cru_mmio;
+   netss_dev_info_t clk_ctrl_mmio;
    int ret = 0;
-   int count = 0;
-   if(netss_device_get_info(NETSS_DEV_CLK_CTRL, &netip_cru_mmio)) {
-      printk(KERN_ALERT "Couldn't get NetIP CRU MMIO info!\n");
-      ret = -ENOMEM;
+   if(netss_device_get_info(NETSS_DEV_CLK_CTRL, &clk_ctrl_mmio)) {
+      printk(KERN_ALERT "Couldn't get clock Ctrl MMIO info!\n");
+      ret = -1;
    } else {
-      void __iomem *netip_cru_base = ioremap_nocache(netip_cru_mmio.base, netip_cru_mmio.size);
-      uint32_t reg_val;
-
-      if (NULL != netip_cru_base) {
-         reg_val = ioread32be(netip_cru_base + NETIP_CRU0_MOD_STATE_OFFSET);
-
-         if (on) {
-            reg_val |= NETIP_CRU0_ENABLE;
-         } else {
-            reg_val &= ~(NETIP_CRU0_ENABLE);
-         }
-         iowrite32be(reg_val, netip_cru_base + NETIP_CRU0_MOD_STATE_OFFSET);
-
-         if (on) {
-            reg_val = ioread32be(netip_cru_base + NETIP_CRU0_MOD_STATUS_OFFSET);
-            while ((reg_val & NETIP_CRU0_ENABLE) != NETIP_CRU0_ENABLE)
-            {
-               msleep(5);
-               reg_val = ioread32be(netip_cru_base + NETIP_CRU0_MOD_STATUS_OFFSET);
-               if (count > 1000) {
-                  ret = -EBUSY;
-                  printk(KERN_WARNING "NetIP clock not enabled in 5 sec cru0 stat= %08X\n", reg_val);
-                  break;
-               }
-               count++;
-            }
-         }
-         iounmap(netip_cru_base);
-      } else {
-         ret = -EFAULT;
-      }
+      void __iomem *clk_ctrl_base = (void __iomem *)ioremap_nocache(clk_ctrl_mmio.base, clk_ctrl_mmio.size);
+      uint32_t reg_val = __raw_readl(clk_ctrl_base + CLK_CTRL_CRU0_OFFSET);
+      reg_val &= ~(0x3);
+      __raw_writel(reg_val, clk_ctrl_base + CLK_CTRL_CRU0_OFFSET);
+      iounmap(clk_ctrl_base);
    }
    return ret;
 }
@@ -1529,8 +1196,15 @@
 
    if(!ret)
    {
-      /** 2. Disable NetIP */
-      netss_modify_netip_cru_mod_state(false);
+      /** 2. Turn off NetIP clock */
+      netss_turn_off_netip_clock();
+      /** Resume will be like a fresh boot for NETIP, which involues netip properties, configure messages */
+      /** Reset boot handshake variables */
+      g_netss_boot_handshake_done = false;
+      g_netip_services_available = 0;
+      g_netip_services_init_complete = 0;
+      g_netip_services_status_ready = 0;
+      g_netip_services_status_received = 0;
    }
 
    mutex_unlock(&g_netss_sysfs_attributes_info.lock);
@@ -1541,26 +1215,16 @@
 int netss_runtime_resume(struct device *dev)
 {
    struct pci_dev *pdev = to_pci_dev(dev);
-   int ret;
+   uint32_t level;
+   int ret = -1;
 
-   /** Enable NetIP */
-   ret = netss_modify_netip_cru_mod_state(true);
-   if (ret) {
-      return ret;
-   }
    mutex_lock(&g_netss_sysfs_attributes_info.lock);
 
-   /** Resume will be like a fresh boot for NETIP, which involues netip properties, configure messages */
-   /** Reset boot handshake variables */
-   g_netss_boot_handshake_done = 0;
-   g_netip_services_available = 0;
-   g_netip_services_init_complete = 0;
-   g_netip_services_status_ready = 0;
-   g_netip_services_status_received = 0;
-
    /**Notify the NetIP power state to all NetSS child drivers */
    ret = netss_notify_netip_power_state_to_child_drivers(NETSS_NETIP_POWER_STATE_ACTIVE);
 
+   level = g_netss_sysfs_attributes_info.service_level;
+   netss_send_service_request_msg(level);
    mutex_unlock(&g_netss_sysfs_attributes_info.lock);
    return ret;
 }
diff -Naur a/arch/x86/NetIP_SubSystem/netip_subsystem_pm.h b/arch/x86/NetIP_SubSystem/netip_subsystem_pm.h
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_pm.h	2017-10-11 10:16:36.055067000 +0530
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_pm.h	2017-10-11 09:35:36.443826000 +0530
@@ -35,7 +35,6 @@
 #define NETIP_PROPERTIES_MSG 1
 #define NETIP_STATUS_MSG 2
 #define NETIP_STATUS_REQUEST_REPLY 3
-#define MAX_BOARD_INTERFACES 4
 
 /**Bit position 3 in sysfs service level vector that indicates whether we are on Battery or not */
 #define NETSS_BIT_MASK_ON_BATTERY (8)
@@ -58,8 +57,7 @@
    NETSS_OPCODE_NETIP_PROPERTIES = 1,
    NETSS_OPCODE_SERVICE_STATUS = 2,
    NETSS_OPCODE_SERVICE_REQUEST_REPLY = 3,
-   NETSS_OPCODE_CONFIGURE = 4,         /** Tag used from ARM to ATOM msgs*/
-   NETSS_OPCODE_PORT_MAPPING = 4,      /** Tag used from ATOM to ARM msgs*/
+   NETSS_OPCODE_CONFIGURE = 4,
    NETSS_OPCODE_SERVICE_REQUEST = 5,
 }netss_opcodes_t;
 
@@ -89,22 +87,6 @@
    NETSS_SERVICE_STATUS_INITIALIZED
 }netss_service_status_type_t;
 
-enum netss_port_map_id
-{
-   NETSS_PORTMAP_BARE = 0,
-   NETSS_PORTMAP_EXSW = 1,
-   NETSS_PORTMAP_ETHPHY = 2,
-   NETSS_PORTMAP_SFP = 3,
-};
-
-enum netss_board_interface_id
-{
-   NETSS_BRD_INTRFC_SGMII0 = 9,
-   NETSS_BRD_INTRFC_SGMII1 = 8,
-   NETSS_BRD_INTRFC_RGMII2 = 11,
-   NETSS_BRD_INTRFC_RGMII3 = 12,
-};
-
 typedef struct netss_msg_info {
    uint32_t type;         /**Netip properties or service status msg */
    uint32_t len;          /**Payload length */
diff -Naur a/arch/x86/NetIP_SubSystem/netip_subsystem_sysfs.c b/arch/x86/NetIP_SubSystem/netip_subsystem_sysfs.c
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_sysfs.c	2017-10-11 10:16:36.054067000 +0530
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_sysfs.c	2017-10-11 09:35:36.441831000 +0530
@@ -56,7 +56,7 @@
 	dev->destructor = free_netdev;
 }
 
-struct net_device *g_netss_netdev = NULL;
+static struct net_device *g_netss_netdev;
 
 static ssize_t service_show(struct device *dev,
 			struct device_attribute *attr,
@@ -89,9 +89,6 @@
 	} else if (strncmp(attr->attr.name, "boot_handshake_done", 19) == 0) {
 		attribute_value = netss_get_attribute(
 					NETSS_BOOT_HANDSHAKE_DONE_ATTR, 0);
-	} else if (strncmp(attr->attr.name, "port_mapping", 12) == 0) {
-		attribute_value = netss_get_attribute(
-					NETSS_PORT_MAPPING_ATTR, 0);
 	} else {
 		ret = -EIO;
 	}
@@ -135,7 +132,6 @@
 static DEVICE_ATTR(enable_debug, S_IRUGO|S_IWUSR, service_show, service_store);
 static DEVICE_ATTR(netip_soft_off, S_IRUGO|S_IWUSR,
 			service_show, service_store);
-static DEVICE_ATTR(port_mapping, S_IRUGO, service_show, NULL);
 
 char *get_netss_service_name(int i)
 {
@@ -158,18 +154,14 @@
 		return "wifi";
 	case NETSS_SERVICE_ID_EXSW:
 		return "exSw";
-	case NETSS_SERVICE_ID_SFP:
-		return "sfp";
-	case NETSS_SERVICE_ID_SGMII1_BARE:
-		return "sgmii1_bare";
-	case NETSS_SERVICE_ID_ETHPHY:
-		return "ethphy";
-	case NETSS_SERVICE_ID_RGMII3_BARE:
-		return "rgmii3_bare";
-	case NETSS_SERVICE_ID_SGMII0_BARE:
-		return "sgmii0_bare";
-	case NETSS_SERVICE_ID_RGMII2_BARE:
-		return "rgmii2_bare";
+	case NETSS_SERVICE_ID_SGMII0:
+		return "sgmii0";
+	case NETSS_SERVICE_ID_SGMII1:
+		return "sgmii1";
+	case NETSS_SERVICE_ID_RGMII2:
+		return "rgmii2";
+	case NETSS_SERVICE_ID_RGMII3:
+		return "rgmii3";
 	default:
 		return "";
 	}
@@ -217,10 +209,6 @@
 			return ret;
 		ret = device_create_file(&g_netss_netdev->dev,
 					&dev_attr_boot_handshake_done);
-		if (ret < 0)
-			return ret;
-		ret = device_create_file(&g_netss_netdev->dev,
-					&dev_attr_port_mapping);
 	}
 	return ret;
 }
diff -Naur a/arch/x86/NetIP_SubSystem/netip_subsystem_sysfs.h b/arch/x86/NetIP_SubSystem/netip_subsystem_sysfs.h
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_sysfs.h	2017-10-11 10:16:36.060064000 +0530
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_sysfs.h	2017-10-11 09:35:36.449821000 +0530
@@ -39,7 +39,6 @@
 	NETSS_ENABLE_DEBUG_ATTR,
 	NETSS_SERVICE_READY_ATTR,
 	NETSS_BOOT_HANDSHAKE_DONE_ATTR,
-	NETSS_PORT_MAPPING_ATTR,
 } netss_attribute_id_t;
 
 /** Attributes structure */
@@ -66,12 +65,7 @@
 	updated by the services listed in NetIP properties message, the first
 	message received while handshake is done between cores.
 	This is read-only from user space. */
-
 	uint32_t service_available;
-	/** Vector that represents how the four network interfaces are conne
-	cted on the board.
-	This is read-only from user space. */
-	uint32_t port_mapping;
 	/** to synchronise between the thread that is writing to service_level
 	and thread that is sending message. This lock may be needed only during
 	boot time. */
diff -Naur a/arch/x86/avalanche_intd/Makefile b/arch/x86/avalanche_intd/Makefile
--- a/arch/x86/avalanche_intd/Makefile	2017-10-11 10:16:35.708053000 +0530
+++ b/arch/x86/avalanche_intd/Makefile	2017-10-11 09:35:36.058780000 +0530
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2016, Intel Corporation and its suppliers.
+# Copyright (c) 2011, Intel Corporation and its suppliers.
 #
 # This program is free software; you can redistribute it and/or modify it
 # under the terms and conditions of the GNU General Public License,
@@ -16,4 +16,3 @@
 #
 #
 obj-$(CONFIG_AVALANCHE_INTD_APPCPU) := avalanche_intd.o
-
diff -Naur a/arch/x86/configs/puma7-crash-kernel_defconfig b/arch/x86/configs/puma7-crash-kernel_defconfig
--- a/arch/x86/configs/puma7-crash-kernel_defconfig	2017-10-11 10:16:34.879968000 +0530
+++ b/arch/x86/configs/puma7-crash-kernel_defconfig	1970-01-01 05:30:00.000000000 +0530
@@ -1,2534 +0,0 @@
-#
-# Automatically generated file; DO NOT EDIT.
-# Linux/x86 3.12.59 Kernel Configuration
-#
-# CONFIG_64BIT is not set
-CONFIG_X86_32=y
-CONFIG_X86=y
-CONFIG_INSTRUCTION_DECODER=y
-CONFIG_OUTPUT_FORMAT="elf32-i386"
-CONFIG_ARCH_DEFCONFIG="arch/x86/configs/i386_defconfig"
-CONFIG_LOCKDEP_SUPPORT=y
-CONFIG_STACKTRACE_SUPPORT=y
-CONFIG_HAVE_LATENCYTOP_SUPPORT=y
-CONFIG_MMU=y
-CONFIG_NEED_SG_DMA_LENGTH=y
-CONFIG_GENERIC_ISA_DMA=y
-CONFIG_GENERIC_HWEIGHT=y
-CONFIG_ARCH_MAY_HAVE_PC_FDC=y
-CONFIG_RWSEM_XCHGADD_ALGORITHM=y
-CONFIG_GENERIC_CALIBRATE_DELAY=y
-CONFIG_ARCH_HAS_CPU_RELAX=y
-CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
-CONFIG_ARCH_HAS_CPU_AUTOPROBE=y
-CONFIG_HAVE_SETUP_PER_CPU_AREA=y
-CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
-CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
-CONFIG_ARCH_HIBERNATION_POSSIBLE=y
-CONFIG_ARCH_SUSPEND_POSSIBLE=y
-CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
-CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
-# CONFIG_ZONE_DMA32 is not set
-# CONFIG_AUDIT_ARCH is not set
-CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
-CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
-CONFIG_X86_32_SMP=y
-CONFIG_X86_HT=y
-CONFIG_ARCH_HWEIGHT_CFLAGS="-fcall-saved-ecx -fcall-saved-edx"
-CONFIG_ARCH_CPU_PROBE_RELEASE=y
-CONFIG_ARCH_SUPPORTS_UPROBES=y
-CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
-CONFIG_IRQ_WORK=y
-CONFIG_BUILDTIME_EXTABLE_SORT=y
-
-#
-# General setup
-#
-CONFIG_INIT_ENV_ARG_LIMIT=32
-CONFIG_CROSS_COMPILE=""
-# CONFIG_COMPILE_TEST is not set
-CONFIG_LOCALVERSION="-yocto-standard"
-CONFIG_LOCALVERSION_AUTO=y
-CONFIG_HAVE_KERNEL_GZIP=y
-CONFIG_HAVE_KERNEL_BZIP2=y
-CONFIG_HAVE_KERNEL_LZMA=y
-CONFIG_HAVE_KERNEL_XZ=y
-CONFIG_HAVE_KERNEL_LZO=y
-CONFIG_HAVE_KERNEL_LZ4=y
-# CONFIG_KERNEL_GZIP is not set
-# CONFIG_KERNEL_BZIP2 is not set
-CONFIG_KERNEL_LZMA=y
-# CONFIG_KERNEL_XZ is not set
-# CONFIG_KERNEL_LZO is not set
-# CONFIG_KERNEL_LZ4 is not set
-CONFIG_DEFAULT_HOSTNAME="localhost"
-# CONFIG_SWAP is not set
-CONFIG_SYSVIPC=y
-CONFIG_SYSVIPC_SYSCTL=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_POSIX_MQUEUE_SYSCTL=y
-CONFIG_FHANDLE=y
-# CONFIG_AUDIT is not set
-
-#
-# IRQ subsystem
-#
-CONFIG_GENERIC_IRQ_PROBE=y
-CONFIG_GENERIC_IRQ_SHOW=y
-CONFIG_GENERIC_PENDING_IRQ=y
-CONFIG_IRQ_DOMAIN=y
-CONFIG_IRQ_FORCED_THREADING=y
-CONFIG_SPARSE_IRQ=y
-CONFIG_CLOCKSOURCE_WATCHDOG=y
-CONFIG_KTIME_SCALAR=y
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
-CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
-CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
-CONFIG_GENERIC_CMOS_UPDATE=y
-
-#
-# Timers subsystem
-#
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ_COMMON=y
-# CONFIG_HZ_PERIODIC is not set
-CONFIG_NO_HZ_IDLE=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-
-#
-# CPU/Task time and stats accounting
-#
-CONFIG_TICK_CPU_ACCOUNTING=y
-# CONFIG_IRQ_TIME_ACCOUNTING is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
-# CONFIG_TASKSTATS is not set
-
-#
-# RCU Subsystem
-#
-CONFIG_TREE_PREEMPT_RCU=y
-CONFIG_PREEMPT_RCU=y
-CONFIG_RCU_STALL_COMMON=y
-CONFIG_RCU_FANOUT=32
-CONFIG_RCU_FANOUT_LEAF=16
-# CONFIG_RCU_FANOUT_EXACT is not set
-CONFIG_RCU_FAST_NO_HZ=y
-# CONFIG_TREE_RCU_TRACE is not set
-# CONFIG_RCU_BOOST is not set
-# CONFIG_RCU_NOCB_CPU is not set
-# CONFIG_IKCONFIG is not set
-CONFIG_LOG_BUF_SHIFT=18
-CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
-CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
-CONFIG_ARCH_WANTS_PROT_NUMA_PROT_NONE=y
-CONFIG_CGROUPS=y
-# CONFIG_CGROUP_DEBUG is not set
-CONFIG_CGROUP_FREEZER=y
-# CONFIG_CGROUP_DEVICE is not set
-CONFIG_CPUSETS=y
-CONFIG_PROC_PID_CPUSET=y
-CONFIG_CGROUP_CPUACCT=y
-CONFIG_RESOURCE_COUNTERS=y
-# CONFIG_MEMCG is not set
-# CONFIG_CGROUP_PERF is not set
-CONFIG_CGROUP_SCHED=y
-CONFIG_FAIR_GROUP_SCHED=y
-# CONFIG_CFS_BANDWIDTH is not set
-# CONFIG_RT_GROUP_SCHED is not set
-# CONFIG_BLK_CGROUP is not set
-# CONFIG_CHECKPOINT_RESTORE is not set
-# CONFIG_NAMESPACES is not set
-# CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
-CONFIG_SCHED_AUTOGROUP=y
-# CONFIG_SYSFS_DEPRECATED is not set
-CONFIG_RELAY=y
-CONFIG_BLK_DEV_INITRD=y
-CONFIG_INITRAMFS_SOURCE=""
-CONFIG_RD_GZIP=y
-# CONFIG_RD_BZIP2 is not set
-# CONFIG_RD_LZMA is not set
-# CONFIG_RD_XZ is not set
-# CONFIG_RD_LZO is not set
-# CONFIG_RD_LZ4 is not set
-CONFIG_CC_OPTIMIZE_FOR_SIZE=y
-CONFIG_SYSCTL=y
-CONFIG_ANON_INODES=y
-CONFIG_HAVE_UID16=y
-CONFIG_SYSCTL_EXCEPTION_TRACE=y
-CONFIG_HAVE_PCSPKR_PLATFORM=y
-CONFIG_EXPERT=y
-CONFIG_UID16=y
-# CONFIG_SYSCTL_SYSCALL is not set
-# CONFIG_KALLSYMS is not set
-# CONFIG_PRINTK is not set
-# CONFIG_BUG is not set
-CONFIG_ELF_CORE=y
-# CONFIG_PCSPKR_PLATFORM is not set
-# CONFIG_BASE_FULL is not set
-CONFIG_FUTEX=y
-CONFIG_EPOLL=y
-CONFIG_SIGNALFD=y
-CONFIG_TIMERFD=y
-CONFIG_EVENTFD=y
-CONFIG_SHMEM=y
-CONFIG_AIO=y
-CONFIG_PCI_QUIRKS=y
-# CONFIG_EMBEDDED is not set
-CONFIG_HAVE_PERF_EVENTS=y
-
-#
-# Kernel Performance Events And Counters
-#
-CONFIG_PERF_EVENTS=y
-# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
-# CONFIG_VM_EVENT_COUNTERS is not set
-# CONFIG_COMPAT_BRK is not set
-# CONFIG_SLAB is not set
-# CONFIG_SLUB is not set
-CONFIG_SLOB=y
-# CONFIG_PROFILING is not set
-CONFIG_HAVE_OPROFILE=y
-CONFIG_OPROFILE_NMI_TIMER=y
-# CONFIG_KPROBES is not set
-# CONFIG_JUMP_LABEL is not set
-# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
-CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
-CONFIG_ARCH_USE_BUILTIN_BSWAP=y
-CONFIG_HAVE_IOREMAP_PROT=y
-CONFIG_HAVE_KPROBES=y
-CONFIG_HAVE_KRETPROBES=y
-CONFIG_HAVE_OPTPROBES=y
-CONFIG_HAVE_KPROBES_ON_FTRACE=y
-CONFIG_HAVE_ARCH_TRACEHOOK=y
-CONFIG_HAVE_DMA_ATTRS=y
-CONFIG_HAVE_DMA_CONTIGUOUS=y
-CONFIG_USE_GENERIC_SMP_HELPERS=y
-CONFIG_GENERIC_SMP_IDLE_THREAD=y
-CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
-CONFIG_HAVE_CLK=y
-CONFIG_HAVE_DMA_API_DEBUG=y
-CONFIG_HAVE_HW_BREAKPOINT=y
-CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
-CONFIG_HAVE_USER_RETURN_NOTIFIER=y
-CONFIG_HAVE_PERF_EVENTS_NMI=y
-CONFIG_HAVE_PERF_REGS=y
-CONFIG_HAVE_PERF_USER_STACK_DUMP=y
-CONFIG_HAVE_ARCH_JUMP_LABEL=y
-CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
-CONFIG_HAVE_CMPXCHG_LOCAL=y
-CONFIG_HAVE_CMPXCHG_DOUBLE=y
-CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
-CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
-CONFIG_SECCOMP_FILTER=y
-CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
-CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
-CONFIG_HAVE_ARCH_SOFT_DIRTY=y
-CONFIG_MODULES_USE_ELF_REL=y
-CONFIG_CLONE_BACKWARDS=y
-CONFIG_OLD_SIGSUSPEND3=y
-CONFIG_OLD_SIGACTION=y
-
-#
-# GCOV-based kernel profiling
-#
-CONFIG_HAVE_GENERIC_DMA_COHERENT=y
-CONFIG_RT_MUTEXES=y
-CONFIG_BASE_SMALL=1
-CONFIG_MODULES=y
-# CONFIG_MODULE_FORCE_LOAD is not set
-# CONFIG_MODULE_UNLOAD is not set
-# CONFIG_MODVERSIONS is not set
-# CONFIG_MODULE_SRCVERSION_ALL is not set
-# CONFIG_MODULE_SIG is not set
-CONFIG_STOP_MACHINE=y
-CONFIG_BLOCK=y
-CONFIG_LBDAF=y
-CONFIG_BLK_DEV_BSG=y
-# CONFIG_BLK_DEV_BSGLIB is not set
-# CONFIG_BLK_DEV_INTEGRITY is not set
-# CONFIG_BLK_CMDLINE_PARSER is not set
-
-#
-# Partition Types
-#
-# CONFIG_PARTITION_ADVANCED is not set
-CONFIG_MSDOS_PARTITION=y
-CONFIG_EFI_PARTITION=y
-
-#
-# IO Schedulers
-#
-CONFIG_IOSCHED_NOOP=y
-# CONFIG_IOSCHED_DEADLINE is not set
-CONFIG_IOSCHED_CFQ=y
-CONFIG_DEFAULT_CFQ=y
-# CONFIG_DEFAULT_NOOP is not set
-CONFIG_DEFAULT_IOSCHED="cfq"
-CONFIG_UNINLINE_SPIN_UNLOCK=y
-CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
-CONFIG_MUTEX_SPIN_ON_OWNER=y
-CONFIG_FREEZER=y
-
-#
-# Processor type and features
-#
-CONFIG_ZONE_DMA=y
-CONFIG_SMP=y
-CONFIG_X86_MPPARSE=y
-# CONFIG_X86_BIGSMP is not set
-# CONFIG_X86_EXTENDED_PLATFORM is not set
-CONFIG_NET_SUBSYSTEM=y
-# CONFIG_NET_SUBSYSTEM_SYSFS is not set
-
-#
-# Intel Puma7 LitePath Support
-#
-# CONFIG_PUMA_LITEPATH is not set
-
-#
-# Intel PUMA7 AVALANCHE support
-#
-# CONFIG_ARM_AVALANCHE_PDSP is not set
-CONFIG_TI_PACKET_PROCESSOR=y
-CONFIG_TI_PACKET_PROCESSOR_STATS=y
-CONFIG_X86_AVALANCHE_SOC=y
-CONFIG_TI_META_DATA=y
-# CONFIG_MACH_PUMA5 is not set
-# CONFIG_MACH_PUMA6 is not set
-CONFIG_MACH_PUMA7=y
-# CONFIG_MACH_PUMA7_FPGA is not set
-CONFIG_MACH_PUMA7_BOARD=y
-CONFIG_HW_MUTEXES=y
-CONFIG_MUTEX_FIFO=y
-# CONFIG_MUTEX_NULL is not set
-# CONFIG_MUTEX_POLLING is not set
-# CONFIG_X86_PUMA6 is not set
-CONFIG_X86_PUMA7=y
-CONFIG_HW_MAILBOX=y
-CONFIG_X86_INTEL_CE2700=y
-CONFIG_GMIN_INTEL_MID=y
-CONFIG_X86_INTEL_LPSS=y
-CONFIG_IOSF_MBI=y
-# CONFIG_X86_32_IRIS is not set
-CONFIG_SCHED_OMIT_FRAME_POINTER=y
-# CONFIG_HYPERVISOR_GUEST is not set
-CONFIG_NO_BOOTMEM=y
-# CONFIG_MEMTEST is not set
-# CONFIG_M486 is not set
-# CONFIG_M586 is not set
-# CONFIG_M586TSC is not set
-# CONFIG_M586MMX is not set
-# CONFIG_M686 is not set
-# CONFIG_MPENTIUMII is not set
-# CONFIG_MPENTIUMIII is not set
-# CONFIG_MPENTIUMM is not set
-# CONFIG_MPENTIUM4 is not set
-# CONFIG_MK6 is not set
-# CONFIG_MK7 is not set
-# CONFIG_MK8 is not set
-# CONFIG_MCRUSOE is not set
-# CONFIG_MEFFICEON is not set
-# CONFIG_MWINCHIPC6 is not set
-# CONFIG_MWINCHIP3D is not set
-# CONFIG_MELAN is not set
-# CONFIG_MGEODEGX1 is not set
-# CONFIG_MGEODE_LX is not set
-# CONFIG_MCYRIXIII is not set
-# CONFIG_MVIAC3_2 is not set
-# CONFIG_MVIAC7 is not set
-# CONFIG_MCORE2 is not set
-CONFIG_MATOM=y
-# CONFIG_X86_GENERIC is not set
-CONFIG_X86_INTERNODE_CACHE_SHIFT=6
-CONFIG_X86_L1_CACHE_SHIFT=6
-CONFIG_X86_USE_PPRO_CHECKSUM=y
-CONFIG_X86_TSC=y
-CONFIG_X86_CMPXCHG64=y
-CONFIG_X86_CMOV=y
-CONFIG_X86_MINIMUM_CPU_FAMILY=5
-CONFIG_X86_DEBUGCTLMSR=y
-# CONFIG_PROCESSOR_SELECT is not set
-CONFIG_CPU_SUP_INTEL=y
-CONFIG_CPU_SUP_CYRIX_32=y
-CONFIG_CPU_SUP_AMD=y
-CONFIG_CPU_SUP_CENTAUR=y
-CONFIG_CPU_SUP_TRANSMETA_32=y
-CONFIG_CPU_SUP_UMC_32=y
-CONFIG_HPET_TIMER=y
-CONFIG_DMI=y
-CONFIG_NR_CPUS=8
-CONFIG_SCHED_SMT=y
-CONFIG_SCHED_MC=y
-# CONFIG_PREEMPT_NONE is not set
-# CONFIG_PREEMPT_VOLUNTARY is not set
-CONFIG_PREEMPT=y
-CONFIG_PREEMPT_COUNT=y
-CONFIG_X86_UP_APIC_MSI=y
-CONFIG_X86_LOCAL_APIC=y
-CONFIG_X86_IO_APIC=y
-CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
-CONFIG_X86_MCE=y
-CONFIG_X86_MCE_INTEL=y
-# CONFIG_X86_MCE_AMD is not set
-# CONFIG_X86_ANCIENT_MCE is not set
-CONFIG_X86_MCE_THRESHOLD=y
-# CONFIG_X86_MCE_INJECT is not set
-CONFIG_X86_THERMAL_VECTOR=y
-CONFIG_VM86=y
-CONFIG_X86_16BIT=y
-CONFIG_X86_ESPFIX32=y
-# CONFIG_TOSHIBA is not set
-# CONFIG_I8K is not set
-# CONFIG_X86_REBOOTFIXUPS is not set
-# CONFIG_MICROCODE is not set
-# CONFIG_MICROCODE_INTEL_EARLY is not set
-# CONFIG_MICROCODE_AMD_EARLY is not set
-CONFIG_X86_MSR=y
-CONFIG_X86_CPUID=y
-# CONFIG_NOHIGHMEM is not set
-CONFIG_HIGHMEM4G=y
-# CONFIG_HIGHMEM64G is not set
-CONFIG_VMSPLIT_3G=y
-# CONFIG_VMSPLIT_3G_OPT is not set
-# CONFIG_VMSPLIT_2G is not set
-# CONFIG_VMSPLIT_2G_OPT is not set
-# CONFIG_VMSPLIT_1G is not set
-CONFIG_PAGE_OFFSET=0xC0000000
-CONFIG_HIGHMEM=y
-CONFIG_NEED_NODE_MEMMAP_SIZE=y
-CONFIG_ARCH_FLATMEM_ENABLE=y
-CONFIG_ARCH_SPARSEMEM_ENABLE=y
-CONFIG_ARCH_SELECT_MEMORY_MODEL=y
-CONFIG_ILLEGAL_POINTER_VALUE=0
-CONFIG_SELECT_MEMORY_MODEL=y
-# CONFIG_FLATMEM_MANUAL is not set
-CONFIG_SPARSEMEM_MANUAL=y
-CONFIG_SPARSEMEM=y
-CONFIG_HAVE_MEMORY_PRESENT=y
-CONFIG_SPARSEMEM_STATIC=y
-CONFIG_HAVE_MEMBLOCK=y
-CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
-CONFIG_ARCH_DISCARD_MEMBLOCK=y
-# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
-# CONFIG_MEMORY_HOTPLUG is not set
-CONFIG_SPLIT_PTLOCK_CPUS=4
-CONFIG_COMPACTION=y
-CONFIG_MIGRATION=y
-# CONFIG_PHYS_ADDR_T_64BIT is not set
-CONFIG_ZONE_DMA_FLAG=1
-CONFIG_BOUNCE=y
-CONFIG_VIRT_TO_BUS=y
-CONFIG_KSM=y
-CONFIG_DEFAULT_MMAP_MIN_ADDR=8192
-# CONFIG_TRANSPARENT_HUGEPAGE is not set
-CONFIG_CROSS_MEMORY_ATTACH=y
-# CONFIG_CLEANCACHE is not set
-# CONFIG_CMA is not set
-# CONFIG_ZBUD is not set
-# CONFIG_HIGHPTE is not set
-# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
-CONFIG_X86_RESERVE_LOW=64
-# CONFIG_MATH_EMULATION is not set
-CONFIG_MTRR=y
-CONFIG_MTRR_SANITIZER=y
-CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=1
-CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
-CONFIG_X86_PAT=y
-CONFIG_ARCH_USES_PG_UNCACHED=y
-CONFIG_ARCH_RANDOM=y
-CONFIG_X86_SMAP=y
-CONFIG_EFI=y
-CONFIG_EFI_STUB=y
-CONFIG_SECCOMP=y
-CONFIG_CC_STACKPROTECTOR=y
-# CONFIG_HZ_100 is not set
-# CONFIG_HZ_250 is not set
-# CONFIG_HZ_300 is not set
-CONFIG_HZ_1000=y
-CONFIG_HZ=1000
-CONFIG_SCHED_HRTICK=y
-# CONFIG_KEXEC is not set
-CONFIG_CRASH_DUMP=y
-CONFIG_PHYSICAL_START=0x200000
-CONFIG_RELOCATABLE=y
-CONFIG_X86_NEED_RELOCS=y
-CONFIG_PHYSICAL_ALIGN=0x200000
-CONFIG_HOTPLUG_CPU=y
-# CONFIG_BOOTPARAM_HOTPLUG_CPU0 is not set
-# CONFIG_DEBUG_HOTPLUG_CPU0 is not set
-CONFIG_COMPAT_VDSO=y
-# CONFIG_CMDLINE_BOOL is not set
-CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
-
-#
-# Power management and ACPI options
-#
-# CONFIG_SUSPEND is not set
-# CONFIG_PM_RUNTIME is not set
-CONFIG_ACPI=y
-# CONFIG_ACPI_PROCFS is not set
-# CONFIG_ACPI_PROCFS_POWER is not set
-# CONFIG_ACPI_EC_DEBUGFS is not set
-CONFIG_ACPI_AC=y
-CONFIG_ACPI_BATTERY=y
-CONFIG_ACPI_FAN=y
-CONFIG_ACPI_DOCK=y
-CONFIG_ACPI_PROCESSOR=y
-CONFIG_ACPI_HOTPLUG_CPU=y
-# CONFIG_ACPI_PROCESSOR_AGGREGATOR is not set
-CONFIG_ACPI_THERMAL=y
-# CONFIG_ACPI_CUSTOM_DSDT is not set
-# CONFIG_ACPI_INITRD_TABLE_OVERRIDE is not set
-CONFIG_ACPI_BLACKLIST_YEAR=0
-# CONFIG_ACPI_DEBUG is not set
-# CONFIG_ACPI_PCI_SLOT is not set
-CONFIG_X86_PM_TIMER=y
-CONFIG_ACPI_CONTAINER=y
-# CONFIG_ACPI_SBS is not set
-# CONFIG_ACPI_HED is not set
-# CONFIG_ACPI_BGRT is not set
-# CONFIG_ACPI_APEI is not set
-# CONFIG_SFI is not set
-
-#
-# CPU Frequency scaling
-#
-CONFIG_CPU_FREQ=y
-CONFIG_CPU_FREQ_TABLE=y
-CONFIG_CPU_FREQ_GOV_COMMON=y
-# CONFIG_CPU_FREQ_STAT is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
-# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
-CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
-CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
-CONFIG_CPU_FREQ_GOV_POWERSAVE=y
-# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
-CONFIG_CPU_FREQ_GOV_ONDEMAND=y
-# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
-
-#
-# x86 CPU frequency scaling drivers
-#
-CONFIG_X86_INTEL_PSTATE=y
-CONFIG_X86_PCC_CPUFREQ=y
-CONFIG_X86_ACPI_CPUFREQ=y
-CONFIG_X86_ACPI_CPUFREQ_CPB=y
-# CONFIG_X86_POWERNOW_K6 is not set
-# CONFIG_X86_POWERNOW_K7 is not set
-# CONFIG_X86_POWERNOW_K8 is not set
-# CONFIG_X86_AMD_FREQ_SENSITIVITY is not set
-# CONFIG_X86_GX_SUSPMOD is not set
-# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
-# CONFIG_X86_SPEEDSTEP_ICH is not set
-# CONFIG_X86_SPEEDSTEP_SMI is not set
-# CONFIG_X86_P4_CLOCKMOD is not set
-# CONFIG_X86_CPUFREQ_NFORCE2 is not set
-# CONFIG_X86_LONGRUN is not set
-# CONFIG_X86_LONGHAUL is not set
-# CONFIG_X86_E_POWERSAVER is not set
-
-#
-# shared options
-#
-# CONFIG_X86_SPEEDSTEP_LIB is not set
-
-#
-# CPU Idle
-#
-CONFIG_CPU_IDLE=y
-# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
-CONFIG_CPU_IDLE_GOV_LADDER=y
-CONFIG_CPU_IDLE_GOV_MENU=y
-# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
-# CONFIG_INTEL_IDLE is not set
-
-#
-# Bus options (PCI etc.)
-#
-CONFIG_PCI=y
-# CONFIG_PCI_GOBIOS is not set
-# CONFIG_PCI_GOMMCONFIG is not set
-# CONFIG_PCI_GODIRECT is not set
-CONFIG_PCI_GOANY=y
-CONFIG_PCI_BIOS=y
-CONFIG_PCI_DIRECT=y
-CONFIG_PCI_MMCONFIG=y
-CONFIG_PCI_DOMAINS=y
-# CONFIG_PCI_CNB20LE_QUIRK is not set
-CONFIG_PCIEPORTBUS=y
-CONFIG_PCIEAER=y
-# CONFIG_PCIE_ECRC is not set
-# CONFIG_PCIEAER_INJECT is not set
-CONFIG_PCIEASPM=y
-# CONFIG_PCIEASPM_DEBUG is not set
-# CONFIG_PCIEASPM_DEFAULT is not set
-CONFIG_PCIEASPM_POWERSAVE=y
-# CONFIG_PCIEASPM_PERFORMANCE is not set
-CONFIG_PCI_MSI=y
-# CONFIG_PCI_DEBUG is not set
-# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
-# CONFIG_PCI_STUB is not set
-CONFIG_HT_IRQ=y
-# CONFIG_PCI_IOV is not set
-# CONFIG_PCI_PRI is not set
-# CONFIG_PCI_PASID is not set
-# CONFIG_PCI_IOAPIC is not set
-CONFIG_PCI_LABEL=y
-
-#
-# PCI host controller drivers
-#
-CONFIG_ISA_DMA_API=y
-# CONFIG_ISA is not set
-# CONFIG_SCx200 is not set
-# CONFIG_OLPC is not set
-# CONFIG_ALIX is not set
-# CONFIG_NET5501 is not set
-# CONFIG_GEOS is not set
-CONFIG_AMD_NB=y
-# CONFIG_PCCARD is not set
-# CONFIG_HOTPLUG_PCI is not set
-# CONFIG_RAPIDIO is not set
-CONFIG_X86_SYSFB=y
-
-#
-# Executable file formats / Emulations
-#
-CONFIG_BINFMT_ELF=y
-CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
-CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
-CONFIG_BINFMT_SCRIPT=y
-CONFIG_HAVE_AOUT=y
-# CONFIG_BINFMT_AOUT is not set
-# CONFIG_BINFMT_MISC is not set
-CONFIG_COREDUMP=y
-CONFIG_HAVE_ATOMIC_IOMAP=y
-CONFIG_NET=y
-
-#
-# Networking options
-#
-CONFIG_PACKET=y
-# CONFIG_PACKET_DIAG is not set
-CONFIG_UNIX=y
-# CONFIG_UNIX_DIAG is not set
-# CONFIG_XFRM_USER is not set
-# CONFIG_NET_KEY is not set
-CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-# CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IP_PNP_BOOTP is not set
-# CONFIG_IP_PNP_RARP is not set
-CONFIG_NET_IPIP=y
-CONFIG_NET_IPGRE_DEMUX=y
-CONFIG_NET_IP_TUNNEL=y
-CONFIG_NET_IPGRE=y
-CONFIG_NET_IPGRE_BROADCAST=y
-# CONFIG_IP_MROUTE is not set
-# CONFIG_SYN_COOKIES is not set
-# CONFIG_INET_AH is not set
-# CONFIG_INET_ESP is not set
-# CONFIG_INET_IPCOMP is not set
-# CONFIG_INET_XFRM_TUNNEL is not set
-CONFIG_INET_TUNNEL=y
-# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
-# CONFIG_INET_XFRM_MODE_TUNNEL is not set
-# CONFIG_INET_XFRM_MODE_BEET is not set
-CONFIG_INET_LRO=y
-# CONFIG_INET_DIAG is not set
-CONFIG_TCP_CONG_ADVANCED=y
-# CONFIG_TCP_CONG_BIC is not set
-# CONFIG_TCP_CONG_CUBIC is not set
-# CONFIG_TCP_CONG_WESTWOOD is not set
-# CONFIG_TCP_CONG_HTCP is not set
-# CONFIG_TCP_CONG_HSTCP is not set
-# CONFIG_TCP_CONG_HYBLA is not set
-# CONFIG_TCP_CONG_VEGAS is not set
-# CONFIG_TCP_CONG_SCALABLE is not set
-# CONFIG_TCP_CONG_LP is not set
-# CONFIG_TCP_CONG_VENO is not set
-# CONFIG_TCP_CONG_YEAH is not set
-# CONFIG_TCP_CONG_ILLINOIS is not set
-CONFIG_DEFAULT_RENO=y
-CONFIG_DEFAULT_TCP_CONG="reno"
-# CONFIG_TCP_MD5SIG is not set
-# CONFIG_IPV6 is not set
-# CONFIG_NETLABEL is not set
-# CONFIG_NETWORK_SECMARK is not set
-# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
-# CONFIG_NETFILTER is not set
-# CONFIG_IP_DCCP is not set
-# CONFIG_IP_SCTP is not set
-# CONFIG_RDS is not set
-# CONFIG_TIPC is not set
-# CONFIG_ATM is not set
-# CONFIG_L2TP is not set
-# CONFIG_BRIDGE is not set
-CONFIG_HAVE_NET_DSA=y
-CONFIG_VLAN_8021Q=y
-# CONFIG_VLAN_8021Q_GVRP is not set
-# CONFIG_VLAN_8021Q_MVRP is not set
-# CONFIG_DECNET is not set
-# CONFIG_LLC2 is not set
-# CONFIG_IPX is not set
-# CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_PHONET is not set
-# CONFIG_IEEE802154 is not set
-# CONFIG_NET_SCHED is not set
-# CONFIG_DCB is not set
-# CONFIG_DNS_RESOLVER is not set
-# CONFIG_BATMAN_ADV is not set
-# CONFIG_OPENVSWITCH is not set
-# CONFIG_VSOCKETS is not set
-# CONFIG_NETLINK_MMAP is not set
-# CONFIG_NETLINK_DIAG is not set
-# CONFIG_NET_MPLS_GSO is not set
-CONFIG_RPS=y
-CONFIG_RFS_ACCEL=y
-CONFIG_XPS=y
-# CONFIG_NETPRIO_CGROUP is not set
-CONFIG_NET_RX_BUSY_POLL=y
-CONFIG_BQL=y
-CONFIG_NET_FLOW_LIMIT=y
-
-#
-# Network testing
-#
-# CONFIG_NET_PKTGEN is not set
-# CONFIG_APPCPU_GW_PP_HANDLE is not set
-# CONFIG_HAMRADIO is not set
-# CONFIG_CAN is not set
-# CONFIG_IRDA is not set
-# CONFIG_BT is not set
-# CONFIG_AF_RXRPC is not set
-
-#
-# Texas Instruments Kernel Extensions
-#
-CONFIG_TI_DEVICE_PROTOCOL_HANDLING=y
-# CONFIG_TI_UNMANAGED_BRIDGE is not set
-# CONFIG_INTEL_KERNEL_DOCSIS_SUPPORT is not set
-# CONFIG_INTEL_KERNEL_BBU_SUPPORT is not set
-# CONFIG_INTEL_NF_TRIGGER_SUPPORT is not set
-# CONFIG_INTEL_NF_GWMETA_SUPPORT is not set
-# CONFIG_INTEL_NF_WEBSTR_SUPPORT is not set
-# CONFIG_TI_IP_PKTINFO_SOCKOPT is not set
-# CONFIG_TI_META_DATA_CONSOLE_DUMP is not set
-# CONFIG_TI_DOCSIS_INPUT_DEV is not set
-# CONFIG_INTEL_DOCSIS_ICMP_IIF is not set
-# CONFIG_TI_L2_SELECTIVE_FORWARDER is not set
-# CONFIG_INTEL_L2VPN_L2CP_FORWARD is not set
-# CONFIG_TI_DEVICE_INDEX_REUSE is not set
-# CONFIG_TI_L2_SELECTIVE_PACKET_HANDLING is not set
-# CONFIG_TI_DOCSIS_EGRESS_HOOK is not set
-# CONFIG_TI_GW_EGRESS_HOOK is not set
-CONFIG_TI_EGRESS_HOOK=y
-# CONFIG_TI_ICMP_ECHO_REPLY_NETFILTER_BYPASS is not set
-# CONFIG_INTEL_NS_DEVICE_FILTER is not set
-
-#
-# TI Packet Processor Subsystem
-#
-# CONFIG_NPCPU_HARDCODED_OFFCHIP_INFO is not set
-# CONFIG_EXCLUDE_GMAC4 is not set
-# CONFIG_TI_PACKET_PROCESSOR_EXT_SWITCH is not set
-# CONFIG_TI_HIL_DEBUG is not set
-# CONFIG_TI_HIL_PROFILE_INTRUSIVE is not set
-# CONFIG_TI_HIL_PROFILE_STATIC is not set
-# CONFIG_TI_HIL_PROFILE_INTRUSIVE_PP2K is not set
-CONFIG_TI_HIL_PROFILE_INTRUSIVE_P7=y
-# CONFIG_INTEL_PP_TUNNEL_SUPPORT is not set
-# CONFIG_INTEL_IRQ_THREAD_CHANGE_PRIORITY is not set
-# CONFIG_INTEL_DEFAULT_IPV6_AUTOCONF_DISABLES_IPV6_AUTOCONF is not set
-# CONFIG_INTEL_MAX_BRIDGE_MACS_LIMIT is not set
-# CONFIG_INTEL_KERNEL_VOICE_SUPPORT is not set
-# CONFIG_INTEL_KERNEL_FORCE_IPV6_DOWN_WHEN_NO_ADDRES is not set
-# CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL is not set
-CONFIG_WIRELESS=y
-# CONFIG_CFG80211 is not set
-# CONFIG_LIB80211 is not set
-
-#
-# CFG80211 needs to be enabled for MAC80211
-#
-# CONFIG_WIMAX is not set
-# CONFIG_RFKILL is not set
-# CONFIG_RFKILL_REGULATOR is not set
-# CONFIG_NET_9P is not set
-# CONFIG_CAIF is not set
-# CONFIG_CEPH_LIB is not set
-# CONFIG_NFC is not set
-
-#
-# Device Drivers
-#
-
-#
-# Generic Driver Options
-#
-CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
-CONFIG_DEVTMPFS=y
-CONFIG_DEVTMPFS_MOUNT=y
-CONFIG_STANDALONE=y
-CONFIG_PREVENT_FIRMWARE_BUILD=y
-# CONFIG_FW_LOADER is not set
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
-# CONFIG_SYS_HYPERVISOR is not set
-# CONFIG_GENERIC_CPU_DEVICES is not set
-# CONFIG_DMA_SHARED_BUFFER is not set
-
-#
-# Bus devices
-#
-# CONFIG_CONNECTOR is not set
-# CONFIG_MTD is not set
-# CONFIG_PARPORT is not set
-CONFIG_PNP=y
-CONFIG_PNP_DEBUG_MESSAGES=y
-
-#
-# Protocols
-#
-CONFIG_PNPACPI=y
-CONFIG_BLK_DEV=y
-# CONFIG_BLK_DEV_FD is not set
-# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
-# CONFIG_BLK_CPQ_DA is not set
-# CONFIG_BLK_CPQ_CISS_DA is not set
-# CONFIG_BLK_DEV_DAC960 is not set
-# CONFIG_BLK_DEV_UMEM is not set
-# CONFIG_BLK_DEV_COW_COMMON is not set
-# CONFIG_BLK_DEV_LOOP is not set
-# CONFIG_BLK_DEV_DRBD is not set
-# CONFIG_BLK_DEV_NBD is not set
-# CONFIG_BLK_DEV_NVME is not set
-# CONFIG_BLK_DEV_SX8 is not set
-# CONFIG_BLK_DEV_RAM is not set
-# CONFIG_CDROM_PKTCDVD is not set
-# CONFIG_ATA_OVER_ETH is not set
-# CONFIG_BLK_DEV_HD is not set
-# CONFIG_BLK_DEV_RBD is not set
-# CONFIG_BLK_DEV_RSXX is not set
-
-#
-# Misc devices
-#
-# CONFIG_AD525X_DPOT is not set
-# CONFIG_ATMEL_PWM is not set
-# CONFIG_DUMMY_IRQ is not set
-# CONFIG_PHANTOM is not set
-# CONFIG_SGI_IOC4 is not set
-# CONFIG_TIFM_CORE is not set
-# CONFIG_ICS932S401 is not set
-# CONFIG_ATMEL_SSC is not set
-# CONFIG_ENCLOSURE_SERVICES is not set
-# CONFIG_HP_ILO is not set
-# CONFIG_APDS9802ALS is not set
-# CONFIG_ISL29003 is not set
-# CONFIG_ISL29020 is not set
-# CONFIG_SENSORS_TSL2550 is not set
-# CONFIG_SENSORS_BH1780 is not set
-# CONFIG_SENSORS_BH1770 is not set
-# CONFIG_SENSORS_APDS990X is not set
-# CONFIG_HMC6352 is not set
-# CONFIG_DS1682 is not set
-# CONFIG_TI_DAC7512 is not set
-# CONFIG_BMP085_I2C is not set
-# CONFIG_BMP085_SPI is not set
-# CONFIG_PCH_PHUB is not set
-# CONFIG_USB_SWITCH_FSA9480 is not set
-# CONFIG_LATTICE_ECP3_CONFIG is not set
-# CONFIG_SRAM is not set
-CONFIG_CE_MAILBOX=y
-# CONFIG_C2PORT is not set
-
-#
-# EEPROM support
-#
-# CONFIG_EEPROM_AT24 is not set
-# CONFIG_EEPROM_AT25 is not set
-# CONFIG_EEPROM_LEGACY is not set
-# CONFIG_EEPROM_MAX6875 is not set
-# CONFIG_EEPROM_93CX6 is not set
-# CONFIG_EEPROM_93XX46 is not set
-# CONFIG_CB710_CORE is not set
-
-#
-# Texas Instruments shared transport line discipline
-#
-# CONFIG_TI_ST is not set
-
-#
-# Altera FPGA firmware download module
-#
-# CONFIG_ALTERA_STAPL is not set
-# CONFIG_INTEL_MEI is not set
-# CONFIG_INTEL_MEI_ME is not set
-# CONFIG_INTEL_MEI_TXE is not set
-# CONFIG_INTEL_ISS is not set
-# CONFIG_VMWARE_VMCI is not set
-CONFIG_HAVE_IDE=y
-# CONFIG_IDE is not set
-
-#
-# SCSI device support
-#
-CONFIG_SCSI_MOD=y
-# CONFIG_RAID_ATTRS is not set
-CONFIG_SCSI=y
-CONFIG_SCSI_DMA=y
-# CONFIG_SCSI_TGT is not set
-# CONFIG_SCSI_NETLINK is not set
-CONFIG_SCSI_PROC_FS=y
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=y
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-# CONFIG_BLK_DEV_SR is not set
-# CONFIG_CHR_DEV_SG is not set
-# CONFIG_CHR_DEV_SCH is not set
-# CONFIG_SCSI_MULTI_LUN is not set
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_LOGGING is not set
-# CONFIG_SCSI_SCAN_ASYNC is not set
-
-#
-# SCSI Transports
-#
-CONFIG_SCSI_SPI_ATTRS=y
-# CONFIG_SCSI_FC_ATTRS is not set
-# CONFIG_SCSI_ISCSI_ATTRS is not set
-# CONFIG_SCSI_SAS_ATTRS is not set
-# CONFIG_SCSI_SAS_LIBSAS is not set
-# CONFIG_SCSI_SRP_ATTRS is not set
-CONFIG_SCSI_LOWLEVEL=y
-# CONFIG_ISCSI_TCP is not set
-# CONFIG_ISCSI_BOOT_SYSFS is not set
-# CONFIG_SCSI_CXGB3_ISCSI is not set
-# CONFIG_SCSI_CXGB4_ISCSI is not set
-# CONFIG_SCSI_BNX2_ISCSI is not set
-# CONFIG_SCSI_BNX2X_FCOE is not set
-# CONFIG_BE2ISCSI is not set
-# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
-# CONFIG_SCSI_HPSA is not set
-# CONFIG_SCSI_3W_9XXX is not set
-# CONFIG_SCSI_3W_SAS is not set
-# CONFIG_SCSI_ACARD is not set
-# CONFIG_SCSI_AACRAID is not set
-# CONFIG_SCSI_AIC7XXX is not set
-# CONFIG_SCSI_AIC7XXX_OLD is not set
-# CONFIG_SCSI_AIC79XX is not set
-# CONFIG_SCSI_AIC94XX is not set
-# CONFIG_SCSI_MVSAS is not set
-# CONFIG_SCSI_MVUMI is not set
-# CONFIG_SCSI_DPT_I2O is not set
-# CONFIG_SCSI_ADVANSYS is not set
-# CONFIG_SCSI_ARCMSR is not set
-# CONFIG_SCSI_ESAS2R is not set
-# CONFIG_MEGARAID_NEWGEN is not set
-# CONFIG_MEGARAID_LEGACY is not set
-# CONFIG_MEGARAID_SAS is not set
-# CONFIG_SCSI_MPT2SAS is not set
-# CONFIG_SCSI_MPT3SAS is not set
-# CONFIG_SCSI_UFSHCD is not set
-# CONFIG_SCSI_HPTIOP is not set
-# CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_VMWARE_PVSCSI is not set
-# CONFIG_LIBFC is not set
-# CONFIG_LIBFCOE is not set
-# CONFIG_FCOE is not set
-# CONFIG_FCOE_FNIC is not set
-# CONFIG_SCSI_DMX3191D is not set
-# CONFIG_SCSI_EATA is not set
-# CONFIG_SCSI_FUTURE_DOMAIN is not set
-# CONFIG_SCSI_GDTH is not set
-# CONFIG_SCSI_ISCI is not set
-# CONFIG_SCSI_IPS is not set
-# CONFIG_SCSI_INITIO is not set
-# CONFIG_SCSI_INIA100 is not set
-# CONFIG_SCSI_STEX is not set
-# CONFIG_SCSI_SYM53C8XX_2 is not set
-# CONFIG_SCSI_IPR is not set
-# CONFIG_SCSI_QLOGIC_1280 is not set
-# CONFIG_SCSI_QLA_FC is not set
-# CONFIG_SCSI_QLA_ISCSI is not set
-# CONFIG_SCSI_LPFC is not set
-# CONFIG_SCSI_DC395x is not set
-# CONFIG_SCSI_DC390T is not set
-# CONFIG_SCSI_NSP32 is not set
-# CONFIG_SCSI_DEBUG is not set
-# CONFIG_SCSI_PMCRAID is not set
-# CONFIG_SCSI_PM8001 is not set
-# CONFIG_SCSI_SRP is not set
-# CONFIG_SCSI_BFA_FC is not set
-# CONFIG_SCSI_CHELSIO_FCOE is not set
-# CONFIG_SCSI_DH is not set
-# CONFIG_SCSI_OSD_INITIATOR is not set
-CONFIG_ATA=y
-# CONFIG_ATA_NONSTANDARD is not set
-CONFIG_ATA_VERBOSE_ERROR=y
-CONFIG_ATA_ACPI=y
-# CONFIG_SATA_ZPODD is not set
-CONFIG_SATA_PMP=y
-
-#
-# Controllers with non-SFF native interface
-#
-# CONFIG_SATA_AHCI is not set
-# CONFIG_SATA_AHCI_PLATFORM is not set
-# CONFIG_SATA_INIC162X is not set
-# CONFIG_SATA_ACARD_AHCI is not set
-# CONFIG_SATA_SIL24 is not set
-CONFIG_ATA_SFF=y
-
-#
-# SFF controllers with custom DMA interface
-#
-# CONFIG_PDC_ADMA is not set
-# CONFIG_SATA_QSTOR is not set
-# CONFIG_SATA_SX4 is not set
-CONFIG_ATA_BMDMA=y
-
-#
-# SATA SFF controllers with BMDMA
-#
-# CONFIG_ATA_PIIX is not set
-# CONFIG_SATA_HIGHBANK is not set
-# CONFIG_SATA_MV is not set
-# CONFIG_SATA_NV is not set
-# CONFIG_SATA_PROMISE is not set
-# CONFIG_SATA_RCAR is not set
-# CONFIG_SATA_SIL is not set
-# CONFIG_SATA_SIS is not set
-# CONFIG_SATA_SVW is not set
-# CONFIG_SATA_ULI is not set
-# CONFIG_SATA_VIA is not set
-# CONFIG_SATA_VITESSE is not set
-
-#
-# PATA SFF controllers with BMDMA
-#
-# CONFIG_PATA_ALI is not set
-# CONFIG_PATA_AMD is not set
-# CONFIG_PATA_ARTOP is not set
-# CONFIG_PATA_ATIIXP is not set
-# CONFIG_PATA_ATP867X is not set
-# CONFIG_PATA_CMD64X is not set
-# CONFIG_PATA_CS5520 is not set
-# CONFIG_PATA_CS5530 is not set
-# CONFIG_PATA_CS5535 is not set
-# CONFIG_PATA_CS5536 is not set
-# CONFIG_PATA_CYPRESS is not set
-# CONFIG_PATA_EFAR is not set
-# CONFIG_PATA_HPT366 is not set
-# CONFIG_PATA_HPT37X is not set
-# CONFIG_PATA_HPT3X2N is not set
-# CONFIG_PATA_HPT3X3 is not set
-# CONFIG_PATA_IT8213 is not set
-# CONFIG_PATA_IT821X is not set
-# CONFIG_PATA_JMICRON is not set
-# CONFIG_PATA_MARVELL is not set
-# CONFIG_PATA_NETCELL is not set
-# CONFIG_PATA_NINJA32 is not set
-# CONFIG_PATA_NS87415 is not set
-# CONFIG_PATA_OLDPIIX is not set
-# CONFIG_PATA_OPTIDMA is not set
-# CONFIG_PATA_PDC2027X is not set
-# CONFIG_PATA_PDC_OLD is not set
-# CONFIG_PATA_RADISYS is not set
-# CONFIG_PATA_RDC is not set
-# CONFIG_PATA_SC1200 is not set
-# CONFIG_PATA_SCH is not set
-# CONFIG_PATA_SERVERWORKS is not set
-# CONFIG_PATA_SIL680 is not set
-# CONFIG_PATA_SIS is not set
-# CONFIG_PATA_TOSHIBA is not set
-# CONFIG_PATA_TRIFLEX is not set
-# CONFIG_PATA_VIA is not set
-# CONFIG_PATA_WINBOND is not set
-
-#
-# PIO-only SFF controllers
-#
-# CONFIG_PATA_CMD640_PCI is not set
-# CONFIG_PATA_MPIIX is not set
-# CONFIG_PATA_NS87410 is not set
-# CONFIG_PATA_OPTI is not set
-# CONFIG_PATA_PLATFORM is not set
-# CONFIG_PATA_RZ1000 is not set
-
-#
-# Generic fallback / legacy drivers
-#
-# CONFIG_PATA_ACPI is not set
-# CONFIG_ATA_GENERIC is not set
-# CONFIG_PATA_LEGACY is not set
-# CONFIG_MD is not set
-# CONFIG_TARGET_CORE is not set
-# CONFIG_FUSION is not set
-
-#
-# IEEE 1394 (FireWire) support
-#
-# CONFIG_FIREWIRE is not set
-# CONFIG_FIREWIRE_NOSY is not set
-# CONFIG_I2O is not set
-# CONFIG_MACINTOSH_DRIVERS is not set
-CONFIG_NETDEVICES=y
-CONFIG_MII=y
-CONFIG_NET_CORE=y
-# CONFIG_BONDING is not set
-# CONFIG_DUMMY is not set
-# CONFIG_EQUALIZER is not set
-# CONFIG_NET_FC is not set
-# CONFIG_NET_TEAM is not set
-CONFIG_MACVLAN=y
-# CONFIG_MACVTAP is not set
-# CONFIG_VXLAN is not set
-# CONFIG_NETCONSOLE is not set
-# CONFIG_NETPOLL is not set
-# CONFIG_NET_POLL_CONTROLLER is not set
-# CONFIG_TUN is not set
-# CONFIG_VETH is not set
-# CONFIG_NLMON is not set
-# CONFIG_ARCNET is not set
-
-#
-# CAIF transport drivers
-#
-
-#
-# Distributed Switch Architecture drivers
-#
-# CONFIG_NET_DSA_MV88E6XXX is not set
-# CONFIG_NET_DSA_MV88E6060 is not set
-# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
-# CONFIG_NET_DSA_MV88E6131 is not set
-# CONFIG_NET_DSA_MV88E6123_61_65 is not set
-CONFIG_ETHERNET=y
-# CONFIG_NET_VENDOR_3COM is not set
-# CONFIG_NET_VENDOR_ADAPTEC is not set
-# CONFIG_NET_VENDOR_ALTEON is not set
-# CONFIG_NET_VENDOR_AMD is not set
-# CONFIG_NET_VENDOR_ARC is not set
-# CONFIG_NET_VENDOR_ATHEROS is not set
-# CONFIG_NET_CADENCE is not set
-# CONFIG_NET_VENDOR_BROADCOM is not set
-# CONFIG_NET_VENDOR_BROCADE is not set
-# CONFIG_NET_CALXEDA_XGMAC is not set
-# CONFIG_NET_VENDOR_CHELSIO is not set
-# CONFIG_NET_VENDOR_CISCO is not set
-# CONFIG_NET_VENDOR_LANTIQ is not set
-# CONFIG_DNET is not set
-# CONFIG_NET_VENDOR_DEC is not set
-# CONFIG_NET_VENDOR_DLINK is not set
-# CONFIG_NET_VENDOR_EMULEX is not set
-# CONFIG_NET_VENDOR_EXAR is not set
-# CONFIG_NET_VENDOR_HP is not set
-# CONFIG_NET_VENDOR_INTEL is not set
-# CONFIG_IP1000 is not set
-# CONFIG_JME is not set
-# CONFIG_NET_VENDOR_MARVELL is not set
-# CONFIG_NET_VENDOR_MELLANOX is not set
-# CONFIG_NET_VENDOR_MICREL is not set
-# CONFIG_NET_VENDOR_MICROCHIP is not set
-# CONFIG_NET_VENDOR_MYRI is not set
-# CONFIG_FEALNX is not set
-# CONFIG_NET_VENDOR_NATSEMI is not set
-# CONFIG_NET_VENDOR_NVIDIA is not set
-# CONFIG_NET_VENDOR_OKI is not set
-# CONFIG_ETHOC is not set
-# CONFIG_NET_PACKET_ENGINE is not set
-# CONFIG_NET_VENDOR_QLOGIC is not set
-# CONFIG_NET_VENDOR_REALTEK is not set
-# CONFIG_SH_ETH is not set
-# CONFIG_NET_VENDOR_RDC is not set
-# CONFIG_NET_VENDOR_SEEQ is not set
-# CONFIG_NET_VENDOR_SILAN is not set
-# CONFIG_NET_VENDOR_SIS is not set
-# CONFIG_SFC is not set
-# CONFIG_NET_VENDOR_SMSC is not set
-# CONFIG_NET_VENDOR_STMICRO is not set
-# CONFIG_NET_VENDOR_SUN is not set
-CONFIG_DWC_QOS=m
-CONFIG_DWC_QOS_DEBUGFS=y
-# CONFIG_DWC_QOS_PTP is not set
-# CONFIG_NET_VENDOR_TEHUTI is not set
-# CONFIG_NET_VENDOR_TI is not set
-# CONFIG_NET_VENDOR_VIA is not set
-# CONFIG_NET_VENDOR_WIZNET is not set
-# CONFIG_FDDI is not set
-# CONFIG_HIPPI is not set
-# CONFIG_NET_SB1000 is not set
-CONFIG_PHYLIB=y
-
-#
-# MII PHY device drivers
-#
-# CONFIG_AT803X_PHY is not set
-# CONFIG_AMD_PHY is not set
-# CONFIG_MARVELL_PHY is not set
-# CONFIG_DAVICOM_PHY is not set
-# CONFIG_QSEMI_PHY is not set
-# CONFIG_LXT_PHY is not set
-# CONFIG_CICADA_PHY is not set
-# CONFIG_VITESSE_PHY is not set
-# CONFIG_SMSC_PHY is not set
-# CONFIG_BROADCOM_PHY is not set
-# CONFIG_BCM87XX_PHY is not set
-# CONFIG_ICPLUS_PHY is not set
-# CONFIG_REALTEK_PHY is not set
-# CONFIG_NATIONAL_PHY is not set
-# CONFIG_STE10XP is not set
-# CONFIG_LSI_ET1011C_PHY is not set
-# CONFIG_MICREL_PHY is not set
-# CONFIG_FIXED_PHY is not set
-# CONFIG_MDIO_BITBANG is not set
-# CONFIG_MICREL_KS8995MA is not set
-# CONFIG_SFP_PHY is not set
-# CONFIG_PPP is not set
-# CONFIG_SLIP is not set
-
-#
-# USB Network Adapters
-#
-CONFIG_USB_CATC=y
-# CONFIG_USB_KAWETH is not set
-CONFIG_USB_PEGASUS=y
-CONFIG_USB_RTL8150=y
-# CONFIG_USB_RTL8152 is not set
-CONFIG_USB_USBNET=y
-CONFIG_USB_NET_AX8817X=y
-CONFIG_USB_NET_AX88179_178A=y
-CONFIG_USB_NET_CDCETHER=y
-CONFIG_USB_NET_CDC_EEM=y
-CONFIG_USB_NET_CDC_NCM=y
-# CONFIG_USB_NET_CDC_MBIM is not set
-CONFIG_USB_NET_DM9601=y
-CONFIG_USB_NET_SR9700=m
-CONFIG_USB_NET_SMSC75XX=y
-CONFIG_USB_NET_SMSC95XX=y
-# CONFIG_USB_NET_GL620A is not set
-CONFIG_USB_NET_NET1080=y
-# CONFIG_USB_NET_PLUSB is not set
-CONFIG_USB_NET_MCS7830=y
-# CONFIG_USB_NET_RNDIS_HOST is not set
-CONFIG_USB_NET_CDC_SUBSET=y
-# CONFIG_USB_ALI_M5632 is not set
-# CONFIG_USB_AN2720 is not set
-CONFIG_USB_BELKIN=y
-CONFIG_USB_ARMLINUX=y
-# CONFIG_USB_EPSON2888 is not set
-# CONFIG_USB_KC2190 is not set
-CONFIG_USB_NET_ZAURUS=y
-# CONFIG_USB_NET_CX82310_ETH is not set
-# CONFIG_USB_NET_KALMIA is not set
-# CONFIG_USB_NET_QMI_WWAN is not set
-# CONFIG_USB_NET_INT51X1 is not set
-CONFIG_USB_IPHETH=y
-CONFIG_USB_SIERRA_NET=y
-# CONFIG_USB_VL600 is not set
-CONFIG_WLAN=y
-# CONFIG_AIRO is not set
-# CONFIG_ATMEL is not set
-# CONFIG_PRISM54 is not set
-# CONFIG_USB_ZD1201 is not set
-# CONFIG_HOSTAP is not set
-# CONFIG_WL_TI is not set
-
-#
-# Enable WiMAX (Networking options) to see the WiMAX drivers
-#
-# CONFIG_WAN is not set
-# CONFIG_VMXNET3 is not set
-# CONFIG_ISDN is not set
-
-#
-# Input device support
-#
-# CONFIG_INPUT is not set
-
-#
-# Hardware I/O ports
-#
-# CONFIG_SERIO is not set
-# CONFIG_GAMEPORT is not set
-
-#
-# Character devices
-#
-CONFIG_TTY=y
-# CONFIG_VT is not set
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_LEGACY_PTYS is not set
-# CONFIG_SERIAL_NONSTANDARD is not set
-# CONFIG_NOZOMI is not set
-# CONFIG_N_GSM is not set
-# CONFIG_TRACE_SINK is not set
-# CONFIG_DEVKMEM is not set
-
-#
-# Serial drivers
-#
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
-CONFIG_SERIAL_8250_PNP=y
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_FIX_EARLYCON_MEM=y
-CONFIG_SERIAL_8250_PCI=y
-CONFIG_SERIAL_8250_NR_UARTS=2
-CONFIG_SERIAL_8250_RUNTIME_UARTS=1
-# CONFIG_SERIAL_8250_EXTENDED is not set
-# CONFIG_SERIAL_8250_DW is not set
-# CONFIG_SERIAL_HSU is not set
-
-#
-# Non-8250 serial port support
-#
-# CONFIG_SERIAL_MAX3100 is not set
-# CONFIG_SERIAL_MAX310X is not set
-CONFIG_SERIAL_CORE=y
-CONFIG_SERIAL_CORE_CONSOLE=y
-# CONFIG_SERIAL_JSM is not set
-# CONFIG_SERIAL_SCCNXP is not set
-# CONFIG_SERIAL_TIMBERDALE is not set
-# CONFIG_SERIAL_ALTERA_JTAGUART is not set
-# CONFIG_SERIAL_ALTERA_UART is not set
-# CONFIG_SERIAL_IFX6X60 is not set
-# CONFIG_SERIAL_PCH_UART is not set
-# CONFIG_SERIAL_ARC is not set
-# CONFIG_SERIAL_RP2 is not set
-# CONFIG_SERIAL_FSL_LPUART is not set
-# CONFIG_SERIAL_ST_ASC is not set
-# CONFIG_TTY_PRINTK is not set
-# CONFIG_IPMI_HANDLER is not set
-# CONFIG_HW_RANDOM is not set
-# CONFIG_NVRAM is not set
-# CONFIG_R3964 is not set
-# CONFIG_APPLICOM is not set
-# CONFIG_MWAVE is not set
-# CONFIG_PC8736x_GPIO is not set
-# CONFIG_NSC_GPIO is not set
-# CONFIG_RAW_DRIVER is not set
-CONFIG_HPET=y
-# CONFIG_HPET_MMAP is not set
-# CONFIG_HANGCHECK_TIMER is not set
-# CONFIG_TCG_TPM is not set
-# CONFIG_TELCLOCK is not set
-CONFIG_DEVPORT=y
-CONFIG_I2C=y
-CONFIG_I2C_BOARDINFO=y
-# CONFIG_I2C_COMPAT is not set
-CONFIG_I2C_CHARDEV=y
-# CONFIG_I2C_MUX is not set
-CONFIG_I2C_HELPER_AUTO=y
-
-#
-# I2C Hardware Bus support
-#
-
-#
-# PC SMBus host controller drivers
-#
-# CONFIG_I2C_ALI1535 is not set
-# CONFIG_I2C_ALI1563 is not set
-# CONFIG_I2C_ALI15X3 is not set
-# CONFIG_I2C_AMD756 is not set
-# CONFIG_I2C_AMD8111 is not set
-CONFIG_I2C_I801=y
-CONFIG_I2C_ISCH=y
-# CONFIG_I2C_ISMT is not set
-# CONFIG_I2C_PIIX4 is not set
-# CONFIG_I2C_NFORCE2 is not set
-# CONFIG_I2C_SIS5595 is not set
-# CONFIG_I2C_SIS630 is not set
-# CONFIG_I2C_SIS96X is not set
-# CONFIG_I2C_VIA is not set
-# CONFIG_I2C_VIAPRO is not set
-
-#
-# ACPI drivers
-#
-CONFIG_I2C_SCMI=y
-
-#
-# I2C system bus drivers (mostly embedded / system-on-chip)
-#
-# CONFIG_I2C_CBUS_GPIO is not set
-CONFIG_I2C_DESIGNWARE_CORE=y
-CONFIG_I2C_DESIGNWARE_PLATFORM=y
-CONFIG_I2C_DESIGNWARE_PCI=y
-# CONFIG_I2C_EG20T is not set
-# CONFIG_I2C_GPIO is not set
-# CONFIG_I2C_OCORES is not set
-# CONFIG_I2C_PCA_PLATFORM is not set
-# CONFIG_I2C_SIMTEC is not set
-# CONFIG_I2C_XILINX is not set
-
-#
-# External I2C/SMBus adapter drivers
-#
-# CONFIG_I2C_DIOLAN_U2C is not set
-# CONFIG_I2C_PARPORT_LIGHT is not set
-# CONFIG_I2C_TAOS_EVM is not set
-# CONFIG_I2C_TINY_USB is not set
-
-#
-# Other I2C/SMBus bus drivers
-#
-# CONFIG_SCx200_ACB is not set
-# CONFIG_I2C_STUB is not set
-# CONFIG_I2C_DEBUG_CORE is not set
-# CONFIG_I2C_DEBUG_ALGO is not set
-# CONFIG_I2C_DEBUG_BUS is not set
-CONFIG_SPI=y
-# CONFIG_SPI_DEBUG is not set
-CONFIG_SPI_MASTER=y
-
-#
-# SPI Master Controller Drivers
-#
-# CONFIG_SPI_ALTERA is not set
-# CONFIG_SPI_BITBANG is not set
-# CONFIG_SPI_GPIO is not set
-# CONFIG_SPI_FSL_DSPI is not set
-# CONFIG_SPI_OC_TINY is not set
-CONFIG_SPI_PXA2XX_DMA=y
-CONFIG_SPI_PXA2XX=y
-CONFIG_SPI_PXA2XX_PCI=y
-# CONFIG_SPI_SC18IS602 is not set
-# CONFIG_SPI_TOPCLIFF_PCH is not set
-# CONFIG_SPI_XCOMM is not set
-# CONFIG_SPI_XILINX is not set
-# CONFIG_SPI_DESIGNWARE is not set
-
-#
-# SPI Protocol Masters
-#
-# CONFIG_SPI_SPIDEV is not set
-# CONFIG_SPI_TLE62X0 is not set
-# CONFIG_HSI is not set
-
-#
-# PPS support
-#
-CONFIG_PPS=y
-# CONFIG_PPS_DEBUG is not set
-
-#
-# PPS clients support
-#
-# CONFIG_PPS_CLIENT_KTIMER is not set
-# CONFIG_PPS_CLIENT_LDISC is not set
-# CONFIG_PPS_CLIENT_GPIO is not set
-
-#
-# PPS generators support
-#
-
-#
-# PTP clock support
-#
-CONFIG_PTP_1588_CLOCK=y
-
-#
-# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
-#
-# CONFIG_PTP_1588_CLOCK_PCH is not set
-CONFIG_PINCTRL=y
-
-#
-# Pin controllers
-#
-# CONFIG_PINMUX is not set
-# CONFIG_PINCONF is not set
-# CONFIG_DEBUG_PINCTRL is not set
-# CONFIG_PINCTRL_BAYTRAIL is not set
-CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
-CONFIG_GPIO_DEVRES=y
-CONFIG_GPIOLIB=y
-CONFIG_GPIO_ACPI=y
-CONFIG_DEBUG_GPIO=y
-# CONFIG_GPIO_SYSFS is not set
-
-#
-# Memory mapped GPIO drivers:
-#
-# CONFIG_GPIO_GENERIC_PLATFORM is not set
-# CONFIG_GPIO_IT8761E is not set
-# CONFIG_GPIO_F7188X is not set
-# CONFIG_GPIO_TS5500 is not set
-# CONFIG_GPIO_SCH is not set
-CONFIG_GPIO_ICH=y
-# CONFIG_GPIO_VX855 is not set
-# CONFIG_GPIO_LYNXPOINT is not set
-
-#
-# I2C GPIO expanders:
-#
-# CONFIG_GPIO_MAX7300 is not set
-# CONFIG_GPIO_MAX732X is not set
-# CONFIG_GPIO_PCA953X is not set
-# CONFIG_GPIO_PCF857X is not set
-# CONFIG_GPIO_SX150X is not set
-# CONFIG_GPIO_ADP5588 is not set
-
-#
-# PCI GPIO expanders:
-#
-# CONFIG_GPIO_BT8XX is not set
-# CONFIG_GPIO_AMD8111 is not set
-# CONFIG_GPIO_LANGWELL is not set
-# CONFIG_GPIO_PCH is not set
-# CONFIG_GPIO_ML_IOH is not set
-# CONFIG_GPIO_RDC321X is not set
-
-#
-# SPI GPIO expanders:
-#
-# CONFIG_GPIO_MAX7301 is not set
-# CONFIG_GPIO_MCP23S08 is not set
-# CONFIG_GPIO_MC33880 is not set
-# CONFIG_GPIO_74X164 is not set
-
-#
-# AC97 GPIO expanders:
-#
-
-#
-# LPC GPIO expanders:
-#
-
-#
-# MODULbus GPIO expanders:
-#
-
-#
-# USB GPIO expanders:
-#
-CONFIG_GPIO_INTELCE2700=y
-# CONFIG_W1 is not set
-CONFIG_POWER_SUPPLY=y
-# CONFIG_POWER_SUPPLY_DEBUG is not set
-# CONFIG_PDA_POWER is not set
-# CONFIG_TEST_POWER is not set
-# CONFIG_BATTERY_DS2780 is not set
-# CONFIG_BATTERY_DS2781 is not set
-# CONFIG_BATTERY_DS2782 is not set
-# CONFIG_BATTERY_SBS is not set
-# CONFIG_BATTERY_BQ27x00 is not set
-# CONFIG_BATTERY_MAX17040 is not set
-# CONFIG_BATTERY_MAX17042 is not set
-# CONFIG_CHARGER_ISP1704 is not set
-# CONFIG_CHARGER_MAX8903 is not set
-# CONFIG_CHARGER_LP8727 is not set
-# CONFIG_CHARGER_GPIO is not set
-# CONFIG_CHARGER_BQ2415X is not set
-# CONFIG_CHARGER_BQ24190 is not set
-# CONFIG_CHARGER_SMB347 is not set
-# CONFIG_POWER_RESET is not set
-# CONFIG_POWER_AVS is not set
-# CONFIG_HWMON is not set
-CONFIG_THERMAL=y
-CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
-# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
-# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
-# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
-CONFIG_THERMAL_GOV_STEP_WISE=y
-CONFIG_THERMAL_GOV_USER_SPACE=y
-# CONFIG_CPU_THERMAL is not set
-# CONFIG_THERMAL_EMULATION is not set
-CONFIG_INTEL_POWERCLAMP=y
-CONFIG_X86_PKG_TEMP_THERMAL=y
-
-#
-# Texas Instruments thermal drivers
-#
-CONFIG_PUMA_THERMAL_USE_IOSF_PRIMARY=y
-CONFIG_PUMA_THERMAL=y
-CONFIG_WATCHDOG=y
-CONFIG_WATCHDOG_CORE=y
-# CONFIG_WATCHDOG_NOWAYOUT is not set
-
-#
-# Watchdog Device Drivers
-#
-# CONFIG_SOFT_WATCHDOG is not set
-# CONFIG_ACQUIRE_WDT is not set
-# CONFIG_ADVANTECH_WDT is not set
-# CONFIG_ALIM1535_WDT is not set
-# CONFIG_ALIM7101_WDT is not set
-# CONFIG_F71808E_WDT is not set
-# CONFIG_SP5100_TCO is not set
-# CONFIG_SC520_WDT is not set
-# CONFIG_SBC_FITPC2_WATCHDOG is not set
-# CONFIG_EUROTECH_WDT is not set
-# CONFIG_IB700_WDT is not set
-# CONFIG_IBMASR is not set
-# CONFIG_WAFER_WDT is not set
-# CONFIG_I6300ESB_WDT is not set
-# CONFIG_IE6XX_WDT is not set
-CONFIG_ITCO_WDT=y
-# CONFIG_ITCO_VENDOR_SUPPORT is not set
-# CONFIG_IT8712F_WDT is not set
-# CONFIG_IT87_WDT is not set
-# CONFIG_HP_WATCHDOG is not set
-# CONFIG_SC1200_WDT is not set
-# CONFIG_PC87413_WDT is not set
-# CONFIG_NV_TCO is not set
-# CONFIG_60XX_WDT is not set
-# CONFIG_SBC8360_WDT is not set
-# CONFIG_SBC7240_WDT is not set
-# CONFIG_CPU5_WDT is not set
-# CONFIG_SMSC_SCH311X_WDT is not set
-# CONFIG_SMSC37B787_WDT is not set
-# CONFIG_VIA_WDT is not set
-# CONFIG_W83627HF_WDT is not set
-# CONFIG_W83697HF_WDT is not set
-# CONFIG_W83697UG_WDT is not set
-# CONFIG_W83877F_WDT is not set
-# CONFIG_W83977F_WDT is not set
-# CONFIG_MACHZ_WDT is not set
-# CONFIG_SBC_EPX_C3_WATCHDOG is not set
-# CONFIG_MEN_A21_WDT is not set
-
-#
-# PCI-based Watchdog Cards
-#
-# CONFIG_PCIPCWATCHDOG is not set
-# CONFIG_WDTPCI is not set
-
-#
-# USB-based Watchdog Cards
-#
-# CONFIG_USBPCWATCHDOG is not set
-CONFIG_SSB_POSSIBLE=y
-
-#
-# Sonics Silicon Backplane
-#
-# CONFIG_SSB is not set
-CONFIG_BCMA_POSSIBLE=y
-
-#
-# Broadcom specific AMBA
-#
-# CONFIG_BCMA is not set
-
-#
-# Multifunction device drivers
-#
-CONFIG_MFD_CORE=y
-# CONFIG_MFD_CS5535 is not set
-# CONFIG_MFD_AS3711 is not set
-# CONFIG_PMIC_ADP5520 is not set
-# CONFIG_MFD_AAT2870_CORE is not set
-# CONFIG_MFD_CROS_EC is not set
-# CONFIG_PMIC_DA903X is not set
-# CONFIG_MFD_DA9052_SPI is not set
-# CONFIG_MFD_DA9052_I2C is not set
-# CONFIG_MFD_DA9055 is not set
-# CONFIG_MFD_DA9063 is not set
-# CONFIG_MFD_MC13XXX_SPI is not set
-# CONFIG_MFD_MC13XXX_I2C is not set
-# CONFIG_HTC_PASIC3 is not set
-# CONFIG_HTC_I2CPLD is not set
-CONFIG_LPC_ICH=y
-CONFIG_LPC_SCH=y
-# CONFIG_MFD_JANZ_CMODIO is not set
-# CONFIG_MFD_KEMPLD is not set
-# CONFIG_MFD_88PM800 is not set
-# CONFIG_MFD_88PM805 is not set
-# CONFIG_MFD_88PM860X is not set
-# CONFIG_MFD_MAX77686 is not set
-# CONFIG_MFD_MAX77693 is not set
-# CONFIG_MFD_MAX8907 is not set
-# CONFIG_MFD_MAX8925 is not set
-# CONFIG_MFD_MAX8997 is not set
-# CONFIG_MFD_MAX8998 is not set
-# CONFIG_EZX_PCAP is not set
-# CONFIG_MFD_VIPERBOARD is not set
-# CONFIG_MFD_RETU is not set
-# CONFIG_MFD_PCF50633 is not set
-# CONFIG_MFD_RDC321X is not set
-# CONFIG_MFD_RTSX_PCI is not set
-# CONFIG_MFD_RC5T583 is not set
-# CONFIG_MFD_SEC_CORE is not set
-# CONFIG_MFD_SI476X_CORE is not set
-# CONFIG_MFD_SM501 is not set
-# CONFIG_MFD_SMSC is not set
-# CONFIG_ABX500_CORE is not set
-# CONFIG_MFD_STMPE is not set
-# CONFIG_MFD_SYSCON is not set
-# CONFIG_MFD_TI_AM335X_TSCADC is not set
-# CONFIG_MFD_LP8788 is not set
-# CONFIG_MFD_PALMAS is not set
-# CONFIG_TPS6105X is not set
-# CONFIG_TPS65010 is not set
-# CONFIG_TPS6507X is not set
-# CONFIG_MFD_TPS65090 is not set
-# CONFIG_MFD_TPS65217 is not set
-# CONFIG_MFD_TPS6586X is not set
-# CONFIG_MFD_TPS65910 is not set
-# CONFIG_MFD_TPS65912 is not set
-# CONFIG_MFD_TPS65912_I2C is not set
-# CONFIG_MFD_TPS65912_SPI is not set
-# CONFIG_MFD_TPS80031 is not set
-# CONFIG_TWL4030_CORE is not set
-# CONFIG_TWL6040_CORE is not set
-# CONFIG_MFD_WL1273_CORE is not set
-# CONFIG_MFD_LM3533 is not set
-# CONFIG_MFD_TIMBERDALE is not set
-# CONFIG_MFD_TC3589X is not set
-# CONFIG_MFD_TMIO is not set
-# CONFIG_MFD_VX855 is not set
-# CONFIG_MFD_ARIZONA_I2C is not set
-# CONFIG_MFD_ARIZONA_SPI is not set
-# CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM831X_I2C is not set
-# CONFIG_MFD_WM831X_SPI is not set
-# CONFIG_MFD_WM8350_I2C is not set
-# CONFIG_MFD_WM8994 is not set
-CONFIG_REGULATOR=y
-# CONFIG_REGULATOR_DEBUG is not set
-# CONFIG_REGULATOR_DUMMY is not set
-# CONFIG_REGULATOR_FIXED_VOLTAGE is not set
-# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
-# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
-# CONFIG_REGULATOR_AD5398 is not set
-# CONFIG_REGULATOR_DA9210 is not set
-# CONFIG_REGULATOR_FAN53555 is not set
-# CONFIG_REGULATOR_GPIO is not set
-# CONFIG_REGULATOR_ISL6271A is not set
-# CONFIG_REGULATOR_LP3971 is not set
-# CONFIG_REGULATOR_LP3972 is not set
-# CONFIG_REGULATOR_LP872X is not set
-# CONFIG_REGULATOR_LP8755 is not set
-# CONFIG_REGULATOR_MAX1586 is not set
-# CONFIG_REGULATOR_MAX8649 is not set
-# CONFIG_REGULATOR_MAX8660 is not set
-# CONFIG_REGULATOR_MAX8952 is not set
-# CONFIG_REGULATOR_MAX8973 is not set
-# CONFIG_REGULATOR_PFUZE100 is not set
-# CONFIG_REGULATOR_TPS51632 is not set
-# CONFIG_REGULATOR_TPS62360 is not set
-# CONFIG_REGULATOR_TPS65023 is not set
-# CONFIG_REGULATOR_TPS6507X is not set
-# CONFIG_REGULATOR_TPS6524X is not set
-CONFIG_REGULATOR_INT34D9=y
-# CONFIG_MEDIA_SUPPORT is not set
-
-#
-# Graphics support
-#
-# CONFIG_AGP is not set
-# CONFIG_VGA_ARB is not set
-# CONFIG_VGA_SWITCHEROO is not set
-# CONFIG_DRM is not set
-# CONFIG_VGASTATE is not set
-# CONFIG_VIDEO_OUTPUT_CONTROL is not set
-# CONFIG_FB is not set
-# CONFIG_EXYNOS_VIDEO is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
-# CONFIG_SOUND is not set
-CONFIG_USB_OHCI_LITTLE_ENDIAN=y
-CONFIG_USB_SUPPORT=y
-CONFIG_USB_COMMON=y
-CONFIG_USB_ARCH_HAS_HCD=y
-CONFIG_USB=y
-# CONFIG_USB_DEBUG is not set
-CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
-
-#
-# Miscellaneous USB options
-#
-CONFIG_USB_DEFAULT_PERSIST=y
-CONFIG_USB_DYNAMIC_MINORS=y
-# CONFIG_USB_OTG_WHITELIST is not set
-# CONFIG_USB_OTG_BLACKLIST_HUB is not set
-CONFIG_USB_MON=y
-# CONFIG_USB_WUSB_CBAF is not set
-
-#
-# USB Host Controller Drivers
-#
-# CONFIG_USB_C67X00_HCD is not set
-CONFIG_USB_XHCI_HCD=y
-# CONFIG_USB_EHCI_HCD is not set
-# CONFIG_USB_OXU210HP_HCD is not set
-# CONFIG_USB_ISP116X_HCD is not set
-# CONFIG_USB_ISP1760_HCD is not set
-# CONFIG_USB_ISP1362_HCD is not set
-# CONFIG_USB_FUSBH200_HCD is not set
-# CONFIG_USB_FOTG210_HCD is not set
-# CONFIG_USB_OHCI_HCD is not set
-# CONFIG_USB_UHCI_HCD is not set
-# CONFIG_USB_SL811_HCD is not set
-# CONFIG_USB_R8A66597_HCD is not set
-# CONFIG_USB_HCD_TEST_MODE is not set
-# CONFIG_USB_MUSB_HDRC is not set
-# CONFIG_USB_RENESAS_USBHS is not set
-
-#
-# USB Device Class drivers
-#
-# CONFIG_USB_ACM is not set
-# CONFIG_USB_PRINTER is not set
-# CONFIG_USB_WDM is not set
-# CONFIG_USB_TMC is not set
-
-#
-# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
-#
-
-#
-# also be needed; see USB_STORAGE Help for more info
-#
-CONFIG_USB_STORAGE=y
-# CONFIG_USB_STORAGE_DEBUG is not set
-# CONFIG_USB_STORAGE_REALTEK is not set
-# CONFIG_USB_STORAGE_DATAFAB is not set
-# CONFIG_USB_STORAGE_FREECOM is not set
-# CONFIG_USB_STORAGE_ISD200 is not set
-# CONFIG_USB_STORAGE_USBAT is not set
-CONFIG_USB_STORAGE_SDDR09=y
-CONFIG_USB_STORAGE_SDDR55=y
-# CONFIG_USB_STORAGE_JUMPSHOT is not set
-# CONFIG_USB_STORAGE_ALAUDA is not set
-# CONFIG_USB_STORAGE_KARMA is not set
-# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
-# CONFIG_USB_STORAGE_ENE_UB6250 is not set
-
-#
-# USB Imaging devices
-#
-# CONFIG_USB_MDC800 is not set
-# CONFIG_USB_MICROTEK is not set
-# CONFIG_USB_DWC3 is not set
-# CONFIG_USB_CHIPIDEA is not set
-
-#
-# USB port drivers
-#
-# CONFIG_USB_SERIAL is not set
-
-#
-# USB Miscellaneous drivers
-#
-# CONFIG_USB_EMI62 is not set
-# CONFIG_USB_EMI26 is not set
-# CONFIG_USB_ADUTUX is not set
-# CONFIG_USB_SEVSEG is not set
-# CONFIG_USB_RIO500 is not set
-# CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_LCD is not set
-# CONFIG_USB_LED is not set
-# CONFIG_USB_CYPRESS_CY7C63 is not set
-# CONFIG_USB_CYTHERM is not set
-# CONFIG_USB_IDMOUSE is not set
-# CONFIG_USB_FTDI_ELAN is not set
-# CONFIG_USB_APPLEDISPLAY is not set
-# CONFIG_USB_LD is not set
-# CONFIG_USB_TRANCEVIBRATOR is not set
-# CONFIG_USB_IOWARRIOR is not set
-# CONFIG_USB_TEST is not set
-# CONFIG_USB_EHSET_TEST_FIXTURE is not set
-# CONFIG_USB_ISIGHTFW is not set
-# CONFIG_USB_YUREX is not set
-# CONFIG_USB_EZUSB_FX2 is not set
-# CONFIG_USB_HSIC_USB3503 is not set
-
-#
-# USB Physical Layer drivers
-#
-CONFIG_USB_PHY=y
-# CONFIG_USB_OTG_FSM is not set
-CONFIG_NOP_USB_XCEIV=y
-# CONFIG_AM335X_PHY_USB is not set
-# CONFIG_SAMSUNG_USB2PHY is not set
-# CONFIG_SAMSUNG_USB3PHY is not set
-# CONFIG_USB_GPIO_VBUS is not set
-# CONFIG_USB_ISP1301 is not set
-# CONFIG_USB_RCAR_PHY is not set
-CONFIG_USB_GADGET=y
-# CONFIG_USB_GADGET_DEBUG is not set
-# CONFIG_USB_GADGET_DEBUG_FILES is not set
-CONFIG_USB_GADGET_VBUS_DRAW=500
-CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
-
-#
-# USB Peripheral Controller
-#
-# CONFIG_USB_FUSB300 is not set
-# CONFIG_USB_FOTG210_UDC is not set
-# CONFIG_USB_R8A66597 is not set
-# CONFIG_USB_PXA27X is not set
-# CONFIG_USB_MV_UDC is not set
-# CONFIG_USB_MV_U3D is not set
-# CONFIG_USB_M66592 is not set
-# CONFIG_USB_AMD5536UDC is not set
-# CONFIG_USB_NET2272 is not set
-# CONFIG_USB_NET2280 is not set
-# CONFIG_USB_GOKU is not set
-# CONFIG_USB_EG20T is not set
-# CONFIG_USB_DUMMY_HCD is not set
-# CONFIG_USB_CONFIGFS is not set
-# CONFIG_USB_ZERO is not set
-# CONFIG_USB_ETH is not set
-# CONFIG_USB_G_NCM is not set
-# CONFIG_USB_GADGETFS is not set
-# CONFIG_USB_FUNCTIONFS is not set
-# CONFIG_USB_MASS_STORAGE is not set
-# CONFIG_USB_G_SERIAL is not set
-# CONFIG_USB_G_PRINTER is not set
-# CONFIG_USB_CDC_COMPOSITE is not set
-# CONFIG_USB_G_ACM_MS is not set
-# CONFIG_USB_G_MULTI is not set
-# CONFIG_USB_G_HID is not set
-# CONFIG_USB_G_DBGP is not set
-# CONFIG_UWB is not set
-CONFIG_MMC=y
-# CONFIG_MMC_DEBUG is not set
-# CONFIG_MMC_UNSAFE_RESUME is not set
-# CONFIG_MMC_CLKGATE is not set
-# CONFIG_MMC_EMBEDDED_SDIO is not set
-# CONFIG_MMC_PARANOID_SD_INIT is not set
-
-#
-# MMC/SD/SDIO Card Drivers
-#
-CONFIG_MMC_BLOCK=y
-CONFIG_MMC_BLOCK_MINORS=32
-CONFIG_MMC_BLOCK_BOUNCE=y
-CONFIG_SDIO_UART=y
-# CONFIG_MMC_TEST is not set
-
-#
-# MMC/SD/SDIO Host Controller Drivers
-#
-CONFIG_MMC_SDHCI=y
-CONFIG_MMC_SDHCI_IO_ACCESSORS=y
-# CONFIG_MMC_SDHCI_PCI is not set
-CONFIG_MMC_SDHCI_ACPI=y
-# CONFIG_MMC_SDHCI_ACPI_FORCE_POWER_ON is not set
-# CONFIG_MMC_SDHCI_PLTFM is not set
-# CONFIG_MMC_SDHCI_PXAV3 is not set
-# CONFIG_MMC_SDHCI_PXAV2 is not set
-CONFIG_MMC_WBSD=y
-# CONFIG_MMC_TIFM_SD is not set
-# CONFIG_MMC_CB710 is not set
-# CONFIG_MMC_VIA_SDMMC is not set
-# CONFIG_MMC_VUB300 is not set
-# CONFIG_MMC_USHC is not set
-# CONFIG_MEMSTICK is not set
-# CONFIG_NEW_LEDS is not set
-# CONFIG_ACCESSIBILITY is not set
-# CONFIG_INFINIBAND is not set
-# CONFIG_EDAC is not set
-CONFIG_RTC_LIB=y
-# CONFIG_RTC_CLASS is not set
-# CONFIG_DMADEVICES is not set
-# CONFIG_AUXDISPLAY is not set
-# CONFIG_UIO is not set
-# CONFIG_VIRT_DRIVERS is not set
-
-#
-# Virtio drivers
-#
-# CONFIG_VIRTIO_PCI is not set
-# CONFIG_VIRTIO_MMIO is not set
-
-#
-# Microsoft Hyper-V guest support
-#
-# CONFIG_STAGING is not set
-CONFIG_X86_PLATFORM_DEVICES=y
-# CONFIG_ACERHDF is not set
-# CONFIG_CHROMEOS_LAPTOP is not set
-# CONFIG_INTEL_MENLOW is not set
-# CONFIG_ACPI_WMI is not set
-# CONFIG_TOSHIBA_BT_RFKILL is not set
-# CONFIG_ACPI_CMPC is not set
-# CONFIG_INTEL_IPS is not set
-# CONFIG_IBM_RTL is not set
-# CONFIG_SAMSUNG_Q10 is not set
-# CONFIG_INTEL_RST is not set
-# CONFIG_INTEL_SMARTCONNECT is not set
-# CONFIG_PVPANIC is not set
-CONFIG_PUMA_ACPI=y
-CONFIG_CLKDEV_LOOKUP=y
-CONFIG_HAVE_CLK_PREPARE=y
-CONFIG_COMMON_CLK=y
-
-#
-# Common Clock Framework
-#
-# CONFIG_COMMON_CLK_DEBUG is not set
-# CONFIG_COMMON_CLK_SI5351 is not set
-
-#
-# Hardware Spinlock drivers
-#
-CONFIG_CLKSRC_I8253=y
-CONFIG_CLKEVT_I8253=y
-CONFIG_CLKBLD_I8253=y
-# CONFIG_MAILBOX is not set
-# CONFIG_IOMMU_SUPPORT is not set
-
-#
-# Remoteproc drivers
-#
-# CONFIG_STE_MODEM_RPROC is not set
-
-#
-# Rpmsg drivers
-#
-# CONFIG_PM_DEVFREQ is not set
-# CONFIG_EXTCON is not set
-# CONFIG_MEMORY is not set
-# CONFIG_IIO is not set
-# CONFIG_NTB is not set
-# CONFIG_VME_BUS is not set
-# CONFIG_PWM is not set
-# CONFIG_IPACK_BUS is not set
-CONFIG_RESET_CONTROLLER=y
-# CONFIG_FMC is not set
-# CONFIG_MRPC is not set
-
-#
-# Firmware Drivers
-#
-# CONFIG_EDD is not set
-# CONFIG_FIRMWARE_MEMMAP is not set
-# CONFIG_DELL_RBU is not set
-# CONFIG_DCDBAS is not set
-CONFIG_DMIID=y
-# CONFIG_DMI_SYSFS is not set
-# CONFIG_ISCSI_IBFT_FIND is not set
-# CONFIG_GOOGLE_FIRMWARE is not set
-
-#
-# EFI (Extensible Firmware Interface) Support
-#
-# CONFIG_EFI_VARS is not set
-
-#
-# File systems
-#
-CONFIG_DCACHE_WORD_ACCESS=y
-# CONFIG_EXT2_FS is not set
-CONFIG_EXT3_FS=y
-# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
-# CONFIG_EXT3_FS_XATTR is not set
-# CONFIG_EXT4_FS is not set
-CONFIG_JBD=y
-# CONFIG_REISERFS_FS is not set
-# CONFIG_JFS_FS is not set
-# CONFIG_XFS_FS is not set
-# CONFIG_GFS2_FS is not set
-# CONFIG_BTRFS_FS is not set
-# CONFIG_NILFS2_FS is not set
-CONFIG_FS_POSIX_ACL=y
-CONFIG_EXPORTFS=y
-CONFIG_FILE_LOCKING=y
-CONFIG_FSNOTIFY=y
-CONFIG_DNOTIFY=y
-CONFIG_INOTIFY_USER=y
-CONFIG_FANOTIFY=y
-# CONFIG_FANOTIFY_ACCESS_PERMISSIONS is not set
-CONFIG_QUOTA=y
-CONFIG_QUOTA_NETLINK_INTERFACE=y
-# CONFIG_PRINT_QUOTA_WARNING is not set
-# CONFIG_QUOTA_DEBUG is not set
-CONFIG_QUOTA_TREE=y
-# CONFIG_QFMT_V1 is not set
-CONFIG_QFMT_V2=y
-CONFIG_QUOTACTL=y
-CONFIG_AUTOFS4_FS=y
-# CONFIG_FUSE_FS is not set
-CONFIG_GENERIC_ACL=y
-
-#
-# Caches
-#
-# CONFIG_FSCACHE is not set
-
-#
-# CD-ROM/DVD Filesystems
-#
-# CONFIG_ISO9660_FS is not set
-# CONFIG_UDF_FS is not set
-
-#
-# DOS/FAT/NT Filesystems
-#
-CONFIG_FAT_FS=y
-# CONFIG_MSDOS_FS is not set
-CONFIG_VFAT_FS=y
-CONFIG_FAT_DEFAULT_CODEPAGE=437
-CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
-
-#
-# Pseudo filesystems
-#
-CONFIG_PROC_FS=y
-# CONFIG_PROC_KCORE is not set
-CONFIG_PROC_VMCORE=y
-CONFIG_PROC_SYSCTL=y
-CONFIG_PROC_PAGE_MONITOR=y
-CONFIG_SYSFS=y
-CONFIG_TMPFS=y
-CONFIG_TMPFS_POSIX_ACL=y
-CONFIG_TMPFS_XATTR=y
-# CONFIG_HUGETLBFS is not set
-# CONFIG_HUGETLB_PAGE is not set
-# CONFIG_CONFIGFS_FS is not set
-CONFIG_MISC_FILESYSTEMS=y
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_ECRYPT_FS is not set
-# CONFIG_HFS_FS is not set
-# CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
-# CONFIG_LOGFS is not set
-# CONFIG_CRAMFS is not set
-CONFIG_SQUASHFS=y
-CONFIG_SQUASHFS_XATTR=y
-CONFIG_SQUASHFS_ZLIB=y
-CONFIG_SQUASHFS_LZO=y
-CONFIG_SQUASHFS_XZ=y
-# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
-CONFIG_SQUASHFS_EMBEDDED=y
-CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
-# CONFIG_VXFS_FS is not set
-# CONFIG_MINIX_FS is not set
-# CONFIG_OMFS_FS is not set
-# CONFIG_HPFS_FS is not set
-# CONFIG_QNX4FS_FS is not set
-# CONFIG_QNX6FS_FS is not set
-# CONFIG_ROMFS_FS is not set
-# CONFIG_PSTORE is not set
-# CONFIG_SYSV_FS is not set
-# CONFIG_UFS_FS is not set
-# CONFIG_F2FS_FS is not set
-# CONFIG_EFIVAR_FS is not set
-CONFIG_NETWORK_FILESYSTEMS=y
-CONFIG_NFS_FS=y
-CONFIG_NFS_V2=y
-CONFIG_NFS_V3=y
-# CONFIG_NFS_V3_ACL is not set
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFS_SWAP is not set
-CONFIG_ROOT_NFS=y
-# CONFIG_NFSD is not set
-CONFIG_LOCKD=y
-CONFIG_LOCKD_V4=y
-CONFIG_NFS_COMMON=y
-CONFIG_SUNRPC=y
-# CONFIG_SUNRPC_DEBUG is not set
-# CONFIG_CEPH_FS is not set
-# CONFIG_CIFS is not set
-# CONFIG_NCP_FS is not set
-# CONFIG_CODA_FS is not set
-# CONFIG_AFS_FS is not set
-CONFIG_NLS=y
-CONFIG_NLS_DEFAULT="utf8"
-CONFIG_NLS_CODEPAGE_437=y
-# CONFIG_NLS_CODEPAGE_737 is not set
-# CONFIG_NLS_CODEPAGE_775 is not set
-# CONFIG_NLS_CODEPAGE_850 is not set
-# CONFIG_NLS_CODEPAGE_852 is not set
-# CONFIG_NLS_CODEPAGE_855 is not set
-# CONFIG_NLS_CODEPAGE_857 is not set
-# CONFIG_NLS_CODEPAGE_860 is not set
-# CONFIG_NLS_CODEPAGE_861 is not set
-# CONFIG_NLS_CODEPAGE_862 is not set
-# CONFIG_NLS_CODEPAGE_863 is not set
-# CONFIG_NLS_CODEPAGE_864 is not set
-# CONFIG_NLS_CODEPAGE_865 is not set
-# CONFIG_NLS_CODEPAGE_866 is not set
-# CONFIG_NLS_CODEPAGE_869 is not set
-# CONFIG_NLS_CODEPAGE_936 is not set
-# CONFIG_NLS_CODEPAGE_950 is not set
-# CONFIG_NLS_CODEPAGE_932 is not set
-# CONFIG_NLS_CODEPAGE_949 is not set
-# CONFIG_NLS_CODEPAGE_874 is not set
-# CONFIG_NLS_ISO8859_8 is not set
-# CONFIG_NLS_CODEPAGE_1250 is not set
-# CONFIG_NLS_CODEPAGE_1251 is not set
-CONFIG_NLS_ASCII=y
-CONFIG_NLS_ISO8859_1=y
-# CONFIG_NLS_ISO8859_2 is not set
-# CONFIG_NLS_ISO8859_3 is not set
-# CONFIG_NLS_ISO8859_4 is not set
-# CONFIG_NLS_ISO8859_5 is not set
-# CONFIG_NLS_ISO8859_6 is not set
-# CONFIG_NLS_ISO8859_7 is not set
-# CONFIG_NLS_ISO8859_9 is not set
-# CONFIG_NLS_ISO8859_13 is not set
-# CONFIG_NLS_ISO8859_14 is not set
-# CONFIG_NLS_ISO8859_15 is not set
-# CONFIG_NLS_KOI8_R is not set
-# CONFIG_NLS_KOI8_U is not set
-# CONFIG_NLS_MAC_ROMAN is not set
-# CONFIG_NLS_MAC_CELTIC is not set
-# CONFIG_NLS_MAC_CENTEURO is not set
-# CONFIG_NLS_MAC_CROATIAN is not set
-# CONFIG_NLS_MAC_CYRILLIC is not set
-# CONFIG_NLS_MAC_GAELIC is not set
-# CONFIG_NLS_MAC_GREEK is not set
-# CONFIG_NLS_MAC_ICELAND is not set
-# CONFIG_NLS_MAC_INUIT is not set
-# CONFIG_NLS_MAC_ROMANIAN is not set
-# CONFIG_NLS_MAC_TURKISH is not set
-CONFIG_NLS_UTF8=y
-
-#
-# Kernel hacking
-#
-CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-
-#
-# printk and dmesg options
-#
-CONFIG_DEFAULT_MESSAGE_LOGLEVEL=7
-
-#
-# Compile-time checks and compiler options
-#
-CONFIG_DEBUG_INFO=y
-# CONFIG_DEBUG_INFO_REDUCED is not set
-# CONFIG_ENABLE_WARN_DEPRECATED is not set
-# CONFIG_ENABLE_MUST_CHECK is not set
-CONFIG_FRAME_WARN=2048
-# CONFIG_STRIP_ASM_SYMS is not set
-# CONFIG_READABLE_ASM is not set
-# CONFIG_UNUSED_SYMBOLS is not set
-# CONFIG_DEBUG_FS is not set
-# CONFIG_HEADERS_CHECK is not set
-# CONFIG_DEBUG_SECTION_MISMATCH is not set
-CONFIG_ARCH_WANT_FRAME_POINTERS=y
-# CONFIG_FRAME_POINTER is not set
-# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
-# CONFIG_MAGIC_SYSRQ is not set
-CONFIG_DEBUG_KERNEL=y
-
-#
-# Memory Debugging
-#
-# CONFIG_DEBUG_PAGEALLOC is not set
-# CONFIG_DEBUG_OBJECTS is not set
-CONFIG_HAVE_DEBUG_KMEMLEAK=y
-# CONFIG_DEBUG_KMEMLEAK is not set
-# CONFIG_DEBUG_STACK_USAGE is not set
-# CONFIG_DEBUG_VM is not set
-# CONFIG_DEBUG_VIRTUAL is not set
-# CONFIG_DEBUG_MEMORY_INIT is not set
-# CONFIG_DEBUG_PER_CPU_MAPS is not set
-# CONFIG_DEBUG_HIGHMEM is not set
-CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
-# CONFIG_DEBUG_STACKOVERFLOW is not set
-CONFIG_HAVE_ARCH_KMEMCHECK=y
-# CONFIG_DEBUG_SHIRQ is not set
-
-#
-# Debug Lockups and Hangs
-#
-# CONFIG_LOCKUP_DETECTOR is not set
-# CONFIG_DETECT_HUNG_TASK is not set
-# CONFIG_PANIC_ON_OOPS is not set
-CONFIG_PANIC_ON_OOPS_VALUE=0
-# CONFIG_SCHED_DEBUG is not set
-# CONFIG_SCHEDSTATS is not set
-# CONFIG_TIMER_STATS is not set
-# CONFIG_DEBUG_PREEMPT is not set
-
-#
-# Lock Debugging (spinlocks, mutexes, etc...)
-#
-# CONFIG_DEBUG_RT_MUTEXES is not set
-# CONFIG_RT_MUTEX_TESTER is not set
-# CONFIG_DEBUG_SPINLOCK is not set
-# CONFIG_DEBUG_MUTEXES is not set
-# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
-# CONFIG_DEBUG_LOCK_ALLOC is not set
-# CONFIG_PROVE_LOCKING is not set
-# CONFIG_LOCK_STAT is not set
-# CONFIG_DEBUG_ATOMIC_SLEEP is not set
-# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
-# CONFIG_DEBUG_KOBJECT is not set
-# CONFIG_DEBUG_WRITECOUNT is not set
-# CONFIG_DEBUG_LIST is not set
-# CONFIG_DEBUG_SG is not set
-# CONFIG_DEBUG_NOTIFIERS is not set
-# CONFIG_DEBUG_CREDENTIALS is not set
-
-#
-# RCU Debugging
-#
-# CONFIG_PROVE_RCU_DELAY is not set
-# CONFIG_SPARSE_RCU_POINTER is not set
-# CONFIG_RCU_TORTURE_TEST is not set
-CONFIG_RCU_CPU_STALL_TIMEOUT=300
-# CONFIG_RCU_CPU_STALL_VERBOSE is not set
-# CONFIG_RCU_CPU_STALL_INFO is not set
-# CONFIG_RCU_TRACE is not set
-# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
-# CONFIG_NOTIFIER_ERROR_INJECTION is not set
-# CONFIG_FAULT_INJECTION is not set
-# CONFIG_LATENCYTOP is not set
-CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS=y
-# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
-CONFIG_USER_STACKTRACE_SUPPORT=y
-CONFIG_HAVE_FUNCTION_TRACER=y
-CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
-CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
-CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
-CONFIG_HAVE_DYNAMIC_FTRACE=y
-CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
-CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
-CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
-CONFIG_HAVE_C_RECORDMCOUNT=y
-CONFIG_TRACING_SUPPORT=y
-# CONFIG_FTRACE is not set
-
-#
-# Runtime Testing
-#
-# CONFIG_TEST_LIST_SORT is not set
-# CONFIG_BACKTRACE_SELF_TEST is not set
-# CONFIG_RBTREE_TEST is not set
-# CONFIG_INTERVAL_TREE_TEST is not set
-# CONFIG_ATOMIC64_SELFTEST is not set
-# CONFIG_TEST_STRING_HELPERS is not set
-# CONFIG_TEST_KSTRTOX is not set
-# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
-# CONFIG_DMA_API_DEBUG is not set
-# CONFIG_SAMPLES is not set
-CONFIG_HAVE_ARCH_KGDB=y
-# CONFIG_KGDB is not set
-# CONFIG_STRICT_DEVMEM is not set
-# CONFIG_X86_VERBOSE_BOOTUP is not set
-# CONFIG_EARLY_PRINTK is not set
-# CONFIG_X86_PTDUMP is not set
-# CONFIG_DEBUG_RODATA is not set
-# CONFIG_DEBUG_SET_MODULE_RONX is not set
-# CONFIG_DEBUG_NX_TEST is not set
-# CONFIG_DOUBLEFAULT is not set
-# CONFIG_DEBUG_TLBFLUSH is not set
-# CONFIG_IOMMU_STRESS is not set
-CONFIG_HAVE_MMIOTRACE_SUPPORT=y
-CONFIG_IO_DELAY_TYPE_0X80=0
-CONFIG_IO_DELAY_TYPE_0XED=1
-CONFIG_IO_DELAY_TYPE_UDELAY=2
-CONFIG_IO_DELAY_TYPE_NONE=3
-CONFIG_IO_DELAY_0X80=y
-# CONFIG_IO_DELAY_0XED is not set
-# CONFIG_IO_DELAY_UDELAY is not set
-# CONFIG_IO_DELAY_NONE is not set
-CONFIG_DEFAULT_IO_DELAY_TYPE=0
-# CONFIG_CPA_DEBUG is not set
-CONFIG_OPTIMIZE_INLINING=y
-# CONFIG_DEBUG_NMI_SELFTEST is not set
-# CONFIG_X86_DEBUG_STATIC_CPU_HAS is not set
-
-#
-# Security options
-#
-CONFIG_KEYS=y
-# CONFIG_ENCRYPTED_KEYS is not set
-# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
-# CONFIG_SECURITY_DMESG_RESTRICT is not set
-CONFIG_SECURITY=y
-# CONFIG_SECURITYFS is not set
-# CONFIG_SECURITY_NETWORK is not set
-# CONFIG_SECURITY_PATH is not set
-# CONFIG_SECURITY_SMACK is not set
-# CONFIG_SECURITY_TOMOYO is not set
-# CONFIG_SECURITY_APPARMOR is not set
-# CONFIG_SECURITY_YAMA is not set
-# CONFIG_IMA is not set
-# CONFIG_EVM is not set
-CONFIG_DEFAULT_SECURITY_DAC=y
-CONFIG_DEFAULT_SECURITY=""
-CONFIG_CRYPTO=y
-
-#
-# Crypto core or helper
-#
-# CONFIG_CRYPTO_FIPS is not set
-CONFIG_CRYPTO_ALGAPI=y
-CONFIG_CRYPTO_ALGAPI2=y
-CONFIG_CRYPTO_RNG=y
-CONFIG_CRYPTO_RNG2=y
-# CONFIG_CRYPTO_MANAGER is not set
-# CONFIG_CRYPTO_MANAGER2 is not set
-# CONFIG_CRYPTO_USER is not set
-# CONFIG_CRYPTO_GF128MUL is not set
-# CONFIG_CRYPTO_NULL is not set
-# CONFIG_CRYPTO_PCRYPT is not set
-# CONFIG_CRYPTO_CRYPTD is not set
-# CONFIG_CRYPTO_AUTHENC is not set
-# CONFIG_CRYPTO_TEST is not set
-
-#
-# Authenticated Encryption with Associated Data
-#
-# CONFIG_CRYPTO_CCM is not set
-# CONFIG_CRYPTO_GCM is not set
-# CONFIG_CRYPTO_SEQIV is not set
-
-#
-# Block modes
-#
-# CONFIG_CRYPTO_CBC is not set
-# CONFIG_CRYPTO_CTR is not set
-# CONFIG_CRYPTO_CTS is not set
-# CONFIG_CRYPTO_ECB is not set
-# CONFIG_CRYPTO_LRW is not set
-# CONFIG_CRYPTO_PCBC is not set
-# CONFIG_CRYPTO_XTS is not set
-
-#
-# Hash modes
-#
-# CONFIG_CRYPTO_CMAC is not set
-# CONFIG_CRYPTO_HMAC is not set
-# CONFIG_CRYPTO_XCBC is not set
-# CONFIG_CRYPTO_VMAC is not set
-
-#
-# Digest
-#
-# CONFIG_CRYPTO_CRC32C is not set
-# CONFIG_CRYPTO_CRC32C_INTEL is not set
-# CONFIG_CRYPTO_CRC32 is not set
-# CONFIG_CRYPTO_CRC32_PCLMUL is not set
-# CONFIG_CRYPTO_CRCT10DIF is not set
-# CONFIG_CRYPTO_GHASH is not set
-# CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
-# CONFIG_CRYPTO_MICHAEL_MIC is not set
-# CONFIG_CRYPTO_RMD128 is not set
-# CONFIG_CRYPTO_RMD160 is not set
-# CONFIG_CRYPTO_RMD256 is not set
-# CONFIG_CRYPTO_RMD320 is not set
-# CONFIG_CRYPTO_SHA1 is not set
-# CONFIG_CRYPTO_SHA256 is not set
-# CONFIG_CRYPTO_SHA512 is not set
-# CONFIG_CRYPTO_TGR192 is not set
-# CONFIG_CRYPTO_WP512 is not set
-
-#
-# Ciphers
-#
-CONFIG_CRYPTO_AES=y
-# CONFIG_CRYPTO_AES_586 is not set
-# CONFIG_CRYPTO_AES_NI_INTEL is not set
-# CONFIG_CRYPTO_ANUBIS is not set
-# CONFIG_CRYPTO_ARC4 is not set
-# CONFIG_CRYPTO_BLOWFISH is not set
-# CONFIG_CRYPTO_CAMELLIA is not set
-# CONFIG_CRYPTO_CAST5 is not set
-# CONFIG_CRYPTO_CAST6 is not set
-# CONFIG_CRYPTO_DES is not set
-# CONFIG_CRYPTO_FCRYPT is not set
-# CONFIG_CRYPTO_KHAZAD is not set
-# CONFIG_CRYPTO_SALSA20 is not set
-# CONFIG_CRYPTO_SALSA20_586 is not set
-# CONFIG_CRYPTO_SEED is not set
-# CONFIG_CRYPTO_SERPENT is not set
-# CONFIG_CRYPTO_SERPENT_SSE2_586 is not set
-# CONFIG_CRYPTO_TEA is not set
-# CONFIG_CRYPTO_TWOFISH is not set
-# CONFIG_CRYPTO_TWOFISH_586 is not set
-
-#
-# Compression
-#
-# CONFIG_CRYPTO_DEFLATE is not set
-# CONFIG_CRYPTO_ZLIB is not set
-# CONFIG_CRYPTO_LZO is not set
-# CONFIG_CRYPTO_LZ4 is not set
-# CONFIG_CRYPTO_LZ4HC is not set
-
-#
-# Random Number Generation
-#
-CONFIG_CRYPTO_ANSI_CPRNG=y
-# CONFIG_CRYPTO_USER_API_HASH is not set
-# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
-CONFIG_CRYPTO_HW=y
-# CONFIG_CRYPTO_DEV_PADLOCK is not set
-# CONFIG_CRYPTO_DEV_GEODE is not set
-# CONFIG_CRYPTO_DEV_HIFN_795X is not set
-# CONFIG_ASYMMETRIC_KEY_TYPE is not set
-CONFIG_HAVE_KVM=y
-# CONFIG_VIRTUALIZATION is not set
-# CONFIG_BINARY_PRINTF is not set
-
-#
-# Library routines
-#
-CONFIG_BITREVERSE=y
-CONFIG_GENERIC_STRNCPY_FROM_USER=y
-CONFIG_GENERIC_STRNLEN_USER=y
-CONFIG_GENERIC_NET_UTILS=y
-CONFIG_GENERIC_FIND_FIRST_BIT=y
-CONFIG_GENERIC_PCI_IOMAP=y
-CONFIG_GENERIC_IOMAP=y
-CONFIG_GENERIC_IO=y
-# CONFIG_CRC_CCITT is not set
-CONFIG_CRC16=y
-# CONFIG_CRC_T10DIF is not set
-# CONFIG_CRC_ITU_T is not set
-CONFIG_CRC32=y
-# CONFIG_CRC32_SELFTEST is not set
-CONFIG_CRC32_SLICEBY8=y
-# CONFIG_CRC32_SLICEBY4 is not set
-# CONFIG_CRC32_SARWATE is not set
-# CONFIG_CRC32_BIT is not set
-# CONFIG_CRC7 is not set
-# CONFIG_LIBCRC32C is not set
-# CONFIG_CRC8 is not set
-CONFIG_ZLIB_INFLATE=y
-CONFIG_LZO_DECOMPRESS=y
-CONFIG_XZ_DEC=y
-CONFIG_XZ_DEC_X86=y
-# CONFIG_XZ_DEC_POWERPC is not set
-# CONFIG_XZ_DEC_IA64 is not set
-# CONFIG_XZ_DEC_ARM is not set
-# CONFIG_XZ_DEC_ARMTHUMB is not set
-# CONFIG_XZ_DEC_SPARC is not set
-CONFIG_XZ_DEC_BCJ=y
-# CONFIG_XZ_DEC_TEST is not set
-CONFIG_DECOMPRESS_GZIP=y
-CONFIG_HAS_IOMEM=y
-CONFIG_HAS_IOPORT=y
-CONFIG_HAS_DMA=y
-CONFIG_CHECK_SIGNATURE=y
-CONFIG_CPU_RMAP=y
-CONFIG_DQL=y
-CONFIG_NLATTR=y
-CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
-# CONFIG_AVERAGE is not set
-# CONFIG_CORDIC is not set
-# CONFIG_DDR is not set
-CONFIG_UCS2_STRING=y
-# CONFIG_PP_TX_INIT is not set
diff -Naur a/arch/x86/kernel/iosf_mbi.c b/arch/x86/kernel/iosf_mbi.c
--- a/arch/x86/kernel/iosf_mbi.c	2017-10-11 10:16:34.756956000 +0530
+++ b/arch/x86/kernel/iosf_mbi.c	2017-10-11 09:35:34.944695000 +0530
@@ -30,7 +30,7 @@
 #define PCI_DEVICE_ID_BAYTRAIL		0x0F00
 #define PCI_DEVICE_ID_BRASWELL		0x2280
 #define PCI_DEVICE_ID_QUARK_X1000	0x0958
-#define PCI_DEVICE_ID_INTEL_PUMA7	0x2B80
+#define PCI_DEVICE_ID_COUGAR_MTN 	0x2B80
 
 static DEFINE_SPINLOCK(iosf_mbi_lock);
 
@@ -293,7 +293,7 @@
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_BAYTRAIL) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_BRASWELL) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_QUARK_X1000) },
-	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_PUMA7) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_COUGAR_MTN) },
 	{ 0, },
 };
 MODULE_DEVICE_TABLE(pci, iosf_mbi_pci_ids);
diff -Naur a/arch/x86/pal_cppi41/Makefile b/arch/x86/pal_cppi41/Makefile
--- a/arch/x86/pal_cppi41/Makefile	2017-10-11 10:16:34.876973000 +0530
+++ b/arch/x86/pal_cppi41/Makefile	2017-10-11 09:35:35.070713000 +0530
@@ -19,9 +19,7 @@
 
 obj-$(CONFIG_PAL_CPPI41_APPCPU) := pal_cppi41.o
 obj-$(CONFIG_PAL_CPPI41_APPCPU) += cru_ctrl.o
-obj-y += cppi41_hw_mbox_if.o
 
-ccflags-y := -DCONFIG_X86_AVALANCHE_SOC \
+ccflags-y :=	-DCONFIG_X86_AVALANCHE_SOC \
 		-DCONFIG_TI_META_DATA\
 		-DCONFIG_INET_LRO
-
diff -Naur a/arch/x86/pal_cppi41/cppi41_hw_mbox_if.c b/arch/x86/pal_cppi41/cppi41_hw_mbox_if.c
--- a/arch/x86/pal_cppi41/cppi41_hw_mbox_if.c	2017-10-11 10:16:34.872970000 +0530
+++ b/arch/x86/pal_cppi41/cppi41_hw_mbox_if.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,362 +0,0 @@
-/*
- *
- * cppi41_hw_mbox_if.c 
- * Description:
- * CPPI access via HW mailbox
- *
- *
- * GPL LICENSE SUMMARY
- *
- *  Copyright(c) 2015 Intel Corporation.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of version 2 of the GNU General Public License as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *  The full GNU General Public License is included in this distribution
- *  in the file called LICENSE.GPL.
- *
- *  Contact Information:
- *  Intel Corporation
- *  2200 Mission College Blvd.
- *  Santa Clara, CA  97052
- */
-
-
-/************************************************/
-/*                    Includes                  */
-/************************************************/
-#include <linux/module.h>
-#include <linux/moduleparam.h>  // to support input parameters for the module
-#include <linux/kernel.h>
-#include <linux/byteorder/generic.h>
-#include <linux/fs.h>
-#include <linux/cdev.h>
-#include <linux/interrupt.h>
-#include <linux/avalanche/generic/pal_cppi41.h>
-#include <linux/hw_mbox_defs.h>
-#include <linux/avalanche/puma7/puma7.h>
-#include <linux/avalanche/generic/avalanche_intd.h>
-#include <linux/avalanche/puma7/puma7_npcpu_appcpu_defs.h>
-#include <linux/avalanche/generic/cppi41_hw_mbox_if.h>
-
-/************************************************/
-/*                    Defines                   */
-/************************************************/
-//#define CPPI_MBOX_DBG
-
-#ifdef CPPI_MBOX_DBG
-/* Debug print, also print function name and line number */
-#  define DPRINTK(fmt, args...) printk("[CPPI-MBOX-DBG] %s(%d): " fmt "\n", __FUNCTION__ , __LINE__,  ## args)
-#else
-#  define DPRINTK(fmt, args...)
-#endif
-/* Error print, also print function name and line number */
-#define EPRINTK(fmt, args...) printk(KERN_ERR "[CPPI-MBOX-ERROR] %s(%d): " fmt "\n", __FUNCTION__ , __LINE__, ## args)
-
-/************************************************/
-/*        hw mailbox driver  Functions          */
-/************************************************/
-extern int hwMbox_isReady(void);
-extern int hwMbox_registerRecvOpcode(hw_mbox_Masters_e commander, hwMboxRecvOpcodeCallback pOpcodeCallbackFunc, Uint32 tag, Uint32 token);
-extern int hwMbox_sendReplyOpcode(hw_mbox_Masters_e commander, Uint8 *dataBuf, Uint32 dataLen);
-extern int hwMbox_sendAckOpcode(hw_mbox_Masters_e commander);
-
-/************************************************/
-/*          Interface Functions                 */
-/************************************************/
-static int cppi41_hw_mbox_callback(hw_mbox_Masters_e commander, Uint8 *dataBuf, Uint32 dataLen, Uint32 *token);
-static int cppi41_hw_mbox_acc_ch_open_handler(Cppi4AccumulatorCfg *initCfg, PAL_Cppi4AccChHnd *accChHnd, Ptr *curPage);
-static int cppi41_hw_mbox_acc_ch_close_handler(PAL_Cppi4AccChHnd accChHnd);
-
-/************************************************/
-/*         Global and Static Variables          */
-/************************************************/
-
-/* handle to PAL */
-static PAL_Handle cppi_hw_mobx_hnd = NULL;
-
-/*****************************************************************************************/
-/**  ___  ___            _         _                                                    **/
-/**  |  \/  |           | |       | |                                                   **/
-/**  | .  . |  ___    __| | _   _ | |  ___                                              **/
-/**  | |\/| | / _ \  / _` || | | || | / _ \                                             **/
-/**  | |  | || (_) || (_| || |_| || ||  __/                                             **/
-/**  \_|  |_/ \___/  \__,_| \__,_||_| \___|                                             **/
-/**  ______                    _    _                                                   **/
-/**  |  ___|                  | |  (_)                                                  **/
-/**  | |_  _   _  _ __    ___ | |_  _   ___   _ __   ___                                **/
-/**  |  _|| | | || '_ \  / __|| __|| | / _ \ | '_ \ / __|                               **/
-/**  | |  | |_| || | | || (__ | |_ | || (_) || | | |\__ \                               **/
-/**  \_|   \__,_||_| |_| \___| \__||_| \___/ |_| |_||___/                               **/
-/*****************************************************************************************/
-
-
-/*! \fn int cppi41_hw_mbox_init (void) 
-  * \brief initialize CPPI hw mailbox interface 
-  * \return 0 on succuss, non zero value otherwise 
-  */
-int cppi41_hw_mbox_init(void)
-{
-    /* HW Mailbox checking and registeration */
-    if ( 0 != hwMbox_isReady() )
-    {
-        EPRINTK("HW Mailbox driver not ready, init fails!");
-        return -1;
-    }
-
-    DPRINTK("HW Mailbox driver is ready");
-
-    cppi_hw_mobx_hnd = PAL_cppi4Init(NULL, CPPI41_DOMAIN_PP);
-    if (NULL == cppi_hw_mobx_hnd)
-    {
-        EPRINTK("Failed to get PP domain PAL handle");
-        return -1;
-    }
-
-    DPRINTK("PP Domain PAL handle = %p", cppi_hw_mobx_hnd);
-
-
-    /* HW Mailbox is ready, registering the callback */
-    if(0 != hwMbox_registerRecvOpcode(HW_MBOX_MASTER_NP_CPU, cppi41_hw_mbox_callback,
-                                      NPCPU_APPCPU_HW_MBOX_TAG_CPPI41_MBX, 0 ))
-    {
-        EPRINTK("hwMbox_registerRecvOpcode fails, Master = %d, Tag = %d",
-                HW_MBOX_MASTER_APP_CPU, NPCPU_APPCPU_HW_MBOX_TAG_CPPI41_MBX);
-        return -1;
-    }
-
-    printk("CPPI41 HW Mailbox: init DONE\n");
-
-    return 0;
-}
-EXPORT_SYMBOL(cppi41_hw_mbox_init);
-
-/*! \fn int cppi41_hw_mbox_deinit(void)
-  * \brief de initialize CPPI hw mailbox interface 
-  * \return 0 on succuss
-  */
-void cppi41_hw_mbox_deinit(void)
-{
-    DPRINTK("Unregister interface callback from hw mailbox driver");
-    /* TBD - unregister callback */
-
-    DPRINTK("Removing cppi hw mailbox interface");
-    PAL_cppi4Exit(NULL, CPPI41_DOMAIN_PP);
-}
-EXPORT_SYMBOL(cppi41_hw_mbox_deinit);
-
-/*!
- * \fn static int cppi41_hw_mbox_callback(hw_mbox_Masters_e commander, Uint8 *dataBuf, Uint32 dataLen, Uint32 *token) 
- * \brief handles all cppi41 incoming hw mailbox commands
- * 
- * \author iemergi (11/19/2015)
- * 
- * \param commander hw mailbox commander
- * \param dataBuf data buffer
- * \param dataLen data length
- * \param token token
- * 
- * \return 0 for succuss
- */
-static int cppi41_hw_mbox_callback(hw_mbox_Masters_e commander, Uint8 *dataBuf, Uint32 dataLen, Uint32 *token)
-{
-    Cppi41HwMboxCmd_e cmd;
-    Cppi41HwMboxFailMsg_t failReply = {0};
-
-    DPRINTK("start");
-
-    if (dataBuf == NULL)
-    {
-        EPRINTK("Received NULL pointer");
-        goto out_err;
-    }
-
-    /* the CMD ID MUST be the first word (32bits) in all CPPI mbox msg types! */
-    cmd = be32_to_cpu(*((Cppi41HwMboxCmd_e *)dataBuf));
-
-    switch(cmd)
-    {
-        case CPPI41_HWMBOX_CMD_ACC_CH_OPEN:
-            {
-                Cppi41HwMboxAccChOpenMsg_t *AccChOpenMsg;
-                Cppi41HwMboxAccChOpenReplyMsg_t AccChOpenReply = {0};
-
-                AccChOpenMsg = (Cppi41HwMboxAccChOpenMsg_t *) dataBuf;
-                Cppi41HwMboxAccChangeEndianness(AccChOpenMsg, endiannessLittle);
-
-                DPRINTK("calling cppi41_hw_mbox_acc_ch_open_handler");
-                if(0 == cppi41_hw_mbox_acc_ch_open_handler(&AccChOpenMsg->initCfg, 
-                                                           &AccChOpenReply.accChHnd, 
-                                                           &AccChOpenReply.curPage))
-                {
-                    /* open channel done ok */
-                    AccChOpenReply.accChHnd = cpu_to_be32(AccChOpenReply.accChHnd);
-                    AccChOpenReply.curPage = cpu_to_be32(AccChOpenReply.curPage);
-
-                    AccChOpenReply.cmd = cpu_to_be32(CPPI41_HWMBOX_CMD_ACC_CH_OPEN_REPLY);
-                    hwMbox_sendReplyOpcode(HW_MBOX_MASTER_NP_CPU, &AccChOpenReply, sizeof(AccChOpenReply));
-                    return 0;
-                }
-                failReply.failCode = cpu_to_be32(CPPI41_HWMBOX_RET_CODE_CMD_ERROR);
-                break;
-            }
-        case CPPI41_HWMBOX_CMD_ACC_CH_CLOSE:
-            {
-                Cppi41HwMboxAccChCloseMsg_t *AccChCloseMsg;
-
-                AccChCloseMsg = (Cppi41HwMboxAccChCloseMsg_t *) dataBuf;
-
-                DPRINTK("calling cppi41_hw_mbox_acc_ch_close_handler");
-                if(0 == cppi41_hw_mbox_acc_ch_close_handler(be32_to_cpu(AccChCloseMsg->accChHnd)))
-                {
-                    hwMbox_sendAckOpcode(HW_MBOX_MASTER_NP_CPU);
-                    return 0;
-                }
-                failReply.failCode = cpu_to_be32(CPPI41_HWMBOX_RET_CODE_CMD_ERROR);
-                break;
-            }
-        default:
-            EPRINTK("Unsupported command code = %d, replying fail code", cmd);
-            failReply.failCode = cpu_to_be32(CPPI41_HWMBOX_RET_CODE_UNSUPPORTED_CMD);
-            break;
-    }
-
-out_err:   
-    failReply.cmd = cpu_to_be32(CPPI41_HWMBOX_CMD_FAILED);
- 
-    hwMbox_sendReplyOpcode(HW_MBOX_MASTER_NP_CPU, &failReply, sizeof(failReply));
-    EPRINTK("Failed to handle incoming message");
-    
-    return 0;
-}
-
-#define ACCUM_CH_PARAM_DEBUG(initCfg)     \
-            DPRINTK("\n                                  \   
-                     accChanNum=%d \n                    \   
-                     mode=%d \n                          \   
-                     qMg=%d \n                           \   
-                     qNum=%d \n                          \   
-                     pacingTickCnt=%d \n                 \   
-                     list.istBase=%p \n                  \   
-                     list.axPageEntry=%d \n              \   
-                     list.acingMode=%d \n                \   
-                     list.tallAvoidance=%d \n            \   
-                     list.istCountMode=%d \n             \   
-                     list.istEntrySize=%d \n             \   
-                     list.axPageCnt=%d \n                \   
-                     monitor.pktCountThresh=%d \n        \   
-                     monitor.pacingMode=%d \n",          \                                        
-                     initCfg->accChanNum,                \
-                     initCfg->mode,                      \
-                     initCfg->queue.qMgr,                \
-                     initCfg->queue.qNum,                \
-                     initCfg->pacingTickCnt,             \
-                     initCfg->list.listBase,             \
-                     initCfg->list.maxPageEntry,         \
-                     initCfg->list.pacingMode,           \
-                     initCfg->list.stallAvoidance,       \
-                     initCfg->list.listCountMode,        \
-                     initCfg->list.listEntrySize,        \
-                     initCfg->list.maxPageCnt,           \
-                     initCfg->monitor.pktCountThresh,    \
-                     initCfg->monitor.pacingMode)
-
-
-static int cppi41_hw_mbox_acc_ch_open_handler(Cppi4AccumulatorCfg *initCfg, PAL_Cppi4AccChHnd *accChHnd, Ptr *curPage)
-{
-    PAL_Cppi4AccChObj *accChObj;
-    DPRINTK("start");
-
-    if(NULL == initCfg)
-    {
-        EPRINTK("initCfg is NULL, cannot open accumulator channel without initCfg");
-        return -1;
-    }
-
-    ACCUM_CH_PARAM_DEBUG(initCfg);
-
-    accChObj = ( PAL_Cppi4AccChObj *) PAL_cppi4AccChOpenAppCpu(cppi_hw_mobx_hnd, initCfg);
-    DPRINTK("PAL_cppi4AccChOpenAtom return accChObj = %p", accChObj);
-
-    if(!accChObj)
-    {
-        EPRINTK("Failed to open accumulator channel %d", initCfg->accChanNum);
-        return -1;
-    }
-
-    DPRINTK("succussfully open accumulator channel %d", initCfg->accChanNum);
-
-    *curPage = accChObj->curPage;
-    *accChHnd = accChObj;
-    DPRINTK("accChHnd = *p, curPage = %p", *accChHnd, *curPage);
-    return 0;
-}
-
-static int cppi41_hw_mbox_acc_ch_close_handler(PAL_Cppi4AccChHnd accChHnd)
-{
-    PAL_cppi4AccChClose(accChHnd, NULL);
-    DPRINTK("close accumulator channel succussfully for accChHnd = %p",accChHnd);
-
-    return 0;
-}
-
-bool Cppi41HwMboxAccChangeEndianness(Cppi41HwMboxAccChOpenMsg_t *destCfgData, endianness_e endianity)
-{
-    if( !destCfgData )
-    {
-        EPRINTK(" null pointer reference ");
-        return false;
-    }
-    if( (endianity != endiannessBig) && (endianity != endiannessLittle) )
-    {
-        EPRINTK(" Endianness value pass in datapipe is not correct ");
-        return false; 
-    }
-
-    if(endianity == endiannessBig)
-    {
-        (*destCfgData).initCfg.accChanNum               =   cpu_to_be32((*destCfgData).initCfg.accChanNum);
-        (*destCfgData).initCfg.mode                     =   cpu_to_be32((*destCfgData).initCfg.mode);
-        (*destCfgData).initCfg.queue.qMgr               =   cpu_to_be32((*destCfgData).initCfg.queue.qMgr);
-        (*destCfgData).initCfg.queue.qNum               =   cpu_to_be32((*destCfgData).initCfg.queue.qNum);
-        (*destCfgData).initCfg.pacingTickCnt            =   cpu_to_be32((*destCfgData).initCfg.pacingTickCnt);
-        (*destCfgData).initCfg.list.listBase            =   (void *)cpu_to_be32((unsigned int)(*destCfgData).initCfg.list.listBase);
-        (*destCfgData).initCfg.list.maxPageEntry        =   cpu_to_be32((*destCfgData).initCfg.list.maxPageEntry);
-        (*destCfgData).initCfg.list.pacingMode          =   cpu_to_be32((*destCfgData).initCfg.list.pacingMode);
-        (*destCfgData).initCfg.list.stallAvoidance      =   cpu_to_be32((*destCfgData).initCfg.list.stallAvoidance);
-        (*destCfgData).initCfg.list.listCountMode       =   cpu_to_be32((*destCfgData).initCfg.list.listCountMode);
-        (*destCfgData).initCfg.list.listEntrySize       =   cpu_to_be32((*destCfgData).initCfg.list.listEntrySize);
-        (*destCfgData).initCfg.list.maxPageCnt          =   cpu_to_be32((*destCfgData).initCfg.list.maxPageCnt);
-        (*destCfgData).initCfg.monitor.pktCountThresh   =   cpu_to_be32((*destCfgData).initCfg.monitor.pktCountThresh);
-        (*destCfgData).initCfg.monitor.pacingMode       =   cpu_to_be32((*destCfgData).initCfg.monitor.pacingMode);
-    }
-    if(endianity == endiannessLittle)
-    {
-        (*destCfgData).initCfg.accChanNum               =   be32_to_cpu((*destCfgData).initCfg.accChanNum);
-        (*destCfgData).initCfg.mode                     =   be32_to_cpu((*destCfgData).initCfg.mode);
-        (*destCfgData).initCfg.queue.qMgr               =   be32_to_cpu((*destCfgData).initCfg.queue.qMgr);
-        (*destCfgData).initCfg.queue.qNum               =   be32_to_cpu((*destCfgData).initCfg.queue.qNum);
-        (*destCfgData).initCfg.pacingTickCnt            =   be32_to_cpu((*destCfgData).initCfg.pacingTickCnt);
-        (*destCfgData).initCfg.list.listBase            =   (void *)be32_to_cpu((*destCfgData).initCfg.list.listBase);
-        (*destCfgData).initCfg.list.maxPageEntry        =   be32_to_cpu((*destCfgData).initCfg.list.maxPageEntry);
-        (*destCfgData).initCfg.list.pacingMode          =   be32_to_cpu((*destCfgData).initCfg.list.pacingMode);
-        (*destCfgData).initCfg.list.stallAvoidance      =   be32_to_cpu((*destCfgData).initCfg.list.stallAvoidance);
-        (*destCfgData).initCfg.list.listCountMode       =   be32_to_cpu((*destCfgData).initCfg.list.listCountMode);
-        (*destCfgData).initCfg.list.listEntrySize       =   be32_to_cpu((*destCfgData).initCfg.list.listEntrySize);
-        (*destCfgData).initCfg.list.maxPageCnt          =   be32_to_cpu((*destCfgData).initCfg.list.maxPageCnt);
-        (*destCfgData).initCfg.monitor.pktCountThresh   =   be32_to_cpu((*destCfgData).initCfg.monitor.pktCountThresh);
-        (*destCfgData).initCfg.monitor.pacingMode       =   be32_to_cpu((*destCfgData).initCfg.monitor.pacingMode);
-    }
-    return true;
-}
-EXPORT_SYMBOL(Cppi41HwMboxAccChangeEndianness);
diff -Naur a/arch/x86/pal_cppi41/cppi41_hw_mbox_if.h b/arch/x86/pal_cppi41/cppi41_hw_mbox_if.h
--- a/arch/x86/pal_cppi41/cppi41_hw_mbox_if.h	1970-01-01 05:30:00.000000000 +0530
+++ b/arch/x86/pal_cppi41/cppi41_hw_mbox_if.h	2017-10-11 09:35:35.067721000 +0530
@@ -0,0 +1,131 @@
+/*
+ *
+ * cppi41_hw_mbox_if.h
+ * Description:
+ * CPPI access via HW mailbox
+ *
+ *
+ * GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2015 Intel Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *  Intel Corporation
+ *  2200 Mission College Blvd.
+ *  Santa Clara, CA  97052
+ */
+
+ /************************************************/
+/*                 Structures                   */
+/************************************************/
+#ifndef _PPI41_HW_MBOX_IF_H
+#define  _PPI41_HW_MBOX_IF_H
+
+/*! \enum hw_mbox_Masters_e
+  \brief Enumerate all HW_MBOX Master with MID value.
+  \note name of the Masters is according to HW_MBOX_MASTER_TABLE_AS_ENUM Macro.
+ */
+
+typedef enum npcpu_appcpu_hw_mbox_tags
+{
+    NPCPU_APPCPU_HW_MBOX_MID_INVALID = -1,
+    NPCPU_APPCPU_HW_MBOX_TAG_NET_IP_DRV,
+    NPCPU_APPCPU_HW_MBOX_TAG_PM,
+    NPCPU_APPCPU_HW_MBOX_TAG_CM,
+    NPCPU_APPCPU_HW_MBOX_TAG_RPC,
+    NPCPU_APPCPU_HW_MBOX_TAG_MUX,
+    NPCPU_APPCPU_HW_MBOX_TAG_VLAN,
+    NPCPU_APPCPU_HW_MBOX_TAG_PP,
+    NPCPU_APPCPU_HW_MBOX_TAG_NETDEV,
+    NPCPU_APPCPU_HW_MBOX_TAG_CPPI41_MBX,
+    NPCPU_APPCPU_HW_MBOX_TAG_DATAPIPE_MBX,
+    NPCPU_APPCPU_HW_LAST_ENTRY
+} npcpu_appcpu_hw_mbox_tags_e;
+
+
+
+/* CPPI HW mailbox commands enum */
+typedef enum
+{
+    CPPI41_HWMBOX_CMD_ACC_CH_OPEN = 0           ,    /* Accumulator open command */
+    CPPI41_HWMBOX_CMD_ACC_CH_OPEN_REPLY         ,    /* Accumulator open reply command */
+    CPPI41_HWMBOX_CMD_ACC_CH_CLOSE              ,    /* Accumulator close command */
+    CPPI41_HWMBOX_CMD_GET_REGION_MEM_INFO       ,    /* Descriptors region memory info command */
+    CPPI41_HWMBOX_CMD_GET_REGION_MEM_INFO_REPLY ,    /* Descriptors region memory info reply command */
+    CPPI41_HWMBOX_CMD_FAILED                    ,    /* command processing failed command, use only for reply - the error code is from the type Cppi41HwMboxRetCode_e */
+    CPPI41_HWMBOX_CMD_COUNT
+}Cppi41HwMboxCmd_e;
+
+/* error codes for CPPI41_HWMBOX_CMD_FAILED command */
+typedef enum
+{
+    CPPI41_HWMBOX_RET_CODE_OK = 0,
+    CPPI41_HWMBOX_RET_CODE_UNSUPPORTED_CMD,
+    CPPI41_HWMBOX_RET_CODE_CMD_ERROR,
+    CPPI41_HWMBOX_RET_CODE_COUNT,
+}Cppi41HwMboxRetCode_e;
+
+/* Cppi HW mailbox fail message */
+typedef struct
+{
+    Cppi41HwMboxCmd_e       cmd;        /* command type - must be CPPI41_HWMBOX_CMD_FAILED */
+    Cppi41HwMboxRetCode_e   failCode;   /* fail code */
+} Cppi41HwMboxFailMsg_t;
+
+/* Cppi HW mailbox message to open accumulator channel */
+typedef struct
+{
+    Cppi41HwMboxCmd_e       cmd;        /* command type - must be CPPI41_HWMBOX_CMD_ACC_CH_OPEN  */
+    Cppi4AccumulatorCfg     initCfg;    /* The accumulator channel init configuration */
+} Cppi41HwMboxAccChOpenMsg_t;
+
+/* Cppi HW mailbox response message to open accumulator channel */
+typedef struct
+{
+    Cppi41HwMboxCmd_e   cmd;            /* command type - must be CPPI41_HWMBOX_CMD_ACC_CH_OPEN_REPLY */
+    Ptr                 curPage;        /* Current accumulator page physical address */
+    PAL_Cppi4AccChHnd   accChHnd;       /* handle to accumulator channel handle, this field is mandatory for closing the channel */
+}Cppi41HwMboxAccChOpenReplyMsg_t;
+
+/* Cppi HW mailbox message to close accumulator channel */
+typedef struct
+{
+    Cppi41HwMboxCmd_e   cmd;        /* command type */
+    PAL_Cppi4AccChHnd   accChHnd;   /* The accumulator channel init configuration */
+} Cppi41HwMboxAccChCloseMsg_t;
+
+/* Cppi HW mailbox message to get descriptor region memory info, phyical address and length */
+typedef struct
+{
+    Cppi41HwMboxCmd_e           cmd;    /* command type */
+    //PAL_CPPI_PP_DESC_REGIONs_e  region; /* region number */
+    unsigned int                region; /* region number */
+    Uint32                      qMgr;   /* queue manager */
+} Cppi41HwMboxDescRegionMemInfoGetMsg_t;
+
+/* Cppi HW mailbox message to reply to a get descriptor region memory info message */
+typedef struct
+{
+    Cppi41HwMboxCmd_e   cmd;            /* command type */
+    Ptr                 regionPhyAddr;  /* region memory physical address */
+    Uint32              length;         /* region memory length in bytes */
+} Cppi41HwMboxDescRegionMemInfoReplyMsg_t;
+
+
+#endif
diff -Naur a/arch/x86/pal_cppi41/pal_cppi41.c b/arch/x86/pal_cppi41/pal_cppi41.c
--- a/arch/x86/pal_cppi41/pal_cppi41.c	2017-10-11 10:16:34.873979000 +0530
+++ b/arch/x86/pal_cppi41/pal_cppi41.c	2017-10-11 09:35:35.066707000 +0530
@@ -91,8 +91,8 @@
 #include <linux/avalanche/generic/pal_os.h>
 #include <linux/avalanche/generic/pal_osProtect.h>
 #include <linux/avalanche/generic/pal_osProtect_inline.h>
-#include <linux/avalanche/generic/cppi41_hw_mbox_if.h>
-#include <linux/avalanche/puma7/puma7_npcpu_appcpu_defs.h>
+
+#include "cppi41_hw_mbox_if.h"
 #include <linux/hw_mailbox.h>
 /***************/
 /**  Defines  **/
@@ -143,6 +143,15 @@
 static bool initialized = false;
 static spinlock_t init_lock;
 
+/***************************************/
+/*  enum for endianness conversion    **/
+/**************************************/
+typedef enum
+{
+    DataPipeBig,
+    DataPipeLittle
+}dataPipeEndianNess_e;
+
 /*ADP accumulator HW Mailbox message format*/
 /*******************************************/
 /* ------------------------------------
@@ -166,6 +175,12 @@
  *-----------------------------------*/
 /***************************************/
 
+
+
+/*********************************/
+/**  local Functions declaration  **/
+/*********************************/
+
 /*********************************/
 /**  Functions Implementations  **/
 /*********************************/
@@ -229,6 +244,13 @@
 }
 EXPORT_SYMBOL(PAL_cppi4BufDecRefCnt);
 
+Ptr PAL_cppi4BufPopBuf (PAL_Handle hnd, Cppi4BufPool pool)
+{
+    CSL_BufMgr_Regs *bPoolRegs = (CSL_BufMgr_Regs *)bMgrBase;
+
+    return (Ptr)be32_to_cpu(bPoolRegs->Pointer_Size[pool.bPool].Buffer_Pool_Pointer);
+}
+EXPORT_SYMBOL(PAL_cppi4BufPopBuf);
 
 PAL_Cppi4QueueHnd PAL_cppi4QueueOpen(PAL_Handle hnd, Cppi4Queue  queue)
 {
@@ -245,12 +267,6 @@
 }
 EXPORT_SYMBOL(PAL_cppi4QueueOpen);
 
-PAL_Cppi4QueueHnd PAL_cppi4QueueOpenNoReset (PAL_Handle hnd, Cppi4Queue  queue)
-{
-    return PAL_cppi4QueueOpen(hnd, queue);
-}
-EXPORT_SYMBOL(PAL_cppi4QueueOpenNoReset);
-
 int PAL_cppi4QueueClose(PAL_Handle hnd, PAL_Cppi4QueueHnd qHnd)
 {
     DPRINTK("Close queue %p", qHnd);
@@ -425,13 +441,13 @@
 
     return (PP_RC_SUCCESS);
 }
-#ifdef CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL
+
 PAL_Cppi4AccChHnd PAL_cppi4AccChOpen(PAL_Handle hnd, Cppi4AccumulatorCfg* accCfg)
 {
     Uint32 cookie;
     PAL_Cppi4AccChObj *accChObj;
 #if PUMA7_OR_NEWER_SOC_TYPE
-    AVALANCHE_PP_ACC_CH_INFO_t ptr_ch_cfg = {0};
+    AVALANCHE_PP_ACC_CH_INFO_t ptr_ch_cfg;
     AVALANCHE_PP_RET_e rc;
 #else
     Uint32 i;
@@ -515,157 +531,8 @@
 
     return (PAL_Cppi4AccChHnd) accChObj;
 }
-#else
-/* Following API will use HW mailbox provide Accumulator fuctionalities */ 
-PAL_Cppi4AccChHnd PAL_cppi4AccChOpen(PAL_Handle hnd, Cppi4AccumulatorCfg* accCfg)
-{
-    
-    /*Return pointer to the caller */
-    PAL_Cppi4AccChObj *accChObj = NULL;
-    /* transport message over HW_MBOX */
-    Cppi41HwMboxAccChOpenMsg_t  openAccChObj = {0};
-    /* local temporary varaibles */
-    Cppi41HwMboxAccChOpenReplyMsg_t* tmp = NULL;
-    unsigned long tmpPtr = 0;
-    /* transport message over HW_MBOX */
-    /* Return length of HW mailbox Op-Code channle */
-    Uint32 dataLen = sizeof(Cppi41HwMboxAccChOpenMsg_t);
-    if(!accCfg)
-    {
-        EPRINTK("NULL pointer reference.");
-        return NULL;
-    }
-
-    /* kmalloc returns cache line aligned memory unless you are debugging the slab allocator (2.6.18) */
-    accChObj = (PAL_Cppi4AccChObj *)kzalloc(sizeof(PAL_Cppi4AccChObj) ,GFP_KERNEL);
-    if(!accChObj)
-    {
-        EPRINTK("could not allocate memeory for local accumulator ojbect");
-        return NULL;
-    }
-
-    /*copy accCfg data to accumulator channel onject */
-    if(!accCfg->list.listBase)
-    {
-        EPRINTK("NULL pointer reference. for accCfg.list.base");
-        kfree(accChObj);
-        return NULL;
-    }
-
-    /* Copy datapipe accumulator init paramters into the message container */
-    memcpy(&openAccChObj.initCfg, accCfg, sizeof(Cppi4AccumulatorCfg));  
-    DPRINTK(" Virtual  list.listBase=%p, address received=%p before sending to HWMbox.\n",  openAccChObj.initCfg.list.listBase,  accCfg->list.listBase );
-
-    /* APPCPU virtual address need to converted to Physical address before sending to HW mailbox */
-    tmpPtr = (unsigned long)PAL_CPPI4_VIRT_2_PHYS(openAccChObj.initCfg.list.listBase);
-    openAccChObj.initCfg.list.listBase = (void*)tmpPtr; 
-    DPRINTK(" Physical  list.listBase=%p, Original address received=%p before sending to HWMbox.\n",  openAccChObj.initCfg.list.listBase,  accCfg->list.listBase );
-
-    /* hardware mailbox implementation to open accumulator channel goes here */
-    if(hwMbox_isReady())
-    { 
-        EPRINTK("HW mailbox isn't ready yet.");
-        kfree(accChObj);
-        return NULL;
-    }
-     ACCUM_CH_PARAM_DEBUG(openAccChObj.initCfg);
-    /* need to convert data from cpu_to_be(); */
-     
-    if(!Cppi41HwMboxAccChangeEndianness(&openAccChObj, endiannessBig))
-    {
-        EPRINTK("data conversion fo endianness failed");
-        kfree(accChObj);
-        return NULL;
-    }
-
-    /* need to send accumulator handler as well  though we are not using it right now but incase needed in future */
-    /*  will receive back Object address in SendReplyOp() at npcpuAddress variable */
-     openAccChObj.cmd = cpu_to_be32(CPPI41_HWMBOX_CMD_ACC_CH_OPEN);
-     ACCUM_CH_PARAM_DEBUG(openAccChObj.initCfg);
-    /* send a message to NP-CPU and expect a 64 byte reply back using SendReplyOp()*/
-    DPRINTK(" size of data length=%d.", sizeof(Cppi41HwMboxAccChOpenMsg_t));
-    if(hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU, NPCPU_APPCPU_HW_MBOX_TAG_CPPI41_MBX , (uint8_t *)&openAccChObj, sizeof(Cppi41HwMboxAccChOpenMsg_t) , sizeof(Cppi41HwMboxAccChOpenMsg_t) , &dataLen))
-    {
-        EPRINTK("HW mailbox hwMbox_sendOpcode failed.");
-        kfree(accChObj);
-        return NULL;
-    }
-    if(dataLen != sizeof(Cppi41HwMboxAccChOpenReplyMsg_t))
-    {
-        EPRINTK("HW mailbox hwMbox_sendOpcode reply wasnt of desire length Cppi41HwMboxAccChOpenReplyMsg=%d dataLen=%d ",sizeof(Cppi41HwMboxAccChOpenReplyMsg_t), dataLen);
-        kfree(accChObj);
-        return NULL;
-    }
-
-    DPRINTK("HW mailbox adpHwMboxmessageObj.msgData.initCfg.list.listBase before Endian change=%p.", openAccChObj.initCfg.list.listBase);
-    /* need to conver data from be_to_cpu(); */
-
-    DPRINTK("HW mailbox Received adpHwMboxmessageObj.msgData.initCfg.list.listBase after Endian change=%p.", openAccChObj.initCfg.list.listBase);
-    DPRINTK("HW mailbox called to  accumulator open successful.");
-    /* copy HW_Mbox message to kmalloced object for return */
-    DPRINTK("data length=%d.",dataLen );
-    memcpy(&(accChObj->initCfg), accCfg, sizeof(Cppi4AccumulatorCfg)); 
-    tmp = (Cppi41HwMboxAccChOpenReplyMsg_t *) &openAccChObj;
-    accChObj->curPage = be32_to_cpu( tmp->curPage);
-    DPRINTK("curPage=%d.", accChObj->curPage );
-    accChObj->palCppi4Obj = (void *)be32_to_cpu((unsigned int)(tmp->accChHnd));
-    DPRINTK("npcpuAddress=%d.", tmp->accChHnd );
-
-    DPRINTK("HW mailbox Received accChObj->initCfg.list.listBase after phys_to_virt=%p.", accChObj->initCfg.list.listBase);
-
-    return (PAL_Cppi4AccChHnd)accChObj;  
-}
-#endif
 EXPORT_SYMBOL(PAL_cppi4AccChOpen);
 
-PAL_Cppi4AccChHnd PAL_cppi4AccChOpenAppCpu(PAL_Handle hnd, Cppi4AccumulatorCfg* accCfg)
-{
-    Uint32 cookie;
-    PAL_Cppi4AccChObj *accChObj;
-    AVALANCHE_PP_ACC_CH_INFO_t ptr_ch_cfg;
-    AVALANCHE_PP_RET_e rc;
-
-    if (PAL_osMemAlloc(0, sizeof(PAL_Cppi4AccChObj), 0, (Ptr *) &accChObj) != PAL_SOK) {
-        EPRINTK ("\nERROR:PAL: PAL_cppi4AccChOpen: Failed to allocate Acc channel object structure.");
-        return NULL;
-    }
-
-    PAL_osMemSet (accChObj, 0, sizeof (PAL_Cppi4AccChObj));
-
-    PAL_osMemCopy(&accChObj->initCfg, accCfg, sizeof(Cppi4AccumulatorCfg));
-
-    accChObj->palCppi4Obj = hnd;
-
-    /* Need to protect the accumulator register writes. They are shared with pre-fetcher */
-    PAL_osProtectEntry(PAL_OSPROTECT_INTERRUPT, &cookie);
-
-    ptr_ch_cfg.Channel      =   accCfg->accChanNum ;
-    ptr_ch_cfg.Command      =   0 ;
-    ptr_ch_cfg.Param0Ret    =   (Uint32)(accCfg->list.listBase) ;
-    ptr_ch_cfg.Param1       =   (accCfg->queue.qNum) | (accCfg->queue.qMgr << 12) | (accCfg->list.maxPageEntry << 16);
-    ptr_ch_cfg.Param2       =   (accCfg->pacingTickCnt)             |
-                                (accCfg->list.maxPageCnt    << 16)  | (accCfg->list.listEntrySize  << 18)|
-                                (accCfg->list.listCountMode << 20)  | (accCfg->list.stallAvoidance << 21)|
-                                (accCfg->list.pacingMode    << 22)  | (accCfg->mode << 31);
-
-    rc = __cppi4AccChOpen(&ptr_ch_cfg);
-    if (PP_RC_SUCCESS != rc)
-    {
-        EPRINTK("Error: Accumulator PDSP is not responding, return code: %u\n", rc);
-        PAL_osProtectExit(PAL_OSPROTECT_INTERRUPT, cookie);
-
-        PAL_osMemFree( 0, accChObj, sizeof(PAL_Cppi4AccChObj) );
-        return NULL;
-    }
-
-    accChObj->curPage = 0;
-
-    PAL_osProtectExit(PAL_OSPROTECT_INTERRUPT, cookie);
-
-    return (PAL_Cppi4AccChHnd) accChObj;
-}
-EXPORT_SYMBOL(PAL_cppi4AccChOpenAppCpu);
-
 void PAL_cppi4AccChEnRateLimit(Cppi4AccumulatorRateLimitCfg* accCfg)
 {
     Uint32                      cookie;
@@ -693,7 +560,6 @@
 }
 EXPORT_SYMBOL(PAL_cppi4AccChEnRateLimit);
 
-#ifdef CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL
 int PAL_cppi4AccChClose(PAL_Cppi4AccChHnd hnd, void *closeArgs)
 {
     PAL_Cppi4AccChObj *accChObj = (PAL_Cppi4AccChObj *) hnd;
@@ -737,94 +603,8 @@
 
     return PAL_SOK;
 }
-#else
-int PAL_cppi4AccChClose(PAL_Cppi4AccChHnd hnd, void *closeArgs)
-{
-    /* local pointer to free */
-    PAL_Cppi4AccChObj *accChObj;
-    /* transport message over HW_MBOX */
-    Cppi41HwMboxAccChCloseMsg_t adpHwMboxmessageObj;
-    Uint32 dataLen = sizeof(Cppi41HwMboxAccChCloseMsg_t);
-
-    if(!hnd)
-    {
-        EPRINTK("NULL pointer reference.");
-        return false;
-    }
-
-    accChObj = (PAL_Cppi4AccChObj *)hnd;
-    /*copy PAL_Cppi4AccChObj data to accumulator channel onject */
-    /* convert data since CPPI need ch_num for accumulator close  */
-    adpHwMboxmessageObj.accChHnd =  (void *)cpu_to_be32((unsigned int)(accChObj->palCppi4Obj));  
-    DPRINTK("npcpuAddress=%d.", accChObj->palCppi4Obj );
-
-    adpHwMboxmessageObj.cmd = cpu_to_be32(CPPI41_HWMBOX_CMD_ACC_CH_CLOSE);
-    /* send a message to NP-CPU and expect to pointer get free in NPCPUaddress space make sure correct poiter by reply*/
-    if(hwMbox_sendOpcode(HW_MBOX_MASTER_NP_CPU,NPCPU_APPCPU_HW_MBOX_TAG_CPPI41_MBX, (uint8_t *)&adpHwMboxmessageObj, sizeof(Cppi41HwMboxAccChCloseMsg_t), sizeof(Cppi41HwMboxAccChCloseMsg_t), &dataLen))
-    {
-        EPRINTK("HW mailbox hwMbox_sendOpcode failed.");
-        return false;
-    }
-    /* free local onject which was created in Open call */
-    kfree(accChObj);
-    /* hardware mailbox implementation to close accumulator channel goes here */
-    DPRINTK("HW mailbox called to free accumulator channel successful.");
-    return true;
-}
-#endif
 EXPORT_SYMBOL(PAL_cppi4AccChClose);
 
-bool Cppi41AccChangeEndianness(Cppi41HwMboxAccChOpenMsg_t *destCfgData, endianness_e endianity)
-{
-    if( !destCfgData )
-    {
-        EPRINTK(" null pointer reference ");
-        return false;
-    }
-    if( (endianity != endiannessBig) && (endianity != endiannessLittle) )
-    {
-        EPRINTK(" Endianness value pass in datapipe is not correct ");
-        return false; 
-    }
-
-    if(endianity == endiannessBig)
-    {
-        (*destCfgData).initCfg.accChanNum               =   cpu_to_be32((*destCfgData).initCfg.accChanNum);
-        (*destCfgData).initCfg.mode                     =   cpu_to_be32((*destCfgData).initCfg.mode);
-        (*destCfgData).initCfg.queue.qMgr               =   cpu_to_be32((*destCfgData).initCfg.queue.qMgr);
-        (*destCfgData).initCfg.queue.qNum               =   cpu_to_be32((*destCfgData).initCfg.queue.qNum);
-        (*destCfgData).initCfg.pacingTickCnt            =   cpu_to_be32((*destCfgData).initCfg.pacingTickCnt);
-        (*destCfgData).initCfg.list.listBase            =   (void *)cpu_to_be32((unsigned int)(*destCfgData).initCfg.list.listBase);
-        (*destCfgData).initCfg.list.maxPageEntry        =   cpu_to_be32((*destCfgData).initCfg.list.maxPageEntry);
-        (*destCfgData).initCfg.list.pacingMode          =   cpu_to_be32((*destCfgData).initCfg.list.pacingMode);
-        (*destCfgData).initCfg.list.stallAvoidance      =   cpu_to_be32((*destCfgData).initCfg.list.stallAvoidance);
-        (*destCfgData).initCfg.list.listCountMode       =   cpu_to_be32((*destCfgData).initCfg.list.listCountMode);
-        (*destCfgData).initCfg.list.listEntrySize       =   cpu_to_be32((*destCfgData).initCfg.list.listEntrySize);
-        (*destCfgData).initCfg.list.maxPageCnt          =   cpu_to_be32((*destCfgData).initCfg.list.maxPageCnt);
-        (*destCfgData).initCfg.monitor.pktCountThresh   =   cpu_to_be32((*destCfgData).initCfg.monitor.pktCountThresh);
-        (*destCfgData).initCfg.monitor.pacingMode       =   cpu_to_be32((*destCfgData).initCfg.monitor.pacingMode);
-    }
-    if(endianity == endiannessLittle)
-    {
-        (*destCfgData).initCfg.accChanNum               =   be32_to_cpu((*destCfgData).initCfg.accChanNum);
-        (*destCfgData).initCfg.mode                     =   be32_to_cpu((*destCfgData).initCfg.mode);
-        (*destCfgData).initCfg.queue.qMgr               =   be32_to_cpu((*destCfgData).initCfg.queue.qMgr);
-        (*destCfgData).initCfg.queue.qNum               =   be32_to_cpu((*destCfgData).initCfg.queue.qNum);
-        (*destCfgData).initCfg.pacingTickCnt            =   be32_to_cpu((*destCfgData).initCfg.pacingTickCnt);
-        (*destCfgData).initCfg.list.listBase            =   (void *)be32_to_cpu((*destCfgData).initCfg.list.listBase);
-        (*destCfgData).initCfg.list.maxPageEntry        =   be32_to_cpu((*destCfgData).initCfg.list.maxPageEntry);
-        (*destCfgData).initCfg.list.pacingMode          =   be32_to_cpu((*destCfgData).initCfg.list.pacingMode);
-        (*destCfgData).initCfg.list.stallAvoidance      =   be32_to_cpu((*destCfgData).initCfg.list.stallAvoidance);
-        (*destCfgData).initCfg.list.listCountMode       =   be32_to_cpu((*destCfgData).initCfg.list.listCountMode);
-        (*destCfgData).initCfg.list.listEntrySize       =   be32_to_cpu((*destCfgData).initCfg.list.listEntrySize);
-        (*destCfgData).initCfg.list.maxPageCnt          =   be32_to_cpu((*destCfgData).initCfg.list.maxPageCnt);
-        (*destCfgData).initCfg.monitor.pktCountThresh   =   be32_to_cpu((*destCfgData).initCfg.monitor.pktCountThresh);
-        (*destCfgData).initCfg.monitor.pacingMode       =   be32_to_cpu((*destCfgData).initCfg.monitor.pacingMode);
-    }
-    return true;
-}
-EXPORT_SYMBOL(Cppi41AccChangeEndianness);
-
 void* PAL_cppi4AccChGetNextList(PAL_Cppi4AccChHnd hnd)
 {
     PAL_Cppi4AccChObj *accChObj = (PAL_Cppi4AccChObj *) hnd;
diff -Naur a/arch/x86/platform/intel-ce2700/Makefile b/arch/x86/platform/intel-ce2700/Makefile
--- a/arch/x86/platform/intel-ce2700/Makefile	2017-10-11 10:16:36.326083000 +0530
+++ b/arch/x86/platform/intel-ce2700/Makefile	2017-10-11 09:35:36.771839000 +0530
@@ -1 +1,2 @@
 obj-$(CONFIG_X86_INTEL_CE2700) += intel-ce2700.o
+obj-$(CONFIG_X86_INTEL_HAVEN_PARK) += haven_park.o
diff -Naur /dev/null b/arch/x86/platform/intel-ce2700/haven_park.c
--- /dev/null
+++ b/arch/x86/platform/intel-ce2700/haven_park.c	2017-10-11 09:35:36.770839000 +0530
@@ -0,0 +1,61 @@
+/*
+ * haven-park.c Board file for Haven Park platform
+ * Copyright (c) 2016 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/power/ap21x1_switch.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+
+static struct ap21x1_data ap21x1[] = {
+	{
+		/* Controlling - USB Type A connector */
+		.gpio_vin = 172, /* EXT_INT4_ARM11_RTCK_3P3 */
+		.gpio_vin_assert_value = 0,
+		.gpio_oc = 280,  /* USB_OC1_B_1P8 */
+		.gpio_oc_assert_value = 0,
+		.gpio_oc_irq = 0,
+	},
+	{
+		/* Controlling - USB Type C connector */
+		.gpio_vin = 237 /* SC0_CLK_3P3 */,
+		.gpio_vin_assert_value = 0,
+		.gpio_oc = 281, /* USB_OC0_B_1P8 */
+		.gpio_oc_assert_value = 0,
+		.gpio_oc_irq = 0,
+	},
+};
+
+static struct platform_device ap21x1_devices[] = {
+	{
+		.name	= "ap21x1",
+		.id	= -1,
+		.dev	= {
+			.platform_data	= &ap21x1[0],
+		},
+	},
+	{
+		.name	= "pxa21x1",
+		.id	= -1,
+		.dev	= {
+			.platform_data	= &ap21x1[1],
+		},
+	},
+};
+
+static int __init hp_platform_init(void)
+{
+	return platform_add_devices(ap21x1_devices,
+			ARRAY_SIZE(ap21x1_devices));
+}
+
+device_initcall(hp_platform_init);
diff -Naur a/arch/x86/pp_init/puma7_pp_init.c b/arch/x86/pp_init/puma7_pp_init.c
--- a/arch/x86/pp_init/puma7_pp_init.c	2017-10-11 10:16:35.542024000 +0530
+++ b/arch/x86/pp_init/puma7_pp_init.c	2017-10-11 09:35:35.947795000 +0530
@@ -39,13 +39,12 @@
 #include <linux/avalanche/puma7/puma7_cppi.h>
 #include <linux/avalanche/puma7/puma7_cppi_prv.h>
 #include <linux/avalanche/puma7/puma7.h>
-#include <linux/avalanche/generic/cppi41_hw_mbox_if.h>
 #include <linux/avalanche/generic/avalanche_intc.h>
 #include <linux/netdevice.h>
 #include <linux/unistd.h>
 #include <linux/interrupt.h>
 #include <linux/netip_subsystem.h>
-#include <linux/handshake_server.h>
+
 
 #ifdef CONFIG_ARM_AVALANCHE_SOC
 /* interrupts NPCPU*/
@@ -475,16 +474,6 @@
         goto tx_comp_exit;
     }
 
-    if(cppi41_hw_mbox_init())
-    {
-        pr_err("%s(%d): Error - cppi41_hw_mbox_init failed!\n", __FUNCTION__, __LINE__);
-        goto tx_comp_exit;
-    }
-
-#ifdef CONFIG_MRPC_HANDSHAKE
-        boot_status_report(HANDSHAKE_ID_PP_INIT);
-#endif
-
 tx_comp_exit:
     return ret;
 }
@@ -499,6 +488,6 @@
 
 
 MODULE_AUTHOR ("Intel Corporation");
-MODULE_DESCRIPTION ("pp_init");
+MODULE_DESCRIPTION (DRV_NAME);
 MODULE_LICENSE("GPL");
-MODULE_VERSION("1.0");
+MODULE_VERSION(DRV_VERSION);
diff -Naur a/drivers/mrpc/Kconfig b/drivers/mrpc/Kconfig
--- a/drivers/mrpc/Kconfig	2017-10-11 10:17:03.435306000 +0530
+++ b/drivers/mrpc/Kconfig	2017-10-11 09:36:03.228998000 +0530
@@ -26,12 +26,12 @@
     help
        RPC over HW mailbox example server
 
-config MRPC_CONNTRACK_CLIENT
-    bool "ATOM to ARM CONNTRACK RPC over HW Mailbox"
-    depends on MRPC && APPCPU_GW_PP_HANDLE
+config MRPC_MODPHY_CLIENT
+    tristate "modphy mrpc client"
+    depends on MRPC
     default n
     help
-       Enable Puma7 conntrack MRPC between ATOM and ARM
+       modphy mrpc client
 
 config MRPC_HANDSHAKE
     tristate "handshake mrpc client"
@@ -47,12 +47,19 @@
     help
        Packet Processor mrpc client
 
-config MRPC_MODPHY_CLIENT
-    tristate "modphy mrpc client"
+config MRPC_CONNTRACK_CLIENT
+    bool "ATOM to ARM CONNTRACK RPC over HW Mailbox"
+    depends on MRPC && APPCPU_GW_PP_HANDLE
+    default n
+    help
+       Enable Puma7 conntrack MRPC between ATOM and ARM
+
+config MRPC_PP_CLIENT
+    bool "ATOM to ARM PP PROC over HW Mailbox"
     depends on MRPC
     default n
     help
-       modphy mrpc client
+       Enable Puma7 PP MRPC between ATOM and ARM
 
 config MRPC_HIL_CMDS_CLIENT
     bool "ATOM to ARM HIL commands over HW Mailbox"
@@ -61,45 +68,16 @@
     help
        Enable Puma7 HIL command handle MRPC between ATOM and ARM
 
-config MRPC_WIFI_PROXY_CLIENT
-    bool "ATOM to ARM wifi commands over HW Mailbox"
+config MRPC_CPPI_CLIENT
+    tristate "cppi mrpc client"
     depends on MRPC
     default n
     help
-       Enable wifi MRPC between ATOM and ARM
+       cppi mrpc client
 
-+config MRPC_CPPI_SERVER
+config MRPC_CPPI_SERVER
     tristate "cppi MRPC server"
     depends on MRPC
     default n
     help
        cppi MRPC server driver support
-
-config MRPC_CPPI_CLIENT
-    tristate "CPPI MRPC client"
-    depends on MRPC
-    default n
-    help
-       CPPI MRPC client provides CPPI related operations that are implemented
-       on ARM side over MRPC interface.
-
-config MRPC_SGC_SERVER
-    bool "Session Group Counter server"
-    depends on MRPC
-    default n
-    help
-       Session Group Counter MRPC server driver support
-
-config MRPC_HIL_EVENTS_SERVER
-    bool "ARM to ATOM HIL events over HW Mailbox"
-    depends on MRPC
-    default n
-    help
-       Enable HIL events MRPC between ARM and ATOM
-
-config MRPC_GPIO_CLIENT
-    tristate "GPIO MRPC client for NETIP GPIOs"
-    depends on MRPC
-    default n
-    help
-       GPIO MRPC client for NETIP GPIOs
diff -Naur a/drivers/mrpc/Makefile b/drivers/mrpc/Makefile
--- a/drivers/mrpc/Makefile	2017-10-11 10:17:03.434295000 +0530
+++ b/drivers/mrpc/Makefile	2017-10-11 09:36:03.227996000 +0530
@@ -1,10 +1,7 @@
-obj-$(CONFIG_MRPC)		 += core/
-obj-$(CONFIG_MRPC_EXAMPLES)	 += examples/
-obj-$(CONFIG_MRPC_MODPHY_CLIENT) += modphy_client.o
-obj-$(CONFIG_MRPC_HANDSHAKE)	 += handshake_client.o handshake_server.o
-obj-$(CONFIG_MRPC_PP_CLIENT)	 += pp_client.o
-obj-$(CONFIG_MRPC_CPPI_CLIENT)	 += cppi_client.o
-obj-$(CONFIG_MRPC_CPPI_SERVER) 	 += cppi_server.o
-obj-$(CONFIG_MRPC_SGC_SERVER)    += sgc_server.o
-obj-$(CONFIG_MRPC_HIL_EVENTS_SERVER)    += hil_events_server.o
-obj-$(CONFIG_MRPC_GPIO_CLIENT)          += gpio_client.o
+obj-$(CONFIG_MRPC)		+= core/
+obj-$(CONFIG_MRPC_EXAMPLES)	+= examples/
+obj-$(CONFIG_MRPC_MODPHY_CLIENT)	+= modphy_client.o
+obj-$(CONFIG_MRPC_PP_CLIENT)		+= pp_client.o
+obj-$(CONFIG_MRPC_HANDSHAKE)		+= handshake_client.o
+obj-$(CONFIG_MRPC_CPPI_SERVER) 		+= cppi_server.o
+obj-$(CONFIG_MRPC_CPPI_CLIENT)		+= cppi_client.o
diff -Naur a/drivers/mrpc/core/Makefile b/drivers/mrpc/core/Makefile
--- a/drivers/mrpc/core/Makefile	2017-10-11 10:17:03.415299000 +0530
+++ b/drivers/mrpc/core/Makefile	2017-10-11 09:36:03.210998000 +0530
@@ -1,9 +1,4 @@
 obj-$(CONFIG_MRPC) += mrpc.o
-
-ifneq ($(CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL),y)
-	obj-$(CONFIG_MRPC_CONNTRACK_CLIENT) += conntrack_client.o
-	obj-$(CONFIG_MRPC_PP_CLIENT) += pp_client.o
-	obj-$(CONFIG_MRPC_HIL_CMDS_CLIENT) += hil_cmds_client.o
-endif
-
-obj-$(CONFIG_MRPC_WIFI_PROXY_CLIENT) += wifi_proxy_client.o
+obj-$(CONFIG_MRPC_CONNTRACK_CLIENT) += conntrack_client.o
+obj-$(CONFIG_MRPC_PP_CLIENT) += pp_client.o
+obj-$(CONFIG_MRPC_HIL_CMDS_CLIENT) += hil_cmds_client.o
diff -Naur a/drivers/mrpc/core/conntrack_client.c b/drivers/mrpc/core/conntrack_client.c
--- a/drivers/mrpc/core/conntrack_client.c	2017-10-11 10:17:03.417292000 +0530
+++ b/drivers/mrpc/core/conntrack_client.c	2017-10-11 09:36:03.212001000 +0530
@@ -51,7 +51,6 @@
 #include <linux/mrpc.h>
 #include <linux/ti_hil.h>
 #include <linux/platform_device.h>
-#include <linux/circ_buf.h>
 #include <net/netfilter/nf_conntrack.h>
 #include <net/netfilter/nf_conntrack_l3proto.h>
 #include <net/netfilter/nf_conntrack_l4proto.h>
@@ -78,40 +77,21 @@
 #define DBG(fmt, ...) pr_debug(fmt, ##__VA_ARGS__)
 #endif
 
-/* HACK - redefine IP_CT_DIR_ORIGINAL from 0 to 1 just in minimize the changes.
-LAN to WAN UDP NAT'd traffic related connection tracking entry on ATOM was not match
-with the Packet Processor Session in ARM due to conflicts in learning the connection
-tracking entry at ARM and ATOM. (mainly due to Puma7 slow path packet flow).
-By choosing CT reply tuple information, we could match all the possible packet flow
-scenarios. LAN to LAN, LAN to WAN, bridge mode.*/
-/*NOTE: This module will be disabled once we get the PP on ATOM working!*/
-#define IP_CT_DIR_ORIGINAL 1
+#define IP_CT_DIR_ORIGINAL 0
 #define IP_CT_DIR_REPLY 1
 #define CT_MRPC_FALIURE -1
 #define IN_PROGRESS 1
 #define COMPLETE 0
-/*Circular buffer size - allocated during boot up 
-  CB_MAX should be power-of-2 while we use linux 
-  provided macros to handle circular buffer data*/
-#define CB_MAX 1024
 
 static struct platform_device *ct_client_device;
-/* connection tracking entry and event type - per connection */
-struct ct_worker_info {
-    struct nf_conn *ct;
-    unsigned long event;
-};
 
 struct ct_client_private {
     struct platform_device *pdev;
     struct mrpc_client *mrpc;
     struct notifier_block ct_event_notifier;
     struct workqueue_struct *workQ;
-    struct work_struct worker;
-    struct circ_buf ct_data; /* connection tracking data buffer*/
     unsigned int call_success_count;/* number of successful MRPC calls made */
     unsigned int call_failure_count;/* number of failure  MRPC calls made */
-    unsigned int cb_alloc_failure_count; /* number of workqueue log failures */
 
 };
 
@@ -128,6 +108,12 @@
 	int  extend_timeout;
 };
 
+struct ct_worker_info {
+    struct work_struct work;
+    struct nf_conn *ct;
+    unsigned long event;
+};
+
 enum {
 	TI_CT_DEATH_BY_TIMEOUT_PROC = 0,
         TI_NPCPU_CONNTRACK_FLUSH_PROC = 1,
@@ -147,7 +133,7 @@
    int ret, errcode;
    if(!priv)
    {
-     pr_info("ERROR: Conntrack MRPC client not initialized");
+     pr_err("ERROR: Conntrack MRPC client not initialized");
      return CT_MRPC_FALIURE;
    }
 
@@ -254,25 +240,17 @@
  */
 static void ct_tuple_info_fetcher(struct work_struct *work_arg)
 {
-   struct ct_client_private *priv = this;
-   struct circ_buf *cb = &priv->ct_data;
+   struct ct_worker_info *worker = container_of(work_arg, struct ct_worker_info, work);
+   struct nf_conn *ct = worker->ct;
+   unsigned long event = worker->event;
    unsigned long extend_ct_time;
    struct mrpc_conntrack_tuple_info conntrack_tuple_info;
    struct mrpc_conntrack_arm_reply mrpc_reply;
    int extend_timeout = 0;
-   unsigned long event;
-   struct nf_conn *ct;
 
-   while(CIRC_CNT(cb->head, cb->tail, CB_MAX) >= 1)
+   switch(event)
    {
-     struct ct_worker_info *ct_work_info;
-     ct_work_info = &((struct ct_worker_info *)cb->buf)[cb->tail];
-     ct = ct_work_info->ct;
-     event = ct_work_info->event;
-     smp_read_barrier_depends();
-     switch(event)
-     {
-        case TI_CT_ENTRY_CREATED:
+      case TI_CT_ENTRY_CREATED:
 	  /*Do nothing. When there is a connection tracking entry getting created,the ARM side
 	   *init_conntrack generates this event to PP HIL layer.The HIL profile sets the
 	   *ti_pp_status_flag to TI_PP_BYPASS if this connection is associated to an ALG.
@@ -282,8 +260,8 @@
 	   *We don't need to sync the TI_CT_ENTRY_CREATED event with ARM as the SKB PP_INFO
 	   *flag set/reset is handled locally by ARM.
 	   */
-        break;
-        case TI_CT_DEATH_BY_TIMEOUT:
+      break;
+      case TI_CT_DEATH_BY_TIMEOUT:
 	   /*memset(&conntrack_tuple_info,0,sizeof(struct mrpc_conntrack_tuple_info));*/
 
 	   /*Copy required tuple information from timeout ct to conntrack_tuple_info.
@@ -323,18 +301,17 @@
 	     DBG("ARM replyed to KILL conntrack record. delete record.\n");
 	     ct->ti_pp_status_flag |= TI_PP_KILL_CONNTRACK;
 	   }
-        break;
-        case TI_NPCPU_CONNTRACK_FLUSH:
+      break;
+      case TI_NPCPU_CONNTRACK_FLUSH:
            printk(KERN_DEBUG "CT FLUSH event generated.MRPC NPCPU to flush the sessions\n");
            ct_mrpc_call(TI_NPCPU_CONNTRACK_FLUSH_PROC, &conntrack_tuple_info, &mrpc_reply);
-        break;
-        default:
+      break;
+      default:
 	   DBG("Connection tracking event not supported.");
-     } //switch
-     smp_mb();
-     cb->tail = (cb->tail + 1) & (CB_MAX - 1);
-   } //while
-   return;
+  }
+handle_error:
+  kfree(worker);
+  return;
 }
 
 /*Name: ct_tuple_info_worker
@@ -347,17 +324,14 @@
 {
    struct ct_client_private *priv = this;
    struct ct_worker_info *ct_work_info;
-   struct circ_buf *cb = &priv->ct_data;
 
-   if(!CIRC_SPACE(cb->head, cb->tail, CB_MAX))
+   ct_work_info = kzalloc(sizeof(*ct_work_info), GFP_ATOMIC);
+   if(!ct_work_info)
    {
-     pr_err("Error: MRPC Buffer FULL:Success: %d Failure: %d CB Failure: %d\n",            
-            priv->call_success_count,priv->call_failure_count,++priv->cb_alloc_failure_count);
-     return notifier_from_errno(-ENOSPC);
+     pr_err("Memory allocation failed for ct_work_info");
+     return NOTIFY_DONE;
    }
-   /*get the CB location to store the connection tracking ptr and event information */
-   ct_work_info = &((struct ct_worker_info *)cb->buf)[cb->head];
-    
+
    if(event == TI_NPCPU_CONNTRACK_FLUSH) 
    {
       ct_work_info->ct = NULL;
@@ -367,34 +341,13 @@
       ct_work_info->ct = (struct nf_conn *)ptr;
    }
    ct_work_info->event = event;
-   smp_wmb();
-   cb->head = (cb->head + 1) & (CB_MAX - 1);
-   queue_work(priv->workQ, &priv->worker);
-   return NOTIFY_DONE;
-}
-
-/*Name: create_data_buffer
- *Desc: creates and init the circular data buffer to handle connection tracking entry 
- *      and event info.
- *Input:NONE.
- *Return: 0 SUCCESS, -ENOMEM FAILURE
- */
+   INIT_WORK(&ct_work_info->work, ct_tuple_info_fetcher);
+   queue_work(priv->workQ, &ct_work_info->work);
 
-static int create_data_buffer(struct ct_client_private *priv)
-{
-  struct ct_worker_info *ct_info;
-  void *data_buff;
+   return NOTIFY_DONE;
 
-  priv->ct_data.head = 0;
-  priv->ct_data.tail = 0;
-  data_buff = kzalloc(sizeof(*ct_info) * CB_MAX, GFP_KERNEL);
-  if(!data_buff)
-  {
-    return -ENOMEM;
-  }
-  priv->ct_data.buf = data_buff;
-  return 0;
 }
+
 /*Name: nf_conn_info_event
  *Desc: Event notify function used by nf_conntrack module to post CT events to this module.
  *      conntrack_client_module.
@@ -414,11 +367,8 @@
    if(!priv)
      return -EINVAL;
 
-   return scnprintf(buf, PAGE_SIZE, "status ok.\nMRPC Success : %d\nMRPC Failure : %d\n" \
-                                    "CB Failure : %d\n", \
-                                     priv->call_success_count,\
-                                     priv->call_failure_count,\
-                                     priv->cb_alloc_failure_count);
+   return scnprintf(buf, PAGE_SIZE, "status ok.\nMRPC Success : %d\nMRPC Failure : %d\n",
+                                     priv->call_success_count,priv->call_failure_count);
 
 }
 
@@ -456,12 +406,6 @@
       pr_err("sysfs_create_group failed (ret=%d)", ret);
       return ret;
   }
-  /*Create circular buffer to handle conntrack timeout MRPC request */
-  ret = create_data_buffer(priv);
-  if(ret) {
-      pr_err("Conntrack MRPC circular data buffer creation and init failed.");
-      goto out_remove_group;
-  }
 
   priv->workQ = create_workqueue("Connection tracking MRPC worker");
   if(!priv->workQ) {
@@ -469,8 +413,6 @@
       ret = -ENOMEM;
       goto out_remove_group;
   }
-  /*Init workqueue*/ 
-  INIT_WORK(&priv->worker, ct_tuple_info_fetcher);  
 
   priv->mrpc = mrpc_client_register(MRPC_RESERVED_ID_CONNTRACK,
 				    "Connection Tracking Client");
@@ -485,7 +427,6 @@
   atomic_notifier_chain_register(&ct_chain, &ct_info_notifier_block);
   priv->call_success_count = 0;
   priv->call_failure_count = 0;
-  priv->cb_alloc_failure_count = 0;
   this = priv;
   return 0;
 
diff -Naur a/drivers/mrpc/core/wifi_proxy_client.c b/drivers/mrpc/core/wifi_proxy_client.c
--- a/drivers/mrpc/core/wifi_proxy_client.c	2017-10-11 10:17:03.411289000 +0530
+++ b/drivers/mrpc/core/wifi_proxy_client.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,432 +0,0 @@
-/*
- *
- * wifi_proxy_client.c
- * Description:
- * wifi_proxy over MRPC client driver
- *
- *
- * GPL LICENSE SUMMARY
- *
- *  Copyright(c) 2016 Intel Corporation.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of version 2 of the GNU General Public License as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *  The full GNU General Public License is included in this distribution
- *  in the file called LICENSE.GPL.
- *
- *  Contact Information:
- *  Intel Corporation
- *  2200 Mission College Blvd.
- *  Santa Clara, CA  97052
- */
-
-/************************************************/
-/**                    Includes                 */
-/************************************************/
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/slab.h>
-#include <linux/byteorder/generic.h>
-#include <linux/types.h>
-#include <linux/mutex.h>
-#include <linux/err.h>
-#include <linux/mrpc.h>
-
-#define WIFI_PROXY_MAX_PIDS         (4)
-#define WIFI_PROXY_MAX_VAPIDS       (50)
-#define WIFI_PROXY_INVALID_PID      (-1)
-#define MRPC_WIFI_PROXY_TIMEOUT_MS  (800)
-/* driver private database */
-struct wifi_proxy_private {
-	struct kobject *kobj;           /* kobj for sysfs */
-	struct mrpc_client *mrpc;       /* mrpc client handle */
-	int    pids[WIFI_PROXY_MAX_PIDS];
-	int    vpids[WIFI_PROXY_MAX_PIDS][WIFI_PROXY_MAX_VAPIDS];
-	int    DevID;
-	int    VapID;
-};
-
-enum wifi_dev_id {
-	WIFI_DEV_ID_0 = 0,
-	WIFI_DEV_ID_1,
-	WIFI_DEV_ID_2,
-	WIFI_DEV_ID_3,
-	WIFI_DEV_ID_MAX,
-} wifi_dev_id_e;
-
-enum wifi_vap_id {
-	WIFI_VAP_ID_0 = 0,
-	WIFI_VAP_ID_1,
-	WIFI_VAP_ID_2,
-	WIFI_VAP_ID_3,
-	WIFI_VAP_ID_MAX,
-} wifi_vap_id_e;
-
-struct wifi_proxy_args {
-	uint32_t devId;
-	uint32_t vapId;
-	uint32_t rate;
-	uint32_t pps;
-};
-
-enum wifi_mrpc_id {
-	WIFI_PROXY_PID_CREATE_PROC = 0,
-	WIFI_PROXY_PID_DELETE_PROC,
-	WIFI_PROXY_VAP_CREATE_PROC,
-	WIFI_PROXY_VAP_DELETE_PROC,
-	WIFI_PROXY_MAX_PROC,
-};
-
-static struct wifi_proxy_private *priv;
-
-static void wifi_proxy_initialize_pid_vpids(void)
-{
-	int i, j;
-
-	if (!priv)
-		return;
-
-	for (i = 0; i < WIFI_PROXY_MAX_PIDS; i++) {
-		priv->pids[i] = WIFI_PROXY_INVALID_PID;
-		for (j = 0; j < WIFI_PROXY_MAX_VAPIDS; j++)
-			priv->vpids[i][j] = WIFI_PROXY_INVALID_PID;
-	}
-
-}
-
-static int make_mrpc_call(enum wifi_mrpc_id proc_id,
-		struct wifi_proxy_args *args, int *reply)
-{
-	int ret, errorcode;
-	int repargs;
-	ret = mrpc_call(priv->mrpc, proc_id,
-			args, sizeof(struct wifi_proxy_args),
-			&repargs, sizeof(repargs),
-			MRPC_WIFI_PROXY_TIMEOUT_MS, &errorcode);
-	if (ret) {
-		*reply = -1;
-		pr_err("mrpc call proc %d failed ret = %d errorcode = %08X\n",
-				proc_id, ret, errorcode);
-	} else {
-		*reply = be32_to_cpu(repargs);
-		pr_debug("PROC ID %d Received Handle = %d\n", proc_id, repargs);
-	}
-	return ret;
-}
-int mrpc_wifi_proxy_pid_create(uint32_t DevID, int *pid_handle)
-{
-	struct  wifi_proxy_args args;
-	if (!priv || !pid_handle)
-		return -EINVAL;
-
-	pr_debug("call wifi_proxy_pid_create %u\n", DevID);
-
-	args.devId = cpu_to_be32(DevID);
-	/* Create new wifi_proxy pid according to devId,
-	 * return actual pid number to be placed in descriptor */
-	return make_mrpc_call(WIFI_PROXY_PID_CREATE_PROC, &args, pid_handle);
-}
-EXPORT_SYMBOL(mrpc_wifi_proxy_pid_create);
-
-int mrpc_wifi_proxy_vap_create(uint32_t DevID, uint32_t VapID,
-				uint32_t rate, uint32_t pps,
-				int *vpid_handle)
-{
-	struct  wifi_proxy_args args;
-	if (!priv || !vpid_handle)
-		return -EINVAL;
-	pr_debug("call wifi_proxy_vpid_create %u %u\n", DevID, VapID);
-
-	args.devId = cpu_to_be32(DevID);
-	args.vapId = cpu_to_be32(VapID);
-	args.rate  = cpu_to_be32(rate);
-	args.pps   = cpu_to_be32(pps);
-	/* Create new wifi_proxy pid according to devId,
-	 * return actual pid number to be placed in descriptor */
-	return make_mrpc_call(WIFI_PROXY_VAP_CREATE_PROC, &args, vpid_handle);
-}
-EXPORT_SYMBOL(mrpc_wifi_proxy_vap_create);
-
-int mrpc_wifi_proxy_pid_delete(uint32_t DevID, int *retCode)
-{
-	struct wifi_proxy_args args;
-	if (!priv || !retCode)
-		return -EINVAL;
-
-	pr_debug("call wifi_proxy_pid_delete %u\n", DevID);
-
-	args.devId = cpu_to_be32(DevID);
-	args.vapId = 0xFFFFFFFF;
-
-	return make_mrpc_call(WIFI_PROXY_PID_DELETE_PROC, &args, retCode);
-}
-EXPORT_SYMBOL(mrpc_wifi_proxy_pid_delete);
-
-int mrpc_wifi_proxy_vap_delete(uint32_t DevID, uint32_t VapID, int *retCode)
-{
-	struct wifi_proxy_args args;
-	if (!priv || !retCode)
-		return -EINVAL;
-
-	pr_debug("call wifi_proxy_vap_delete %u %u\n", DevID, VapID);
-
-	args.devId = cpu_to_be32(DevID);
-	args.vapId = cpu_to_be32(VapID);
-
-	return make_mrpc_call(WIFI_PROXY_VAP_DELETE_PROC, &args, retCode);
-}
-EXPORT_SYMBOL(mrpc_wifi_proxy_vap_delete);
-
-static ssize_t wifi_proxy_client_call(struct kobject *kobj,
-		struct kobj_attribute *attr, char *buf, size_t cnt)
-{
-	ssize_t ret;
-	int retCode;
-	enum wifi_mrpc_id proc_id;
-	unsigned long attribute_value;
-
-	ret = kstrtoul(buf, 0, &attribute_value);
-	if (ret != 0)
-		return ret;
-
-	proc_id = attribute_value;
-
-	if (!priv || proc_id >= WIFI_PROXY_MAX_PROC)
-		return -EINVAL;
-	switch (proc_id) {
-	case WIFI_PROXY_PID_CREATE_PROC:
-		if (priv->pids[priv->DevID] == WIFI_PROXY_INVALID_PID) {
-			ret = mrpc_wifi_proxy_pid_create(priv->DevID,
-					&priv->pids[priv->DevID]);
-		} else {
-			pr_info(
-			"Already Allocated PID DevID:Handle [%d:%d]\n",
-			priv->DevID,
-			priv->pids[priv->DevID]);
-		}
-		break;
-	case WIFI_PROXY_VAP_CREATE_PROC:
-		if (priv->pids[priv->DevID] != WIFI_PROXY_INVALID_PID) {
-			if (priv->vpids[priv->DevID][priv->VapID] ==
-					WIFI_PROXY_INVALID_PID)
-				ret = mrpc_wifi_proxy_vap_create(
-				priv->DevID, priv->VapID, 0, 0,
-				&priv->vpids[priv->DevID][priv->VapID]);
-			else
-				pr_info(
-				"Already Allocated VapID:Handle [%d]:[%d]\n",
-				priv->VapID,
-				priv->vpids[priv->DevID][priv->VapID]);
-		} else {
-			pr_info("Invalid DevID:Handle [%d:%d]\n",
-					priv->DevID,
-					priv->pids[priv->DevID]);
-		}
-		break;
-	case WIFI_PROXY_PID_DELETE_PROC:
-		if (priv->pids[priv->DevID] != WIFI_PROXY_INVALID_PID) {
-			ret = mrpc_wifi_proxy_pid_delete(priv->DevID, &retCode);
-			if (!ret)
-				priv->pids[priv->DevID] =
-					WIFI_PROXY_INVALID_PID;
-		} else {
-			pr_info("Invalid DevID:Handle [%d:%d]\n",
-					priv->DevID, priv->pids[priv->DevID]);
-		}
-		break;
-	case WIFI_PROXY_VAP_DELETE_PROC:
-		if (priv->pids[priv->DevID] != WIFI_PROXY_INVALID_PID &&
-			priv->vpids[priv->DevID][priv->VapID] !=
-					WIFI_PROXY_INVALID_PID) {
-			ret = mrpc_wifi_proxy_vap_delete(priv->DevID,
-					priv->VapID, &retCode);
-			if (!ret)
-				priv->vpids[priv->DevID][priv->VapID] =
-					WIFI_PROXY_INVALID_PID;
-		} else {
-			pr_info(
-			"Invalid DevID:Handle [%d:%d] VapiID:Handle [%d:%d]\n",
-			priv->DevID, priv->pids[priv->DevID],
-			priv->VapID,
-			priv->vpids[priv->DevID][priv->VapID]);
-		}
-		break;
-	default:
-		break;
-	}
-	if (!ret)
-		ret = cnt;
-	return ret;
-}
-
-static ssize_t pid_vpid_show(struct kobject *kobj,
-		struct kobj_attribute *attr, char *buf)
-{
-	int ret = 0, i, j;
-	char *ptr = buf;
-	char *end = buf + PAGE_SIZE;
-
-	if (!priv)
-		return -EINVAL;
-	if (!strncmp(attr->attr.name, "PIDS", 4)) {
-		for (i = 0; i < WIFI_PROXY_MAX_PIDS; i++)
-			ptr += scnprintf(ptr, (end-ptr), "%02d:%03d ",
-							i, priv->pids[i]);
-		ptr += scnprintf(ptr, (end-ptr), "\n");
-	} else if (!strncmp(attr->attr.name, "VPIDS", 6)) {
-		for (i = 0; i < WIFI_PROXY_MAX_PIDS; i++) {
-			ptr += scnprintf(ptr, (end-ptr),
-					"\nDevID-%02d:%3d\n", i,
-					priv->pids[i]);
-			for (j = 0; j < WIFI_PROXY_MAX_VAPIDS; j++) {
-				ptr += scnprintf(ptr, (end-ptr),
-						"%02d:%03d ",
-						j, priv->vpids[i][j]);
-			}
-		}
-		ptr += scnprintf(ptr, (end-ptr), "\n");
-	} else if (!strncmp(attr->attr.name, "DevID", 5)) {
-		ptr += scnprintf(buf, (end-ptr), "%d\n", priv->DevID);
-	} else if (!strncmp(attr->attr.name, "VapID", 5)) {
-		ptr += scnprintf(buf, (end-ptr), "%d\n", priv->VapID);
-	}
-	ret = ptr - buf;
-
-	return ret;
-}
-
-static ssize_t devid_vapid_store(struct kobject *kobj,
-		struct kobj_attribute *attr, char *buf, size_t cnt)
-{
-	int ret = 0;
-	unsigned long attribute_value;
-
-	ret = kstrtoul(buf, 0, &attribute_value);
-	if (ret != 0)
-		return ret;
-
-	if (!priv)
-		return -EINVAL;
-	if (!strncmp(attr->attr.name, "DevID", 5)) {
-		if (attribute_value < WIFI_PROXY_MAX_PIDS)
-			priv->DevID = attribute_value;
-		else
-			ret = -EINVAL;
-	} else if (!strncmp(attr->attr.name, "VapID", 5)) {
-		if (attribute_value < WIFI_PROXY_MAX_VAPIDS)
-			priv->VapID = attribute_value;
-		else
-			ret = -EINVAL;
-	}
-	if (!ret)
-		ret = cnt;
-	return ret;
-}
-
-
-static struct kobj_attribute client_call =
-	__ATTR(client_call, S_IWUSR, NULL, wifi_proxy_client_call);
-static struct kobj_attribute PIDS =
-	__ATTR(PIDS, S_IRUSR, pid_vpid_show, NULL);
-static struct kobj_attribute VPIDS =
-	__ATTR(VPIDS, S_IRUSR, pid_vpid_show, NULL);
-static struct kobj_attribute DevID =
-	__ATTR(DevID, S_IWUSR|S_IRUSR, pid_vpid_show, devid_vapid_store);
-static struct kobj_attribute VapID =
-	__ATTR(VapID, S_IWUSR|S_IRUSR, pid_vpid_show, devid_vapid_store);
-
-static struct attribute *wifi_proxy_attrs[] = {
-	&client_call.attr,
-	&PIDS.attr,
-	&VPIDS.attr,
-	&DevID.attr,
-	&VapID.attr,
-	NULL,
-};
-
-static struct attribute_group wifi_proxy_attrs_group = {
-	.attrs = wifi_proxy_attrs,
-};
-
-/**
- * wifi_proxy_client_init
- *
- * This function is called when the wifi_proxy_client module is
- * initialized.
- * @return 0 for success, error code otherwise
- */
-static __init int wifi_proxy_client_init(void)
-{
-	int ret;
-
-	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
-		pr_err("memory allocation failed");
-		return -ENOMEM;
-	}
-	priv->mrpc = mrpc_client_register(MRPC_RESERVED_ID_WIFI_PROXY_FUNC_CALL,
-			"Wifi Proxy");
-	if (!priv->mrpc) {
-		pr_err("failed to register wifi_proxy");
-		ret = -ENODEV;
-		goto out_free_mem;
-	}
-	priv->kobj = kobject_create_and_add("wifi_mrpc_client", NULL);
-	if (!priv->kobj) {
-		ret = -ENOMEM;
-		goto out_mrpc_unreg;
-	}
-	wifi_proxy_initialize_pid_vpids();
-	ret = sysfs_create_group(priv->kobj,
-				&wifi_proxy_attrs_group);
-	if (ret) {
-		pr_err("sysfs_create_group failed (ret=%d)", ret);
-		goto out_kobj_put;
-	}
-
-	return ret;
-
-out_kobj_put:
-	kobject_put(priv->kobj);
-out_mrpc_unreg:
-	ret = mrpc_client_unregister(priv->mrpc);
-out_free_mem:
-	kfree(priv);
-	return ret;
-}
-
-/**
- * wifi_proxy_client_exit
- *
- * This function is called when the wifi_proxy_client module is
- * removed.
- * @return 0 for success error code otherwise
- */
-static __exit int wifi_proxy_client_exit(void)
-{
-	int ret;
-	ret = mrpc_client_unregister(priv->mrpc);
-	sysfs_remove_group(priv->kobj, &wifi_proxy_attrs_group);
-	kfree(priv);
-	priv = NULL;
-	return ret;
-}
-
-module_init(wifi_proxy_client_init);
-module_exit(wifi_proxy_client_exit);
-
-MODULE_AUTHOR("Intel Corporation");
-MODULE_DESCRIPTION("wifi_proxy mrpc client");
-MODULE_LICENSE("GPL");
-MODULE_VERSION("1.0");
diff -Naur a/drivers/mrpc/cppi_client.c b/drivers/mrpc/cppi_client.c
--- a/drivers/mrpc/cppi_client.c	2017-10-11 10:17:03.438292000 +0530
+++ b/drivers/mrpc/cppi_client.c	2017-10-11 09:36:03.230997000 +0530
@@ -51,7 +51,6 @@
 #include <linux/ethtool.h>
 #include <linux/mrpc.h>
 #include <linux/avalanche/generic/pal_cppi41.h>
-#include <linux/netip_mem_util.h> // Memory mapping utility is needed for CPPI buffer pools mapping
 
 #ifdef DEBUG
 #define DBG(fmt, ...) pr_err(fmt, ##__VA_ARGS__)
@@ -72,6 +71,7 @@
     Uint32 buffer_sz;
     Uint32 buffer_cnt;
 };
+
 typedef struct {
     Uint32 bMgr;
     Uint32 bPool;
@@ -81,27 +81,9 @@
     PAL_Result result;
     Cppi4BufPoolInfo bp_info;
 } cppi_get_bpool_info_rep_t;
-
-#ifdef CONFIG_PP_SANITY_TESTS
-struct cppi_sanity_dma_args {
-    Uint32 freeQMgr;
-    Uint32 freeQNum;
-    Uint32 freeBMgr;
-    Uint32 freeBpool;
-};
-#endif
-
-struct cppi_pp_buf_args {
-    Uint32 bMgr;
-    Uint32 bPool;
-    Uint32 bufAddr;
-};
-
 enum {
     CPPI_INIT_PP_WIFI_BUFFER_POOL = 0,
     CPPI_GET_BPOOL_INFO,
-    CPPI_CONFIGURE_SANITY_DMA_CHANNELS,
-    CPPI_POP_BUFFER_PP_REGION,
 };
 
 
@@ -124,7 +106,6 @@
         return errcode;
     }
 
-    return ntohl(rep);
     return be32_to_cpu(rep);
 }
 
@@ -148,6 +129,7 @@
         rep.result = errcode;
         return rep;
     }
+
     return rep;
 }
 
@@ -166,7 +148,6 @@
     return cppi_mrpc_call(CPPI_INIT_PP_WIFI_BUFFER_POOL, &args, sizeof(args));
 }
 EXPORT_SYMBOL(avalanche_cppi_init_pp_wifi_buffer_pool);
-
 /*
  * PAL_cppi4GetBufferPoolInfo
  *  - Get Buffer Pool info
@@ -202,47 +183,6 @@
 }
 EXPORT_SYMBOL(PAL_cppi4GetBufferPoolInfo);
 
-
-#ifdef CONFIG_PP_SANITY_TESTS
-/* DMA channels configuration for sanity tool */
-Int32 avalanche_cppi_init_pp_sanity_dma_channels(PAL_Handle palHandle, Cppi4Queue freeQ, Cppi4BufPool freeBuf)
-
-{
-    struct cppi_sanity_dma_args args;
-
-    args.freeQMgr = htonl(freeQ.qMgr);
-    args.freeQNum = htonl(freeQ.qNum);
-    args.freeBMgr = htonl(freeBuf.bMgr);
-    args.freeBpool = htonl(freeBuf.bPool);
-
-    return cppi_mrpc_call(CPPI_CONFIGURE_SANITY_DMA_CHANNELS, &args, sizeof(args));
-}
-EXPORT_SYMBOL(avalanche_cppi_init_pp_sanity_dma_channels);
-#endif
-
-/*
- * PAL_cppi4BufPopBuf
- *  - Decrement the reference count of the valid buffer
- */
-Ptr PAL_cppi4BufPopBuf (PAL_Handle hnd, Cppi4BufPool pool)
-{
-    struct cppi_pp_buf_args args;
-
-    // Approach mem_util with the pool to map
-    if (netip_memmap_cppi_bPool(pool.bPool))
-    {
-        printk("%s:%d ERROR !!! Failed to map buffer pool memory region !!!\n",__FUNCTION__,__LINE__);
-        return NULL;
-    }
-
-    args.bMgr = htonl(pool.bMgr);
-    args.bPool = htonl(pool.bPool);
-    args.bufAddr = 0;
-
-    return (void*)cppi_mrpc_call(CPPI_POP_BUFFER_PP_REGION, &args, sizeof(args));
-}
-EXPORT_SYMBOL(PAL_cppi4BufPopBuf);
-
 /* sysfs for future use */
 static ssize_t status_show(struct device *dev,
                            struct device_attribute *attr, char *buf)
diff -Naur a/drivers/mrpc/gpio_client.c b/drivers/mrpc/gpio_client.c
--- a/drivers/mrpc/gpio_client.c	2017-10-11 10:17:03.429294000 +0530
+++ b/drivers/mrpc/gpio_client.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,402 +0,0 @@
-/*
- *
- * gpio_client.c
- * Description:
- * gpio mrpc client driver
- *
- *
- * GPL LICENSE SUMMARY
- *
- *  Copyright(c) 2016 Intel Corporation.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of version 2 of the GNU General Public License as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *  The full GNU General Public License is included in this distribution
- *  in the file called LICENSE.GPL.
- *
- *  Contact Information:
- *  Intel Corporation
- *  2200 Mission College Blvd.
- *  Santa Clara, CA  97052
- */
-
-/************************************************/
-/**                    Includes                 */
-/************************************************/
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/byteorder/generic.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/mutex.h>
-#include <linux/workqueue.h>
-#include <linux/err.h>
-#include <linux/netdevice.h>
-#include <linux/ethtool.h>
-#include <linux/mrpc.h>
-#include <linux/ioctl.h>
-#include <linux/cdev.h>
-#include <linux/avalanche/generic/gpio_mrpc_api.h>
-
-#define DEV_NAME          "docsis_gpio_dev"
-
-#define FIRST_MINOR 0
-#define MINOR_CNT   1
-
-#define GPIO_CLIENT_MRPC_CALL_TIMEOUT_MS (1000) /* Timeout is needed due to delays in gpio server */
-
-static long gpio_proxy_ioctl(struct file *fd, unsigned int cmd, unsigned long arg);
-
-/**************************************************************************/
-/*      LOCAL VARIABLES:                                                  */
-/**************************************************************************/
-
-static dev_t dev;
-static struct cdev *c_dev;
-static struct class *cl;
-
-/* Structure to map driver functions to kernel */
-static struct file_operations gpio_drv_fops =
-{
-    .owner   = THIS_MODULE,
-    .unlocked_ioctl   = gpio_proxy_ioctl /*We assume there are no 2 processes in a race condition*/
-};
-
-/* driver private database */
-struct gpio_private {
-    struct platform_device *pdev;   /* platform device */
-    struct mrpc_client *mrpc;       /* mrpc client handle */
-};
-
-static struct gpio_private *this;
-
-enum {
-    GPIO_SET_DIR_PROC = 0,
-    GPIO_SET_VAL_PROC
-};
-
-static inline int gpio_mrpc_call(__u8 procid,
-		                           int gpio,
-								   int dir,
-                                   int value)
-{
-    struct gpio_private *priv = this;
-    struct gpio_user_info args;
-    int ret, errcode;
-
-    if (!priv) {
-        pr_err("ERROR: mrpc gpio not initialized");
-        return GPIO_FAIL;
-    }
-
-    args.gpio_pin = htonl(gpio);
-    args.pin_direction = htonl(dir);
-    args.value = htonl(value);
-
-    ret = mrpc_call(priv->mrpc,
-                    procid,
-                    &args,
-                    sizeof(args),
-                    NULL,
-                    0,
-                    GPIO_CLIENT_MRPC_CALL_TIMEOUT_MS,
-                    &errcode);
-
-    if (ret || errcode) {
-        pr_err("ERROR: ret=%d, errcode=%d", ret, errcode);
-        return GPIO_FAIL;
-    }
-
-    return GPIO_OK;
-}
-
-int gpio_set_value(int gpio, int value)
-{
-	return gpio_mrpc_call(GPIO_SET_VAL_PROC, gpio, GPIO_OUTPUT_DIR, value);
-}
-EXPORT_SYMBOL(gpio_set_value);
-
-int gpio_set_direction(int gpio, int dir)
-{
-	return gpio_mrpc_call(GPIO_SET_DIR_PROC, gpio, dir, 0);
-}
-EXPORT_SYMBOL(gpio_set_direction);
-
-/* sysfs for future use */
-static ssize_t status_show(struct device *dev,
-                           struct device_attribute *attr, char *buf)
-{
-    struct gpio_private *priv = dev_get_drvdata(dev);
-
-    if (!priv)
-        return -EINVAL;
-
-    return scnprintf(buf, PAGE_SIZE, "status ok");
-}
-
-static DEVICE_ATTR(status, S_IRUGO, status_show, NULL);
-
-static struct attribute *gpio_attrs[] = {
-    &dev_attr_status.attr,
-    NULL
-};
-
-static struct attribute_group gpio_attrs_group = {
-    .attrs = gpio_attrs,
-};
-
-/**
- * gpio_mrpc_probe
- *
- * @param pdev   platform device
- *
- * @return 0 for success, error code otherwise
- */
-static int gpio_mrpc_probe(struct platform_device *pdev)
-{
-    struct gpio_private *priv;
-    int ret;
-
-    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
-    if (!priv) {
-        pr_err("memory allocation failed");
-        return -ENOMEM;
-    }
-
-    dev_set_drvdata(&pdev->dev, priv);
-    priv->pdev = pdev;
-
-    ret = sysfs_create_group(&priv->pdev->dev.kobj, &gpio_attrs_group);
-    if (ret) {
-        pr_err("sysfs_create_group failed (ret=%d)", ret);
-        return ret;
-    }
-
-    priv->mrpc = mrpc_client_register(MRPC_RESERVED_ID_GPIO, "gpio");
-    if (!priv->mrpc) {
-        pr_err("failed to register gpio");
-        ret = -ENODEV;
-        goto out_remove_group;
-    }
-
-    this = priv;
-    return 0;
-
-out_remove_group:
-    sysfs_remove_group(&priv->pdev->dev.kobj, &gpio_attrs_group);
-    return 0;
-}
-
-/**
- * gpio_mrpc_remove
- *
- * This function is called when the gpio mrpc driver is
- * removed.
- *
- * @param pdev   platform device
- *
- * @return 0 for success, error code otherwise
- */
-static int gpio_mrpc_remove(struct platform_device *pdev)
-{
-    struct gpio_private *priv = platform_get_drvdata(pdev);
-    mrpc_client_unregister(priv->mrpc);
-    sysfs_remove_group(&priv->pdev->dev.kobj, &gpio_attrs_group);
-    dev_set_drvdata(&pdev->dev, NULL);
-    this = NULL;
-
-    return 0;
-}
-
-static struct platform_driver gpio_driver = {
-    .driver = {
-        .name   = "gpio",
-    },
-    .probe = gpio_mrpc_probe,
-    .remove = gpio_mrpc_remove,
-};
-
-static struct platform_device *gpio_device;
-
-static int create_proxy_device(void)
-{
-	int ret;
-    struct device *dev_ret;
-
-    if ((ret = alloc_chrdev_region(&dev, 0, 1, DEV_NAME)) < 0)
-    {
-        printk(KERN_ERR "gpio: Failed alloc_chrdev_region\n");
-        return ret;
-    }
-    pr_debug("alloc_chrdev_region - Done");
-
-    if (!(c_dev = cdev_alloc()))
-    {
-        printk(KERN_ERR "%s:%d Failed to allocate character device gpio_driver\n", __FUNCTION__, __LINE__);
-        unregister_chrdev_region(dev, MINOR_CNT);
-        return (-1);
-    }
-    pr_debug("cdev_alloc - Done");
-
-    /* Init the driver */
-    cdev_init(c_dev, &gpio_drv_fops);
-    pr_debug("cdev_init - Done");
-
-    if ((ret = cdev_add(c_dev, dev, MINOR_CNT)) < 0)
-    {
-        printk(KERN_ERR "%s:%d Failed to add character device gpio_driver\n", __FUNCTION__, __LINE__);
-        cdev_del(c_dev);
-        unregister_chrdev_region(dev, MINOR_CNT);
-        return ret;
-    }
-    pr_debug("cdev_add - Done");
-
-    if (IS_ERR(cl = class_create(THIS_MODULE, DEV_NAME)))
-    {
-        printk(KERN_ERR "gpio: class_create failed\n");
-        cdev_del(c_dev);
-        unregister_chrdev_region(dev, MINOR_CNT);
-        return PTR_ERR(cl);
-    }
-    pr_debug("class_create - Done");
-
-    if (IS_ERR(dev_ret = device_create(cl, NULL, dev, NULL, DEV_NAME)))
-    {
-        printk(KERN_ERR "device_create failed\n");
-        class_destroy(cl);
-        cdev_del(c_dev);
-        unregister_chrdev_region(dev, MINOR_CNT);
-        return PTR_ERR(dev_ret);
-    }
-    pr_debug("device_create %s - Done", DEV_NAME);
-
-    return 0;
-}
-
-
-static int __init gpio_mrpc_init(void)
-{
-    int ret;
-
-    ret = platform_driver_register(&gpio_driver);
-    if (ret < 0) {
-        pr_err("Failed to register gpio platform driver: %d\n", ret);
-        return ret;
-    }
-    pr_debug("Done to register gpio platform driver");
-
-    gpio_device = platform_device_register_simple("gpio", -1, NULL, 0);
-    if (IS_ERR(gpio_device)) {
-        pr_err("Failed to register gpio platform device\n");
-        platform_driver_unregister(&gpio_driver);
-        return PTR_ERR(gpio_device);
-    }
-    pr_debug("Done to register gpio platform device");
-
-    return create_proxy_device();
-}
-
-/**************************************************************************/
-/*! \fn static void delete_proxy_device(void)
- **************************************************************************
- *  \brief     Delete proxy device created in create_proxy_device()
- *  \param[in] none
- *  \return    none
- *************************************************************************/
-static void delete_proxy_device(void)
-{
-    device_destroy(cl, dev);
-    class_destroy(cl);
-    cdev_del(c_dev);
-    unregister_chrdev_region(dev, MINOR_CNT);
-}
-
-static void __exit gpio_mrpc_exit(void)
-{
-    platform_device_unregister(gpio_device);
-    platform_driver_unregister(&gpio_driver);
-
-    delete_proxy_device();
-}
-
-static long gpio_proxy_ioctl(struct file *fd, unsigned int cmd, unsigned long arg)
-{
-    struct gpio_user_info  gpio_info;
-    struct io_ctrl_user_info io_ctrl_info;
-    int ret = 0;
-
-    /* Check for valid pointer to the parameter list */
-    if (0 == arg)
-    {
-        printk(KERN_ERR "[%s] Arg == 0\n",__FUNCTION__);
-        return -EINVAL;
-    }
-    if (cmd == GPIO_CTRL_IO_PAD)
-    {
-        if (copy_from_user(&io_ctrl_info, (void __user *)arg, sizeof(struct io_ctrl_user_info)))
-        {
-            printk(KERN_ERR "[%s] Copy from user the IO ctrl data failed\n",__FUNCTION__);
-            return -EFAULT;
-            /* Execute ioctl request */
-        }
-    }
-    else
-    {
-        if (copy_from_user(&gpio_info, (void __user *)arg, sizeof(struct gpio_user_info)))
-        {
-            printk(KERN_ERR "[%s] Copy from user the GPIO data failed\n",__FUNCTION__);
-            return -EFAULT;
-        }
-    }
-
-    switch (cmd)
-    {
-        /*---------------------------------------------------------------------------*/
-    case GPIO_SET_DIRECTION_CMD:
-            printk(KERN_DEBUG "[%s] Request to set GPIO pin = %d , direction = %d\n",__FUNCTION__,gpio_info.gpio_pin,gpio_info.pin_direction);
-            if (gpio_set_direction(gpio_info.gpio_pin, gpio_info.pin_direction) == GPIO_FAIL)
-            {
-                ret = -ENOSYS;
-            }
-            break;
-        /*---------------------------------------------------------------------------*/
-    case GPIO_OUT_BIT_CMD:
-            printk(KERN_DEBUG "[%s] Set GPIO pin = %d data out for value = %d\n",__FUNCTION__,gpio_info.gpio_pin,gpio_info.value);
-            if (gpio_set_value(gpio_info.gpio_pin, gpio_info.value) == GPIO_FAIL)
-            {
-                ret = -ENOSYS;
-            }
-            break;
-        /*---------------------------------------------------------------------------*/
-    default:
-            printk(KERN_ERR "[%s] iosfsb no legal command given\n",__FUNCTION__);
-            ret = -ENOSYS;
-            break;
-        }
-    return ret;
-}
-
-/******************************************************/
-/**    Module Declarations                           **/
-/******************************************************/
-module_init(gpio_mrpc_init);
-module_exit(gpio_mrpc_exit);
-
-MODULE_AUTHOR("Intel Corporation");
-MODULE_DESCRIPTION("gpio mrpc client");
-MODULE_LICENSE("GPL");
-MODULE_VERSION("1.0");
diff -Naur a/drivers/mrpc/handshake_client.c b/drivers/mrpc/handshake_client.c
--- a/drivers/mrpc/handshake_client.c	2017-10-11 10:17:03.430300000 +0530
+++ b/drivers/mrpc/handshake_client.c	2017-10-11 09:36:03.220997000 +0530
@@ -54,8 +54,6 @@
 #define DBG(fmt, ...) pr_debug(fmt, ##__VA_ARGS__)
 #endif
 
-#define HANDSHAKE_CLIENT_NAME "handshake"
-
 /* driver private database */
 struct handshake_private {
     struct platform_device *pdev;   /* platform device */
@@ -134,7 +132,7 @@
         return ret;
     }
 
-    priv->mrpc = mrpc_client_register(MRPC_RESERVED_ID_HANDSHAKE, HANDSHAKE_CLIENT_NAME);
+    priv->mrpc = mrpc_client_register(MRPC_RESERVED_ID_HANDSHAKE, "handshake");
     if (!priv->mrpc) {
         pr_err("failed to register handshake");
         ret = -ENODEV;
@@ -172,7 +170,7 @@
 
 static struct platform_driver handshake_driver = {
     .driver = {
-        .name   = HANDSHAKE_CLIENT_NAME,
+        .name   = "handshake",
     },
     .probe = handshake_mrpc_probe,
     .remove = handshake_mrpc_remove,
@@ -190,7 +188,7 @@
         return ret;
     }
 
-    handshake_device = platform_device_register_simple(HANDSHAKE_CLIENT_NAME, -1, NULL, 0);
+    handshake_device = platform_device_register_simple("handshake", -1, NULL, 0);
     if (IS_ERR(handshake_device)) {
         ret = PTR_ERR(handshake_device);
         pr_err("Failed to register handshake platform device: %d\n", ret);
diff -Naur a/drivers/mrpc/handshake_server.c b/drivers/mrpc/handshake_server.c
--- a/drivers/mrpc/handshake_server.c	2017-10-11 10:17:03.440293000 +0530
+++ b/drivers/mrpc/handshake_server.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,264 +0,0 @@
-/*
- *
- * handshake_server.c
- * Description:
- * handshake over MRPC server driver
- *
- *
- * GPL LICENSE SUMMARY
- *
- *  Copyright(c) 2016 Intel Corporation.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of version 2 of the GNU General Public License as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *  The full GNU General Public License is included in this distribution
- *  in the file called LICENSE.GPL.
- *
- *  Contact Information:
- *  Intel Corporation
- *  2200 Mission College Blvd.
- *  Santa Clara, CA  97052
- */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ":%s:%d " fmt "\n", __func__, __LINE__
-
-/************************************************/
-/**                    Includes                 */
-/************************************************/
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/byteorder/generic.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/mutex.h>
-#include <linux/err.h>
-#include <linux/mrpc.h>
-#include <linux/handshake_server.h>
-
-#ifdef DEBUG
-#define DBG(fmt, ...) pr_err(fmt, ##__VA_ARGS__)
-#else
-#define DBG(fmt, ...) pr_debug(fmt, ##__VA_ARGS__)
-#endif
-
-#define HANDSHAKE_SERVER_NAME "handshake_server"
-
-/* driver private database */
-struct handshake_private {
-    struct platform_device *pdev;   /* platform device */
-    struct mrpc_server *mrpc;       /* mrpc server handle */
-};
-
-enum{
-    BOOT_DONE = 0,
-    BOOT_NOT_DONE,
-};
-
-#define handshake_PROC(proc, func)                    \
-[proc] = {                                            \
-        .procid   = proc,                             \
-        .p_func	  = func,                             \
-        .p_arglen = 0,                                \
-        .p_replen = sizeof(int),                     \
-        .p_name   = #func,                            \
-}
-
-enum {
-    HANDSHAKE_BOOT_STATUS = 0,
-};
-
-/*Set all enabled services to be synced*/
-static volatile unsigned int sync_status = SYNC_POINTS;
-
-EXPORT_SYMBOL(boot_status_report);
-
-/**
- * boot_status_report
- * Function to allow different client to report sync point
- * reached
- *
- * @param client_id   specific client ID reporting boot status
- *
- * @return 0 for success, error code otherwise
- */
-int boot_status_report(int client_id)
-{
-    pr_info("Client ID = %d reported sync ready. sync_status=0x%x > 0x%x\n", client_id, sync_status, sync_status & ~(1 << client_id));
-    if (client_id >= HANDSHAKE_ID_LAST)
-        return -1;
-
-    sync_status &= ~(1 << client_id);
-    return 0;
-}
-
-/**
- * mrpc_handshake_boot_status
- * Function to report boot status, will only announce boot is
- * done when all clients reported sync point reached
- *
- * @param rep - pointer to hold boot status
- *
- * @return 0 always
- */
-static int mrpc_handshake_boot_status(void *arg, ssize_t arglen, void *rep, ssize_t replen)
-{
-    pr_info("Call handshake boot status\n");
-    if (sync_status)
-        *(int *)rep = htonl(BOOT_NOT_DONE);
-    else
-        *(int *)rep = htonl(BOOT_DONE);
-
-    return 0;
-}
-
-static struct mrpc_procinfo handshake_server_procs[] = {
-    handshake_PROC(HANDSHAKE_BOOT_STATUS, mrpc_handshake_boot_status)
-};
-
-/* sysfs for future use */
-static ssize_t status_show(struct device *dev,
-                           struct device_attribute *attr, char *buf)
-{
-    struct handshake_private *priv = dev_get_drvdata(dev);
-
-    if (!priv)
-        return -EINVAL;
-
-    return scnprintf(buf, PAGE_SIZE, "current boot value 0x%x", sync_status);
-}
-
-static DEVICE_ATTR(status, S_IRUGO, status_show, NULL);
-
-static struct attribute *handshake_attrs[] = {
-    &dev_attr_status.attr,
-    NULL
-};
-
-static struct attribute_group handshake_attrs_group = {
-    .attrs = handshake_attrs,
-};
-
-/**
- * handshake_probe
- *
- * @param pdev   platform device
- *
- * @return 0 for success, error code otherwise
- */
-static int handshake_probe(struct platform_device *pdev)
-{
-    struct handshake_private *priv;
-    int ret;
-
-    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
-    if (!priv) {
-        pr_err("memory allocation failed\n");
-        return -ENOMEM;
-    }
-
-    dev_set_drvdata(&pdev->dev, priv);
-    priv->pdev = pdev;
-
-    ret = sysfs_create_group(&priv->pdev->dev.kobj, &handshake_attrs_group);
-    if (ret) {
-        pr_err("sysfs_create_group failed (ret=%d)\n", ret);
-        return ret;
-    }
-
-    priv->mrpc = mrpc_server_register(MRPC_RESERVED_ID_HANDSHAKE, HANDSHAKE_SERVER_NAME,
-                                    handshake_server_procs,
-                                    ARRAY_SIZE(handshake_server_procs));
-    if (!priv->mrpc) {
-        pr_err("failed to register handshake\n");
-        ret = -ENODEV;
-        goto out_remove_group;
-    }
-
-    return 0;
-
-out_remove_group:
-    sysfs_remove_group(&priv->pdev->dev.kobj, &handshake_attrs_group);
-    return 0;
-}
-
-/**
- * handshake_remove
- *
- * This function is called when the handshake driver is removed.
- *
- * @param pdev   platform device
- *
- * @return 0 for success, error code otherwise
- */
-static int handshake_remove(struct platform_device *pdev)
-{
-    struct handshake_private *priv = platform_get_drvdata(pdev);
-
-    mrpc_server_unregister(priv->mrpc);
-    sysfs_remove_group(&priv->pdev->dev.kobj, &handshake_attrs_group);
-    dev_set_drvdata(&pdev->dev, NULL);
-
-    return 0;
-}
-
-static struct platform_driver handshake_driver = {
-    .driver = {
-        .name   = HANDSHAKE_SERVER_NAME,
-    },
-    .probe = handshake_probe,
-    .remove = handshake_remove,
-};
-
-static struct platform_device *handshake_device;
-
-static int __init handshake_server_init(void)
-{
-    int ret;
-
-    ret = platform_driver_register(&handshake_driver);
-    if (ret < 0) {
-        pr_err("Failed to register handshake platform driver: %d\n", ret);
-        return ret;
-    }
-
-    handshake_device = platform_device_register_simple(HANDSHAKE_SERVER_NAME, -1, NULL, 0);
-    if (IS_ERR(handshake_device)) {
-        pr_err("Failed to register handshake platform device\n");
-        platform_driver_unregister(&handshake_driver);
-        return PTR_ERR(handshake_device);
-    }
-
-    return 0;
-}
-
-static void __exit handshake_server_exit(void)
-{
-    platform_device_unregister(handshake_device);
-    platform_driver_unregister(&handshake_driver);
-}
-
-/******************************************************/
-/**    Module Declarations                           **/
-/******************************************************/
-module_init(handshake_server_init);
-module_exit(handshake_server_exit);
-
-MODULE_AUTHOR("Intel Corporation");
-MODULE_AUTHOR("Tzviel Lemberger tzviel.lemberger@intel.com");
-MODULE_DESCRIPTION("handshake mrpc server");
-MODULE_LICENSE("GPL");
-MODULE_VERSION("1.0");
diff -Naur a/drivers/mrpc/hil_events_server.c b/drivers/mrpc/hil_events_server.c
--- a/drivers/mrpc/hil_events_server.c	2017-10-11 10:17:03.443291000 +0530
+++ b/drivers/mrpc/hil_events_server.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,175 +0,0 @@
-/*
- *
- * hil_events_server.c
- * Description:
- * HIL events MRPC server driver
- *
- *
- * GPL LICENSE SUMMARY
- *
- *  Copyright(c) 2016 Intel Corporation.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of version 2 of the GNU General Public License as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *  The full GNU General Public License is included in this distribution
- *  in the file called LICENSE.GPL.
- *
- *  Contact Information:
- *  Intel Corporation
- *  2200 Mission College Blvd.
- *  Santa Clara, CA  97052
- */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/ti_hil.h>
-#include <linux/mrpc.h>
-
-#define MAX_NAME_SIZE   50
-#define HILEVENTS_MRPC_ID        MRPC_RESERVED_ID_HILEVENTS
-
-#define HILEVENTS_SERV_PROC(proc, func, arglen) \
-[proc] = {                                      \
-        .procid   = proc,                       \
-        .p_func   = func,                       \
-        .p_arglen = arglen,                     \
-        .p_replen = 0,                          \
-        .p_name   = #func,                      \
-}
-
-/*HIL events MRPC PROC id*/
-enum
-{
-    MRPC_HIL_INIT_PROC_ID = 0,
-    MRPC_HIL_REMOTE_PROC_ID,
-    MRPC_HIL_NUM_IDS
-};
-
-typedef struct
-{
-    char                    name[MAX_NAME_SIZE];
-    struct  mrpc_server *   mrpc_serv;
-
-    struct mrpc_procinfo    hilevents_mrpc_procs[MRPC_HIL_NUM_IDS];
-} hil_mrpc_info_t;
-
-static int mrpc_hil_init_proc(void *arg, ssize_t arglen, void *rep, ssize_t replen);
-static int mrpc_hil_remote_proc(void *arg, ssize_t arglen, void *rep, ssize_t replen);
-
-static hil_mrpc_info_t mrpc =
-{
-    .hilevents_mrpc_procs =
-    {
-        HILEVENTS_SERV_PROC(MRPC_HIL_INIT_PROC_ID, mrpc_hil_init_proc, 0),
-        HILEVENTS_SERV_PROC(MRPC_HIL_REMOTE_PROC_ID, mrpc_hil_remote_proc, sizeof(unsigned int)),
-    }
-};
-
-
-/**************************************************************************/
-/*! \fn static int mrpc_hil_init_proc
- *                  (void *arg, ssize_t arglen, void *rep, ssize_t replen)
- **************************************************************************
- *  \brief prepare hil events server
- *  \param[in] arg - Pointer to arguments buffer.
- *  \param[in] arglen - Arguments length.
- *  \param[out] rep - Pointer to reply buffer.
- *  \param[out] replen - Reply length.
- *  \return 0.
- **************************************************************************/
-static int mrpc_hil_init_proc(void *arg, ssize_t arglen, void *rep, ssize_t replen)
-{
-    printk ("HIL Core: %s invoked, remote profile on ARM activated \n", __func__);
-    return 0;
-}
-
-/**************************************************************************/
-/*! \fn static int mrpc_hil_remote_proc
- *                  (void *arg, ssize_t arglen, void *rep, ssize_t replen)
- **************************************************************************
- *  \brief serv remote hil events 
- *  \param[in] arg - Pointer to arguments buffer.
- *  \param[in] arglen - Arguments length.
- *  \param[out] rep - Pointer to reply buffer.
- *  \param[out] replen - Reply length.
- *  \return 0 for success, error code otherwise.
- **************************************************************************/
-static int mrpc_hil_remote_proc(void *arg, ssize_t arglen, void *rep, ssize_t replen)
-{
-    int ret = 0;
-    unsigned int *p_arg = arg;
-    Uint32 event = ntohl(*p_arg);
-
-    /* printk ("HIL Core: %s invoked for event %d\n", __func__, event); */
-
-    ret = ti_hil_pp_event(event, NULL);
-    if (ret)
-    {
-    	pr_err("hil event handler failed for event %lu, res=%d\n", event, ret);
-    }
-
-    return ret;
-}
-
-/**************************************************************************/
-/*! \fn static int __init hilevents_server_init(void)
- **************************************************************************
- *  \brief Init function.
- *  \param[in] None
- *  \param[out] None
- *  \0 for success, error code otherwise.
- **************************************************************************/
-static int __init hilevents_server_init(void)
-{
-    int ret = 0;
-
-    snprintf(mrpc.name, MAX_NAME_SIZE, "HIL events MRPC");
-    mrpc.mrpc_serv = mrpc_server_register(  HILEVENTS_MRPC_ID,
-                                            mrpc.name,
-                                            mrpc.hilevents_mrpc_procs,
-                                            ARRAY_SIZE(mrpc.hilevents_mrpc_procs) );	
-
-    if (!mrpc.mrpc_serv)
-    {
-        pr_err("failed to register %s server\n", mrpc.name);	
-        ret = -ENODEV;
-    }
-
-    return ret;
-}
-
-/**************************************************************************/
-/*! \fn static void __exit hilevents_server_exit(void)
- **************************************************************************
- *  \brief Exit function.
- *  \param[in] None
- *  \param[out] None
- *  \0 for success, error code otherwise.
- **************************************************************************/
-static void __exit hilevents_server_exit(void)
-{
-	int ret;
-
-	ret = mrpc_server_unregister(mrpc.mrpc_serv);
-	return ret;
-}
-
-module_init(hilevents_server_init);
-module_exit(hilevents_server_exit);
-
-MODULE_AUTHOR("Intel Corporation");
-MODULE_DESCRIPTION("HIL events mrpc server");
-MODULE_LICENSE("GPL");
-MODULE_VERSION("1.0");
diff -Naur a/drivers/mrpc/modphy_client.c b/drivers/mrpc/modphy_client.c
--- a/drivers/mrpc/modphy_client.c	2017-10-11 10:17:03.432291000 +0530
+++ b/drivers/mrpc/modphy_client.c	2017-10-11 09:36:03.226993000 +0530
@@ -50,13 +50,7 @@
 #include <linux/netdevice.h>
 #include <linux/ethtool.h>
 #include <linux/mrpc.h>
-#include <linux/ioctl.h>
 #include <linux/avalanche/generic/modphy_mrpc_api.h>
-#include <linux/cdev.h>
-
-
-#define FIRST_MINOR 0
-#define MINOR_CNT   1
 
 #ifdef DEBUG
 #define DBG(fmt, ...) pr_err(fmt, ##__VA_ARGS__)
@@ -64,26 +58,6 @@
 #define DBG(fmt, ...) pr_debug(fmt, ##__VA_ARGS__)
 #endif
 
-#define MODPHY_CLIENT_MRPC_CALL_TIMEOUT_MS (1000) /* Timeout is needed due to delays in modphy server */
-
-
-static long modphy_proxy_ioctl(struct file *fd, unsigned int cmd, unsigned long arg);
-
-/**************************************************************************/
-/*      LOCAL VARIABLES:                                                  */
-/**************************************************************************/
-
-static dev_t dev;
-static struct cdev *c_dev;
-static struct class *cl;
-
-/* Structure to map driver functions to kernel */
-static struct file_operations modphy_drv_fops =
-{
-    .owner   = THIS_MODULE,
-    .unlocked_ioctl   = modphy_proxy_ioctl /*We assume there are no 2 processes in a race condition*/
-};
-
 /* driver private database */
 struct modphy_private {
     struct platform_device *pdev;   /* platform device */
@@ -121,14 +95,7 @@
     args.client = htonl(modphyClientId);
     args.lane = htonl(lane);
 
-    ret = mrpc_call(priv->mrpc,
-                    procid,
-                    &args,
-                    sizeof(struct modphy_args),
-                    NULL,
-                    0,
-                    MODPHY_CLIENT_MRPC_CALL_TIMEOUT_MS,
-                    &errcode);
+    ret = mrpc_call(priv->mrpc, procid, &args, sizeof(struct modphy_args), NULL, 0, 0, &errcode);
 
     if (ret || errcode) {
         pr_err("ERROR: ret=%d, errcode=%d", ret, errcode);
@@ -301,60 +268,6 @@
 
 static struct platform_device *modphy_device;
 
-static int create_proxy_device(void)
-{
-	int ret;
-    struct device *dev_ret;
-
-    if ((ret = alloc_chrdev_region(&dev, 0, 1, MODPHY_NAME)) < 0)
-    {
-        pr_err("MODPHY: Failed alloc_chrdev_region\n");
-        return ret;
-    }
-    pr_debug("MODPHY: alloc_chrdev_region - Done\n");
-
-    if (!(c_dev = cdev_alloc()))
-    {
-        pr_err("%s:%d Failed to allocate character device modphy_driver\n", __FUNCTION__, __LINE__);
-        unregister_chrdev_region(dev, MINOR_CNT);
-        return (-1);
-    }
-    pr_debug("MODPHY: cdev_alloc - Done\n");
-
-    /* Init the driver */
-    cdev_init(c_dev, &modphy_drv_fops);
-    pr_debug("MODPHY: cdev_init - Done\n");
-
-    if ((ret = cdev_add(c_dev, dev, MINOR_CNT)) < 0)
-    {
-        pr_err("%s:%d Failed to add character device modphy_driver\n", __FUNCTION__, __LINE__);
-        cdev_del(c_dev);
-        unregister_chrdev_region(dev, MINOR_CNT);
-        return ret;
-    }
-    pr_debug("MODPHY: cdev_add - Done\n");
-
-    if (IS_ERR(cl = class_create(THIS_MODULE, MODPHY_NAME)))
-    {
-        pr_err("MODPHY: class_create -Fail\n");
-        cdev_del(c_dev);
-        unregister_chrdev_region(dev, MINOR_CNT);
-        return PTR_ERR(cl);
-    }
-    pr_debug("MODPHY: class_create - Done\n");
-
-    if (IS_ERR(dev_ret = device_create(cl, NULL, dev, NULL, MODPHY_NAME)))
-    {
-        class_destroy(cl);
-        cdev_del(c_dev);
-        unregister_chrdev_region(dev, MINOR_CNT);
-        return PTR_ERR(dev_ret);
-    }
-
-    return 0;
-}
-
-
 static int __init modphy_mrpc_init(void)
 {
     int ret;
@@ -372,62 +285,13 @@
         return PTR_ERR(modphy_device);
     }
 
-    return create_proxy_device();
-}
-
-/**************************************************************************/
-/*! \fn static void delete_proxy_device(void)
- **************************************************************************
- *  \brief     Delete proxy device created in create_proxy_device()
- *  \param[in] none
- *  \return    none
- *************************************************************************/
-static void delete_proxy_device(void)
-{
-    device_destroy(cl, dev);
-    class_destroy(cl);
-    cdev_del(c_dev);
-    unregister_chrdev_region(dev, MINOR_CNT);
+    return 0;
 }
 
 static void __exit modphy_mrpc_exit(void)
 {
     platform_device_unregister(modphy_device);
     platform_driver_unregister(&modphy_driver);
-
-    delete_proxy_device();
-}
-
-static long modphy_proxy_ioctl(struct file *fd, unsigned int cmd, unsigned long arg)
-{
-    int ret = MODPHY_OK;
-    ModphyController_e modphyClientId;
-
-    if (fd == NULL)
-    {
-        pr_err("\nMODPHY Error value\n");
-        return MODPHY_FAIL;
-    }
-
-    switch (cmd)
-    {
-    case MODPHY_RESET_LANE:
-        {
-            if (copy_from_user(&modphyClientId, (void __user *)arg, sizeof(modphyClientId)))
-            {
-            	pr_err("\n MODPHY failed to copy from user data. IOCTL=%d\n", cmd);
-                return -EFAULT;
-            }
-
-            modphy_reset_client(modphyClientId);
-            break;
-        }
-    default:
-        pr_err("%s:%d Invalid IOCTL(0x%08X) has been received \n", __FUNCTION__, __LINE__, cmd);
-        return -ENOSYS;
-    }
-
-    return ret;
 }
 
 /******************************************************/
diff -Naur a/drivers/mrpc/sgc_server.c b/drivers/mrpc/sgc_server.c
--- a/drivers/mrpc/sgc_server.c	2017-10-11 10:17:03.439294000 +0530
+++ b/drivers/mrpc/sgc_server.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,600 +0,0 @@
-/*
- *
- * sgc_server.c
- * Description:
- * PP Sessions Group Counter over MRPC server driver
- *
- *
- * GPL LICENSE SUMMARY
- *
- *  Copyright(c) 2016 Intel Corporation.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of version 2 of the GNU General Public License as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *  The full GNU General Public License is included in this distribution
- *  in the file called LICENSE.GPL.
- *
- *  Contact Information:
- *  Intel Corporation
- *  2200 Mission College Blvd.
- *  Santa Clara, CA  97052
- */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/byteorder/generic.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/mutex.h>
-#include <linux/workqueue.h>
-#include <linux/err.h>
-#include <linux/netdevice.h>
-#include <linux/ethtool.h>
-#include <linux/mrpc.h>
-#include <linux/avalanche/puma7/ppsgc_db.h>
-#include <linux/sgc_server.h>
-
-#define SGC_PROC(proc, func, arglen, replen)    \
-{                                               \
-		.procid   = proc,                       \
-		.p_func   = func,                       \
-		.p_arglen = arglen,                     \
-		.p_replen = replen,                     \
-		.p_name   = #func,                      \
-}
-
-/* driver private database */
-struct SgcServerPrivate {
-	struct kobject          *kobj;      /* kobj for sysfs */
-	struct mrpc_server      *mrpc;      /* mrpc server handle */
-	struct sgc_funcs        *callbacks;
-};
-
-enum {
-	SGC_ALLOC_GROUP_COUNTER_ID_PROC = 0,
-	SGC_RELEASE_GROUP_COUNTER_ID_PROC,
-	SGC_DEL_GROUP_COUNTER_SESSIONS_PROC,
-	SGC_GET_GROUP_COUNTER_AMOUNT_PROC,
-	SGC_GET_IF_COUNTERS_PROC,
-	SGC_GET_TP_PORT_COUNTERS_PROC,
-	SGC_GET_SF_COUNTERS_PROC,
-	SGC_PRINT_TPPORT_COUNTERS_PROC,
-	SGC_PRINT_IF_COUNTERS_PROC,
-	SGC_PRINT_GROUP_COUNTERS_PROC,
-};
-
-static struct SgcServerPrivate  *sgcServerDb;
-
-/**************************************************************************/
-/*! \fn void mrpc_sgc_server_unregister(void)
- **************************************************************************
- *  \brief unregister sgc callbacks
- *  \param[in] None
- *  \param[out] None
- *  \return 0 for success, error code otherwise.
- **************************************************************************/
-void mrpc_sgc_server_unregister(void)
-{
-	WARN_ON(!sgcServerDb);
-	WARN_ON(!sgcServerDb->callbacks);
-
-	kfree(sgcServerDb->callbacks);
-	sgcServerDb->callbacks = NULL;
-
-	pr_info("callback functions unregistered\n");
-}
-EXPORT_SYMBOL(mrpc_sgc_server_unregister);
-
-/**************************************************************************/
-/*! \fn int mrpc_sgc_server_register(struct sgc_funcs *callbacks)
- **************************************************************************
- *  \brief register sgc callbacks
- *  \param[in] sgc_funcs - Pointer to callback functions structure/
- *  \param[out] None
- *  \return 0 for success, error code otherwise.
- **************************************************************************/
-int mrpc_sgc_server_register(struct sgc_funcs *callbacks)
-{
-	WARN_ON(!sgcServerDb);
-	WARN_ON(!callbacks);
-	WARN_ON(sgcServerDb->callbacks);
-
-	sgcServerDb->callbacks = kzalloc(sizeof(*callbacks), GFP_KERNEL);
-	if (!sgcServerDb->callbacks) {
-		pr_err("Failed to allocate memory\n");
-		return -ENOMEM;
-	}
-
-	memcpy(sgcServerDb->callbacks, callbacks, sizeof(*callbacks));
-
-	pr_info("callback functions registered\n");
-	return 0;
-}
-EXPORT_SYMBOL(mrpc_sgc_server_register);
-
-/**************************************************************************/
-/*! \fn static int mrpc_sgc_AllocGroupCounter
- *                  (void *arg, ssize_t arglen, void *rep, ssize_t replen)
- **************************************************************************
- *  \brief Allocate group counter.
- *  \param[in] arg - Pointer to arguments buffer.
- *  \param[in] arglen - Arguments length.
- *  \param[out] rep - Pointer to reply buffer.
- *  \param[out] replen - Reply length.
- *  \return 0 for success, error code otherwise.
- **************************************************************************/
-static int mrpc_sgc_AllocGroupCounter
-			(void *arg, ssize_t arglen, void *rep, ssize_t replen)
-{
-	int                 ret;
-	unsigned short      allocGroupCounterId;
-	unsigned int        tmpGroupCounterId;
-	unsigned int        *repGroupCounterId = (unsigned int *)rep;
-
-	WARN_ON(!sgcServerDb->callbacks);
-	ret = sgcServerDb->callbacks->PPSGC_Db_AllocGroupCounterId
-			(&allocGroupCounterId);
-	tmpGroupCounterId = allocGroupCounterId;
-	tmpGroupCounterId = htonl(tmpGroupCounterId);
-	*repGroupCounterId = tmpGroupCounterId;
-	return ret;
-}
-
-/**************************************************************************/
-/*! \fn static int mrpc_sgc_ReleaseGroupCounter
- *                  (void *arg, ssize_t arglen, void *rep, ssize_t replen)
- **************************************************************************
- *  \brief Release group counter.
- *  \param[in] arg - Pointer to arguments buffer.
- *  \param[in] arglen - Arguments length.
- *  \param[out] rep - Pointer to reply buffer.
- *  \param[out] replen - Reply length.
- *  \return 0 for success, error code otherwise.
- **************************************************************************/
-static int mrpc_sgc_ReleaseGroupCounter
-			(void *arg, ssize_t arglen, void *rep, ssize_t replen)
-{
-	unsigned int        *argGroupCounterId = (unsigned int *)arg;
-	unsigned int        tmpGroupCounterId;
-	unsigned short      relGroupCounterId;
-
-	tmpGroupCounterId = *argGroupCounterId;
-	tmpGroupCounterId = ntohl(tmpGroupCounterId);
-	relGroupCounterId = tmpGroupCounterId;
-
-	WARN_ON(!sgcServerDb->callbacks);
-	return sgcServerDb->callbacks->PPSGC_Db_ReleaseGroupCounterId
-			(relGroupCounterId);
-}
-
-/**************************************************************************/
-/*! \fn static int mrpc_sgc_DelGroupCounterSessions
- *                  (void *arg, ssize_t arglen, void *rep, ssize_t replen)
- **************************************************************************
- *  \brief Delete group counter sessions.
- *  \param[in] arg - Pointer to arguments buffer.
- *  \param[in] arglen - Arguments length.
- *  \param[out] rep - Pointer to reply buffer.
- *  \param[out] replen - Reply length.
- *  \return 0 for success, error code otherwise.
- **************************************************************************/
-static int mrpc_sgc_DelGroupCounterSessions
-			(void *arg, ssize_t arglen, void *rep, ssize_t replen)
-{
-	unsigned int        *argGroupCounterId = (unsigned int *)arg;
-	unsigned int        tmpGroupCounterId;
-	unsigned short      delGroupCounterId;
-
-	tmpGroupCounterId = *argGroupCounterId;
-	tmpGroupCounterId = ntohl(tmpGroupCounterId);
-	delGroupCounterId = tmpGroupCounterId;
-
-	WARN_ON(!sgcServerDb->callbacks);
-	return sgcServerDb->callbacks->PPSGC_Db_DeleteGroupCounterSessions
-			(delGroupCounterId);
-}
-
-/**************************************************************************/
-/*! \fn static int mrpc_sgc_GetGroupCounterAmount
- *                  (void *arg, ssize_t arglen, void *rep, ssize_t replen)
- **************************************************************************
- *  \brief Get group counter sessions traffic amount.
- *  \param[in] arg - Pointer to arguments buffer.
- *  \param[in] arglen - Arguments length.
- *  \param[out] rep - Pointer to reply buffer.
- *  \param[out] replen - Reply length.
- *  \return 0 for success, error code otherwise.
- **************************************************************************/
-static int mrpc_sgc_GetGroupCounterAmount
-			(void *arg, ssize_t arglen, void *rep, ssize_t replen)
-{
-	int                         ret;
-	unsigned int                *argGroupCounterId = (unsigned int *)arg;
-	unsigned int                tmpGroupCounterId;
-	struct PpsgcPpCounters      *repPpCounters =
-		(struct PpsgcPpCounters *)rep;
-	struct PpsgcGroupCounters   groupCounters;
-
-	tmpGroupCounterId = *argGroupCounterId;
-	tmpGroupCounterId = ntohl(tmpGroupCounterId);
-	groupCounters.groupCounterId = tmpGroupCounterId;
-
-	WARN_ON(!sgcServerDb->callbacks);
-	ret = sgcServerDb->callbacks->
-		PPSGC_Db_GetGroupCounterAmount(&groupCounters);
-
-	repPpCounters->totalBytesFwd    =
-		cpu_to_be64(groupCounters.ppCounters.totalBytesFwd);
-	repPpCounters->totalPktsFwd     =
-		cpu_to_be64(groupCounters.ppCounters.totalPktsFwd);
-	repPpCounters->multicastPktsFwd =
-		cpu_to_be64(groupCounters.ppCounters.multicastPktsFwd);
-	repPpCounters->unicastPktsFwd   =
-		cpu_to_be64(groupCounters.ppCounters.unicastPktsFwd);
-
-	return ret;
-}
-
-/**************************************************************************/
-/*! \fn static int mrpc_sgc_GetIfCounters
- *                  (void *arg, ssize_t arglen, void *rep, ssize_t replen)
- **************************************************************************
- *  \brief Get IF counters.
- *  \param[in] arg - Pointer to arguments buffer.
- *  \param[in] arglen - Arguments length.
- *  \param[out] rep - Pointer to reply buffer.
- *  \param[out] replen - Reply length.
- *  \return 0 for success, error code otherwise.
- **************************************************************************/
-static int mrpc_sgc_GetIfCounters
-			(void *arg, ssize_t arglen, void *rep, ssize_t replen)
-{
-	int                     ret;
-	struct PpsgcIfCounters  ppsgcIfCounters = {0};
-	struct PpsgcIfCounters  *argPpsgcIfCounters =
-		(struct PpsgcIfCounters *)arg;
-	struct PpsgcIfCounters  *repPpsgcIfCounter  =
-		(struct PpsgcIfCounters *)rep;
-
-	WARN_ON(!sgcServerDb->callbacks);
-	strncpy(ppsgcIfCounters.ifName, argPpsgcIfCounters->ifName,
-			sizeof(ppsgcIfCounters.ifName)-1);
-	ppsgcIfCounters.includeQosDrops = argPpsgcIfCounters->includeQosDrops;
-
-	ret = sgcServerDb->callbacks->PPSGC_Db_GetIfCounters(&ppsgcIfCounters);
-
-	repPpsgcIfCounter->ifCounters.rx_byte          =
-		cpu_to_be64(ppsgcIfCounters.ifCounters.rx_byte);
-	repPpsgcIfCounter->ifCounters.rx_unicast_pkt   =
-		cpu_to_be64(ppsgcIfCounters.ifCounters.rx_unicast_pkt);
-	repPpsgcIfCounter->ifCounters.rx_broadcast_pkt =
-		cpu_to_be64(ppsgcIfCounters.ifCounters.rx_broadcast_pkt);
-	repPpsgcIfCounter->ifCounters.rx_multicast_pkt =
-		cpu_to_be64(ppsgcIfCounters.ifCounters.rx_multicast_pkt);
-	repPpsgcIfCounter->ifCounters.rx_discard_pkt   =
-		cpu_to_be64(ppsgcIfCounters.ifCounters.rx_discard_pkt);
-
-	repPpsgcIfCounter->ifCounters.tx_byte          =
-		cpu_to_be64(ppsgcIfCounters.ifCounters.tx_byte);
-	repPpsgcIfCounter->ifCounters.tx_unicast_pkt   =
-		cpu_to_be64(ppsgcIfCounters.ifCounters.tx_unicast_pkt);
-	repPpsgcIfCounter->ifCounters.tx_broadcast_pkt =
-		cpu_to_be64(ppsgcIfCounters.ifCounters.tx_broadcast_pkt);
-	repPpsgcIfCounter->ifCounters.tx_multicast_pkt =
-		cpu_to_be64(ppsgcIfCounters.ifCounters.tx_multicast_pkt);
-	repPpsgcIfCounter->ifCounters.tx_discard_pkt   =
-		cpu_to_be64(ppsgcIfCounters.ifCounters.tx_discard_pkt);
-
-	return ret;
-}
-
-/**************************************************************************/
-/*! \fn static int mrpc_sgc_GetTpPortCounters
- *                  (void *arg, ssize_t arglen, void *rep, ssize_t replen)
- **************************************************************************
- *  \brief Get TP counters.
- *  \param[in] arg - Pointer to arguments buffer.
- *  \param[in] arglen - Arguments length.
- *  \param[out] rep - Pointer to reply buffer.
- *  \param[out] replen - Reply length.
- *  \return 0 for success, error code otherwise.
- **************************************************************************/
-static int mrpc_sgc_GetTpPortCounters
-			(void *arg, ssize_t arglen, void *rep, ssize_t replen)
-{
-	int                             ret;
-	struct PpsgcTpPortCounters      ppsgcTpPortCounters = {0};
-	struct PpsgcTpPortCounters      *argPpsgcTpPortCounters =
-			(struct PpsgcTpPortCounters *)arg;
-	struct PpsgcTpPortCounters      *repPpsgcTpPortCounters =
-			(struct PpsgcTpPortCounters *)rep;
-
-	WARN_ON(!sgcServerDb->callbacks);
-	strncpy(ppsgcTpPortCounters.ifName, argPpsgcTpPortCounters->ifName,
-			sizeof(ppsgcTpPortCounters.ifName)-1);
-	ret = sgcServerDb->callbacks->
-		PPSGC_Db_GetTpPortCounters(&ppsgcTpPortCounters);
-
-	repPpsgcTpPortCounters->tpCounters.rx_byte          =
-		cpu_to_be64(ppsgcTpPortCounters.tpCounters.rx_byte);
-	repPpsgcTpPortCounters->tpCounters.rx_unicast_pkt   =
-		cpu_to_be64(ppsgcTpPortCounters.tpCounters.rx_unicast_pkt);
-	repPpsgcTpPortCounters->tpCounters.rx_broadcast_pkt =
-		cpu_to_be64(ppsgcTpPortCounters.tpCounters.rx_broadcast_pkt);
-	repPpsgcTpPortCounters->tpCounters.rx_multicast_pkt =
-		cpu_to_be64(ppsgcTpPortCounters.tpCounters.rx_multicast_pkt);
-	repPpsgcTpPortCounters->tpCounters.rx_discard_pkt   =
-		cpu_to_be64(ppsgcTpPortCounters.tpCounters.rx_discard_pkt);
-
-	repPpsgcTpPortCounters->tpCounters.tx_byte          =
-		cpu_to_be64(ppsgcTpPortCounters.tpCounters.tx_byte);
-	repPpsgcTpPortCounters->tpCounters.tx_unicast_pkt   =
-		cpu_to_be64(ppsgcTpPortCounters.tpCounters.tx_unicast_pkt);
-	repPpsgcTpPortCounters->tpCounters.tx_broadcast_pkt =
-		cpu_to_be64(ppsgcTpPortCounters.tpCounters.tx_broadcast_pkt);
-	repPpsgcTpPortCounters->tpCounters.tx_multicast_pkt =
-		cpu_to_be64(ppsgcTpPortCounters.tpCounters.tx_multicast_pkt);
-	repPpsgcTpPortCounters->tpCounters.tx_discard_pkt   =
-		cpu_to_be64(ppsgcTpPortCounters.tpCounters.tx_discard_pkt);
-
-	return ret;
-}
-
-/**************************************************************************/
-/*! \fn static int mrpc_sgc_GetSfCounters
- *                  (void *arg, ssize_t arglen, void *rep, ssize_t replen)
- **************************************************************************
- *  \brief Get SF counters.
- *  \param[in] arg - Pointer to arguments buffer.
- *  \param[in] arglen - Arguments length.
- *  \param[out] rep - Pointer to reply buffer.
- *  \param[out] replen - Reply length.
- *  \return 0 for success, error code otherwise.
- **************************************************************************/
-static int mrpc_sgc_GetSfCounters
-			(void *arg, ssize_t arglen, void *rep, ssize_t replen)
-{
-	int                     ret;
-	struct PpsgcSfCounters  ppsgcSfCounters = {0};
-	struct PpsgcSfCounters  *argPpsgcSfCounters =
-		(struct PpsgcSfCounters *)arg;
-	struct PpsgcSfCounters  *repPpsgcSfCounters =
-		(struct PpsgcSfCounters *)rep;
-
-	WARN_ON(!sgcServerDb->callbacks);
-	strncpy(ppsgcSfCounters.ifName, argPpsgcSfCounters->ifName,
-			sizeof(ppsgcSfCounters.ifName)-1);
-	ppsgcSfCounters.sfIndex = ntohl(argPpsgcSfCounters->sfIndex);
-	ppsgcSfCounters.clearFlag = ntohl(argPpsgcSfCounters->clearFlag);
-
-	ret = sgcServerDb->callbacks->PPSGC_Db_GetSfCounters(&ppsgcSfCounters);
-
-	repPpsgcSfCounters->sfCounters.fwd_pkts =
-		htonl(ppsgcSfCounters.sfCounters.fwd_pkts);
-	repPpsgcSfCounters->sfCounters.drp_cnt  =
-		htonl(ppsgcSfCounters.sfCounters.drp_cnt);
-
-	return ret;
-}
-
-/**************************************************************************/
-/*! \fn static int mrpc_sgc_PrintTpPortCounters
- *                  (void *arg, ssize_t arglen, void *rep, ssize_t replen)
- **************************************************************************
- *  \brief Print TP port counters.
- *  \param[in] arg - Pointer to arguments buffer.
- *  \param[in] arglen - Arguments length.
- *  \param[out] rep - Pointer to reply buffer.
- *  \param[out] replen - Reply length.
- *  \return 0 for success, error code otherwise.
- **************************************************************************/
-static int mrpc_sgc_PrintTpPortCounters
-			(void *arg, ssize_t arglen, void *rep, ssize_t replen)
-{
-	WARN_ON(!sgcServerDb->callbacks);
-	return sgcServerDb->callbacks->PPSGC_Db_PrintTpPortCounters();
-}
-
-/**************************************************************************/
-/*! \fn static int mrpc_sgc_PrintIfCounters
- *                  (void *arg, ssize_t arglen, void *rep, ssize_t replen)
- **************************************************************************
- *  \brief Print IF counters.
- *  \param[in] arg - Pointer to arguments buffer.
- *  \param[in] arglen - Arguments length.
- *  \param[out] rep - Pointer to reply buffer.
- *  \param[out] replen - Reply length.
- *  \return 0 for success, error code otherwise.
- **************************************************************************/
-static int mrpc_sgc_PrintIfCounters
-			(void *arg, ssize_t arglen, void *rep, ssize_t replen)
-{
-	WARN_ON(!sgcServerDb->callbacks);
-	return sgcServerDb->callbacks->PPSGC_Db_PrintIfCounters();
-}
-
-/**************************************************************************/
-/*! \fn static int mrpc_sgc_PrintGroupCounters
- *                  (void *arg, ssize_t arglen, void *rep, ssize_t replen)
- **************************************************************************
- *  \brief Print group counters statistics.
- *  \param[in] arg - Pointer to arguments buffer.
- *  \param[in] arglen - Arguments length.
- *  \param[out] rep - Pointer to reply buffer.
- *  \param[out] replen - Reply length.
- *  \return 0 for success, error code otherwise.
- **************************************************************************/
-static int mrpc_sgc_PrintGroupCounters
-			(void *arg, ssize_t arglen, void *rep, ssize_t replen)
-{
-	WARN_ON(!sgcServerDb->callbacks);
-	return sgcServerDb->callbacks->PPSGC_Db_PrintGroupCounters();
-}
-
-static struct mrpc_procinfo sgc_server_procs[] = {
-	/* Request, Handle function, Argument length, Reply length */
-	SGC_PROC(SGC_ALLOC_GROUP_COUNTER_ID_PROC,
-			 mrpc_sgc_AllocGroupCounter,
-			 0,
-			 sizeof(unsigned int)),
-	SGC_PROC(SGC_RELEASE_GROUP_COUNTER_ID_PROC,
-			 mrpc_sgc_ReleaseGroupCounter,
-			 sizeof(unsigned int),
-			 0),
-	SGC_PROC(SGC_DEL_GROUP_COUNTER_SESSIONS_PROC,
-			 mrpc_sgc_DelGroupCounterSessions,
-			 sizeof(unsigned int),
-			 0),
-	SGC_PROC(SGC_GET_GROUP_COUNTER_AMOUNT_PROC,
-			 mrpc_sgc_GetGroupCounterAmount,
-			 sizeof(unsigned int),
-			 sizeof(struct PpsgcPpCounters)),
-	SGC_PROC(SGC_GET_IF_COUNTERS_PROC,
-			 mrpc_sgc_GetIfCounters,
-			 sizeof(struct PpsgcIfCounters),
-			 sizeof(struct PpsgcIfCounters)),
-	SGC_PROC(SGC_GET_TP_PORT_COUNTERS_PROC,
-			 mrpc_sgc_GetTpPortCounters,
-			 sizeof(struct PpsgcTpPortCounters),
-			 sizeof(struct PpsgcTpPortCounters)),
-	SGC_PROC(SGC_GET_SF_COUNTERS_PROC,
-			 mrpc_sgc_GetSfCounters,
-			 sizeof(struct PpsgcSfCounters),
-			 sizeof(struct PpsgcSfCounters)),
-	SGC_PROC(SGC_PRINT_TPPORT_COUNTERS_PROC,
-			 mrpc_sgc_PrintTpPortCounters,
-			 0,
-			 0),
-	SGC_PROC(SGC_PRINT_IF_COUNTERS_PROC,
-			 mrpc_sgc_PrintIfCounters,
-			 0,
-			 0),
-	SGC_PROC(SGC_PRINT_GROUP_COUNTERS_PROC,
-			 mrpc_sgc_PrintGroupCounters,
-			 0,
-			 0),
-};
-
-/**************************************************************************/
-/*! \fn static ssize_t status_show
- *		(struct device *dev, struct device_attribute *attr, char *buf)
- **************************************************************************
- *  \brief Status show function.
- *  \param[in]
- *  \param[out]
- *  \return 0 for success, error code otherwise.
- **************************************************************************/
-static ssize_t status_show
-		(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct SgcServerPrivate *sgcServer = dev_get_drvdata(dev);
-
-	if (!sgcServer)
-		return -EINVAL;
-
-	return scnprintf(buf, PAGE_SIZE, "status ok");
-}
-
-static DEVICE_ATTR(status, S_IRUGO, status_show, NULL);
-
-static struct attribute *sgc_attrs[] = {
-	&dev_attr_status.attr,
-	NULL
-};
-
-static struct attribute_group sgc_attrs_group = {
-	.attrs = sgc_attrs,
-};
-
-/**************************************************************************/
-/*! \fn static int __init sgc_server_init(void)
- **************************************************************************
- *  \brief Init function.
- *  \param[in] None
- *  \param[out] None
- *  \0 for success, error code otherwise.
- **************************************************************************/
-static int __init sgc_server_init(void)
-{
-	int ret;
-
-	sgcServerDb = kzalloc(sizeof(*sgcServerDb), GFP_KERNEL);
-	if (!sgcServerDb) {
-		pr_err("memory allocation failed\n");
-		return -ENOMEM;
-	}
-	sgcServerDb->mrpc = mrpc_server_register
-		(MRPC_RESERVED_ID_SGC,
-		"Session Group Counter",
-		sgc_server_procs,
-		ARRAY_SIZE(sgc_server_procs));
-
-	if (!sgcServerDb->mrpc) {
-		pr_err("failed to register sgc\n");
-		ret = -ENODEV;
-		goto out_free_mem;
-	}
-	sgcServerDb->kobj = kobject_create_and_add("sgc_mrpc_server", NULL);
-	if (!sgcServerDb->kobj) {
-		ret = -ENOMEM;
-		goto out_mrpc_unreg;
-	}
-	ret = sysfs_create_group(sgcServerDb->kobj, &sgc_attrs_group);
-	if (ret) {
-		pr_err("sysfs_create_group failed (ret=%d)\n", ret);
-		goto out_kobj_put;
-	}
-
-	return ret;
-
-out_kobj_put:
-	kobject_put(sgcServerDb->kobj);
-out_mrpc_unreg:
-	ret = mrpc_server_unregister(sgcServerDb->mrpc);
-out_free_mem:
-	kfree(sgcServerDb);
-	return ret;
-}
-
-/**************************************************************************/
-/*! \fn static void __exit sgc_server_exit(void)
- **************************************************************************
- *  \brief Exit function.
- *  \param[in] None
- *  \param[out] None
- *  \0 for success, error code otherwise.
- **************************************************************************/
-static void __exit sgc_server_exit(void)
-{
-	int ret;
-
-	ret = mrpc_server_unregister(sgcServerDb->mrpc);
-	sysfs_remove_group(sgcServerDb->kobj, &sgc_attrs_group);
-	kfree(sgcServerDb->callbacks);
-	kfree(sgcServerDb);
-	sgcServerDb = NULL;
-	return ret;
-}
-
-module_init(sgc_server_init);
-module_exit(sgc_server_exit);
-
-MODULE_AUTHOR("Intel Corporation");
-MODULE_DESCRIPTION("PPSGC mrpc server");
-MODULE_LICENSE("GPL");
-MODULE_VERSION("1.0");
-
diff -Naur a/drivers/net/ethernet/lantiq/Kconfig b/drivers/net/ethernet/lantiq/Kconfig
--- a/drivers/net/ethernet/lantiq/Kconfig	2017-10-11 10:17:22.032805000 +0530
+++ b/drivers/net/ethernet/lantiq/Kconfig	2017-10-11 09:36:21.653514000 +0530
@@ -27,24 +27,6 @@
 services from the underlaying packet acceleration engine.


-config LTQ_DIRECTCONNECT_DP_GRX750
-        tristate "Lantiq DirectConnect Datapath driver for GRX750"
-        default n
-        depends on LTQ_DIRECTCONNECT_DP && LTQ_DATAPATH_GRX750
-        ---help---
-          Lantiq DirectConnect Datapath driver for GRX750 series. Provides
-          common interface for network devices to get partial or full
-          acceleration services from the GRX750 packet processor.
-
-config LTQ_DIRECTCONNECT_DP_DBG
-        bool "Datapath Debug Tool"
-        default y
-        depends on LTQ_DIRECTCONNECT_DP
-        ---help---
-          Directconnect Datapath Debug Tool is used to provide simple debug proc tool
-          Each flag can be enabled/disabled easily
-          Once this flag is enabled, the debugging information will be printed out
-          otherwise, no debugging information for this flag will be printed


 #
@@ -63,7 +40,6 @@
 config LTQ_DATAPATH
         bool "Datapath Lib"
         default n
-	depends on !PUMA_LITEPATH && WIFI_PROXY
         ---help---
         Datapath Lib is to provide common rx/tx wrapper API without taking
         care of much HW knowledge and also provide common interface for legacy
@@ -71,13 +47,29 @@
         Take note: All devices need to register to datapath API first
 
 config LTQ_DATAPATH_GRX750
-        bool "Datapath Lib for GRX750"
-        depends on LTQ_DATAPATH
+        bool "Datapath Lib"
         default n
         ---help---
-        Datapath Lib for GRX750 platform. This option enables the datapath
-        library implementation for GRX750. This library provides an abstraction
-        layer above GRX750 cppi interface for partial or full offload.
+        Datapath Lib for XRX750 platform
+
+config LTQ_DATAPATH_MIB
+        bool "Datapath aggregated mib support"
+        default n
+        ---help---
+        It is to aggregate GSWIP-L/R, TMU and driver's MIB counter
+
+config LTQ_DATAPATH_CPUFREQ
+        bool "Datapath DFS(COC) support"
+        default n
+        ---help---
+        It is to support DFS(COC) in Datapath
+
+config LTQ_DATAPATH_LOCAL_SESSION
+        bool "Datapath local session accelerate"
+        default n
+        ---help---
+        It is to accelerate local sessions
+
 
 config LTQ_DATAPATH_DBG
         bool "Datapath Debug Tool"
@@ -89,4 +81,35 @@
         Once this flag is enabled, the debugging information will be printed out
         otherwise, no debugging information for this flag will be printed
 
+config LTQ_DATAPATH_LOOPETH
+        bool "pseudo driver simulation"
+        default n
+        depends on LTQ_DATAPATH
+        ---help---
+        Pseudo driver is to simulate ethernet/wifi device to register to datapath
+        api. Use this pseudo driver can test whether datatpath API is implemented
+        properly or not.
+        Also it can be used to measure the directpath performance
+
+config LTQ_DP_MPE_FASTHOOK_TEST
+        bool "MPE FW Fast Hook Test for skb"
+        default n
+        depends on  LTQ_DATAPATH
+        ---help---
+        MPE FW Fast Hook is used to quick verify MPE FW Functionality without
+        fullPPA support. Once it is enabled, it will add some fields in skb structure
+        in order to support MPE FAST HOOK. The reason is that some network driver is
+        pre-build out of this build system.
+
+config LTQ_DP_MPE_FASTHOOK_TEST_COMPILE
+        bool "MPE FW Fast Hook Test"
+        default n
+        depends on  LTQ_DP_MPE_FASTHOOK_TEST
+        ---help---
+        MPE FW Fast Hook is used to quick verify MPE FW Functionality without
+        fullPPA support. It will install two hook in dp_rx/dp_xmit API and
+        quickly learn session informatin. Once the session is learned,
+        it will configure MPE FW session table, ie, the compare table and
+        test MPE FW functionalities.
+
 endif # NET_VENDOR_LANTIQ
diff -Naur a/drivers/net/ethernet/lantiq/lantiq_pcie_ep_vrx320_test.h b/drivers/net/ethernet/lantiq/lantiq_pcie_ep_vrx320_test.h
--- a/drivers/net/ethernet/lantiq/lantiq_pcie_ep_vrx320_test.h	2017-10-11 10:17:22.027819000 +0530
+++ b/drivers/net/ethernet/lantiq/lantiq_pcie_ep_vrx320_test.h	2017-10-11 09:36:21.640505000 +0530
@@ -27,11 +27,11 @@
 /* Inbound address translation for iATU0 */
 #define PCIE_EP_INBOUND_INTERNAL_BASE          0x1E000000
 #define PCIE_EP_OUTBOUND_INTERNAL_BASE         0x20000000
-#define PCIE_EP_OUTBOUND_MEMSIZE               0x80000000
-
+#define PCIE_EP_OUTBOUND_MEMSIZE               0x80000000
+
 #define VRX218_MASK_ADDR(X)  (0x00FFFFFF & (X))
-#define VRX218_ADDR(X)       ((0x00FFFFFF & (X)) | 0x1e000000)
-
+#define VRX218_ADDR(X)       ((0x00FFFFFF & (X)) | 0x1e000000)
+
 /* VRX218 internal address */
 #define VRX218_PDRAM_BASE    0x1e080000
 #define PPE_SB_RAM_BLOCK0    (0x1e200000 + (0x8000 << 2))
@@ -73,8 +73,8 @@
 #define REMOTE_RX1_DATA_LOC    VRX218_PDRAM_BASE + 0x8000
 #define VRX218_TX_DESC         VRX218_PDRAM_BASE + 0x10000
 #define VRX218_RX_DESC         VRX218_PDRAM_BASE + 0x11000
-#endif
-
+#endif
+
 #define VRX218_CDMA_OFFSET                0x00104100
 #define CDMA_CLC(__membase)                   ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0000))
 #define CDMA_ID(__membase)                    ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0008))
diff -Naur a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_desc.c b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_desc.c
--- a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_desc.c	2017-10-11 10:17:20.919715000 +0530
+++ b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_desc.c	2017-10-11 09:36:20.324402000 +0530
@@ -36,6 +36,10 @@
 #include "DWC_ETH_QOS_desc.h"
 #include "DWC_ETH_QOS_yregacc.h"
 
+#ifdef GBE_DEBUG
+extern uint mss_for_tso;
+#endif
+
 /*!
 * \brief API to free the transmit descriptor memory.
 *
@@ -353,9 +357,7 @@
 		    (desc_dma + sizeof(rx_descriptor_t) * i);
 		GET_RX_BUF_PTR(qInx, i) = &buffer[i];
 		/* allocate skb & assign to each desc */
-		if (pdata->alloc_rx_buf(pdata, GET_RX_BUF_PTR(qInx, i),
-			(pdata->power_state & DWC_ETH_QOS_NETIP_PWRUP)?
-			GFP_ATOMIC : GFP_KERNEL))
+		if (pdata->alloc_rx_buf(pdata, GET_RX_BUF_PTR(qInx, i), GFP_KERNEL))
 			break;
 		wmb();
 	}
@@ -839,6 +841,7 @@
  * \retval count  number of packet to be programmed in the descriptor or
  * zero on failure.
  */
+
 static unsigned int DWC_ETH_QOS_map_skb(struct net_device *dev,
 					struct sk_buff *skb)
 {
@@ -997,7 +1000,6 @@
 *
 * \return void
 */
-
 static void DWC_ETH_QOS_unmap_tx_skb(struct DWC_ETH_QOS_prv_data *pdata,
 				     struct DWC_ETH_QOS_tx_buffer *buffer)
 {
@@ -1027,6 +1029,7 @@
 		buffer->len2 = 0;
 	}
 
+
 	if (buffer->skb != NULL) {
 		dev_kfree_skb_any(buffer->skb);
 		buffer->skb = NULL;
@@ -1044,12 +1047,13 @@
  *
  * \return void
  */
+
 static void DWC_ETH_QOS_unmap_rx_skb(struct DWC_ETH_QOS_prv_data *pdata,
 				     struct DWC_ETH_QOS_rx_buffer *buffer)
 {
 	DBGPR("-->DWC_ETH_QOS_unmap_rx_skb\n");
 
-	/* Unmap the first buffer */
+	/* unmap the first buffer */
 	if (buffer->dma) {
 		if (pdata->rx_split_hdr) {
 			dma_unmap_single(&pdata->pdev->dev, buffer->dma,
diff -Naur a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_dev.c b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_dev.c
--- a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_dev.c	2017-10-11 10:17:20.911716000 +0530
+++ b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_dev.c	2017-10-11 09:36:20.314411000 +0530
@@ -36,8 +36,6 @@
 #include "DWC_ETH_QOS_yapphdr.h"
 #include "DWC_ETH_QOS_yregacc.h"
 
-extern struct DWC_ETH_QOS_prv_data *pdata_p;
-
 /*!
 * \brief This sequence is used to enable/disable MAC loopback mode
 * \param[in] enb_dis
@@ -1630,7 +1628,7 @@
  int stop_dma_rx(uint32_t qInx)
 {
    int retryCount = 10;
-   uint32_t ch_state = 0;
+   volatile uint32_t ch_state;
    int ret = Y_SUCCESS;
 
    /* issue Rx dma stop command */
@@ -1701,7 +1699,7 @@
  int stop_dma_tx(uint32_t qInx)
 {
    int retryCount = 10;
-   uint32_t ch_state = 0;
+   volatile uint32_t ch_state;
    int ret = Y_SUCCESS;
 
    /* issue Tx dma stop command */
@@ -1951,8 +1949,97 @@
    return Y_SUCCESS;
 }
 
+/*! \fn Uint32 bit_field32_get(Uint32 data, Uint32 offset, Uint32 width)
+ *  \brief get the value of a specific bit-field from 32-bit value
+ *  \param[in] data the value from which to extract the bit-field
+ *  \param[in] bitOffset the offset (in bits) of the required bit-field
+ *  \param[in] width the number of bits in the required bit-field
+ *  \return bit-field value
+ */
+Uint32 bit_field32_get_synopsys(Uint32 data, Uint32 bitOffset, Uint32 width)
+{
+    Uint32 mask;
+
+    mask = ((0xFFFFFFFF >> (32-width)) << bitOffset);
+
+    return ((data & mask) >> bitOffset);
+}
+
+void bit_field32_set_with_endian_convertion_synopsys(volatile Uint32 *addr, Uint32 data, Uint32 bitOffset, Uint32 width)
+{
+    Uint32 mask, readData;
+
+    mask = ((0xFFFFFFFF >> (32-width)) << bitOffset);
+
+    readData   =  be32_to_cpu(*addr);
+    readData  &=  ~mask;
+    readData  |=  mask & (data << bitOffset);
+    *addr      =  cpu_to_be32(readData);
+
+#ifdef  DEBUG_REGS_WRITE
+    printk("[0x%x] <-- [0x%x] \n", addr, *addr);
+#endif
+}
+
+/*! \fn void bit_field32_set(uint32 *addr, uint32 data, uint32 offset, uint32 width)
+ *  \brief set the value of a specific bit-field in a given 32-bit field
+ *  \param[in] addr the address of the 32-bit field that contains the bit-field
+ *  \param[in] data the value to be written
+ *  \param[in] bitOffset the offset (in bits) of the required bit-field
+ *  \param[in] width the number of bits in the required bit-field
+ *  \return none.
+ */
+void bit_field32_set_synopsys(volatile Uint32 *addr, Uint32 data, Uint32 bitOffset, Uint32 width)
+{
+#ifndef CONFIG_ARM_AVALANCHE_SOC
+    bit_field32_set_with_endian_convertion_synopsys(addr, data, bitOffset, width);
+#else
+    Uint32 mask;
+
+    mask = ((0xFFFFFFFF >> (32-width)) << bitOffset);
+
+    *addr &= ~mask;
+    *addr |=  mask & (data << bitOffset);
+
+#ifdef  DEBUG_REGS_WRITE
+    printk("[0x%x] <-- [0x%x] \n", addr, *addr);
+#endif
+#endif
+}
+
+extern struct DWC_ETH_QOS_prv_data *pdata_p;
+
+void mux_configuration(int req_mdio_num){
+	
+   volatile GBE_general_s *GBE_gnrl = GBE_GENERAL_BASE_ADDRESS;
+	
+   if (bit_field32_get_synopsys(be32_to_cpu(GBE_gnrl->GMCR), GMCR_MDIO_MUX_BIT, GMCR_MDIO_MUX_BIT_WIDTH) != req_mdio_num)
+   {
+       bit_field32_set_synopsys((void*)&GBE_gnrl->GMCR, req_mdio_num, GMCR_MDIO_MUX_BIT, GMCR_MDIO_MUX_BIT_WIDTH);
+       udelay(5);
+   }
+}
+
+bool poll_on_busy_bit(void){
+	
+	uint32_t retryCount = 1000, varMAC_MDIOAR, vy_count = 0;
+	
+	while (DWC_REG_RD_BIT(MAC_MDIO_AR, MAC_MDIO_AR_GB) && --retryCount) {
+		if (vy_count > retryCount) {
+			spin_unlock(&pdata_p->mdiolock);
+			return false;
+		} else {
+			vy_count++;
+			/* Retry count is 1000, this gives maximum busy wait of 10ms with good granularity */
+			udelay(10);
+		}
+	}
+	return true;
+}
+
 /*!
 * \brief This sequence is used to write into phy registers in clause22 protocol
+* \param[in] MDIO_0 / MDIO_1
 * \param[in] phy_id
 * \param[in] phy_reg
 * \param[in] phy_reg_data
@@ -1996,9 +2083,10 @@
     spin_unlock(&pdata_p->mdiolock);
     
     return Y_SUCCESS;
- }
+}
 
-/* \brief This sequence is used to write into phy registers in clause45 protocol
+/*!
+* \brief This sequence is used to write into phy registers in clause45 protocol
 * \param[in] MDIO_0 / MDIO_1
 * \param[in] phy_id
 * \param[in] mmd
@@ -2073,7 +2161,8 @@
 }
 
 /*!
-* \brief This sequence is used to read the phy registers
+* \brief This sequence is used to read the phy registers in clause22 protocol
+* \param[in] MDIO_0 / MDIO_1
 * \param[in] phy_id
 * \param[in] phy_reg
 * \param[out] phy_reg_data
@@ -2131,7 +2220,7 @@
 * \param[in] MDIO_0 / MDIO_1
 * \param[in] phy_id
 * \param[in] mmd
- \param[in] phy_reg
+* \param[in] phy_reg
 * \param[out] phy_reg_data
 * \return Success or Failure
 * \retval  0 Success
@@ -2142,7 +2231,7 @@
    uint32_t varMAC_MDIOAR;
    
    /* Do MDIO under lock because we touch MDIO mux */
-spin_lock(&pdata_p->mdiolock);
+	spin_lock(&pdata_p->mdiolock);
 	
 	/* Check the MDIO MUX configuration */
     mux_configuration(req_mdio_num);
@@ -2202,11 +2291,12 @@
 */
 static int read_phy_regs(int req_mdio_num, bool c45e, int phy_id, int mmd, int phy_reg, int *phy_reg_data)
 {	
-if(c45e)
+	if(c45e)
 		return read_phy_regs_c45(req_mdio_num, phy_id, mmd, phy_reg, phy_reg_data);
 	else 
 		return read_phy_regs_c22(req_mdio_num, phy_id, phy_reg, phy_reg_data);
- }
+}
+
 /*!
 * \brief This sequence is used to check whether transmitted pkts have
 * fifo under run loss error or not, returns 1 if fifo under run error
@@ -2473,44 +2563,6 @@
 
    DBGPR("<--tx_descriptor_init\n");
 }
-/*!
-* \brief This sequence is used to instruct the MAC to perform one of the
-* the following based on the value of tx_vlan_tag_ctrl
-* ========================================
-* | tx_vlan_tag_ctrl   |    Action       |
-* =======================================|
-* |      00            | Do Not add tags |
-* |      01            | Remove the tags |
-* |      10            | Insert the tags |
-* |      11            | Replace the tags|
-* ========================================
-* \param[in] pdata
-* \param[in] qInx
-*/
-void process_vlan_tags(struct DWC_ETH_QOS_prv_data *pdata, uint32_t qInx)
-{
-   struct DWC_ETH_QOS_tx_wrapper_descriptor *tx_desc_data =
-       GET_TX_WRAPPER_DESC(qInx);
-   tx_descriptor_t *tx_desc = GET_TX_DESC_PTR(qInx, tx_desc_data->cur_tx);
-#ifdef DWC_ETH_QOS_ENABLE_VLAN_TAG
-   /* Insert a VLAN tag with a tag value programmed in MAC Reg 24 or
-    * CONTEXT descriptor
-    * */
-   if (tx_desc_data->vlan_tag_present && Y_FALSE == tx_desc_data->tx_vlan_tag_via_reg) {
-      //printk(KERN_ALERT "VLAN control info update via descriptor\n\n");
-      VAR32_SET_FIELD(tx_desc->TDES2, NORMAL_RF_TDES2_VTIR,
-               tx_desc_data->tx_vlan_tag_ctrl);
-   }
-#endif   /* DWC_ETH_QOS_ENABLE_VLAN_TAG */
-
-#ifdef DWC_ETH_QOS_ENABLE_DVLAN
-   if (pdata->via_reg_or_desc == DWC_ETH_QOS_VIA_DESC) {
-      if (pdata->in_out & DWC_ETH_QOS_DVLAN_OUTER) {
-         VAR32_SET_FIELD(tx_desc->TDES2, NORMAL_RF_TDES2_VTIR, pdata->op_type);
-      }
-   }
-#endif /* End of DWC_ETH_QOS_ENABLE_DVLAN */
-}
 
 /*!
 * \brief This sequence is used to prepare tx descriptor for
@@ -2622,13 +2674,9 @@
       VAR32_SET_BIT(tx_desc->TDES3, CONTEXT_TDES3_TYPE, 1);
       VAR32_SET_BIT(tx_desc->TDES3, CONTEXT_TDES3_OWN, 1);
 
-      /* Deleting the writing of MSS into DMA_CR as the
-       * spec says it should be written into either the
-       * CONTEXT descriptor or DMA_CR register. The
-       * context descriptor is updated with MSS in the
-       * above code. Refer to the
-       * DWC_ether_qos_databook_4.00a.pdf section 11.12
-       */
+      /* DMA uses the MSS value programed in DMA_CR if driver
+       * doesn't provided the CONTEXT descriptor */
+      //DWC_REG_WR_FIELD(DMA_CR(qInx), DMA_CR_MSS, tx_pkt_features->mss);
 
       tx_desc_data->default_mss = tx_pkt_features->mss;
 
@@ -2663,7 +2711,24 @@
       VAR32_SET_FIELD(tx_desc->TDES3, NORMAL_RF_TDES3_PL, total_len);
    }
 
-   process_vlan_tags(pdata, qInx);
+#ifdef DWC_ETH_QOS_ENABLE_VLAN_TAG
+   /* Insert a VLAN tag with a tag value programmed in MAC Reg 24 or
+    * CONTEXT descriptor
+    * */
+   if (tx_desc_data->vlan_tag_present && Y_FALSE == tx_desc_data->tx_vlan_tag_via_reg) {
+      //printk(KERN_ALERT "VLAN control info update via descriptor\n\n");
+      VAR32_SET_FIELD(tx_desc->TDES2, NORMAL_RF_TDES2_VTIR,
+               tx_desc_data->tx_vlan_tag_ctrl);
+   }
+#endif   /* DWC_ETH_QOS_ENABLE_VLAN_TAG */
+
+#ifdef DWC_ETH_QOS_ENABLE_DVLAN
+   if (pdata->via_reg_or_desc == DWC_ETH_QOS_VIA_DESC) {
+      if (pdata->in_out & DWC_ETH_QOS_DVLAN_OUTER) {
+         VAR32_SET_FIELD(tx_desc->TDES2, NORMAL_RF_TDES2_VTIR, pdata->op_type);
+      }
+   }
+#endif /* End of DWC_ETH_QOS_ENABLE_DVLAN */
 
    /* Mark it as First Descriptor */
    VAR32_SET_BIT(tx_desc->TDES3, NORMAL_RF_TDES3_FD, 1);
@@ -2723,8 +2788,6 @@
          VAR32_SET_FIELD(tx_desc->TDES2, NORMAL_RF_TDES2_B2L, buffer->len2);
       }
 
-      process_vlan_tags(pdata, qInx);
-
       /* set own bit */
       VAR32_SET_BIT(tx_desc->TDES3, NORMAL_RF_TDES3_OWN, 1);
       /* Mark it as NORMAL descriptor */
@@ -3582,90 +3645,3 @@
 
    DBGPR("<--DWC_ETH_QOS_init_function_ptrs_dev\n");
 }
-
-/*! \fn Uint32 bit_field32_get(Uint32 data, Uint32 offset, Uint32 width)
- *  \brief get the value of a specific bit-field from 32-bit value
- *  \param[in] data the value from which to extract the bit-field
- *  \param[in] bitOffset the offset (in bits) of the required bit-field
- *  \param[in] width the number of bits in the required bit-field
- *  \return bit-field value
- */
-Uint32 bit_field32_get_synopsys(Uint32 data, Uint32 bitOffset, Uint32 width)
-{
-    Uint32 mask;
-
-    mask = ((0xFFFFFFFF >> (32-width)) << bitOffset);
-
-    return ((data & mask) >> bitOffset);
-}
-
-void bit_field32_set_with_endian_convertion_synopsys(volatile Uint32 *addr, Uint32 data, Uint32 bitOffset, Uint32 width)
-{
-    Uint32 mask, readData;
-
-    mask = ((0xFFFFFFFF >> (32-width)) << bitOffset);
-
-    readData   =  be32_to_cpu(*addr);
-    readData  &=  ~mask;
-    readData  |=  mask & (data << bitOffset);
-    *addr      =  cpu_to_be32(readData);
-
-#ifdef  DEBUG_REGS_WRITE
-    printk("[0x%x] <-- [0x%x] \n", addr, *addr);
-#endif
-}
-
-/*! \fn void bit_field32_set(uint32 *addr, uint32 data, uint32 offset, uint32 width)
- *  \brief set the value of a specific bit-field in a given 32-bit field
- *  \param[in] addr the address of the 32-bit field that contains the bit-field
- *  \param[in] data the value to be written
- *  \param[in] bitOffset the offset (in bits) of the required bit-field
- *  \param[in] width the number of bits in the required bit-field
- *  \return none.
- */
-void bit_field32_set_synopsys(volatile Uint32 *addr, Uint32 data, Uint32 bitOffset, Uint32 width)
-{
-#ifndef CONFIG_ARM_AVALANCHE_SOC
-    bit_field32_set_with_endian_convertion_synopsys(addr, data, bitOffset, width);
-#else
-    Uint32 mask;
-
-    mask = ((0xFFFFFFFF >> (32-width)) << bitOffset);
-
-    *addr &= ~mask;
-    *addr |=  mask & (data << bitOffset);
-
-#ifdef  DEBUG_REGS_WRITE
-    printk("[0x%x] <-- [0x%x] \n", addr, *addr);
-#endif
-#endif
-}
-
-void mux_configuration(int req_mdio_num){
-	
-   volatile GBE_general_s *GBE_gnrl = GBE_GENERAL_BASE_ADDRESS;
-	
-   if (bit_field32_get_synopsys(be32_to_cpu(GBE_gnrl->GMCR), GMCR_MDIO_MUX_BIT, GMCR_MDIO_MUX_BIT_WIDTH) != req_mdio_num)
-   {
-       bit_field32_set_synopsys((void*)&GBE_gnrl->GMCR, req_mdio_num, GMCR_MDIO_MUX_BIT, GMCR_MDIO_MUX_BIT_WIDTH);
-       udelay(5);
-   }
-}
-
-bool poll_on_busy_bit(void){
-	
- uint32_t retryCount = 1000, varMAC_MDIOAR, vy_count = 0;
-	
-	while (DWC_REG_RD_BIT(MAC_MDIO_AR, MAC_MDIO_AR_GB) && --retryCount) {
-		if (vy_count > retryCount) {
-			spin_unlock(&pdata_p->mdiolock);
-			return false;
-		} else {
-			vy_count++;
-			/* Retry count is 1000, this gives maximum busy wait of 10ms with good granularity */
-			udelay(10);
-		}
-	}
-	return true;
-}
-
diff -Naur a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_drv.c b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_drv.c
--- a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_drv.c	2017-10-11 10:17:20.907715000 +0530
+++ b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_drv.c	2017-10-11 09:36:20.309392000 +0530
@@ -66,13 +66,47 @@
 
 #ifdef GBE_DEBUG
 
+#define __dwc_dump_skb(skb) \
+do { \
+	pr_err("skb %p: skb->sk=%p, skb->dev=%s, skb_dst(skb)->dev=%s," \
+		 " skb->len=%d, skb->hdr_len=%d, skb->skb_iif=%d, skb->queue_mapping=%d," \
+		 " skb_mac_header(skb)=%p, skb_network_header(skb)=%p," \
+		 " skb_transport_header(skb)=%p, skb->head=%p, skb->data=%p, skb->tail=%p," \
+		 " skb->end=%p\n", \
+		skb, skb->sk,	\
+		skb->dev ? skb->dev->name : "NULL", \
+		skb_dst(skb) ? (skb_dst(skb)->dev ? skb_dst(skb)->dev->name : "NA") : "NA", \
+		skb->len, skb->hdr_len, skb->skb_iif, skb->queue_mapping, \
+		skb_mac_header(skb), skb_network_header(skb), \
+		skb_transport_header(skb), skb->head, skb->data, skb->tail, \
+		skb->end); \
+	pr_err("eth header: src=%pM, dst=%pM, proto=%d\n", \
+		eth_hdr(skb)->h_source, eth_hdr(skb)->h_dest, eth_hdr(skb)->h_proto); \
+	if (ip_hdr(skb) && ip_hdr(skb)->version == 4) { \
+		pr_err("ip header: src=%pI4, dst=%pI4, protocol=%d (%s)\n", \
+			&ip_hdr(skb)->saddr, &ip_hdr(skb)->daddr, ip_hdr(skb)->protocol, \
+			ip_hdr(skb)->protocol == IPPROTO_TCP ? "tcp" : \
+			(ip_hdr(skb)->protocol == IPPROTO_UDP ? "udp" : "")); \
+	} else if (ip_hdr(skb) && ip_hdr(skb)->version == 6) { \
+		pr_err("ip header: src=%pI6, dst=%pI6, nexthdr=%d (%s)\n", \
+			&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr, ipv6_hdr(skb)->nexthdr, \
+			ipv6_hdr(skb)->nexthdr == IPPROTO_TCP ? "tcp" : \
+			(ipv6_hdr(skb)->nexthdr == IPPROTO_UDP ? "udp" : "")); \
+	} else { \
+		pr_err("not an IP packet\n"); \
+	} \
+} while (0);
+
 extern bool print_tx_pkts;
 extern bool print_rx_pkts;
 
 #define PRINT_SKB_INFO(MSG, PARAM, SKB) \
-   printk(KERN_INFO MSG "Data[0x%08x] Tail[0x%08x] End[0x%08x]\n", \
-          PARAM, (uint32_t)(SKB)->data, \
-          (uint32_t)(SKB)->tail, (uint32_t)(SKB)->end)
+do { \
+   printk(KERN_INFO MSG "Data[0x%08x] Tail[0x%08x] End[0x%08x]\n",\
+             PARAM, (uint32_t)(SKB)->data, \
+             (uint32_t)(SKB)->tail, (uint32_t)(SKB)->end);\
+   __dwc_dump_skb(skb); \
+} while (0);
 
 static inline void print_skb(struct sk_buff *skb, bool isRx)
 {
@@ -303,15 +337,13 @@
    if (pdata->power_state & DWC_ETH_QOS_NETIP_PWRUP) {
       CFG_PRINT("Device waking up from StandBy\n");
    } else if (netif_running(pdata->dev)) {
-      CFG_PRINT("Stopping device\n");
-      hrtimer_cancel(&pdata->rx_itr_timer);
+      CFG_PRINT("Device is not running\n");
       netif_tx_disable(pdata->dev);
       DWC_ETH_QOS_napi_disable(pdata);
       /* Stop DMA TX/RX */
       DWC_ETH_QOS_stop_all_ch_tx_dma(pdata);
       DWC_ETH_QOS_stop_all_ch_rx_dma(pdata);
    } else {
-      CFG_PRINT("Device is not running\n");
       ret = GBE_STOP_STATE;
    }
    /* Issue software reset to device */
@@ -522,8 +554,7 @@
    if (pdata->version == MAC_VER_4_00) {
       // Read and clear interrupt in Atom Interrupt Controller
       atom_ims = GBE_REG_RD(GBE_ATOM_IMS); //Interrupts are cleared when IMS is read
-      if (!VAR32_GET_BIT(atom_ims, GBE_ATOM_INTC) &&
-          !(pdata->power_state & DWC_ETH_QOS_NETIP_PWRDWN))
+      if (!VAR32_GET_BIT(atom_ims, GBE_ATOM_INTC))
          printk(KERN_ALERT "GMAC5 interrupt with bit not set on IC!\n");
    }
 
@@ -1046,7 +1077,6 @@
    .ndo_start_xmit = DWC_ETH_QOS_start_xmit,
    .ndo_get_stats = DWC_ETH_QOS_get_stats,
    .ndo_set_rx_mode = DWC_ETH_QOS_set_rx_mode,
-   .ndo_set_mac_address	= DWC_ETH_QOS_set_mac,
 #ifdef CONFIG_NET_POLL_CONTROLLER
    .ndo_poll_controller = DWC_ETH_QOS_poll_controller,
 #endif            /*end of CONFIG_NET_POLL_CONTROLLER */
@@ -1834,7 +1864,7 @@
    unsigned char hpf_mode = 0;
    int mode, i;
 
-   CFG_PRINT("-->DWC_ETH_QOS_set_rx_mode\n");
+   DBGPR_FILTER("-->DWC_ETH_QOS_set_rx_mode\n");
 
    spin_lock_irqsave(&pdata->lock, flags);
 
@@ -1890,37 +1920,7 @@
 
    spin_unlock_irqrestore(&pdata->lock, flags);
 
-   CFG_PRINT("<--DWC_ETH_QOS_set_rx_mode\n");
-}
-
-static int DWC_ETH_QOS_set_mac(struct net_device *dev, void *p)
-{
-   struct DWC_ETH_QOS_prv_data *pdata = netdev_priv(dev);
-   struct sockaddr *addr = p;
-   gbe_power_state_t state;
-
-   CFG_PRINT("-->DWC_ETH_QOS_set_mac\n");
-
-   if (!is_valid_ether_addr(addr->sa_data)) {
-      ERR_PRINT("Invalid MAC address!\n");
-      return -EADDRNOTAVAIL;
-   }
-
-   /* Stop device before chaginng the MAC address */
-   state = DWC_ETH_QOS_stop_dev(pdata);
-
-   memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
-
-   if (state == GBE_RUN_STATE) {
-      DWC_ETH_QOS_set_rx_mode(dev);
-      DWC_ETH_QOS_start_dev(pdata);
-   } else if (state == GBE_STANDBY_STATE) {
-      /* Save request to apply it when device is powered up */
-      pdata->power_state |= DWC_ETH_QOS_NETIP_MAC_ADDR_REQ;
-   }
-
-   CFG_PRINT("<--DWC_ETH_QOS_set_mac\n");
-   return 0;
+   DBGPR("<--DWC_ETH_QOS_set_rx_mode\n");
 }
 
 /*!
@@ -2766,8 +2766,6 @@
             } else {
                /* this is the middle of a chain */
                payload_len = pdata->rx_buffer_len;
-               /* skb_top must not be NULL for a middle descriptor */
-               BUG_ON(desc_data->skb_top == NULL);
                skb_fill_page_desc(desc_data->skb_top,
                   skb_shinfo(desc_data->skb_top)->nr_frags,
                   buffer->page2, 0,
@@ -2794,8 +2792,6 @@
                      buffer->rx_hdr_size);
                }
 
-               /* skb_top must not be NULL for the last descriptor */
-               BUG_ON(desc_data->skb_top == NULL);
                skb_fill_page_desc(desc_data->skb_top,
                   skb_shinfo(desc_data->skb_top)->nr_frags,
                   buffer->page2, 0,
@@ -3013,21 +3009,18 @@
                   pdata->rx_buffer_len);
 
                DBGPR("RX: pkt in second buffer pointer\n");
-               /* skb_top must not be NULL for the first descriptor */
-               BUG_ON(desc_data->skb_top == NULL);
                skb_fill_page_desc(
                   desc_data->skb_top,
                   skb_shinfo(desc_data->skb_top)->nr_frags,
                   buffer->page2, 0,
                   pdata->rx_buffer_len);
             } else {
-               /* skb_top must not be NULL for a middle descriptor */
-               BUG_ON(desc_data->skb_top == NULL);
                /* this is the middle of a chain */
                skb_fill_page_desc(desc_data->skb_top,
                   skb_shinfo(desc_data->skb_top)->nr_frags,
                   buffer->page, 0,
                   pdata->rx_buffer_len);
+
                DBGPR("RX: pkt in second buffer pointer\n");
                skb_fill_page_desc(desc_data->skb_top,
                   skb_shinfo(desc_data->skb_top)->nr_frags,
@@ -3046,8 +3039,6 @@
                /* end of the chain */
                pkt_len =
                   (pkt_len - (pdata->rx_buffer_len * intermediate_desc_cnt));
-               /* skb_top must not be NULL for the last descriptor */
-               BUG_ON(desc_data->skb_top == NULL);
                if (pkt_len > pdata->rx_buffer_len) {
                   skb_fill_page_desc(desc_data->skb_top,
                      skb_shinfo(desc_data->skb_top)->nr_frags,
@@ -5538,8 +5529,7 @@
 
    /* Configure pending requests (e.g. Split header or MTU changes) */
    if (pdata->power_state &
-      (DWC_ETH_QOS_NETIP_SPLHDR_REQ | DWC_ETH_QOS_NETIP_MTU_REQ |
-       DWC_ETH_QOS_NETIP_MAC_ADDR_REQ)) {
+      (DWC_ETH_QOS_NETIP_SPLHDR_REQ | DWC_ETH_QOS_NETIP_MTU_REQ)) {
       /* Indicate controller is powering up from StandBy */
       pdata->power_state |= DWC_ETH_QOS_NETIP_PWRUP;
       DWC_ETH_QOS_stop_dev(pdata);
@@ -5549,9 +5539,7 @@
          /* Enable/disable split header for all RX DMA channel */
          for (qInx = 0; qInx < DWC_ETH_QOS_RX_QUEUE_CNT; qInx++)
             hw_if->config_split_header_mode(qInx, pdata->rx_split_hdr);
-      } else if (pdata->power_state & DWC_ETH_QOS_NETIP_MAC_ADDR_REQ) {
-         DWC_ETH_QOS_set_rx_mode(dev);
-      }
+         }
       /* Attach net device */
       netif_device_attach(dev);
       DWC_ETH_QOS_start_dev(pdata);
diff -Naur a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_drv.h b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_drv.h
--- a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_drv.h	2017-10-11 10:17:20.920721000 +0530
+++ b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_drv.h	2017-10-11 09:36:20.327387000 +0530
@@ -39,8 +39,6 @@
 
 static void DWC_ETH_QOS_set_rx_mode(struct net_device *);
 
-static int DWC_ETH_QOS_set_mac(struct net_device *dev, void *p);
-
 static int DWC_ETH_QOS_start_xmit(struct sk_buff *, struct net_device *);
 
 static void DWC_ETH_QOS_tx_interrupt(struct net_device *,
diff -Naur a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_ethtool.c b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_ethtool.c
--- a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_ethtool.c	2017-10-11 10:17:20.913733000 +0530
+++ b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_ethtool.c	2017-10-11 09:36:20.317401000 +0530
@@ -505,6 +505,7 @@
 		cmd->port = PORT_OTHER;
 	} else {
 		if (pdata->phydev == NULL) {
+			printk(KERN_ALERT "%s: PHY is not registered\n", dev->name);
 			return -ENODEV;
 		}
 
diff -Naur a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_pci.c b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_pci.c
--- a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_pci.c	2017-10-11 10:17:20.923723000 +0530
+++ b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_pci.c	2017-10-11 09:36:20.330399000 +0530
@@ -51,13 +51,13 @@
 bool config_prints = false;
 static bool msi_mode = true;
 static bool tso_enable = true;
-static bool vlan_filter_enable = false;
-/* Enabling only one queue by default because MAC sends
-   most of the traffic to MTL FIFO 0. */
-static short num_of_queues = 1;
+
 /* default value for gmac5 speed when connected to 4 is 5G */
 unsigned int gmac5to4_speed = 5000;
 
+/* Enabling only one queue by default because MAC sends
+   most of the traffic to MTL FIFO 0. */
+static short num_of_queues = 1;
 
 module_param(config_prints, bool, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(config_prints, "Enable configuration prints");
@@ -67,8 +67,6 @@
 MODULE_PARM_DESC(msi_mode, "Enable/disable MSI interrupts mode");
 module_param(num_of_queues, short, S_IRUGO);
 MODULE_PARM_DESC(num_of_queues, "Number of device queues");
-module_param(vlan_filter_enable, bool, S_IRUGO);
-MODULE_PARM_DESC(vlan_filter_enable, "Enable/disable VLAN hash filter");
 module_param(gmac5to4_speed, uint, S_IRUGO);
 MODULE_PARM_DESC(gmac5to4_speed, "phy speed when connected to gmac4 [10 | 100 | 1000 | 2500 | 5000]");
 
@@ -80,15 +78,15 @@
 uint metadata_on_crc = 0;
 uint mss_for_tso = 0;
 
-module_param(print_tx_pkts, bool, S_IRUGO);
+module_param(print_tx_pkts, bool, 0644);
 MODULE_PARM_DESC(print_tx_pkts, "Dump Tx packets");
-module_param(print_rx_pkts, bool, S_IRUGO);
+module_param(print_rx_pkts, bool, 0644);
 MODULE_PARM_DESC(print_rx_pkts, "Dump Rx packets");
-module_param(print_desc, bool, S_IRUGO);
+module_param(print_desc, bool, 0644);
 MODULE_PARM_DESC(print_desc, "Print Tx descriptors");
-module_param(metadata_on_crc, uint, S_IRUGO);
+module_param(metadata_on_crc, uint, 0644);
 MODULE_PARM_DESC(metadata_on_crc, "Test metadata on CRC");
-module_param(mss_for_tso, uint, S_IRUGO);
+module_param(mss_for_tso, uint, 0644);
 MODULE_PARM_DESC(mss_for_tso, "MSS value to test TSO");
 
 static ssize_t gbe_dbg_show(struct device *dev,
@@ -138,7 +136,7 @@
    }
    return (buf - st);
 }
-
+#ifdef DWC_ETH_NETSS_PM /* TE - netip support is missing for that */
 static int gbe_handle_suspend_resume(void *args, netss_power_state_t state);
 
 static ssize_t gbe_suspend_store(struct device *dev,
@@ -152,7 +150,7 @@
                                     NETSS_NETIP_POWER_STATE_ACTIVE);
    return count;
 }
-
+#endif
 #endif //GBE_DEBUG
 
 unsigned int gbe_get_4to5_speed(void)
@@ -183,7 +181,7 @@
    CFG_PRINT("[GBE] Initializing General registers\n");
    if (!netss_driver_ready()) {
       printk(KERN_ALERT "[GBE] NetSS not ready!\n");
-   } else if (netss_device_get_info(NETSS_DEV_GBE, &gbe_mmio) != 0) {
+   } else if (netss_device_get_info(NETSS_DEV_GBE, &gbe_mmio)) {
       printk(KERN_ALERT "[GBE] Error getting GbE MMIO info!\n");
    } else {
       uint32_t reg_val, reg_cfg;
@@ -347,6 +345,7 @@
    if (device_create_file(&pdata->dev->dev, dev_attr)) {
       printk(KERN_ALERT "[GBE] Error creating debug sysfs attribute!\n");
    }
+#ifdef DWC_ETH_NETSS_PM /* TE - netip support is missing for that */
    dev_attr = &pdata->suspend_attr;
    sysfs_attr_init(&dev_attr->attr);
    dev_attr->show = NULL;
@@ -357,6 +356,7 @@
       printk(KERN_ALERT "[GBE] Error creating suspend sysfs attribute!\n");
    }
 #endif
+#endif
    dev_attr = &pdata->itr_lat_attr;
    sysfs_attr_init(&dev_attr->attr);
    dev_attr->show = gbe_itr_ips_show;
@@ -377,6 +377,7 @@
       gbe_configure_IC(pdata->gbe_base);
 }
 
+#ifdef DWC_ETH_NETSS_PM /* TE - netip support is missing for that */
 static int gbe_handle_suspend_resume(void *args, netss_power_state_t state)
 {
    struct DWC_ETH_QOS_prv_data *pdata = (struct DWC_ETH_QOS_prv_data *)args;
@@ -388,6 +389,7 @@
    }
    return ret;
 }
+#endif
 
 void DWC_ETH_QOS_init_all_fptrs(struct DWC_ETH_QOS_prv_data *pdata)
 {
@@ -427,7 +429,9 @@
    uint8_t tx_q_count = 0, rx_q_count = 0;
    void __iomem *gbe_base;
    unsigned int gbe_mux_cfg;
+#ifdef DWC_ETH_NETSS_PM /* TE - netip support is missing for that */
    netss_power_state_callback_info_t pm_callback_info;
+#endif
 #ifdef GBE_DEBUG
    char dbg_str[]="_DEBUG";
 #else
@@ -534,13 +538,13 @@
 
    // Disable MDIO
    pdata->hw_feat.sma_sel = 0;
-   /* Override TSO with module parameter (if HW supports TSO) */
-   if (pdata->hw_feat.tso_en)
-      pdata->hw_feat.tso_en = tso_enable;
-   /* Notify of potential known issues with TSO in core v4.00 */
-   if (pdata->hw_feat.tso_en && pdata->version == MAC_VER_4_00 &&
-       num_of_queues > 1)
-      WRN_PRINT("TSO in v4.00 with more than one queue may fail!\n");
+	/* Override TSO with module parameter (if HW supports TSO) */
+	if (pdata->hw_feat.tso_en)
+		pdata->hw_feat.tso_en = tso_enable;
+	/* Notify of potential known issues with TSO in core v4.00 */
+	if (pdata->hw_feat.tso_en && pdata->version == MAC_VER_4_00 &&
+		num_of_queues > 1)
+		WRN_PRINT("TSO in v4.00 with more than one queue may fail!\n");
 
 #ifdef GBE_DEBUG
    // Force enable TSO if mss parameter was passed
@@ -611,11 +615,6 @@
       dev->hw_features |= NETIF_F_HW_VLAN_CTAG_TX;
       CFG_PRINT("VLAN Feature enabled\n");
    }
-
-   /* Override VLAN filter enabling with module parameter */
-   if (pdata->hw_feat.vlan_hash_en)
-      pdata->hw_feat.vlan_hash_en = vlan_filter_enable;
-
    if (pdata->hw_feat.vlan_hash_en) {
       dev->hw_features |= NETIF_F_HW_VLAN_CTAG_FILTER;
       CFG_PRINT("VLAN HASH Filtering enabled\n");
@@ -648,6 +647,7 @@
 
    create_gbe_sysfs(pdata);
 
+#ifdef DWC_ETH_NETSS_PM /* TE - netip support is missing for that */
    /* Register PM callback with NetSS driver */
    pm_callback_info.func = gbe_handle_suspend_resume;
    pm_callback_info.args = pdata;
@@ -657,7 +657,7 @@
       // - Determine if it's ok to continue or return error code
       // - What if NetIP is in DSBY already?
    }
-
+#endif
    if (pdata->hw_feat.pcs_sel) {
       netif_carrier_off(dev);
       CFG_PRINT("Carrier off till LINK is up\n");
@@ -721,14 +721,17 @@
    struct DWC_ETH_QOS_prv_data *pdata = netdev_priv(dev);
    struct desc_if_struct *desc_if = &(pdata->desc_if);
    void __iomem *reg_base = pdata->gbe_base;
+#ifdef DWC_ETH_NETSS_PM /* TE - netip support is missing for that */
    netss_power_state_callback_info_t pm_callback_info;
-
+#endif
    DBGPR("--> DWC_ETH_QOS_remove\n");
 
+#ifdef DWC_ETH_NETSS_PM /* TE - netip support is missing for that */
    /* Deregister PM callback with NetSS driver */
    pm_callback_info.func = NULL;
    pm_callback_info.args = NULL;
    netss_power_state_change_callback_register(NETSS_DEV_GBE, &pm_callback_info);
+#endif
 
    if (pdata->irq_number != 0) {
       free_irq(pdata->irq_number, pdata);
diff -Naur a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_yheader.h b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_yheader.h
--- a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_yheader.h	2017-10-11 10:17:20.916718000 +0530
+++ b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_yheader.h	2017-10-11 09:36:20.322390000 +0530
@@ -115,7 +115,7 @@
 //#define GBE_POLLING
 
 /* Enable GBE debug logic */
-//#define GBE_DEBUG
+#define GBE_DEBUG
 
 #ifdef DWC_ETH_QOS_CONFIG_PTP
 #undef DWC_ETH_QOS_TXPOLLING_MODE_ENABLE
@@ -239,8 +239,6 @@
                                                 // received while device was in StandBy mode
 #define DWC_ETH_QOS_NETIP_MTU_REQ      (1 << 6) // Indicate a mtu change request was
                                                 // received while device was in StandBy mode
-#define DWC_ETH_QOS_NETIP_MAC_ADDR_REQ (1 << 7) // Indicate a MAC address change request was
-                                                // received while device was in StandBy mode
 
 #define DWC_ETH_QOS_MAC_ADDR_LEN 6
 #define DWC_ETH_QOS_ETH_FRAME_LEN (ETH_FRAME_LEN + ETH_FCS_LEN + VLAN_HLEN)
@@ -1330,6 +1328,30 @@
    } \
 } while (0)
 
+#ifdef GBE_DEBUG
+
+extern bool print_desc;
+extern uint metadata_on_crc;
+
+#define PRINT_TX_DESC(DESC, TYPE) \
+do { \
+   if(print_desc) { \
+      printk(KERN_INFO "[TX_DESC:%s] 0x%08x:0x%08x:0x%08x:0x%08x\n", #TYPE, \
+             (DESC)->TDES0, (DESC)->TDES1, (DESC)->TDES2, (DESC)->TDES3); \
+   } \
+} while (0)
+
+#endif //GBE_DEBUG
+
+extern bool config_prints;
+
+#define CFG_PRINT(x...) \
+do { \
+   if(config_prints) { \
+      printk(KERN_INFO x); \
+   } \
+} while (0)
+
 #define ERR_PRINT(x) \
    printk(KERN_ERR "[%s] ERROR: " x, __FUNCTION__)
 
diff -Naur a/drivers/net/ethernet/synopsys/Kconfig b/drivers/net/ethernet/synopsys/Kconfig
--- a/drivers/net/ethernet/synopsys/Kconfig	2017-10-11 10:17:20.931723000 +0530
+++ b/drivers/net/ethernet/synopsys/Kconfig	2017-10-11 09:36:20.339399000 +0530
@@ -1,8 +1,7 @@
 config DWC_QOS
 	tristate "Synopsys Ethernet QOS driver"
-	depends on X86_PUMA7
-	depends on PCI
 	default y
+	depends on (X86_PUMA6 || X86_PUMA7) && PCI
 	---help---
 	  This driver supports Synopsys QOS GMAC core controller.
 	  To compile this driver as a module, choose M here: the
diff -Naur a/drivers/net/lpal_api/Makefile b/drivers/net/lpal_api/Makefile
--- a/drivers/net/lpal_api/Makefile	2017-10-11 10:17:20.778704000 +0530
+++ b/drivers/net/lpal_api/Makefile	2017-10-11 09:36:20.203377000 +0530
@@ -2,6 +2,6 @@
 # Makefile for the LitePath Adaptation Layer driver
 #
 
-obj-$(CONFIG_LPAL_DIRECTPATH) += lpal_dp.o
+obj-$(CONFIG_LTQ_PPA_API_DIRECTPATH_HAS_NEW_API) += lpal_dp.o
 
 lpal_dp-objs := lpal_api.o lpal_directpath.o
diff -Naur a/drivers/net/lpal_api/lpal_directpath.c b/drivers/net/lpal_api/lpal_directpath.c
--- a/drivers/net/lpal_api/lpal_directpath.c	2017-10-11 10:17:20.777711000 +0530
+++ b/drivers/net/lpal_api/lpal_directpath.c	2017-10-11 09:36:20.202377000 +0530
@@ -55,7 +55,7 @@
 	pr_info("[LP-DP-DEBUG][%s:%d] "msg, __func__, __LINE__, ##arg);
 
 /* This API are according to new lpal structure */
-#define MAX_SUBIF       (MAX_VPID+1)
+#define MAX_SUBIF       MAX_VPID
 #define DRV_REGISTER    ppa_drv_lpal_directpath_register
 #define DRV_SEND        ppa_drv_lpal_directpath_send
 #define DRV_ALLOC_SKB   ppa_drv_lpal_directpath_alloc_skb
@@ -64,7 +64,7 @@
  * \brief  PPA synchronization primitive for exclusion and/or synchronization
  */
 static spinlock_t g_lpal_dp_lock;
-static uint32_t g_start_ifid = 0, g_end_ifid = MAX_PID * (MAX_VPID+1);
+static uint32_t g_start_ifid = 0, g_end_ifid = MAX_PID * MAX_VPID;
 struct ppe_directpath_data *ppa_drv_g_ppe_directpath_data;
 EXPORT_SYMBOL(ppa_drv_g_ppe_directpath_data);
 
@@ -132,6 +132,8 @@
 			return PPA_INVALID;
 
 		spin_lock_bh(&g_lpal_dp_lock);
+
+#ifndef USBNET_DEV_TEST
 		/* first check whether the interface already added
 		 * into PPA directpath or not
 		 */
@@ -150,25 +152,31 @@
 				return PPA_SUCCESS;
 			}
 		}
-		spin_unlock_bh(&g_lpal_dp_lock);
-
+#endif /* USBNET_DEV_TEST */
 		ret = DRV_REGISTER(subif, netif, pDirectpathCb, &if_id, flags);
 		if (ret == PPA_SUCCESS) {
 			LPAL_PRINT("Reg. PortId:[%d] subif:[%d] if_id:[%d]\n",
 				   subif->port_id, subif->subif, if_id);
-
-			spin_lock_bh(&g_lpal_dp_lock);
-			if (subif->subif != -1)
+			/* Required only for physical port */
+			if (subif->subif == -1) {
+				tmp_flags =
+				    ppa_drv_g_ppe_directpath_data[if_id].
+				    flags | PPE_DIRECTPATH_DATA_ENTRY_VALID |
+				    PPE_DIRECTPATH_DATA_RX_ENABLE;
+				ppa_drv_g_ppe_directpath_data[if_id].flags =
+				    tmp_flags;
+			} else {
 				LPAL_PRINT("Registered subif :[%d]\n",
-					   	subif->subif);
-			tmp_flags = ppa_drv_g_ppe_directpath_data[if_id].flags
-				| PPE_DIRECTPATH_DATA_ENTRY_VALID
-				| PPE_DIRECTPATH_DATA_RX_ENABLE;
-
-			ppa_drv_g_ppe_directpath_data[if_id].flags =
-			    tmp_flags;
-			spin_unlock_bh(&g_lpal_dp_lock);
+					   subif->subif);
+				tmp_flags =
+				    ppa_drv_g_ppe_directpath_data[if_id].
+				    flags | PPE_DIRECTPATH_DATA_ENTRY_VALID |
+				    PPE_DIRECTPATH_DATA_RX_ENABLE;
+				ppa_drv_g_ppe_directpath_data[if_id].flags =
+				    tmp_flags;
+			}
 		}
+		spin_unlock_bh(&g_lpal_dp_lock);
 
 		LPAL_PRINT("Exit - DP Register\n");
 		return ret;
diff -Naur a/drivers/net/puma7.Kconfig b/drivers/net/puma7.Kconfig
--- a/drivers/net/puma7.Kconfig	2017-10-11 10:17:17.726458000 +0530
+++ b/drivers/net/puma7.Kconfig	2017-10-11 09:36:17.453170000 +0530
@@ -32,3 +32,14 @@
           If wifi proxy emulator is needed
           then select yes.
           else, select no.
+
+#
+# Crypto PDSP / IPSec support
+#
+
+config IPSEC_SUPPORT
+       bool "Enable PP's IPSec Support"
+       default n
+       ---help---
+         Select if IPSec support is needed
+
diff -Naur a/include/linux/avalanche/generic/cppi41_hw_mbox_if.h /dev/null
--- a/include/linux/avalanche/generic/cppi41_hw_mbox_if.h	2017-10-11 10:17:30.217471000 +0530
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- *
- * cppi41_hw_mbox_if.h
- * Description:
- * CPPI access via HW mailbox
- *
- *
- * GPL LICENSE SUMMARY
- *
- *  Copyright(c) 2015-2016 Intel Corporation.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of version 2 of the GNU General Public License as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *  The full GNU General Public License is included in this distribution
- *  in the file called LICENSE.GPL.
- *
- *  Contact Information:
- *  Intel Corporation
- *  2200 Mission College Blvd.
- *  Santa Clara, CA  97052
- */
-
-#ifndef __CPPI41_HW_MBOX_IF_H__
-#define __CPPI41_HW_MBOX_IF_H__
-
-#include <linux/avalanche/generic/pal_cppi41.h>
-
- /************************************************/
-/*                 Structures                   */
-/************************************************/
-
-/* CPPI HW mailbox commands enum */
-typedef enum
-{
-    CPPI41_HWMBOX_CMD_ACC_CH_OPEN = 0           ,    /* Accumulator open command */
-    CPPI41_HWMBOX_CMD_ACC_CH_OPEN_REPLY         ,    /* Accumulator open reply command */
-    CPPI41_HWMBOX_CMD_ACC_CH_CLOSE              ,    /* Accumulator close command */
-    CPPI41_HWMBOX_CMD_GET_REGION_MEM_INFO       ,    /* Descriptors region memory info command */
-    CPPI41_HWMBOX_CMD_GET_REGION_MEM_INFO_REPLY ,    /* Descriptors region memory info reply command */
-    CPPI41_HWMBOX_CMD_GET_OFFCHIP_MEM_INFO_REPLY,    /* OffChip memory info reply command */
-    CPPI41_HWMBOX_CMD_GET_BPOOL_MEM_INFO_REPLY  ,    /* OffChip cppi buffer pool memory info reply command */
-    CPPI41_HWMBOX_CMD_FAILED                    ,    /* command processing failed command, use only for reply - the error code is from the type Cppi41HwMboxRetCode_e */
-    CPPI41_HWMBOX_CMD_COUNT
-}Cppi41HwMboxCmd_e;
-
-/* error codes for CPPI41_HWMBOX_CMD_FAILED command */
-typedef enum
-{
-    CPPI41_HWMBOX_RET_CODE_OK = 0,
-    CPPI41_HWMBOX_RET_CODE_UNSUPPORTED_CMD,
-    CPPI41_HWMBOX_RET_CODE_CMD_ERROR,
-    CPPI41_HWMBOX_RET_CODE_COUNT,
-}Cppi41HwMboxRetCode_e;
-
-/* Cppi HW mailbox fail message */
-typedef struct
-{
-    Cppi41HwMboxCmd_e       cmd;        /* command type - must be CPPI41_HWMBOX_CMD_FAILED */
-    Cppi41HwMboxRetCode_e   failCode;   /* fail code */
-} Cppi41HwMboxFailMsg_t;
-
-/* Cppi HW mailbox message to open accumulator channel */
-typedef struct
-{
-    Cppi41HwMboxCmd_e       cmd;        /* command type - must be CPPI41_HWMBOX_CMD_ACC_CH_OPEN  */
-    Cppi4AccumulatorCfg     initCfg;    /* The accumulator channel init configuration */
-} Cppi41HwMboxAccChOpenMsg_t;
-
-/* Cppi HW mailbox response message to open accumulator channel */
-typedef struct
-{
-    Cppi41HwMboxCmd_e   cmd;            /* command type - must be CPPI41_HWMBOX_CMD_ACC_CH_OPEN_REPLY */
-    Ptr                 curPage;        /* Current accumulator page physical address */
-    PAL_Cppi4AccChHnd   accChHnd;       /* handle to accumulator channel handle, this field is mandatory for closing the channel */
-}Cppi41HwMboxAccChOpenReplyMsg_t;
-
-/* Cppi HW mailbox message to close accumulator channel */
-typedef struct
-{
-    Cppi41HwMboxCmd_e   cmd;        /* command type */
-    PAL_Cppi4AccChHnd   accChHnd;   /* The accumulator channel init configuration */
-} Cppi41HwMboxAccChCloseMsg_t;
-
-/* Cppi HW mailbox message to get descriptor region memory info, phyical address and length */
-typedef struct
-{
-    Cppi41HwMboxCmd_e           cmd;    /* command type */
-    unsigned int                region; /* region number */
-    Uint32                      qMgr;   /* queue manager */
-} Cppi41HwMboxDescRegionMemInfoGetMsg_t;
-
-/* Cppi HW mailbox message to reply to a get descriptor region memory info message */
-typedef struct
-{
-    Cppi41HwMboxCmd_e   cmd;            /* command type */
-    Ptr                 regionPhyAddr;  /* region memory physical address */
-    Uint32              length;         /* region memory length in bytes */
-} Cppi41HwMboxDescRegionMemInfoReplyMsg_t;
-
-/* Cppi HW mailbox message to reply to a get offChip memory info message */
-typedef struct
-{
-    Cppi41HwMboxCmd_e   cmd;                /* command type */
-    Uint32              off_chip_phy_addr;  /* offChip physical address */
-    Uint32              length;             /* offChip memory length in bytes */
-} Cppi41HwMboxOffChipMemInfoReplyMsg_t;
-
-/* Cppi HW mailbox message to reply to a get offChip cppi buffer pool memory info message */
-typedef struct
-{
-    Cppi41HwMboxCmd_e   cmd;                /* command type */
-    Uint32              pool;               /* buffer pool number */
-    Uint32              reserved;              /* Place holder */
-} Cppi41HwMboxCppiBpoolMemInfoGetMsg_t;
-
-/* Cppi HW mailbox message to reply to a get offChip cppi buffer pool memory info message */
-typedef struct
-{
-    Cppi41HwMboxCmd_e   cmd;                /* command type */
-    Uint32              off_chip_phy_addr;  /* offChip physical address */
-    Uint32              length;             /* offChip memory length in bytes */
-} Cppi41HwMboxCppiBpoolMemInfoReplyMsg_t;
-#endif /* __CPPI41_HW_MBOX_IF_H__ */
-
-/*! \fn int cppi41_hw_mbox_init (void) 
-  * \brief initialize CPPI hw mailbox interface 
-  * \return 0 on succuss, non zero value otherwise 
-  */
-int cppi41_hw_mbox_init(void);
-void cppi41_hw_mbox_deinit(void);
-
-bool  Cppi41HwMboxAccChangeEndianness(Cppi41HwMboxAccChOpenMsg_t *destCfgData, endianness_e endianity);
diff -Naur a/include/linux/avalanche/generic/gpio_mrpc_api.h b/include/linux/avalanche/generic/gpio_mrpc_api.h
--- a/include/linux/avalanche/generic/gpio_mrpc_api.h	2017-10-11 10:17:30.206474000 +0530
+++ b/include/linux/avalanche/generic/gpio_mrpc_api.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,187 +0,0 @@
-
-/*
- *
- * gpio_mrpc_api.h
- *
-  This file is provided under a dual BSD/GPLv2 license.  When using or 
-  redistributing this file, you may do so under either license.
-
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2014-2015 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify 
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but 
-  WITHOUT ANY WARRANTY; without even the implied warranty of 
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
-  General Public License for more details.
-
-  You should have received a copy of the GNU General Public License 
-  along with this program; if not, write to the Free Software 
-  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
-  The full GNU General Public License is included in this distribution 
-  in the file called LICENSE.GPL.
-
-
-  Contact Information:
-  Intel Corporation
-  2200 Mission College Blvd.
-  Santa Clara, CA  97052
-
-  BSD LICENSE 
-
-  Copyright(c) 2014-2015 Intel Corporation. All rights reserved.
-
-  Redistribution and use in source and binary forms, with or without 
-  modification, are permitted provided that the following conditions 
-  are met:
-
-    * Redistributions of source code must retain the above copyright 
-      notice, this list of conditions and the following disclaimer.
-
-    * Redistributions in binary form must reproduce the above copyright 
-      notice, this list of conditions and the following disclaimer in 
-      the documentation and/or other materials provided with the 
-      distribution.
-
-    * Neither the name of Intel Corporation nor the names of its 
-      contributors may be used to endorse or promote products derived 
-      from this software without specific prior written permission.
-
-  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
-  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
-  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
-  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
-  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
-  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
-  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
-  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
-  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
-  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-
-/*------------------------------------------------------------------------------
-* File Name: gpio_mrpc_api.h
-*------------------------------------------------------------------------------
-*/
-//! \file
-#ifndef  GPIO_MRPC_API_H
-#define  GPIO_MRPC_API_H
-
-
-/********************************************************************************************************/
-/* IOCTL commands:
-
-   If you are adding new ioctl's to the kernel, you should use the _IO
-   macros defined in <linux/ioctl.h> _IO macros are used to create ioctl numbers:
-
-    _IO(type, nr)         - an ioctl with no parameter.
-   _IOW(type, nr, size)  - an ioctl with write parameters (copy_from_user), kernel would actually read data from user space
-   _IOR(type, nr, size)  - an ioctl with read parameters (copy_to_user), kernel would actually write data to user space
-   _IOWR(type, nr, size) - an ioctl with both write and read parameters
-
-   'Write' and 'read' are from the user's point of view, just like the
-    system calls 'write' and 'read'.  For example, a SET_FOO ioctl would
-    be _IOW, although the kernel would actually read data from user space;
-    a GET_FOO ioctl would be _IOR, although the kernel would actually write
-    data to user space.
-
-    The first argument to _IO, _IOW, _IOR, or _IOWR is an identifying letter
-    or number from the SoC_ModuleIds_e enum located in this file.
-
-    The second argument to _IO, _IOW, _IOR, or _IOWR is a sequence number
-    to distinguish ioctls from each other.
-
-   The third argument to _IOW, _IOR, or _IOWR is the type of the data going
-   into the kernel or coming out of the kernel (e.g.  'int' or 'struct foo').
-
-   NOTE!  Do NOT use sizeof(arg) as the third argument as this results in
-   your ioctl thinking it passes an argument of type size_t.
-
-*/
-
-#define GPIO_OK   (0)
-#define GPIO_FAIL (-1)
-
-#define GPIO_MODULE_ID                         (0x02)
-#define GPIO_SET_DIRECTION_CMD                 _IOW(GPIO_MODULE_ID, 1, unsigned long)
-#define GPIO_GET_DIRECTION_CMD                 _IOWR(GPIO_MODULE_ID, 2, unsigned long)
-#define GPIO_OUT_BIT_CMD                       _IOW(GPIO_MODULE_ID, 3, unsigned long)
-#define GPIO_IN_BIT_CMD                        _IOWR(GPIO_MODULE_ID, 4, unsigned long)
-#define GPIO_CTRL_IO_PAD                       _IOW(GPIO_MODULE_ID, 5, unsigned long)
-
-#define GPIO_INTERFACE_DRIVER_DEV_NAME "/dev/docsis_gpio_dev"
-#define GPIO_PROC_FILE   "/proc/gpio"
-#define GPIO_PROC_NAME   "gpio"
-
-
-struct gpio_user_info
-{
-    unsigned int  gpio_pin;
-    unsigned int  pin_direction;
-    unsigned int  value;
-
-};
-
-struct io_ctrl_user_info
-{
-    unsigned int  opcode;
-    unsigned int  value1;
-    unsigned int  value2;
-};
-
-
-typedef enum GPIO_PIN_DIRECTION_tag
-{
-    GPIO_OUTPUT_DIR = 0,
-    GPIO_INPUT_DIR = 1
-} GPIO_PIN_DIRECTION_T;
-
-/*All PUMA7 platform uses the same GPIO representation*/
-typedef enum
-{
-    PUMA7_GPIO_US_BAND_SEL = 0,
-    PUMA7_GPIO_DS_BAND_SEL,
-    PUMA7_GPIO_NUM2,
-    PUMA7_GPIO_NUM3,
-    PUMA7_GPIO_TUNER_RESET,
-    PUMA7_GPIO_NUM5,
-    PUMA7_GPIO_NUM6,
-    PUMA7_GPIO_NUM7,
-    PUMA7_GPIO_NUM8,
-    PUMA7_GPIO_NUM9,
-    PUMA7_GPIO_NUM10,
-    PUMA7_GPIO_NUM11,
-    PUMA7_GPIO_NUM12,
-    PUMA7_GPIO_NUM13,
-    PUMA7_GPIO_NUM14,
-    PUMA7_GPIO_NUM15,
-    PUMA7_GPIO_RGMII_CONNECTOR_RESET,
-    PUMA7_GPIO_EXTSWITCH_POWER,
-    PUMA7_GPIO_ETH_PHY_RESET,
-    PUMA7_GPIO_EXTSWITCH_RESET,
-    PUMA7_GPIO_LED_POWER,
-    PUMA7_GPIO_LED_DS,
-    PUMA7_GPIO_LED_US,
-    PUMA7_GPIO_LED_ONLINE,
-    PUMA7_GPIO_LED_LINK,
-    PUMA7_GPIO_LED_LINE1,
-    PUMA7_GPIO_LED_LINE2,
-    PUMA7_GPIO_LED_DECT,
-    PUMA7_GPIO_LED_BATTERY,
-    PUMA7_GPIO_LED_MOCA,
-    PUMA7_GPIO_LED_WIFI2_4G,
-    PUMA7_GPIO_LED_WIFI5G,
-
-    PUMA7_MAX_GPIOS
-
-}GPIO_PIN_NUMBER_T;
-
-#endif /* GPIO_MRPC_API_H */
-
-
diff -Naur a/include/linux/avalanche/generic/modphy_mrpc_api.h b/include/linux/avalanche/generic/modphy_mrpc_api.h
--- a/include/linux/avalanche/generic/modphy_mrpc_api.h	2017-10-11 10:17:30.229480000 +0530
+++ b/include/linux/avalanche/generic/modphy_mrpc_api.h	2017-10-11 09:36:30.116186000 +0530
@@ -86,10 +86,6 @@
 #define MODPHY_NAME "modphy_drv"
 
 
-#define MODPHY_DEV_NAME  "/dev/modphy_drv"
-#define MODPHY_NAME "modphy_drv"
-
-
 typedef enum modphyController_e
 {
     MODPHY_MOCA_CLIENT_ID,
@@ -134,21 +130,6 @@
 #define MODPHY_LANE_POWER_STATE_TRANSITION      _IOW(MODPHY_DRIVER_ID, 11, ModphyClientPowerGate_t)
 
 
-#define MODPHY_DRIVER_DEV_NAME                  MODPHY_DEV_NAME
-#define MODPHY_DRIVER_ID                        (0xBE)
-#define MODPHY_INIT                             _IOW(MODPHY_DRIVER_ID, 1, ModphyController_e)
-#define MODPHY_CFG                              _IOW(MODPHY_DRIVER_ID, 2, ModphyClient_t)
-#define MODPHY_DISABLE_TX                       _IOW(MODPHY_DRIVER_ID, 3, ModphyClient_t)
-#define MODPHY_RESET_K_ALIGN                    _IOW(MODPHY_DRIVER_ID, 4, ModphyController_e)
-#define MODPHY_RESET_LANE                       _IOW(MODPHY_DRIVER_ID, 5, ModphyController_e)
-#define MODPHY_GO2_FAST_RECOVERY                _IOW(MODPHY_DRIVER_ID, 6, ModphyClient_t)
-#define MODPHY_GO2_FULL_FUNCTIONAL              _IOW(MODPHY_DRIVER_ID, 7, ModphyClient_t)
-#define MODPHY_COMMON_LANE_RESET                _IOW(MODPHY_DRIVER_ID, 8, ModphyController_e)
-#define MODPHY_COMMON_LANE_INIT                 _IOW(MODPHY_DRIVER_ID, 9, ModphyController_e)
-#define MODPHY_SET_KGREGS                       _IOW(MODPHY_DRIVER_ID, 10, modphyClientKgregs_t)
-#define MODPHY_LANE_POWER_STATE_TRANSITION      _IOW(MODPHY_DRIVER_ID, 11, ModphyClientPowerGate_t)
-
-
 /*********************************************************************************************************/
 /*! \fn int modphy_init(ModphyController_e modphyClientId)
  *********************************************************************************************************
diff -Naur a/include/linux/avalanche/generic/pal_cppi41.h b/include/linux/avalanche/generic/pal_cppi41.h
--- a/include/linux/avalanche/generic/pal_cppi41.h	2017-10-11 10:17:30.213476000 +0530
+++ b/include/linux/avalanche/generic/pal_cppi41.h	2017-10-11 09:36:30.097192000 +0530
@@ -215,8 +215,7 @@
  * underlying hardware) does not use the descriptor structre internally
  * for any of its operations.
  */
-typedef struct
-{
+typedef struct {
 	Uint32 descInfo;     /**< Desc type, proto specific word cnt, pkt len (valid only in Host PD)*/
 	Uint32 tagInfo;      /**< Source tag (31:16), Dest Tag (15:0) (valid only in Host PD)*/
 	Uint32 pktInfo;      /**< pkt err state, type, proto flags, return info, desc location */
@@ -226,39 +225,16 @@
 	Uint32 orgBuffLen;   /**< Original buffer size */
 	Uint32 orgBufPtr;    /**< Original buffer pointer */
 	Uint32 netInfoWord0; /**< Network stack private communications info (valid only in Host PD) */
-    Uint32 netInfoWord1; /**< Network stack private communications info (valid only in Host PD) */
-} Cppi4HostDesc;
-
-typedef struct
-{
-  Uint32 BufInfo;
-  Uint32 BufPtr;                // Pointer to the physical data buffer
-} Cppi4EmbdBuf;
+	Uint32 netInfoWord1; /**< Network stack private communications info (valid only in Host PD) */
 
-typedef struct {
-    Uint32 descInfo;     /**< Desc type, proto specific word cnt, pkt len (valid only in Host PD)*/
-    Uint32 tagInfo;      /**< Source tag (31:16), Dest Tag (15:0) (valid only in Host PD)*/
-    Uint32 pktInfo;      /**< pkt err state, type, proto flags, return info, desc location */
-    Cppi4EmbdBuf Buf;
-    Uint32 EPI[2];       /**< Extended Packet Information (from SR) */
-} Cppi4EmbdDescPp;
-
-typedef struct
-{
-    Uint32 descInfo;     /**< Desc type, proto specific word cnt, pkt len (valid only in Host PD)*/
-    Uint32 tagInfo;      /**< Source tag (31:16), Dest Tag (15:0) (valid only in Host PD)*/
-    Uint32 pktInfo;      /**< pkt err state, type, proto flags, return info, desc location */
-    Cppi4EmbdBuf Buf[1];
-    Uint32 EPI[2];       /**< Extended Packet Information (from SR) */
-    Uint32 PS[3];       /**< Extended Packet Information (from SR) */
-} Cppi4EmbdDesc_ps;
+} Cppi4HostDesc;
 
 typedef struct
 {
 	Cppi4HostDesc       hw;         /* The Hardware Descriptor */
 	int                 psi[5];     /* protocol specific information for fw  */
 	struct sk_buff*     skb;        /* The data pointer virtual address */
-} Cppi4HostDescLinux;
+}Cppi4HostDescLinux;
 
 #define PAL_CPPI4_HOSTDESC_DESC_TYPE_SHIFT      27
 #define PAL_CPPI4_HOSTDESC_DESC_TYPE_MASK       (0x1F << PAL_CPPI4_HOSTDESC_DESC_TYPE_SHIFT)
@@ -437,6 +413,7 @@
     Uint16  reserved;
 } Cppi4AccumulatorRateLimitCfg;
 
+
 /**
  *  \brief CPPI4 PAL Accumulator Channel object
  *
@@ -467,31 +444,26 @@
     DESC_TEARDOWN = 19
 } DESC_TYPE;
 
+typedef struct {
 
-/***************************************/
-/*  enum for endianness conversion    **/
-/**************************************/
-typedef enum
-{
-    endiannessBig,
-    endiannessLittle
-}endianness_e;
-
-#ifdef __KERNEL__
+  Uint32 BufInfo;
+  Uint32 BufPtr;                // Pointer to the physical data buffer
+} Cppi4EmbdBuf;
 
+typedef struct {
+    Uint32 descInfo;     /**< Desc type, proto specific word cnt, pkt len (valid only in Host PD)*/
+    Uint32 tagInfo;      /**< Source tag (31:16), Dest Tag (15:0) (valid only in Host PD)*/
+    Uint32 pktInfo;      /**< pkt err state, type, proto flags, return info, desc location */
+    Cppi4EmbdBuf Buf;
+    Uint32 EPI[2];       /**< Extended Packet Information (from SR) */
+} Cppi4EmbdDescPp;
 
+#ifdef __KERNEL__
 
-/* convert DDR physical address to DDR virtual address - use netip_mmio functions if pp is present */
-#ifdef CONFIG_TI_PACKET_PROCESSOR
+/* convert DDR physical address to DDR virtual address */
 #define PAL_CPPI4_PHYS_2_VIRT(addr)                        (netip_mmio_to_virtual(addr))  /* X86 implementation here */
 /* convert DDR virtual address to DDR physical address */
 #define PAL_CPPI4_VIRT_2_PHYS(addr)                        (netip_mmio_to_physical(addr))  /* X86 implementation here */
-#else
-/* convert DDR physical address to DDR virtual address */
-#define PAL_CPPI4_VIRT_2_PHYS(addr)     PAL_osMemVirt2Phy((Ptr)(addr))
-/* convert DDR virtual address to DDR physical address */
-#define PAL_CPPI4_PHYS_2_VIRT(addr)     PAL_osMemPhy2Virt((Uint32)(addr))
-#endif
 
 #ifdef CONFIG_NET_SUBSYSTEM_SNOOPED_MODE
 
@@ -572,7 +544,6 @@
  */
 Ptr PAL_cppi4BufPopBuf (PAL_Handle hnd, Cppi4BufPool pool);
 
-
 /**
  *  \brief PAL CPPI4.1 Queue Open
  *
@@ -586,12 +557,6 @@
  */
 PAL_Cppi4QueueHnd PAL_cppi4QueueOpen(PAL_Handle hnd, Cppi4Queue  queue);
 
-/*
- *  PAL_cppi4QueueOpenNoReset
- *  - Sanity tool compatibility
- */
-PAL_Cppi4QueueHnd PAL_cppi4QueueOpenNoReset (PAL_Handle hnd, Cppi4Queue  queue);
-
 /**
  * \brief CPPI4.1 Queue Close
  *  closes a specified Queue when the last time it is called.
@@ -649,7 +614,6 @@
  */
 int PAL_cppi4QueueGetEntryCount(PAL_Handle hnd, Cppi4Queue queue, unsigned int *entryCount);
 
-#ifdef CONFIG_MRPC_CPPI_CLIENT
 /**
  *  \brief Get buffer pool info for WiFi TX Zero Copy feature
  *
@@ -661,23 +625,9 @@
  *  @return PAL_SOK on success
  */
 PAL_Result PAL_cppi4GetBufferPoolInfo(PAL_Handle hnd, Cppi4BufPool pool, Cppi4BufPoolInfo* bp_info);
-
 /**
- *  \brief PAL CPPI4.1 Pop buffer and Increment reference count
- *
- *  Pop buffer from buffer pool and Increment reference count.
- *
- *  @param  hnd        [IN]      PAL handle returned from a previous PAL_cppi4Init() call.
- *
- *  @param  pool       [IN]      The buffer pool to which buffer belonged.
- *
- *  @return Buffer point, NULL is pool is empty
- */
 
-Ptr PAL_cppi4BufPopBuf (PAL_Handle hnd, Cppi4BufPool pool);
-#endif
 /**
-
  *  \brief Get buffer pool info for WiFi TX Zero Copy feature
  *
  *  @param  hnd           [IN]      Handle to the PAL Layer.
@@ -690,6 +640,12 @@
 PAL_Result PAL_cppi4GetBufferPoolInfo(PAL_Handle hnd, Cppi4BufPool pool, Cppi4BufPoolInfo* bp_info);
 /**
  *  \brief PAL CPPI 4.1 accumulator channel enable rate limit.
+ *
+ * Sets up an accumulator channel rate limit onfiguration
+ * 
+ *  @param  accCfg        [IN]      Pointer to the accumulator
+ *                        rate limit configuration structure.
+ *
  */
 void PAL_cppi4AccChEnRateLimit(Cppi4AccumulatorRateLimitCfg* accCfg);
 
@@ -731,21 +687,6 @@
 PAL_Cppi4AccChHnd PAL_cppi4AccChOpen(PAL_Handle hnd, Cppi4AccumulatorCfg* accCfg);
 
 /**
- *  \brief PAL CPPI 4.1 accumulator channel setup with physical
- *         listbase address.
- *
- * Sets up an accumulator channel to monitor a queue.
- *
- *  @param  hnd PAL handle
- *  @param  accCfg Pointer to the accumulator configuration
- *                  structure.
- *
- *  @return pointer to a valid handle (PAL_Cppi4AccChHnd) on
- *          success, NULL otherwise.
- */
-PAL_Cppi4AccChHnd PAL_cppi4AccChOpenAppCpu(PAL_Handle hnd, Cppi4AccumulatorCfg* accCfg);
-
-/**
  *  \brief PAL CPPI 4.1 accumulator channel teardown.
  *
  *  Stop an accumulator channel from monitoring a queue.
@@ -757,7 +698,6 @@
  */
 int PAL_cppi4AccChClose(PAL_Cppi4AccChHnd hnd, void *closeArgs);
 
-
 /**
  *  \brief PAL CPPI 4.1 get transmit channel accumulator page.
  *
diff -Naur a/include/linux/avalanche/puma7/ppsgc_db.h b/include/linux/avalanche/puma7/ppsgc_db.h
--- a/include/linux/avalanche/puma7/ppsgc_db.h	2017-10-11 10:17:30.256477000 +0530
+++ b/include/linux/avalanche/puma7/ppsgc_db.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,223 +0,0 @@
-/*
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2016 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
-  The full GNU General Public License is included in this distribution
-  in the file called LICENSE.GPL.
-
-  Contact Information:
-    Intel Corporation
-    2200 Mission College Blvd.
-    Santa Clara, CA  97052
-*/
-
-#ifndef _PPSGC_DB_H_
-#define _PPSGC_DB_H_
-
-#include "ppsgc_defs.h"
-
-/* Un-assigned group counter ID - Must be zero for default value */
-#define PPSGC_GROUP_COUNTER_UNASSIGNED      (0)
-
-/* Packet Processor can run on Atom CPU or on Arm CPU. PPSGC module runs on
- * same CPU where Packet Processor is. PPSGC clients always runs on Arm CPU */
-#if defined(CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL)
-/* The following macro is called by PPSGC clients when sending request.
- * When Packet Processor runs on Arm CPU no conversion is required */
-#define PPSGC_GROUP_COUNTER_HTON(_groupCounterId)   _groupCounterId
-#else
-/* When Packet Processor runs on Atom CPU Arm CPU must convert Group Counter
- * ID from host format to network format before sending it to PPSGC module */
-#define PPSGC_GROUP_COUNTER_HTON(_groupCounterId)   htons(_groupCounterId)
-#endif
-
-#ifdef CONFIG_ARM_AVALANCHE_SOC
-/* The following macro is called by PPSGC module when getting client request.
- * When PPSGC is on Arm no need to convert Counter ID from network format */
-#define PPSGC_GROUP_COUNTER_NTOH(_groupCounterId)   _groupCounterId
-#else
-/* When PPSGC is on Atom convert Group Counter ID from network format */
-#define PPSGC_GROUP_COUNTER_NTOH(_groupCounterId)   ntohs(_groupCounterId)
-#endif
-
-/*! \fn static inline int PPSGC_Db_AssignGroupCounterId(
- *          struct PpsgcAssignedGroupCounters *assignedGroupCounters,
- *          unsigned short groupCounterId)
- *  \brief Assign group counter ID to group counters IDs table if not all
- *         table assigned.
- *  \param[in/out] assignedGroupCounters - Pointer to assigned group counters
- *          structure to assign new group counter ID in. Not assigned entry
- *          must have the value PPSGC_GROUP_COUNTER_UNASSIGNED.
- *  \param[in] groupCounterId - Group counter ID to assign in table.
- *  \return OK or error status.
- */
-static inline int PPSGC_Db_AssignGroupCounterId(
-		struct PpsgcAssignedGroupCounters *assignedGroupCounters,
-		unsigned short                    groupCounterId)
-{
-	/* Validate group counter ID range */
-	if (groupCounterId >= PPSGC_NUM_OF_GROUP_COUNTERS)
-		return PPSGC_RC_FAILURE;
-
-	if (assignedGroupCounters->numAssignedGroupCounters >=
-		PPSGC_GROUP_COUNTERS_PER_SESSION) {
-		/* Assigned group counter IDs table is full */
-		return PPSGC_RC_FAILURE;
-	}
-
-	/* Assign new counter ID and update assigned group counters number */
-	assignedGroupCounters->groupCounterIds[assignedGroupCounters->
-		numAssignedGroupCounters] = groupCounterId;
-	assignedGroupCounters->numAssignedGroupCounters++;
-	return PPSGC_RC_SUCCESS;
-}
-
-/*! \fn int PPSGC_Db_Init(void)
- *  \brief Packet Processor Session Group Counters data base initialization.
- *  \param[in] no input.
- *  \param[out] no output.
- *  \return OK or error status.
- */
-int PPSGC_Db_Init(void);
-
-/*! \fn int PPSGC_Db_AllocGroupCounterId(unsigned short *groupCounterId)
- *  \brief Allocate Group Counter ID.
- *  \param[in/out] groupCounterId - Pointer to group counter ID value.
- *  \return OK or error status.
- */
-int PPSGC_Db_AllocGroupCounterId(unsigned short *groupCounterId);
-
-/*! \fn int PPSGC_Db_ReleaseGroupCounterId(unsigned short groupCounterId)
- *  \brief Release Group Counter ID.
- *  \param[in] groupCounterId - Group Counter ID to release.
- *  \param[out] no output.
- *  \return OK or error status.
- */
-int PPSGC_Db_ReleaseGroupCounterId(unsigned short groupCounterId);
-
-/*! \fn int PPSGC_Db_DeleteGroupCounterSessions(unsigned short groupCounterId)
- *  \brief Send request to PP to delete sessions list of Group Counter ID.
- *  \param[in] groupCounterId - Group Counter ID to delete sessions.
- *  \param[out] no output.
- *  \return OK or error status.
- */
-int PPSGC_Db_DeleteGroupCounterSessions(unsigned short groupCounterId);
-
-/*! \fn int PPSGC_Db_GetGroupCounterAmount
- *                      (struct PpsgcGroupCounters *totalPpCounters)
- *  \brief Retreives the total counters amount of all session in specified
- *         Group Counter.
- *  \param[in,out] totalPpCounters - Total Group Counter counters amount.
- *  \return OK or error status.
- */
-int PPSGC_Db_GetGroupCounterAmount(struct PpsgcGroupCounters *totalPpCounters);
-
-/*! \fn int PPSGC_Db_GetGroupSessionsInfo(unsigned int tableSize,
- *              struct PpsgcGroupSessionsInfo *groupSessionsInfoTable)
- *  \brief Retreives sessions information of sessions in specified
- *         Group Counter table.
- *  \param[in] tableSize - Group sessions info table size.
- *  \param[in,out] groupSessionsInfoTable - Group sessions info table.
- *  \return OK or error status.
- */
-int PPSGC_Db_GetGroupSessionsInfo(unsigned int tableSize,
-		struct PpsgcGroupSessionsInfo *groupSessionsInfoTable);
-
-/*! \fn int PPSGC_Db_CreateSession
- *              (unsigned int sessionHandle, unsigned char sessionType,
- *               unsigned char multicast,    unsigned int ingressPortId,
- *               struct PpsgcAssignedGroupCounters *assignedGroupCounters)
- *  \brief Handle session creation indication from Packet Processor.
- *   Assign session to all Group Counters in assigned Group Counters table.
- *  \param[in] sessionHandle - PP session handle number.
- *  \param[in] sessionType - PP session type.
- *  \param[in] multicast - Is session multicast or unicast.
- *  \param[in] ingressPortId - input device interface index.
- *  \param[in] assignedGroupCounters - Pointer to assigned group counters
- *              IDs structure.
- *  \param[out] no output.
- *  \return OK or error status.
- */
-int PPSGC_Db_CreateSession
-	(unsigned int sessionHandle, unsigned char sessionType,
-	 unsigned char multicast,    unsigned int ingressPortId,
-	 struct PpsgcAssignedGroupCounters *assignedGroupCounters);
-
-/*! \fn int PPSGC_Db_DeleteSession
- *          (unsigned int sessionHandle, unsigned int sessionPacketsFw)
- *  \brief Handle session deletion indication from Packet Processor.
- *   Add session counter to Group Counter dead sessions counter.
- *  \param[in] sessionHandle - PP session handle number.
- *  \param[in] sessionPacketsFw - PP session forwarded packets number.
- *  \param[in] sessionOctetsFw - PP session forwarded bytes number.
- *  \param[out] no output.
- *  \return OK or error status.
- */
-int PPSGC_Db_DeleteSession
-	(unsigned int sessionHandle, unsigned int sessionPacketsFw,
-	 unsigned long long sessionOctetsFw);
-
-/*! \fn int PPSGC_Db_GetIfCounters
- *                      (struct PpsgcIfCounters *ppsgcIfCounters)
- *  \brief Get packet processor interface device counters according to
- *         interface name.
- *  \param[in,out] ppsgcIfCounters - Packet processor interface device
- *      counters structure.
- *  \return OK or error status.
- */
-int PPSGC_Db_GetIfCounters(struct PpsgcIfCounters *ppsgcIfCounters);
-
-/*! \fn int PPSGC_Db_GetSfCounters(struct PpsgcSfCounters *ppsgcSfCounters)
- *  \brief Get PP service flow counters according to interface name.
- *  \param[in,out] ppsgcSfCounters - PP service flow counters structure.
- *  \return OK or error status.
- */
-int PPSGC_Db_GetSfCounters(struct PpsgcSfCounters *ppsgcSfCounters);
-
-/*! \fn int PPSGC_Db_GetTpPortCounters
- *                      (struct PpsgcTpPortCounters* ppsgcTpPortCounters)
- *  \brief Get PP transparent port counters according to interface name.
- *  \param[in,out] ppsgcTpPortCounters-PP transparent port counters structure.
- *  \return OK or error status.
- */
-int PPSGC_Db_GetTpPortCounters
-	(struct PpsgcTpPortCounters *ppsgcTpPortCounters);
-
-/*! \fn int PPSGC_Db_PrintIfCounters(void)
- *  \brief Print packet processor interface device counters.
- *  \param[in] no input.
- *  \param[out] no output.
- *  \return OK or error status.
- */
-int PPSGC_Db_PrintIfCounters(void);
-
-/*! \fn int PPSGC_Db_PrintTpPortCounters(void)
- *  \brief Print acket processor transparent port counters.
- *  \param[in] no input.
- *  \param[out] no output.
- *  \return OK or error status.
- */
-int PPSGC_Db_PrintTpPortCounters(void);
-
-/*! \fn int PPSGC_Db_PrintGroupCounters(void)
- *  \brief Print allocated group counters statistics.
- *  \param[in] no input.
- *  \param[out] no output.
- *  \return OK or error status.
- */
-int PPSGC_Db_PrintGroupCounters(void);
-#endif /* _PPSGC_DB_H_ */
-
diff -Naur a/include/linux/avalanche/puma7/ppsgc_defs.h b/include/linux/avalanche/puma7/ppsgc_defs.h
--- a/include/linux/avalanche/puma7/ppsgc_defs.h	2017-10-11 10:17:30.244475000 +0530
+++ b/include/linux/avalanche/puma7/ppsgc_defs.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,104 +0,0 @@
-/*
-  GPL LICENSE SUMMARY
-
-  Copyright(c) 2016 Intel Corporation.
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of version 2 of the GNU General Public License as
-  published by the Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-  General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
-  The full GNU General Public License is included in this distribution
-  in the file called LICENSE.GPL.
-
-  Contact Information:
-    Intel Corporation
-    2200 Mission College Blvd.
-    Santa Clara, CA  97052
-*/
-
-#ifndef _PPSGC_DEFS_H_
-#define _PPSGC_DEFS_H_
-
-#ifdef CONFIG_ARM_AVALANCHE_SOC
-#include <asm-arm/arch-avalanche/generic/avalanche_pp_api.h>
-#else
-#include <linux/avalanche/generic/avalanche_pp_api.h>
-#endif
-
-#define PPSGC_NUM_OF_GROUP_COUNTERS         (512)
-#define PPSGC_IF_MANE_MAX_LENGTH            (16)
-#define PPSGC_GROUP_COUNTERS_PER_SESSION    (8)
-#define PPSGC_RC_FAILURE                    (-1)
-#define PPSGC_RC_SUCCESS                    (0)
-#define PPSGC_MAX_JIFFIES_VALUE             ULLONG_MAX
-
-/*! \var struct PpsgcAssignedGroupCounters
-    \brief Structure defines the assigned session group counter IDs.
-*/
-struct PpsgcAssignedGroupCounters {
-	unsigned char       numAssignedGroupCounters;
-	unsigned short      groupCounterIds[PPSGC_GROUP_COUNTERS_PER_SESSION];
-};
-
-/*! \var struct PpsgcPpCounters
-    \brief Structure defines packet processor session counters.
-*/
-struct PpsgcPpCounters {
-	unsigned long long      totalBytesFwd;
-	unsigned long long      totalPktsFwd;
-	unsigned long long      multicastPktsFwd;
-	unsigned long long      unicastPktsFwd;
-};
-
-/*! \var struct PpsgcGroupCounters
-    \brief Structure defines packet processor sessions group counters amount.
-*/
-struct PpsgcGroupCounters {
-	unsigned short          groupCounterId;
-	struct PpsgcPpCounters  ppCounters;
-};
-
-struct PpsgcGroupSessionsInfo {
-	unsigned short          groupCounterId;
-	unsigned short          sessionsNumber;
-	unsigned long long      lastSessionDelJiffies;
-};
-
-/*! \var struct PpsgcIfCounters
-    \brief Structure defines the format of PP counters per interface device.
-*/
-struct PpsgcIfCounters {
-	char                        ifName[PPSGC_IF_MANE_MAX_LENGTH];
-	AVALANCHE_PP_VPID_STATS_t   ifCounters;
-	unsigned char               includeQosDrops;
-	unsigned char               AlignTo64Bit[7];
-};
-
-/*! \var struct PpsgcSfCounters
-    \brief Structure defines the format of PP counters per service flow.
-*/
-struct PpsgcSfCounters {
-	unsigned char                   ifName[PPSGC_IF_MANE_MAX_LENGTH];
-	AVALANCHE_PP_QOS_QUEUE_STATS_t  sfCounters;
-	unsigned int                    sfIndex;
-	unsigned int                    clearFlag;
-};
-
-/*! \var struct PpsgcTpPortCounters
-    \brief Structure defines the format of PP counters per transparent port.
-*/
-struct PpsgcTpPortCounters {
-	unsigned char               ifName[PPSGC_IF_MANE_MAX_LENGTH];
-	AVALANCHE_PP_VPID_STATS_t   tpCounters;
-};
-
-#endif /* _PPSGC_DEFS_H_ */
-
diff -Naur a/include/linux/avalanche/puma7/puma7.h b/include/linux/avalanche/puma7/puma7.h
--- a/include/linux/avalanche/puma7/puma7.h	2017-10-11 10:17:30.246478000 +0530
+++ b/include/linux/avalanche/puma7/puma7.h	2017-10-11 09:36:30.133192000 +0530
@@ -75,7 +75,7 @@
 #define IO_ADDRESS(addr) ((unsigned long)netip_mmio_to_virtual(addr))
 #define IO_PHY2VIRT(addr)              (netip_mmio_to_virtual((unsigned long)addr))   /* X86 implementation here */
 /* convert hardware virtual address to hardware physical address */
-#define IO_VIRT2PHY(addr)             (netip_mmio_to_physical(addr))  /* X86 implementation here */
+#define IO_VIRT2PHY(addr)              (netip_mmio_to_physical(addr))  /* X86 implementation here */
 
 #define AVALANCHE_GBE0_ADDR                         ((0xF0300000))
 #define AVALANCHE_GBE1_ADDR                         ((0xF0304000))
@@ -83,9 +83,7 @@
 #define AVALANCHE_GBE3_ADDR                         ((0xF030C000))
 #define AVALANCHE_GBE4_ADDR                         ((0xF0310000))
 #define AVALANCHE_GBE5_ADDR                         ((0xF0314000))
-#define ATOM_INTC_BASE 				                ((0xF00E0000))
-#define AVALANCHE_MOCA_ADDR                         ((0xFF800000))
-#define ATOM_INTC_BASE 								((0xF00E0000))
+#define ATOM_INTC_BASE 				    ((0xF00E0000))
 
 #define AVALANCHE_PFI_REGS                          (IO_ADDRESS(0xF0210000))
 #define AVALANCHE_PFI_WIN_REGS                      (IO_ADDRESS(0xF0210400))
@@ -100,8 +98,6 @@
 #define AVALANCHE_GBE_INT_CTRL_1                    (IO_ADDRESS(0xF031A400))
 #define AVALANCHE_PHY_SLAVE                         (IO_ADDRESS(0xF0500000))
 
-#define AVALANCHE_MOCA                              (IO_ADDRESS(AVALANCHE_MOCA_ADDR))
-
 #define AVALANCHE_CRU_BASE                          (IO_ADDRESS(0xF00D0000))
 /**
  * Interrupts Distributor 0 (INTD0) base address, has 32 ip
diff -Naur a/include/linux/avalanche/puma7/puma7_cppi.h b/include/linux/avalanche/puma7/puma7_cppi.h
--- a/include/linux/avalanche/puma7/puma7_cppi.h	2017-10-11 10:17:30.254481000 +0530
+++ b/include/linux/avalanche/puma7/puma7_cppi.h	2017-10-11 09:36:30.145198000 +0530
@@ -11,7 +11,7 @@
 
   GPL LICENSE SUMMARY
 
-  Copyright(c) 2017 Intel Corporation.
+  Copyright(c) 2014 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of version 2 of the GNU General Public License as
diff -Naur a/include/linux/avalanche/puma7/puma7_cppi_prv.h b/include/linux/avalanche/puma7/puma7_cppi_prv.h
--- a/include/linux/avalanche/puma7/puma7_cppi_prv.h	2017-10-11 10:17:30.238474000 +0530
+++ b/include/linux/avalanche/puma7/puma7_cppi_prv.h	2017-10-11 09:36:30.125185000 +0530
@@ -208,6 +208,7 @@
 #define PAL_CPPI_PP_QMGR_QUEUES_PHY_ADDR(qMgr, qNum)                            \
     ((qNum << 4) + 0xF9220000)
 
+
 /*
 +-+-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+-+
 |D|S|G| |Q|u|e|u|e| |M|a|n|a|g|e|r|s|
@@ -525,7 +526,7 @@
 #define PAL_CPPI_PP_SHARED_LOW_INFRA_HOST_FD_DESC_COUNT                                     512
 #endif
 
-#define PAL_CPPI_PP_DOCSIS_LOW_INFRA_HOST_FD_DESC_COUNT                                     256
+#define PAL_CPPI_PP_DOCSIS_LOW_INFRA_HOST_FD_DESC_COUNT                                     128
 #define PAL_CPPI_PP_DOCSIS_HI_INFRA_HOST_FD_DESC_COUNT                                      64
 #define PAL_CPPI_PP_DOCSIS_RX_MGMT_HOST_FD_DESC_COUNT                                       64
 #define PAL_CPPI_PP_DOCSIS_TX_MGMT_HOST_FD_DESC_COUNT                                       64
@@ -667,9 +668,9 @@
 #define PAL_CPPI_PP_NP2APP_HOST_FD_DESC_COUNT                                               256
 #define PAL_CPPI_PP_NP2APP_INFRA_PPINFO_HOST_FD_DESC_COUNT                                  128
 #define PAL_CPPI_PP_NP2APP_INFRA_DATA_HOST_FD_DESC_COUNT                                    128
-#define PAL_CPPI_PP_APP2NP_HOST_FD_DESC_COUNT                                               512
-#define PAL_CPPI_PP_APP2NP_INFRA_PPINFO_HOST_FD_DESC_COUNT                                  256
-#define PAL_CPPI_PP_APP2NP_INFRA_DATA_HOST_FD_DESC_COUNT                                    256
+#define PAL_CPPI_PP_APP2NP_HOST_FD_DESC_COUNT                                               256
+#define PAL_CPPI_PP_APP2NP_INFRA_PPINFO_HOST_FD_DESC_COUNT                                  128
+#define PAL_CPPI_PP_APP2NP_INFRA_DATA_HOST_FD_DESC_COUNT                                    128
 #define PAL_CPPI_PP_APP2NP_INFRA_HIGH_PPINFO_HOST_FD_DESC_COUNT                             64
 #define PAL_CPPI_PP_APP2NP_INFRA_HIGH_DATA_HOST_FD_DESC_COUNT                               64
 #define PAL_CPPI_PP_NP2APP_INFRA_HIGH_PPINFO_HOST_FD_DESC_COUNT                             64
@@ -1683,7 +1684,6 @@
 }PAL_CPPI_PP_ACCUMULATOR_INTERRUPT_VECTORS_e;
 
 #define PAL_CPPI41_GBE_ACC_INTV_NUM(devInstance, pri)       (PAL_CPPI_PP_SGMII0_LOW_RX_INTD0_ACC_INTV_NUM + ((devInstance)*2) + (pri))
-#define ARM_TX_COMPLETE_MAP_INTD1_VEC_TO_ACC_INT(irq)  (irq + PAL_CPPI_PP_ACCUMULATOR_INTD0_MAX_INTERRUPT_VECTORS)
 
 typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD1_INTERRUPT_VECTORS
 {
@@ -1946,6 +1946,7 @@
 #define WIFI_DEVICE_TO_WIFI_TX_FW_INFRA_11_TX_CH(dev_id)                        \
     ((dev_id) + PAL_CPPI_PP_DMA11_WIFI_DEVICE0_TX_FW_INFRA_TX_CH)
 
+
 /* convert wifi device id to tx fw infra dma tx channel input queue */
 #define WIFI_DEVICE_TO_WIFI_TX_FW_INFRA_TX_CH_INPUT_Q(dev_id)                   \
     (((dev_id)*2) + PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_WIFI_DEVICE0_HOST_TX_HI_Q_NUM)
@@ -1961,6 +1962,7 @@
 #define WIFI_TX_BUFFER_POOL_NUM_TO_BPQ_ADDR(poolNum)                            \
     PAL_CPPI_PP_QMGR_QUEUES_PHY_ADDR(1, WIFI_TX_BUFFER_POOL_NUM_TO_QUEUE_NUM(poolNum))
 
+
 /* VOICE */
 #define PAL_CPPI_PP_VOICE_DSP_C55_EMB_BD_COUNT                                  (256)
 #define PAL_CPPI41_VOICE_DSP_C55_EMB_BD_SIZE                                    (PAL_CPPI_PP_QMGR_GLOBAL_DEFAULT_DESC_SIZE)
diff -Naur a/include/linux/avalanche/puma7/puma7_npcpu_appcpu_defs.h b/include/linux/avalanche/puma7/puma7_npcpu_appcpu_defs.h
--- a/include/linux/avalanche/puma7/puma7_npcpu_appcpu_defs.h	2017-10-11 10:17:30.265475000 +0530
+++ b/include/linux/avalanche/puma7/puma7_npcpu_appcpu_defs.h	2017-10-11 09:36:30.156188000 +0530
@@ -9,7 +9,7 @@
 
   GPL LICENSE SUMMARY
 
-  Copyright(c) 2015-2017 Intel Corporation.
+  Copyright(c) 2015-2016 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify 
   it under the terms of version 2 of the GNU General Public License as
@@ -87,8 +87,6 @@
     NPCPU_APPCPU_HW_MBOX_TAG_DATAPIPE_MBX,
     NPCPU_APPCPU_HW_MBOX_TAG_WIFI_MBX,
     NPCPU_APPCPU_HW_MBOX_TAG_DPI_MBX,
-    NPCPU_APPCPU_HW_MBOX_TAG_EXTSWITCH,
-    NPCPU_APPCPU_HW_MBOX_TAG_PUMA_STARTUP,
     NPCPU_APPCPU_HW_LAST_ENTRY
 } npcpu_appcpu_hw_mbox_tags_e;
 
diff -Naur a/include/linux/avalanche/puma7/puma7_pp.h b/include/linux/avalanche/puma7/puma7_pp.h
--- a/include/linux/avalanche/puma7/puma7_pp.h	2017-10-11 10:17:30.263476000 +0530
+++ b/include/linux/avalanche/puma7/puma7_pp.h	2017-10-11 09:36:30.154188000 +0530
@@ -205,7 +205,7 @@
     WIFI_DEVS_CNT
 } wifi_dev_id_e;
 
-#if (defined(CONFIG_WIFI_PROXY) || defined(PPA_PUMA7))
+#if defined(CONFIG_WIFI_PROXY) || defined(CONFIG_PUMA_LITEPATH)
 #define WIFI_DEVICE_ID_VALID(dev_id)                    (WIFI_DEV_ID_0 <= (dev_id) && (dev_id) < WIFI_DEVS_CNT)
 #define FOR_EACH_WIFI_DEVICE_ID(i)                      for (i = WIFI_DEV_ID_0; i < WIFI_DEVS_CNT; i++)
 #define WIFI_DEVICE_TO_PID(dev_id)                      ((dev_id) + PP_WiFi_PORT0_PID_NUM)
@@ -411,9 +411,6 @@
 #define AVALANCHE_PP_RANDOMIZER_AQM_BASE                (IO_ADDRESS(0xF3C04100))
 #define AVALANCHE_PP_RANDOMIZER_QOS_BASE                (IO_ADDRESS(0xF3E08300))
 
-#define AVALANCHE_PP_RANDOMIZER_AQM_BASE                (IO_ADDRESS(0xF3C04100))
-#define AVALANCHE_PP_RANDOMIZER_QOS_BASE                (IO_ADDRESS(0xF3E08300))
-
 /* MAILBOX */
 #define AVALANCHE_PP_MAILBOX_CLK_CTRL_REG_STAGE1        (IO_ADDRESS(0xF3C20108))
 
@@ -620,11 +617,6 @@
 #define RANDOMIZER_QOS_SEED(seed)                      {(*(volatile unsigned int *)AVALANCHE_PP_RANDOMIZER_QOS_BASE) = cpu_to_be32(seed);}
 
 
-/* Randomizer seeding */
-#define RANDOMIZER_AQM_SEED(seed)                      {(*(volatile unsigned int *)AVALANCHE_PP_RANDOMIZER_AQM_BASE) = cpu_to_be32(seed);}
-#define RANDOMIZER_QOS_SEED(seed)                      {(*(volatile unsigned int *)AVALANCHE_PP_RANDOMIZER_QOS_BASE) = cpu_to_be32(seed);}
-
-
 /* PP MTU size */
 #define UPDATE_MTU_TABLE_IN_PDSP_DMEM(vpidId, mtuSize)        \
     AVALANCHE_PP_MODIFIER_MTU_TABLE_UPDATE(vpidId, mtuSize);  \
diff -Naur a/include/linux/handshake_server.h b/include/linux/handshake_server.h
--- a/include/linux/handshake_server.h	2017-10-11 10:17:29.068382000 +0530
+++ b/include/linux/handshake_server.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,80 +0,0 @@
-/*
- *
- * handshake_server.h
- * Description:
- * handshake over MRPC
- *
- *
- * GPL LICENSE SUMMARY
- *
- *  Copyright(c) 2016 Intel Corporation.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of version 2 of the GNU General Public License as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *  The full GNU General Public License is included in this distribution
- *  in the file called LICENSE.GPL.
- *
- *  Contact Information:
- *  Intel Corporation
- *  2200 Mission College Blvd.
- *  Santa Clara, CA  97052
- */
-
-#ifndef __HANDSHAKE_SERVER_H__
-#define __HANDSHAKE_SERVER_H__
-
-/*Mask value to define all required sync points*/
-#ifdef CONFIG_ARM_AVALANCHE_SOC
-
-/*enum to hold processes ID to be synced*/
-enum {
-    HANDSHAKE_ID_CPPI = 0,
-    HANDSHAKE_ID_CPPI_POST,
-    HANDSHAKE_ID_CPPI_HW_MBOX,
-    HANDSHAKE_ID_MODPHY,
-    HANDSHAKE_ID_LAST,
-};
-#define SYNC_POINTS (1 << HANDSHAKE_ID_CPPI) | (1 << HANDSHAKE_ID_CPPI_POST) | (1 << HANDSHAKE_ID_CPPI_HW_MBOX) | (1 << HANDSHAKE_ID_MODPHY)
-
-#else /* Atom Handshake Server */
-
-/*enum to hold processes ID to be synced*/
-enum {
-    HANDSHAKE_ID_PP_INIT = 0,
-    HANDSHAKE_ID_LAST,
-};
-
-#define SYNC_POINTS (1 << HANDSHAKE_ID_PP_INIT)
-
-#endif
-
-/************************************************/
-/**                 API                         */
-/************************************************/
-
-/**
- * boot_status_report
- * Function to update current boot status, called by client
- * to report sync point reached
- *
- * @param int client_id - the reporting client ID
- *
- * @return -
- *      (-1) - Wrong ID reported
- *      0 - Otherwise
- */
-
-int boot_status_report(int client_id);
-
-#endif /* __HW_MRPC_H__ */
diff -Naur a/include/linux/hw_mbox_defs.h b/include/linux/hw_mbox_defs.h
--- a/include/linux/hw_mbox_defs.h	2017-10-11 10:17:26.935205000 +0530
+++ b/include/linux/hw_mbox_defs.h	2017-10-11 09:36:26.857923000 +0530
@@ -865,8 +865,13 @@
 |                                           |
 ********************************************/
 
+#if (defined CONFIG_TI_KERNEL_GW_APPCPU) || (defined CONFIG_INTEL_KERNEL_PP_DRIVER_ON_ATOM)
 #define HW_MBOX_NP_APP_SRAM_SIZE 256
 #define HW_MBOX_APP_NP_SRAM_SIZE 256
+#else
+#define HW_MBOX_NP_APP_SRAM_SIZE 64
+#define HW_MBOX_APP_NP_SRAM_SIZE 128
+#endif
 
 /*! \def HW_MBOX_STATIC_CHANNEL_TABLE
     \brief X-MACRO hardcoded table for STATIC Channel declarations.
@@ -881,11 +886,11 @@
 /*       |  CID  | Commander                           | Subject                             | HW_MBOX Channel Type     | SRAM size                 | */ \
 /*       |       | [hw_mbox_Masters_e]                 | [hw_mbox_Masters_e]                 | [hw_mbox_channel_type_e] | [Bytes]                   | */ \
 /*       +------------------------------------------------------------------------------------------------------------------------------------------+ */ \
-    ENTRY(    0  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_command          , 32                         )    \
+    ENTRY(    0  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_command          , 0                         )    \
     ENTRY(    1  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_PHY_CPU              , hw_mbox_command          , 32                        )    \
     ENTRY(    2  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_MOCA_C               , hw_mbox_opcode           , 8                         )    \
     ENTRY(    3  , HW_MBOX_MASTER_BBU_C                , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8                         )    \
-    ENTRY(    4  , HW_MBOX_MASTER_PHY_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 656                       )    \
+    ENTRY(    4  , HW_MBOX_MASTER_PHY_CPU              , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 608                       )    \
     ENTRY(    5  , HW_MBOX_MASTER_MOCA_C               , HW_MBOX_MASTER_NP_CPU               , hw_mbox_event            , 8                         )    \
     ENTRY(    6  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_BBU_C                , hw_mbox_opcode           , 8                         )    \
     ENTRY(    7  , HW_MBOX_MASTER_NP_CPU               , HW_MBOX_MASTER_APP_CPU              , hw_mbox_opcode           , HW_MBOX_NP_APP_SRAM_SIZE  )    \
diff -Naur a/include/linux/mrpc.h b/include/linux/mrpc.h
--- a/include/linux/mrpc.h	2017-10-11 10:17:28.021299000 +0530
+++ b/include/linux/mrpc.h	2017-10-11 09:36:27.840004000 +0530
@@ -81,11 +81,6 @@
     MRPC_RESERVED_ID_CONNTRACK,
     MRPC_RESERVED_ID_HILCMDS,
     MRPC_RESERVED_ID_CPPI,
-    MRPC_RESERVED_ID_WIFI_PROXY_FUNC_CALL,
-    MRPC_RESERVED_ID_DOCSIS_NETDEV,
-	MRPC_RESERVED_ID_SGC,
-    MRPC_RESERVED_ID_HILEVENTS,
-    MRPC_RESERVED_ID_GPIO,
     MRPC_RESERVED_ID_LAST,
 };
 
diff -Naur a/include/linux/netdevice.h b/include/linux/netdevice.h
--- a/include/linux/netdevice.h	2017-10-11 10:17:27.276237000 +0530
+++ b/include/linux/netdevice.h	2017-10-11 09:36:27.149943000 +0530
@@ -1436,6 +1436,7 @@
 #if IS_ENABLED(CONFIG_NETPRIO_CGROUP)
 	struct netprio_map __rcu *priomap;
 #endif
+
 #ifdef CONFIG_TI_DEVICE_PROTOCOL_HANDLING
     int (*packet_handler)(struct sk_buff *skb);
 #endif
@@ -1502,14 +1503,6 @@
     int (*qos_select_hook)  (struct sk_buff    *skb);
     void (*qos_get_params_hook)  (struct net_device *dev, Uint16 *egressQ, Uint32 *rate, Uint32 *shaper);
     int devInstance;
-#else
-#ifdef CONFIG_PPA_PUMA7
-    /* pid handle for network device */
-    unsigned int pid_handle;
-
-    /* virtual pid handle for network device */
-    unsigned int vpid_handle;
-#endif /* CONFIG_PPA_PUMA7 */
 #endif
 	/* phy device may attach itself for hardware timestamping */
 	struct phy_device *phydev;
@@ -1519,7 +1512,7 @@
 	/* group the device belongs to */
 	int group;
 
-    struct pm_qos_request   pm_qos_req;
+	struct pm_qos_request	pm_qos_req;
 };
 #define to_net_dev(d) container_of(d, struct net_device, dev)
 
diff -Naur a/include/linux/netfilter_ipv6.h b/include/linux/netfilter_ipv6.h
--- a/include/linux/netfilter_ipv6.h	2017-10-11 10:17:30.120465000 +0530
+++ b/include/linux/netfilter_ipv6.h	2017-10-11 09:36:29.955171000 +0530
@@ -25,7 +25,6 @@
 struct nf_ipv6_ops {
 	int (*chk_addr)(struct net *net, const struct in6_addr *addr,
 			const struct net_device *dev, int strict);
-	int (*fragment)(struct sk_buff *skb, int (*output)(struct sk_buff *));
 };
 
 extern const struct nf_ipv6_ops __rcu *nf_ipv6_ops;
diff -Naur a/include/linux/netip_mem_util.h b/include/linux/netip_mem_util.h
--- a/include/linux/netip_mem_util.h	2017-10-11 10:17:30.036469000 +0530
+++ b/include/linux/netip_mem_util.h	2017-10-11 09:36:29.834164000 +0530
@@ -29,8 +29,6 @@
 
 int netip_memmap_init(void);
 void netip_memmap_cleanup(void);
-void netip_memmap_cleanup_bPools(void);
-int netip_memmap_cppi_bPool(unsigned int pool);
 void *netip_mmio_to_virtual(unsigned long phys_addr);
 void *netip_mmio_to_physical(void* virt_addr);
 void cache_flush_buffer(void *bufptr, int size);
diff -Naur a/include/linux/netip_subsystem.h b/include/linux/netip_subsystem.h
--- a/include/linux/netip_subsystem.h	2017-10-11 10:17:26.867200000 +0530
+++ b/include/linux/netip_subsystem.h	2017-10-11 09:36:26.781928000 +0530
@@ -105,8 +105,6 @@
 #define NETSS_DEV_BBU_CTRLR_MMIO_SIZE   (0x20000)  /*128 KB */
 #define NETSS_DEV_PERIPHERAL_SRAM_MMIO_OFFSET (0xFFF0000)
 #define NETSS_DEV_PERIPHERAL_SRAM_MMIO_SIZE   (0x4000)
-#define NETSS_DEV_PWM_MMIO_OFFSET (0x165000)
-#define NETSS_DEV_PWM_MMIO_SIZE   (0x10)
 
 #define NETSS_INTERUPT_ARM11_MAX (96)  /*ARM11 is a bundle of 96 interrupts */
 
@@ -139,7 +137,6 @@
    NETSS_DEV_TDM2,
    NETSS_DEV_VCODEC,
    NETSS_DEV_BOOT_RAM,
-   NETSS_DEV_PWM,
    NETSS_DEV_MAX
 }netss_dev_t;
 
@@ -193,12 +190,10 @@
    NETSS_SERVICE_ID_BBU,
    NETSS_SERVICE_ID_WIFI,
    NETSS_SERVICE_ID_EXSW,
-   NETSS_SERVICE_ID_SFP,
-   NETSS_SERVICE_ID_SGMII1_BARE,
-   NETSS_SERVICE_ID_ETHPHY,
-   NETSS_SERVICE_ID_RGMII3_BARE,
-   NETSS_SERVICE_ID_SGMII0_BARE,
-   NETSS_SERVICE_ID_RGMII2_BARE,
+   NETSS_SERVICE_ID_SGMII0,
+   NETSS_SERVICE_ID_SGMII1,
+   NETSS_SERVICE_ID_RGMII2,
+   NETSS_SERVICE_ID_RGMII3,
    NETSS_SERVICE_ID_MAX
 } netss_service_id_t;
 
diff -Naur a/include/linux/netlink.h b/include/linux/netlink.h
--- a/include/linux/netlink.h	2017-10-11 10:17:30.173469000 +0530
+++ b/include/linux/netlink.h	2017-10-11 09:36:30.034197000 +0530
@@ -68,8 +68,7 @@
 extern int netlink_has_listeners(struct sock *sk, unsigned int group);
 extern struct sk_buff *netlink_alloc_skb(struct sock *ssk, unsigned int size,
 					 u32 dst_portid, gfp_t gfp_mask);
-extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 portid,
-					int nonblock, gfp_t allocation);
+extern int netlink_unicast(struct sock *ssk, struct sk_buff *skb, __u32 portid, int nonblock);
 extern int netlink_broadcast(struct sock *ssk, struct sk_buff *skb, __u32 portid,
 			     __u32 group, gfp_t allocation);
 extern int netlink_broadcast_filtered(struct sock *ssk, struct sk_buff *skb,
diff -Naur a/include/linux/skbuff.h b/include/linux/skbuff.h
--- a/include/linux/skbuff.h	2017-10-11 10:17:29.444409000 +0530
+++ b/include/linux/skbuff.h	2017-10-11 09:36:29.228114000 +0530
@@ -43,6 +43,7 @@
 #ifndef CONFIG_ARM_AVALANCHE_SOC
 #include <linux/avalanche/puma7/puma7_defs.h>
 #endif
+
 #ifdef CONFIG_NETWORK_EXTMARK
 #include <linux/extmark.h>
 #endif
@@ -143,11 +144,12 @@
 
 #ifdef CONFIG_BRIDGE_NETFILTER
 struct nf_bridge_info {
-	atomic_t		use;
-	unsigned int		mask;
-	struct net_device	*physindev;
-	struct net_device	*physoutdev;
-	unsigned long		data[32 / sizeof(unsigned long)];
+    atomic_t        use;
+    unsigned int        mask;
+    struct net_device   *physindev;
+    struct net_device   *physoutdev;
+    struct net_bridge_port *forward_port;
+    unsigned long       data[32 / sizeof(unsigned long)];
 };
 #endif
 
@@ -274,11 +276,11 @@
         #include <linux/ti_ppm.h>
     #endif
 
-    #ifdef CONFIG_TI_PACKET_PROCESSOR_STATS
-		#include <linux/avalanche/puma7/ppsgc_defs.h>
-    #endif
+    #include <linux/ti_pp_path.h>
 
-    #include <linux/avalanche/generic/avalanche_pp_api.h>
+    #ifdef CONFIG_ARM_AVALANCHE_PDSP_PP
+        #include <linux/avalanche/generic/avalanche_pp_api.h>
+    #endif
 
     /* Egress queue definitions... */
     #define TI_PPM_EGRESS_QUEUE_INVALID     (-1)
@@ -291,7 +293,9 @@
         TI_PP_SESSION                   ti_session;
     #endif
 
+    #ifdef CONFIG_ARM_AVALANCHE_PDSP_PP
         AVALANCHE_PP_SESSION_INFO_t     pp_session;
+    #endif
 
         unsigned int                    flags;
         int                             input_device_index;
@@ -301,25 +305,24 @@
         int                             egress_queue;
 
     #ifdef CONFIG_TI_PACKET_PROCESSOR_STATS
-		struct PpsgcAssignedGroupCounters assignedGroupCounters;
+        void*               ti_match_llc_filter;
+        void*               ti_match_inbound_ip_filter;
+        void*               ti_match_outbound_ip_filter;
+        void*               ti_match_qos_classifier;
+        void*               ti_match_dsg_filter;
     #endif
+        TI_PPP_PACKET_INFO   ppp_packet_info; /* PP Path */
 
     }PP_PACKET_INFO_t;
 
-#ifdef CONFIG_INTEL_KERNEL_SKB_COOKIE
-    typedef union
-    {
-        unsigned int  raw[ 0 ];
-        struct
-        {
-            PP_PACKET_INFO_t    pp_packet_info;  
-            /* Add the additinal info below ... */  
-        }s;
-    }
-    SKB_INTEL_COOKIE;
+/*
+    return pointer to pp_packet_info struct within the skb
+*/
+#if PUMA7_OR_NEWER_SOC_TYPE
+#define SKB_GET_PP_INFO_P(skb)          (skb->pp_packet_info)
 #else
-    #define SKB_INTEL_COOKIE    PP_PACKET_INFO_t
-#endif
+#define SKB_GET_PP_INFO_P(skb)          (&skb->pp_packet_info)
+#endif 
 
 #endif /* CONFIG_TI_PACKET_PROCESSOR */
 
@@ -549,9 +549,9 @@
 	struct nf_conntrack	*nfct;
 #endif
 #ifdef CONFIG_BRIDGE_NETFILTER
-	struct nf_bridge_info	*nf_bridge;
+    struct nf_bridge_info   *nf_bridge;
 #ifdef CONFIG_BRIDGE_EBT_FORWARD
-	struct net_bridge_port	*bridge_forward_port;
+    struct net_bridge_port  *bridge_forward_port;
 #endif
 #endif
 
@@ -623,7 +623,7 @@
 #endif /* CONFIG_TI_META_DATA */
 #ifdef CONFIG_INTEL_NF_GWMETA_SUPPORT
     __u32    ti_gw_meta;
-#endif /* INTEL_NF_GWMETA_SUPPORT */
+#endif /* CONFIG_TI_META_DATA */
 
 #ifdef CONFIG_TI_DOCSIS_INPUT_DEV
     struct net_device   *ti_docsis_input_dev;
@@ -636,23 +636,9 @@
 #endif /* CONFIG_TI_L2_SELECTIVE_FORWARDER */
 #ifdef CONFIG_TI_PACKET_PROCESSOR
     #if PUMA7_OR_NEWER_SOC_TYPE
-        #ifdef CONFIG_INTEL_KERNEL_SKB_COOKIE
-
-            SKB_INTEL_COOKIE *              	intel_cookie;
-            #define SKB_GET_PP_INFO_P(skb)      (&(skb)->intel_cookie->s.pp_packet_info)
-            #define SKB_GET_COOKIE_P(skb)       ((skb)->intel_cookie)
-
-        #else
-
-            PP_PACKET_INFO_t *              	pp_packet_info;
-            #define SKB_GET_PP_INFO_P(skb)      ((skb)->pp_packet_info)
-            #define SKB_GET_COOKIE_P(skb)       ((skb)->pp_packet_info)
-
-        #endif
-
+    PP_PACKET_INFO_t    *pp_packet_info;
     #else
-            PP_PACKET_INFO_t                	pp_packet_info;
-            #define SKB_GET_PP_INFO_P(skb)      (&(skb)->pp_packet_info)
+    PP_PACKET_INFO_t    pp_packet_info;
     #endif
     __u16               vpid_vlan_tci;
 #endif  /* CONFIG_TI_PACKET_PROCESSOR */
@@ -780,8 +766,8 @@
 			     bool *fragstolen, int *delta_truesize);
 
 #ifdef CONFIG_TI_PACKET_PROCESSOR  
-extern void* __alloc_skb_intel_cookie(void);
-extern void kfree_skb_intel_cookie(void *cookie_ptr);
+extern void* __alloc_skb_pp_packet_info(void);
+extern void kfree_pp_packet_info(void *pp_info);
 #endif
 
 extern struct sk_buff *__alloc_skb(unsigned int size,
@@ -2997,6 +2983,18 @@
 #endif
 }
 
+#if defined(CONFIG_PPA_PUMA7) && !defined(CONFIG_ARM_AVALANCHE_SOC)
+struct skb_buf_manager_cb {
+	bool (*is_bm_skb)(struct sk_buff *skb);
+	int  (*bm_free_skb)(struct sk_buff *skb);
+	void (*bm_clear_skb)(struct sk_buff *skb);
+};
+
+int skb_register_buf_manager(struct skb_buf_manager_cb *cb);
+int skb_unregister_buf_manager(void);
+#endif
+
+
 bool skb_partial_csum_set(struct sk_buff *skb, u16 start, u16 off);
 
 u32 __skb_get_poff(const struct sk_buff *skb);
@@ -3032,16 +3030,5 @@
 	return hdr_len + skb_gso_transport_seglen(skb);
 }
 
-#if defined(CONFIG_PPA_PUMA7) && !defined(CONFIG_ARM_AVALANCHE_SOC)
-struct skb_buf_manager_cb {
-	bool (*is_bm_skb)(struct sk_buff *skb);
-	int  (*bm_free_skb)(struct sk_buff *skb);
-	void  (*bm_clear_skb)(struct sk_buff *skb);
-};
-
-int skb_register_buf_manager(struct skb_buf_manager_cb *cb);
-int skb_unregister_buf_manager(void);
-#endif
-
 #endif	/* __KERNEL__ */
 #endif	/* _LINUX_SKBUFF_H */
diff -Naur a/include/linux/ti_hil.h b/include/linux/ti_hil.h
--- a/include/linux/ti_hil.h	2017-10-11 10:17:28.451329000 +0530
+++ b/include/linux/ti_hil.h	2017-10-11 09:36:28.247033000 +0530
@@ -268,7 +268,7 @@
 #define TI_PP_REMOVE_VPID       (TI_PP_GENERAL_EVENT + 0x2)
 
 /* Event generated when created session by sanity test module */
-#define TI_PP_TEST_SESSION       (TI_PP_GENERAL_EVENT + 0x3)
+#define TI_PP_TEST_SESSION      (TI_PP_GENERAL_EVENT + 0x3)
 
 /* Event generated when it is needed to disable moca pdsp */
 #define TI_PP_CONTROL_MOCA      (TI_PP_GENERAL_EVENT + 0x4)
diff -Naur a/include/net/genetlink.h b/include/net/genetlink.h
--- a/include/net/genetlink.h	2017-10-11 10:17:31.220554000 +0530
+++ b/include/net/genetlink.h	2017-10-11 09:36:31.241278000 +0530
@@ -271,7 +271,7 @@
  */
 static inline int genlmsg_unicast(struct net *net, struct sk_buff *skb, u32 portid)
 {
-	return nlmsg_unicast(net->genl_sock, skb, portid, 0);
+	return nlmsg_unicast(net->genl_sock, skb, portid);
 }
 
 /**
diff -Naur a/include/net/ip.h b/include/net/ip.h
--- a/include/net/ip.h	2017-10-11 10:17:31.041543000 +0530
+++ b/include/net/ip.h	2017-10-11 09:36:31.067280000 +0530
@@ -102,7 +102,7 @@
 extern int		ip_rcv(struct sk_buff *skb, struct net_device *dev,
 			       struct packet_type *pt, struct net_device *orig_dev);
 extern int		ip_local_deliver(struct sk_buff *skb);
-extern int      ip_local_deliver_finish(struct sk_buff *skb);
+extern int		ip_local_deliver_finish(struct sk_buff *skb);
 extern int		ip_mr_input(struct sk_buff *skb);
 extern int		ip_output(struct sk_buff *skb);
 extern int		ip_mc_output(struct sk_buff *skb);
diff -Naur a/include/net/ipv6.h b/include/net/ipv6.h
--- a/include/net/ipv6.h	2017-10-11 10:17:30.798522000 +0530
+++ b/include/net/ipv6.h	2017-10-11 09:36:30.791254000 +0530
@@ -516,7 +516,7 @@
 
 void ip6_frag_init(struct inet_frag_queue *q, void *a);
 bool ip6_frag_match(struct inet_frag_queue *q, void *a);
-int ip6_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *));
+
 /*
  *	Equivalent of ipv4 struct ip
  */
diff -Naur a/include/net/lpal_api.h b/include/net/lpal_api.h
--- a/include/net/lpal_api.h	2017-10-11 10:17:31.115551000 +0530
+++ b/include/net/lpal_api.h	2017-10-11 09:36:31.117278000 +0530
@@ -3,10 +3,6 @@
 
 #include <linux/skbuff.h>
 
-#if defined(CONFIG_LTQ_DATAPATH)
-#include <net/datapath_api.h>
-#endif
-
 #define LOG_PRINT(msg, arg...) \
 	pr_crit("[%s:%d] "msg, __func__, __LINE__, ##arg)
 #define LOG_ERROR              err
@@ -27,9 +23,9 @@
 #define	MAX_VPID (50)
 
 #define DP_DATA_INDEX(__p) \
-	((__p)->port_id * (MAX_VPID+1) + ((__p)->subif > 0 ? (__p)->subif : 0))
-#define DP_PORT_ID(_idx)	((_idx) ? ((_idx) / (MAX_VPID+1)) : 0)
-#define DP_SUBIF(_idx)		((_idx) ? ((_idx) % (MAX_VPID+1)) : 0)
+	((__p)->port_id * MAX_VPID + ((__p)->subif > 0 ? (__p)->subif : 0))
+#define DP_PORT_ID(_idx)	((_idx) ? ((_idx) / MAX_VPID) : 0)
+#define DP_SUBIF(_idx)		((_idx) ? ((_idx) % MAX_VPID) : 0)
 
 #define PPA_SUCCESS    0
 #define PPA_FAILURE   -1
@@ -64,9 +60,7 @@
 				*/
 };
 
-#ifndef CONFIG_LTQ_DATAPATH
 #define PPA_SUBIF struct ppa_subif_t
-#endif
 
 typedef int32_t(*PPA_FP_RX_FN) (PPA_NETIF *rxif, PPA_NETIF *txif,
 				PPA_BUF *skb, int32_t len);
diff -Naur a/include/net/netfilter/ipv6/nf_defrag_ipv6.h b/include/net/netfilter/ipv6/nf_defrag_ipv6.h
--- a/include/net/netfilter/ipv6/nf_defrag_ipv6.h	2017-10-11 10:17:30.801527000 +0530
+++ b/include/net/netfilter/ipv6/nf_defrag_ipv6.h	2017-10-11 09:36:30.811246000 +0530
@@ -5,7 +5,8 @@
 
 extern int nf_ct_frag6_init(void);
 extern void nf_ct_frag6_cleanup(void);
-int nf_ct_frag6_gather(struct sk_buff *skb, u32 user);
+extern struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user);
+extern void nf_ct_frag6_consume_orig(struct sk_buff *skb);
 
 struct inet_frags_ctl;
 
diff -Naur a/include/net/netfilter/nf_conntrack.h b/include/net/netfilter/nf_conntrack.h
--- a/include/net/netfilter/nf_conntrack.h	2017-10-11 10:17:30.807519000 +0530
+++ b/include/net/netfilter/nf_conntrack.h	2017-10-11 09:36:30.821258000 +0530
@@ -41,7 +41,7 @@
 #define LANTIQ_ALG_PROTO_DATA      0x00030000
 #endif  //CONFIG_LANTIQ_ALG_QOS
 
-#if defined(CONFIG_APPCPU_GW_PP_HANDLE) || defined(CONFIG_TI_PACKET_PROCESSOR)
+#ifdef CONFIG_TI_PACKET_PROCESSOR 
 /* Flag definitions that are carried in the PP status flag in the connection tracking
  *  * structure. */
 
@@ -52,7 +52,7 @@
 /* Set the flag to 1 indicates that all packets flowing through the box matching the
  *  * connection will have their BYPASS flag set. */
 #define TI_PP_BYPASS               0x2
-#endif /* CONFIG_APPCPU_GW_PP_HANDLE */ /*CONFIG_TI_PACKET_PROCESSOR */
+#endif
 /* per conntrack: protocol private data */
 union nf_conntrack_proto {
 	/* insert conntrack proto private data here */
@@ -148,6 +148,10 @@
 #ifdef CONFIG_NET_NS
 	struct net *ct_net;
 #endif
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    int             ti_pp_status_flag;
+    int             pp_appcpu_status_flag;
+#endif
 
 #if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || \
     defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
@@ -164,10 +168,6 @@
 		unsigned int app_data_len;
 	} layer7;
 #endif
-#ifdef CONFIG_TI_PACKET_PROCESSOR
-    int             ti_pp_status_flag;
-    int             pp_appcpu_status_flag;
-#endif
 #ifdef CONFIG_APPCPU_GW_PP_HANDLE
 	/*flag used to indicate ct client mrpc call in progress b/w ATOM/ARM */
 	int ct_tuple_arm_sync_wait;
diff -Naur a/include/net/netlink.h b/include/net/netlink.h
--- a/include/net/netlink.h	2017-10-11 10:17:31.218559000 +0530
+++ b/include/net/netlink.h	2017-10-11 09:36:31.239277000 +0530
@@ -587,12 +587,11 @@
  * @skb: netlink message as socket buffer
  * @portid: netlink portid of the destination socket
  */
-static inline int nlmsg_unicast(struct sock *sk, struct sk_buff *skb,
-					u32 portid, gfp_t allocation)
+static inline int nlmsg_unicast(struct sock *sk, struct sk_buff *skb, u32 portid)
 {
 	int err;
 
-	err = netlink_unicast(sk, skb, portid, MSG_DONTWAIT, allocation);
+	err = netlink_unicast(sk, skb, portid, MSG_DONTWAIT);
 	if (err > 0)
 		err = 0;
 
diff -Naur a/include/net/sock.h b/include/net/sock.h
--- a/include/net/sock.h	2017-10-11 10:17:30.992537000 +0530
+++ b/include/net/sock.h	2017-10-11 09:36:31.007257000 +0530
@@ -408,14 +408,12 @@
 	int			(*sk_backlog_rcv)(struct sock *sk,
 						  struct sk_buff *skb);
 	void                    (*sk_destruct)(struct sock *sk);
-    uint32_t                acceleration_flag;
+	uint32_t		acceleration_flag;
 };
-
 enum toe_acceleration_flag_set_act {
-    SOCKET_ALLOCATE,
-    SOCKET_RELEASE
+	SOCKET_ALLOCATE,
+	SOCKET_RELEASE
 };
-
 extern int (*toe_acceleration_flag_set_hook)(struct sock *, struct pid *, enum toe_acceleration_flag_set_act);
 
 #define __sk_user_data(sk) ((*((void __rcu **)&(sk)->sk_user_data)))
diff -Naur a/include/uapi/linux/netfilter/Kbuild b/include/uapi/linux/netfilter/Kbuild
--- a/include/uapi/linux/netfilter/Kbuild	2017-10-11 10:17:25.593095000 +0530
+++ b/include/uapi/linux/netfilter/Kbuild	2017-10-11 09:36:25.421807000 +0530
@@ -22,7 +22,6 @@
 header-y += xt_CONNSECMARK.h
 header-y += xt_CT.h
 header-y += xt_DSCP.h
-header-y += xt_GWMETA.h
 header-y += xt_HMARK.h
 header-y += xt_IDLETIMER.h
 header-y += xt_LED.h
@@ -82,4 +81,3 @@
 header-y += xt_tcpudp.h
 header-y += xt_time.h
 header-y += xt_u32.h
-header-y += xt_webstr.h
diff -Naur a/include/uapi/linux/netfilter/xt_GWMETA.h b/include/uapi/linux/netfilter/xt_GWMETA.h
--- a/include/uapi/linux/netfilter/xt_GWMETA.h	2017-10-11 10:17:25.597097000 +0530
+++ b/include/uapi/linux/netfilter/xt_GWMETA.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,68 +0,0 @@
-/* 
- * 
- *
- * Copyright (C) 2011, Intel Ltd.
- * All Rights Reserved.
- ** Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL").
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- *
-   You should have received a copy of the GNU General Public License 
-   along with this program; if not, write to the Free Software 
-   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
-   The full GNU General Public License is included in this distribution 
-   in the file called LICENSE.GPL.
-
-   Contact Information:
-    Intel Corporation
-    2200 Mission College Blvd.
-    Santa Clara, CA  97052
- 
- 
- * Description:
- *   This module provide extends netfilter feature to set a bitmask on a packets.
- *   In a difference from netfilter this masks lasts till packet leaves gateway TCP stack 
- *
- *   The module follows the Netfilter framework, called extended packet
- *   matching modules.
- * Usage :
- *  iptables -t mangle -I POSTROUTING 1 -o rndbr1 -p tcp --dport 6800:6866 -j GWMETA --gwmeta-gwmask 0x00000020
- *  iptables -t mangle -I OUTPUT 1 -o rndbr1 -p tcp --dport 6800:6866 -j GWMETA --gwmeta-gwmask 0x00000002
- *   Packet will have resulted ti_gw_meta ORed mask 0x22 
- */
-
-#ifndef __XT_GWMETA_H_
-#define __XT_GWMETA_H_
-               
-enum xt_gw_skb
-{
-	XT_GW_META = 1,
-	XT_GW_DIS_PP = 2,
-	XT_GW_EN_PP = 3
-};
-               
-struct xt_gw_skb_rule_info 
-{
-	u_int32_t  gwmask;
-	enum xt_gw_skb type;
-};
-
-#endif /*_XT_GWMETA_H*/
diff -Naur a/include/uapi/linux/netfilter/xt_webstr.h b/include/uapi/linux/netfilter/xt_webstr.h
--- a/include/uapi/linux/netfilter/xt_webstr.h	2017-10-11 10:17:25.640114000 +0530
+++ b/include/uapi/linux/netfilter/xt_webstr.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2009 - 2010, CyberTAN Corporation
- *
- * All Rights Reserved.
- * You can redistribute it and/or modify it under the terms of the GPL v2
- *
- * THIS SOFTWARE IS OFFERED "AS IS", AND CYBERTAN GRANTS NO WARRANTIES OF ANY
- * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. CYBERTAN
- * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A SPECIFIC PURPOSE OR NON INFRINGEMENT CONCERNING THIS SOFTWARE.
- */
-
-/*
-Includes Intel Corporation's changes/modifications dated: 2014.
-Changed/modified portions - Copyright  2014, Intel Corporation.
-*/
-#ifndef _XT_WEBSTR_H
-#define _XT_WEBSTR_H
-
-#define BM_MAX_NLEN 256
-#define BM_MAX_HLEN 1024
-
-#define BLK_JAVA		0x01
-#define BLK_ACTIVE		0x02
-#define BLK_COOKIE		0x04
-#define BLK_PROXY		0x08
-
-typedef char *(*proc_xt_search) (char *, char *, int, int);
-
-struct xt_webstr_info {
-    char string[BM_MAX_NLEN];
-    u_int16_t invert;
-    u_int16_t len;
-    u_int8_t type;
-};
-
-enum xt_webstr_type
-{
-    XT_WEBSTR_HOST,
-    XT_WEBSTR_URL,
-    XT_WEBSTR_CONTENT
-};
-
-#endif /* _XT_WEBSTR_H */
diff -Naur a/include/uapi/linux/netfilter_ipv4/Kbuild b/include/uapi/linux/netfilter_ipv4/Kbuild
--- a/include/uapi/linux/netfilter_ipv4/Kbuild	2017-10-11 10:17:25.915150000 +0530
+++ b/include/uapi/linux/netfilter_ipv4/Kbuild	2017-10-11 09:36:25.779834000 +0530
@@ -9,4 +9,3 @@
 header-y += ipt_ah.h
 header-y += ipt_ecn.h
 header-y += ipt_ttl.h
-header-y += ipt_TRIGGER.h
diff -Naur a/include/uapi/linux/netfilter_ipv4/ipt_TRIGGER.h b/include/uapi/linux/netfilter_ipv4/ipt_TRIGGER.h
--- a/include/uapi/linux/netfilter_ipv4/ipt_TRIGGER.h	2017-10-11 10:17:25.914121000 +0530
+++ b/include/uapi/linux/netfilter_ipv4/ipt_TRIGGER.h	1970-01-01 05:30:00.000000000 +0530
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2009 - 2010, CyberTAN Corporation
- *
- * All Rights Reserved.
- * You can redistribute it and/or modify it under the terms of the GPL v2
- *
- * THIS SOFTWARE IS OFFERED "AS IS", AND CYBERTAN GRANTS NO WARRANTIES OF ANY
- * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. CYBERTAN
- * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A SPECIFIC PURPOSE OR NON INFRINGEMENT CONCERNING THIS SOFTWARE.
- *
- ******************************************************************************************************
- Includes Intel Corporation's changes/modifications
- Changed/modified portions :
- * -  X-tables API adapted for kernel 2.6.39
- * -  Added IPT_TRIGGER_BOTH_PROTOCOLS (matches both TCP and UDP)
- * -  Added, improved Debug prints
- * -  Formatting improvements and general code cleanup
- *
- * Copyright  2011-2016, Intel Corporation.
- ******************************************************************************************************
- */
-
-#ifndef _IPT_TRIGGER_H_target
-#define _IPT_TRIGGER_H_target
-#define IPT_TRIGGER_BOTH_PROTOCOLS 253  /* unassigned number */
-
-enum ipt_trigger_type
-{
-    IPT_TRIGGER_DNAT = 1,
-    IPT_TRIGGER_IN = 2,
-    IPT_TRIGGER_OUT = 3
-};
-
-struct ipt_trigger_ports {
-    u_int16_t mport[2];    /* Related destination port range */
-    u_int16_t rport[2];    /* Port range to map related destination port range to */
-};
-
-struct ipt_trigger_info {
-    enum ipt_trigger_type type;
-    u_int16_t proto;       /* Related protocol */
-    struct ipt_trigger_ports ports;
-};
-
-#endif /*_IPT_TRIGGER_H_target*/
diff -Naur a/kernel/audit.c b/kernel/audit.c
--- a/kernel/audit.c	2017-10-11 10:16:11.967115000 +0530
+++ b/kernel/audit.c	2017-10-11 09:35:09.052583000 +0530
@@ -386,7 +386,7 @@
 	int err;
 	/* take a reference in case we can't send it and we want to hold it */
 	skb_get(skb);
-	err = netlink_unicast(audit_sock, skb, audit_nlk_portid, 0, 0);
+	err = netlink_unicast(audit_sock, skb, audit_nlk_portid, 0);
 	if (err < 0) {
 		BUG_ON(err != -ECONNREFUSED); /* Shouldn't happen */
 		printk(KERN_ERR "audit: *NO* daemon at audit_pid=%d\n", audit_pid);
@@ -481,7 +481,7 @@
 	mutex_unlock(&audit_cmd_mutex);
 
 	while ((skb = __skb_dequeue(&dest->q)) != NULL)
-		netlink_unicast(audit_sock, skb, pid, 0, 0);
+		netlink_unicast(audit_sock, skb, pid, 0);
 
 	kfree(dest);
 
@@ -522,7 +522,7 @@
 
 	/* Ignore failure. It'll only happen if the sender goes away,
 	   because our timeout is set to infinite. */
-	netlink_unicast(audit_sock, reply->skb, reply->pid, 0, 0);
+	netlink_unicast(audit_sock, reply->skb, reply->pid, 0);
 	kfree(reply);
 	return 0;
 }
diff -Naur a/net/8021q/vlan.c b/net/8021q/vlan.c
--- a/net/8021q/vlan.c	2017-10-11 10:17:41.679413000 +0530
+++ b/net/8021q/vlan.c	2017-10-11 09:38:03.680821000 +0530
@@ -37,9 +37,7 @@
 #include <asm/uaccess.h>
 
 #include <linux/if_vlan.h>
-#ifdef CONFIG_TI_PACKET_PROCESSOR
 #include <linux/ti_hil.h>
-#endif
 #include "vlan.h"
 #include "vlanproc.h"
 
diff -Naur a/net/8021q/vlan_core.c b/net/8021q/vlan_core.c
--- a/net/8021q/vlan_core.c	2017-10-11 10:17:41.666412000 +0530
+++ b/net/8021q/vlan_core.c	2017-10-11 09:38:03.670819000 +0530
@@ -76,7 +76,10 @@
 		skb_reset_mac_len(skb);
 	}
 
+#ifndef CONFIG_LANTIQ_IPQOS
 	skb->priority = vlan_get_ingress_priority(vlan_dev, skb->vlan_tci);
+#endif
+
 #ifdef CONFIG_TI_PACKET_PROCESSOR
     /* 
      * Need to save the vpid vlan_tci before it will erased
@@ -85,6 +88,7 @@
      */
     skb->vpid_vlan_tci = vlan_tx_tag_get(skb); 
 #endif
+
 	skb->vlan_tci = 0;
 
 	rx_stats = this_cpu_ptr(vlan_dev_priv(vlan_dev)->vlan_pcpu_stats);
diff -Naur a/net/8021q/vlan_dev.c b/net/8021q/vlan_dev.c
--- a/net/8021q/vlan_dev.c	2017-10-11 10:17:41.673410000 +0530
+++ b/net/8021q/vlan_dev.c	2017-10-11 09:38:03.674832000 +0530
@@ -75,14 +75,10 @@
 vlan_dev_get_egress_qos_mask(struct net_device *dev, struct sk_buff *skb)
 #endif
 {
-#if defined(CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL)
-	if ((skb->ti_ds_traffic_prio < 2) && (dev->priv_flags & IFF_BONDING))
-	{
-		/* Increase VLAN priority for traffic directed to the LAG */
-		return (VLAN_PRIO_MASK & ((2) << VLAN_PRIO_SHIFT));
-	}
-	return (VLAN_PRIO_MASK & (((u16)(skb->ti_ds_traffic_prio)) << VLAN_PRIO_SHIFT));
-#else
+#if defined(CONFIG_MACH_PUMA6)
+	return (VLAN_PRIO_MASK & (((u16)(skb->ti_meta_info)) << VLAN_PRIO_SHIFT));
+#elif defined(CONFIG_MACH_PUMA5) || defined(CONFIG_MACH_PUMA7)
+
 	struct vlan_priority_tci_mapping *mp;
 
 	smp_rmb(); /* coupled with smp_wmb() in vlan_dev_set_egress_priority() */
@@ -97,7 +93,11 @@
 		mp = mp->next;
 	}
 	return 0;
-#endif /* CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL */
+#elif defined(CONFIG_MACH_PUMA7)
+	return (VLAN_PRIO_MASK & (((u16)(skb->pp_packet_info->pp_session.priority)) << VLAN_PRIO_SHIFT));
+#else
+	#error Update required for target Puma SoC
+#endif
 }
 
 /*
diff -Naur a/net/Kconfig b/net/Kconfig
--- a/net/Kconfig	2017-10-11 10:17:42.672493000 +0530
+++ b/net/Kconfig	2017-10-11 09:38:04.799909000 +0530
@@ -217,7 +217,7 @@
 	bool "Bridged IP/ARP packets filtering"
 	depends on BRIDGE && NETFILTER && INET
 	depends on NETFILTER_ADVANCED
-	default y
+	default n
 	---help---
 	  Enabling this option will let arptables resp. iptables see bridged
 	  ARP resp. IP traffic. If you want a bridging firewall, you probably
@@ -394,24 +394,6 @@
 	depends on TI_PACKET_PROCESSOR
 	default n
 
-config INTEL_NF_GWMETA_SUPPORT
-        bool "Intel Gateway Packet Meta Data"
-        default y
-        help
-        This feature allows to label skb data of ip packets (GWMETA module of iptables/Netfilter )
-
-config INTEL_NF_TRIGGER_SUPPORT
-        bool "Intel Netfilter Port Trigger"
-    default y
-        help
-        This feature allows to use Port Trigger module of iptables/Netfilter
-
-config INTEL_NF_WEBSTR_SUPPORT
-        bool "WEBSTR match support"
-        default y
-        help
-        This option allows to match string in http web header
-
 source "net/ax25/Kconfig"
 source "net/can/Kconfig"
 source "net/irda/Kconfig"
diff -Naur a/net/atm/koam.c b/net/atm/koam.c
--- a/net/atm/koam.c	2017-10-11 10:17:42.293469000 +0530
+++ b/net/atm/koam.c	2017-10-11 09:38:04.315862000 +0530
@@ -151,7 +151,7 @@
 	skb_put(skb, KOAM_CELL_SIZE);
 	memcpy(skb->data, (u8 *)cell, KOAM_CELL_SIZE);
 
-	status = netlink_unicast(koam_sock, skb, koam_upid, MSG_DONTWAIT, 0);
+	status = netlink_unicast(koam_sock, skb, koam_upid, MSG_DONTWAIT);
 	if (status < 0){
 		printk(KERN_ERR " koam send fail \n");
 		return -1;
diff -Naur a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
--- a/net/bridge/br_fdb.c	2017-10-11 10:17:41.149362000 +0530
+++ b/net/bridge/br_fdb.c	2017-10-11 09:38:03.332783000 +0530
@@ -34,7 +34,6 @@
 #if defined(CONFIG_LTQ_PPA_API) || defined(CONFIG_LTQ_PPA_API_MODULE)
   #include <net/ppa_api.h>
 #endif
-
 static struct kmem_cache *br_fdb_cache __read_mostly;
 static int fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
 		      const unsigned char *addr, u16 vid);
@@ -214,7 +213,6 @@
 #endif
             }
 #endif
-
 			if (f->is_static)
 				continue;
 			this_timer = f->updated + delay;
@@ -538,7 +536,6 @@
         if ( ppa_hook_bridge_entry_add_fn != NULL && source->dev )
             ppa_hook_bridge_entry_add_fn((unsigned char *)addr, br->dev, source->dev, PPA_F_BRIDGE_ACCEL_MODE);
 #endif
-
 		}
 	} else {
 		spin_lock(&br->hash_lock);
@@ -846,31 +843,6 @@
 	return err;
 }
 
-#ifdef CONFIG_LTQ_DIRECTCONNECT_DP
-/* named ppa for compatability with UGW, only used in DC_DP*/
-int ppa_br_fdb_delete(struct net_device *dev, const unsigned char *addr)
-{
-	struct net_bridge_port *p;
-	int err;
-
-	if (!dev || !addr) {
-		return -EINVAL;
-	}
-
-	p = br_port_get_rcu(dev);
-	if (!p) {
-		pr_info("bridge: %s not a bridge port\n",
-			dev->name);
-		return -EINVAL;
-	}
-
-	err = __br_fdb_delete(p, addr, 0);
-
-	return err;
-}
-EXPORT_SYMBOL(ppa_br_fdb_delete);
-#endif
-
 #if ((defined(CONFIG_LTQ_PPA_API) && CONFIG_LTQ_PPA_API) || \
 	(defined(CONFIG_LTQ_PPA_API_MODULE) && CONFIG_LTQ_PPA_API_MODULE))
 int ppa_br_fdb_delete(struct net_device *dev, const unsigned char *addr)
diff -Naur a/net/bridge/br_netfilter.c b/net/bridge/br_netfilter.c
--- a/net/bridge/br_netfilter.c	2017-10-11 10:17:41.124387000 +0530
+++ b/net/bridge/br_netfilter.c	2017-10-11 09:38:03.308798000 +0530
@@ -34,7 +34,6 @@
 
 #include <net/ip.h>
 #include <net/ipv6.h>
-#include <net/addrconf.h>
 #include <net/route.h>
 
 #include <asm/uaccess.h>
@@ -333,109 +332,6 @@
 	return -1;
 }
 
-/* We only check the length. A bridge shouldn't do hop-by-hop stuff anyway */
-static int check_hbh_len(struct sk_buff *skb)
-{
-	unsigned char *raw = (u8 *)(ipv6_hdr(skb) + 1);
-	u32 pkt_len;
-	const unsigned char *nh = skb_network_header(skb);
-	int off = raw - nh;
-	int len = (raw[1] + 1) << 3;
-
-	if ((raw + len) - skb->data > skb_headlen(skb))
-		goto bad;
-
-	off += 2;
-	len -= 2;
-
-	while (len > 0) {
-		int optlen = nh[off + 1] + 2;
-
-		switch (nh[off]) {
-		case IPV6_TLV_PAD1:
-			optlen = 1;
-			break;
-
-		case IPV6_TLV_PADN:
-			break;
-
-		case IPV6_TLV_JUMBO:
-			if (nh[off + 1] != 4 || (off & 3) != 2)
-				goto bad;
-			pkt_len = ntohl(*(__be32 *) (nh + off + 2));
-			if (pkt_len <= IPV6_MAXPLEN ||
-				ipv6_hdr(skb)->payload_len)
-				goto bad;
-			if (pkt_len > skb->len - sizeof(struct ipv6hdr))
-				goto bad;
-			if (pskb_trim_rcsum(skb,
-				pkt_len + sizeof(struct ipv6hdr)))
-				goto bad;
-			nh = skb_network_header(skb);
-			break;
-		default:
-			if (optlen > len)
-				goto bad;
-			break;
-		}
-		off += optlen;
-		len -= optlen;
-	}
-	if (len == 0)
-		return 0;
-bad:
-	return -1;
-}
-
-/* Equivalent to br_parse_ip_options for IPv6 */
-static int br_validate_ipv6(struct sk_buff *skb)
-{
-	const struct ipv6hdr *hdr;
-	struct net_device *dev = skb->dev;
-	struct inet6_dev *idev = __in6_dev_get(skb->dev);
-	u32 pkt_len;
-	u8 ip6h_len = sizeof(struct ipv6hdr);
-
-	if (!pskb_may_pull(skb, ip6h_len))
-		goto inhdr_error;
-
-	if (skb->len < ip6h_len)
-		goto drop;
-
-	hdr = ipv6_hdr(skb);
-
-	if (hdr->version != 6)
-		goto inhdr_error;
-
-	pkt_len = ntohs(hdr->payload_len);
-
-	if (pkt_len || hdr->nexthdr != NEXTHDR_HOP) {
-		if (pkt_len + ip6h_len > skb->len) {
-			IP6_INC_STATS_BH(dev_net(dev), idev,
-			IPSTATS_MIB_INTRUNCATEDPKTS);
-			goto drop;
-		}
-		if (pskb_trim_rcsum(skb, pkt_len + ip6h_len)) {
-			IP6_INC_STATS_BH(dev_net(dev), idev,
-			IPSTATS_MIB_INDISCARDS);
-			goto drop;
-		}
-	}
-	if (hdr->nexthdr == NEXTHDR_HOP && check_hbh_len(skb))
-		goto drop;
-
-	memset(IP6CB(skb), 0, sizeof(struct inet6_skb_parm));
-	/* No IP options in IPv6 header; however it should be
-	 * checked if some next headers need special treatment
-	 */
-	return 0;
-inhdr_error:
-	IP6_INC_STATS_BH(dev_net(dev), idev, IPSTATS_MIB_INHDRERRORS);
-drop:
-	return -1;
-}
-
-
 /* Fill in the header for fragmented IP packets handled by
  * the IPv4 connection tracking code.
  */
@@ -463,10 +359,6 @@
 {
 	struct nf_bridge_info *nf_bridge = skb->nf_bridge;
 	struct rtable *rt;
-	int frag_max_size;
-
-	frag_max_size = IP6CB(skb)->frag_max_size;
-	BR_INPUT_SKB_CB(skb)->frag_max_size = frag_max_size;
 
 	if (nf_bridge->mask & BRNF_PKT_TYPE) {
 		skb->pkt_type = PACKET_OTHERHOST;
@@ -682,16 +574,92 @@
 	return skb->dev;
 }
 
+/* We only check the length. A bridge shouldn't do any hop-by-hop stuff anyway */
+static int check_hbh_len(struct sk_buff *skb)
+{
+	unsigned char *raw = (u8 *)(ipv6_hdr(skb) + 1);
+	u32 pkt_len;
+	const unsigned char *nh = skb_network_header(skb);
+	int off = raw - nh;
+	int len = (raw[1] + 1) << 3;
+
+	if ((raw + len) - skb->data > skb_headlen(skb))
+		goto bad;
+
+	off += 2;
+	len -= 2;
+
+	while (len > 0) {
+		int optlen = nh[off + 1] + 2;
+
+		switch (nh[off]) {
+		case IPV6_TLV_PAD1:
+			optlen = 1;
+			break;
+
+		case IPV6_TLV_PADN:
+			break;
+
+		case IPV6_TLV_JUMBO:
+			if (nh[off + 1] != 4 || (off & 3) != 2)
+				goto bad;
+			pkt_len = ntohl(*(__be32 *) (nh + off + 2));
+			if (pkt_len <= IPV6_MAXPLEN ||
+			    ipv6_hdr(skb)->payload_len)
+				goto bad;
+			if (pkt_len > skb->len - sizeof(struct ipv6hdr))
+				goto bad;
+			if (pskb_trim_rcsum(skb,
+					    pkt_len + sizeof(struct ipv6hdr)))
+				goto bad;
+			nh = skb_network_header(skb);
+			break;
+		default:
+			if (optlen > len)
+				goto bad;
+			break;
+		}
+		off += optlen;
+		len -= optlen;
+	}
+	if (len == 0)
+		return 0;
+bad:
+	return -1;
+
+}
+
 /* Replicate the checks that IPv6 does on packet reception and pass the packet
- * to ip6tables. */
+ * to ip6tables, which doesn't support NAT, so things are fairly simple. */
 static unsigned int br_nf_pre_routing_ipv6(unsigned int hook,
 					   struct sk_buff *skb,
 					   const struct net_device *in,
 					   const struct net_device *out,
 					   int (*okfn)(struct sk_buff *))
 {
-	/* Drop invalid packet */
-	if (br_validate_ipv6(skb))
+	const struct ipv6hdr *hdr;
+	u32 pkt_len;
+
+	if (skb->len < sizeof(struct ipv6hdr))
+		return NF_DROP;
+
+	if (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))
+		return NF_DROP;
+
+	hdr = ipv6_hdr(skb);
+
+	if (hdr->version != 6)
+		return NF_DROP;
+
+	pkt_len = ntohs(hdr->payload_len);
+
+	if (pkt_len || hdr->nexthdr != NEXTHDR_HOP) {
+		if (pkt_len + sizeof(struct ipv6hdr) > skb->len)
+			return NF_DROP;
+		if (pskb_trim_rcsum(skb, pkt_len + sizeof(struct ipv6hdr)))
+			return NF_DROP;
+	}
+	if (hdr->nexthdr == NEXTHDR_HOP && check_hbh_len(skb))
 		return NF_DROP;
 
 	nf_bridge_put(skb->nf_bridge);
@@ -739,18 +707,14 @@
 #endif
 
 	if (IS_IPV6(skb) || IS_VLAN_IPV6(skb) || IS_PPPOE_IPV6(skb)) {
-		/* If the flag is set for this bridge to disable bridge-netfilter hooks, 
-		   that will override the global flag which enables / disables the hooks */
-		if (br->nf_disable_ip6tables || (!brnf_call_ip6tables && !br->nf_call_ip6tables))
+		if (!brnf_call_ip6tables && !br->nf_call_ip6tables)
 			return NF_ACCEPT;
 
 		nf_bridge_pull_encap_header_rcsum(skb);
 		return br_nf_pre_routing_ipv6(hook, skb, in, out, okfn);
 	}
 
-	/* If the flag is set for this bridge to disable bridge-netfilter hooks, 
-	   that will override the global flag which enables / disables the hooks */
-	if (br->nf_disable_iptables || (!brnf_call_iptables && !br->nf_call_iptables))
+	if (!brnf_call_iptables && !br->nf_call_iptables)
 		return NF_ACCEPT;
 
 	if (!IS_IP(skb) && !IS_VLAN_IP(skb) && !IS_PPPOE_IP(skb))
@@ -888,9 +852,7 @@
 		return NF_ACCEPT;
 	br = p->br;
 
-	/* If the flag is set for this bridge to disable bridge-netfilter hooks, 
-	   that will override the global flag which enables / disables the hooks */
-	if (br->nf_disable_arptables || (!brnf_call_arptables && !br->nf_call_arptables))
+	if (!brnf_call_arptables && !br->nf_call_arptables)
 		return NF_ACCEPT;
 
 	if (!IS_ARP(skb)) {
@@ -911,41 +873,29 @@
 	return NF_STOLEN;
 }
 
+#if IS_ENABLED(CONFIG_NF_DEFRAG_IPV4)
 static int br_nf_dev_queue_xmit(struct sk_buff *skb)
 {
-	int frag_max_size;
+	int ret;
 
-#if IS_ENABLED(CONFIG_NF_DEFRAG_IPV4)
 	if (skb->protocol == htons(ETH_P_IP) &&
 	    skb->len + nf_bridge_mtu_reduction(skb) > skb->dev->mtu &&
 	    !skb_is_gso(skb)) {
 		if (br_parse_ip_options(skb))
 			/* Drop invalid packet */
 			return NF_DROP;
-		return ip_fragment(skb, br_dev_queue_push_xmit);
-	}
-#endif
-#if IS_ENABLED(CONFIG_NF_DEFRAG_IPV6)
-	if (skb->protocol == htons(ETH_P_IPV6) &&
-		skb->len + nf_bridge_mtu_reduction(skb) > skb->dev->mtu &&
-		!skb_is_gso(skb)) {
-		const struct nf_ipv6_ops *v6ops = nf_get_ipv6_ops();
-
-		frag_max_size = BR_INPUT_SKB_CB(skb)->frag_max_size;
-		if (br_validate_ipv6(skb))
-		/* Drop invalid packet */
-			return NF_DROP;
-
-		IP6CB(skb)->frag_max_size = frag_max_size;
+		ret = ip_fragment(skb, br_dev_queue_push_xmit);
+	} else
+		ret = br_dev_queue_push_xmit(skb);
 
-		if (v6ops)
-			return v6ops->fragment(skb, br_dev_queue_push_xmit);
-		else
-			return -EMSGSIZE;
-	}
-#endif
-	return br_dev_queue_push_xmit(skb);
+	return ret;
 }
+#else
+static int br_nf_dev_queue_xmit(struct sk_buff *skb)
+{
+        return br_dev_queue_push_xmit(skb);
+}
+#endif
 
 /* PF_BRIDGE/POST_ROUTING ********************************************/
 static unsigned int br_nf_post_routing(unsigned int hook, struct sk_buff *skb,
diff -Naur a/net/bridge/br_private.h b/net/bridge/br_private.h
--- a/net/bridge/br_private.h	2017-10-11 10:17:41.038360000 +0530
+++ b/net/bridge/br_private.h	2017-10-11 09:38:03.237773000 +0530
@@ -18,7 +18,6 @@
 #include <linux/netpoll.h>
 #include <linux/u64_stats_sync.h>
 #include <net/route.h>
-#include <net/ip6_fib.h>
 #include <linux/if_vlan.h>
 
 #define BR_HASH_BITS 8
@@ -317,22 +316,10 @@
 	spinlock_t			hash_lock;
 	struct hlist_head		hash[BR_HASH_SIZE];
 #ifdef CONFIG_BRIDGE_NETFILTER
-	union {
-		struct rtable           fake_rtable;
-		struct rt6_info         fake_rt6_info;
-	};
+	struct rtable 			fake_rtable;
 	bool				nf_call_iptables;
 	bool				nf_call_ip6tables;
 	bool				nf_call_arptables;
-	/* These non-standard parameters allow disabling the bridge-netfilter hooks 
-	   even if those hooks are enabled globally.  This is to support special bridge
-	   configurations which NEED to bypass the bridge-netfilter hooks, for example 
-	   to avoid fragmented packets being reassembled and re-fragmented, and to 
-	   avoid negative performance impact from unecessarily calling those hooks */
-	bool				nf_disable_iptables;
-	bool				nf_disable_ip6tables;
-	bool				nf_disable_arptables;
-    
 #endif
 	u16				group_fwd_mask;
 
@@ -412,7 +399,6 @@
 
 struct br_input_skb_cb {
 	struct net_device *brdev;
-	int frag_max_size;
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	int igmp;
 	int mrouters_only;
diff -Naur a/net/bridge/br_sysfs_br.c b/net/bridge/br_sysfs_br.c
--- a/net/bridge/br_sysfs_br.c	2017-10-11 10:17:41.138361000 +0530
+++ b/net/bridge/br_sysfs_br.c	2017-10-11 09:38:03.321783000 +0530
@@ -715,74 +715,6 @@
 }
 static DEVICE_ATTR(nf_call_arptables, S_IRUGO | S_IWUSR,
 		   show_nf_call_arptables, store_nf_call_arptables);
-
-static ssize_t show_nf_disable_iptables(
-	struct device *d, struct device_attribute *attr, char *buf)
-{
-	struct net_bridge *br = to_bridge(d);
-	return sprintf(buf, "%u\n", br->nf_disable_iptables);
-}
-
-static int set_nf_disable_iptables(struct net_bridge *br, unsigned long val)
-{
-	br->nf_disable_iptables = val ? true : false;
-	return 0;
-}
-
-static ssize_t store_nf_disable_iptables(
-	struct device *d, struct device_attribute *attr, const char *buf,
-	size_t len)
-{
-	return store_bridge_parm(d, buf, len, set_nf_disable_iptables);
-}
-static DEVICE_ATTR(nf_disable_iptables, S_IRUGO | S_IWUSR,
-		   show_nf_disable_iptables, store_nf_disable_iptables);
-
-static ssize_t show_nf_disable_ip6tables(
-	struct device *d, struct device_attribute *attr, char *buf)
-{
-	struct net_bridge *br = to_bridge(d);
-	return sprintf(buf, "%u\n", br->nf_disable_ip6tables);
-}
-
-static int set_nf_disable_ip6tables(struct net_bridge *br, unsigned long val)
-{
-	br->nf_disable_ip6tables = val ? true : false;
-	return 0;
-}
-
-static ssize_t store_nf_disable_ip6tables(
-	struct device *d, struct device_attribute *attr, const char *buf,
-	size_t len)
-{
-	return store_bridge_parm(d, buf, len, set_nf_disable_ip6tables);
-}
-static DEVICE_ATTR(nf_disable_ip6tables, S_IRUGO | S_IWUSR,
-		   show_nf_disable_ip6tables, store_nf_disable_ip6tables);
-
-static ssize_t show_nf_disable_arptables(
-	struct device *d, struct device_attribute *attr, char *buf)
-{
-	struct net_bridge *br = to_bridge(d);
-	return sprintf(buf, "%u\n", br->nf_disable_arptables);
-}
-
-static int set_nf_disable_arptables(struct net_bridge *br, unsigned long val)
-{
-	br->nf_disable_arptables = val ? true : false;
-	return 0;
-}
-
-static ssize_t store_nf_disable_arptables(
-	struct device *d, struct device_attribute *attr, const char *buf,
-	size_t len)
-{
-	return store_bridge_parm(d, buf, len, set_nf_disable_arptables);
-}
-static DEVICE_ATTR(nf_disable_arptables, S_IRUGO | S_IWUSR,
-		   show_nf_disable_arptables, store_nf_disable_arptables);
-
-
 #endif
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 static ssize_t show_vlan_filtering(struct device *d,
@@ -843,10 +775,6 @@
 	&dev_attr_nf_call_iptables.attr,
 	&dev_attr_nf_call_ip6tables.attr,
 	&dev_attr_nf_call_arptables.attr,
-	&dev_attr_nf_disable_iptables.attr,
-	&dev_attr_nf_disable_ip6tables.attr,
-	&dev_attr_nf_disable_arptables.attr,
-	
 #endif
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	&dev_attr_vlan_filtering.attr,
diff -Naur a/net/bridge/intel_br_l2vpn.c b/net/bridge/intel_br_l2vpn.c
--- a/net/bridge/intel_br_l2vpn.c	2017-10-11 10:17:41.136376000 +0530
+++ b/net/bridge/intel_br_l2vpn.c	2017-10-11 09:38:03.319795000 +0530
@@ -57,7 +57,7 @@
 
 	struct net_bridge       *br;
 	struct net_bridge_port  *p;
-//    struct l2_sph       *handle;
+    struct l2_sph       *handle;
  
     int                 ret = 0;
 	/* Get bridge port. */ 
@@ -77,7 +77,6 @@
 
     }
     ret = br->l2vpn_packet_handler(skb, l2vpnRelate); 
-    return ret;
     
 }
 
diff -Naur a/net/bridge/netfilter/Kconfig b/net/bridge/netfilter/Kconfig
--- a/net/bridge/netfilter/Kconfig	2017-10-11 10:17:41.079364000 +0530
+++ b/net/bridge/netfilter/Kconfig	2017-10-11 09:38:03.270789000 +0530
@@ -201,6 +201,16 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config BRIDGE_EBT_FORWARD
+	tristate "ebt: forward target support"
+	help
+	  This option adds the forward target, which allows bypassing the normal
+	  bridging logic and forcing an Ethernet frame to be forwarded to a specific
+	  device, as long as it is connected to the same bridge the frame
+	  arrived on.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config BRIDGE_EBT_SNAT
 	tristate "ebt: snat target support"
 	help
diff -Naur a/net/bridge/ti_br_sf.c b/net/bridge/ti_br_sf.c
--- a/net/bridge/ti_br_sf.c	2017-10-11 10:17:41.150371000 +0530
+++ b/net/bridge/ti_br_sf.c	2017-10-11 09:38:03.333785000 +0530
@@ -90,7 +90,7 @@
        For all the cases of cloning make sure the BYPASS flag is set. */
         if (1 != count)
         {
-            TI_HIL_ADD_PP_INFO_FLAGS(skb, TI_HIL_PACKET_FLAG_PP_SESSION_BYPASS);
+           TI_HIL_ADD_PP_INFO_FLAGS(skb, TI_HIL_PACKET_FLAG_PP_SESSION_BYPASS);
         }
 #endif
 
diff -Naur a/net/core/dev.c b/net/core/dev.c
--- a/net/core/dev.c	2017-10-11 10:17:39.950263000 +0530
+++ b/net/core/dev.c	2017-10-11 09:38:02.117700000 +0530
@@ -139,26 +139,6 @@
 #include <linux/avalanche/puma7/puma7_defs.h>
 #endif
 
-#ifdef CONFIG_TI_DEVICE_PROTOCOL_HANDLING
-extern int ti_protocol_handler (struct net_device* dev, struct sk_buff *skb);
-#endif
-#ifdef CONFIG_TI_DEVICE_INDEX_REUSE
-extern int ti_dev_new_index(struct net *net);
-#endif /* CONFIG_TI_DEVICE_INDEX_REUSE */
-#ifdef CONFIG_TI_L2_SELECTIVE_FORWARDER
-extern void ti_save_netdevice_info(struct net_device *dev);
-extern void ti_free_netdevice_info(struct net_device *dev);
-#endif /* CONFIG_TI_L2_SELECTIVE_FORWARDER */
-#ifdef CONFIG_TI_EGRESS_HOOK
-extern int ti_egress_hook_handler (struct net_device* dev, struct sk_buff *skb);
-#endif /* CONFIG_TI_EGRESS_HOOK */
-#ifdef CONFIG_TI_DOCSIS_EGRESS_HOOK
-extern int ti_docsis_egress_hook_handler (struct net_device* dev, struct sk_buff *skb);
-#endif /* CONFIG_TI_DOCSIS_EGRESS_HOOK */
-#ifdef CONFIG_TI_GW_EGRESS_HOOK
-extern int ti_gw_egress_hook_handler (struct net_device* dev, struct sk_buff *skb);
-#endif /* CONFIG_TI_GW_EGRESS_HOOK */
-
 /* Instead of increasing this, you should create a hash table. */
 #define MAX_GRO_SKBS 8
 
@@ -370,6 +350,25 @@
 }
 #endif
 
+#ifdef CONFIG_TI_DEVICE_PROTOCOL_HANDLING
+extern int ti_protocol_handler (struct net_device* dev, struct sk_buff *skb);
+#endif
+#ifdef CONFIG_TI_DEVICE_INDEX_REUSE
+extern int ti_dev_new_index(struct net *net);
+#endif /* CONFIG_TI_DEVICE_INDEX_REUSE */
+#ifdef CONFIG_TI_L2_SELECTIVE_FORWARDER
+extern void ti_save_netdevice_info(struct net_device *dev);
+extern void ti_free_netdevice_info(struct net_device *dev);
+#endif /* CONFIG_TI_L2_SELECTIVE_FORWARDER */
+#ifdef CONFIG_TI_EGRESS_HOOK
+extern int ti_egress_hook_handler (struct net_device* dev, struct sk_buff *skb);
+#endif /* CONFIG_TI_EGRESS_HOOK */
+#ifdef CONFIG_TI_DOCSIS_EGRESS_HOOK
+extern int ti_docsis_egress_hook_handler (struct net_device* dev, struct sk_buff *skb);
+#endif /* CONFIG_TI_DOCSIS_EGRESS_HOOK */
+#ifdef CONFIG_TI_GW_EGRESS_HOOK
+extern int ti_gw_egress_hook_handler (struct net_device* dev, struct sk_buff *skb);
+#endif /* CONFIG_TI_GW_EGRESS_HOOK */
 /*******************************************************************************
 
 		Protocol management and registration routines
@@ -2835,6 +2834,7 @@
 
 #endif
 
+
 /**
  *	dev_loopback_xmit - loop back @skb
  *	@skb: buffer to transmit
@@ -3698,7 +3698,6 @@
 	pt_prev = NULL;
 
 another_round:
-
 #ifdef CONFIG_TI_DEVICE_PROTOCOL_HANDLING
     if (ti_protocol_handler (skb->dev, skb) < 0)
     {
@@ -3706,7 +3705,6 @@
 		goto out;
     }
 #endif /* CONFIG_TI_DEVICE_PROTOCOL_HANDLING */
-
 	if (toe_receive_skb_hook && toe_receive_skb_hook(skb)) {
 		ret = NET_RX_SUCCESS;
 		goto out;
@@ -4134,7 +4132,7 @@
             if (NAPI_GRO_CB(skb)->free == NAPI_GRO_FREE_STOLEN_HEAD)
             {
 #if PUMA7_OR_NEWER_SOC_TYPE && CONFIG_TI_PACKET_PROCESSOR
-                kfree_skb_intel_cookie( SKB_GET_COOKIE_P(skb) );
+                kfree_pp_packet_info( (skb)->pp_packet_info );
 #endif
                 kmem_cache_free(skbuff_head_cache, skb);
             }
@@ -5865,7 +5863,6 @@
 		}
 #endif /* CONFIG_TI_DEVICE_INDEX_REUSE */
 	}
-
 	else if (__dev_get_by_index(net, dev->ifindex))
 		goto err_uninit;
 
@@ -6334,7 +6331,6 @@
 #endif
     dev->qos_virtual_scheme_idx = NETDEV_PP_QOS_PROFILE_DEFAULT;
 #endif /* CONFIG_TI_PACKET_PROCESSOR */
-
 	setup(dev);
 
 	dev->num_tx_queues = txqs;
@@ -7004,7 +7000,6 @@
             return -1;
     }
 #endif /* CONFIG_TI_HIL_PROFILE_STATIC */
-
 	/*
 	 *	Initialise the packet receive queues.
 	 */
diff -Naur a/net/core/rtnetlink.c b/net/core/rtnetlink.c
--- a/net/core/rtnetlink.c	2017-10-11 10:17:40.003268000 +0530
+++ b/net/core/rtnetlink.c	2017-10-11 09:38:02.185688000 +0530
@@ -558,7 +558,7 @@
 		atomic_inc(&skb->users);
 	netlink_broadcast(rtnl, skb, pid, group, GFP_KERNEL);
 	if (echo)
-		err = netlink_unicast(rtnl, skb, pid, MSG_DONTWAIT, 0);
+		err = netlink_unicast(rtnl, skb, pid, MSG_DONTWAIT);
 	return err;
 }
 
@@ -566,7 +566,7 @@
 {
 	struct sock *rtnl = net->rtnl;
 
-	return nlmsg_unicast(rtnl, skb, pid, 0);
+	return nlmsg_unicast(rtnl, skb, pid);
 }
 EXPORT_SYMBOL(rtnl_unicast);
 
diff -Naur a/net/core/skbuff.c b/net/core/skbuff.c
--- a/net/core/skbuff.c	2017-10-11 10:17:39.971272000 +0530
+++ b/net/core/skbuff.c	2017-10-11 09:38:02.147703000 +0530
@@ -108,7 +108,7 @@
 EXPORT_SYMBOL(sysctl_max_skb_frags);
 #ifdef CONFIG_TI_PACKET_PROCESSOR
 #if PUMA7_OR_NEWER_SOC_TYPE
-struct kmem_cache *skbuff_intel_cookie_cache __read_mostly;
+struct kmem_cache *skbuff_pp_info_cache __read_mostly;
 #endif
 #endif
 
@@ -230,8 +230,8 @@
 void __init intel_cache_init(void)
 {
 #ifdef CONFIG_TI_PACKET_PROCESSOR
-    skbuff_intel_cookie_cache = kmem_cache_create("skbuff_intel_cookie_cache",
-                                             sizeof(SKB_INTEL_COOKIE),
+    skbuff_pp_info_cache = kmem_cache_create("skbuff_pp_info_cache",
+                                             sizeof(PP_PACKET_INFO_t),
                                              0,
                                              SLAB_HWCACHE_ALIGN | SLAB_PANIC,
                                              NULL);
@@ -239,24 +239,25 @@
 }
 
 #ifdef CONFIG_TI_PACKET_PROCESSOR
-void* __alloc_skb_intel_cookie(void)
+void* __alloc_skb_pp_packet_info(void)
 {
-    SKB_INTEL_COOKIE *  cookie_ptr;
+    PP_PACKET_INFO_t *pp_info;
 
     /* Get the HEAD */
-    cookie_ptr = kmem_cache_alloc_node(skbuff_intel_cookie_cache, GFP_ATOMIC, NUMA_NO_NODE);
-    if (!cookie_ptr)
-        return cookie_ptr;
-    prefetchw(cookie_ptr);
-    return (void *) cookie_ptr;
+    pp_info = kmem_cache_alloc_node(skbuff_pp_info_cache, GFP_ATOMIC, NUMA_NO_NODE);
+    if (!pp_info)
+        return pp_info;
+
+    prefetchw(pp_info);
+    return (void *) pp_info;
 }
-EXPORT_SYMBOL(__alloc_skb_intel_cookie);
+EXPORT_SYMBOL(__alloc_skb_pp_packet_info);
 
-void kfree_skb_intel_cookie(void *cookie_ptr)
+void kfree_pp_packet_info(void *pp_info)
 {
-    kmem_cache_free(skbuff_intel_cookie_cache, cookie_ptr);
+    kmem_cache_free(skbuff_pp_info_cache, pp_info);
 }
-EXPORT_SYMBOL(kfree_skb_intel_cookie);
+EXPORT_SYMBOL(kfree_pp_packet_info);
 #endif /* CONFIG_TI_PACKET_PROCESSOR */
 #endif
 /**
@@ -270,8 +271,8 @@
 {
 #ifdef CONFIG_TI_PACKET_PROCESSOR
 #if PUMA7_OR_NEWER_SOC_TYPE
-    SKB_GET_COOKIE_P(skb) = __alloc_skb_intel_cookie();
-    if (!SKB_GET_COOKIE_P(skb))
+    skb->pp_packet_info = __alloc_skb_pp_packet_info();
+    if (!skb->pp_packet_info)
     {
         return -1;
     }
@@ -300,8 +301,20 @@
 #ifndef CONFIG_MACH_PUMA5
     SKB_GET_PP_INFO_P(skb)->pp_session.session_handle = AVALANCHE_PP_MAX_ACCELERATED_SESSIONS; /* Set invalid session */
 #endif
+#ifdef PPP_DEBUG
+#ifdef CONFIG_FTRACE
+    SKB_GET_PP_INFO_P(skb)->ppp_packet_info.allocTime = sched_clock();
+#endif
+#endif
 #endif  /* CONFIG_TI_PACKET_PROCESSOR */
 
+#ifdef CONFIG_TI_PACKET_PROCESSOR_STATS
+    SKB_GET_PP_INFO_P(skb)->ti_match_llc_filter = NULL;
+    SKB_GET_PP_INFO_P(skb)->ti_match_inbound_ip_filter = NULL;
+    SKB_GET_PP_INFO_P(skb)->ti_match_outbound_ip_filter = NULL;
+    SKB_GET_PP_INFO_P(skb)->ti_match_qos_classifier = NULL;
+    SKB_GET_PP_INFO_P(skb)->ti_match_dsg_filter = NULL;
+#endif  /* CONFIG_TI_PACKET_PROCESSOR_STATS */
     return 0;
 }
 
@@ -708,7 +721,7 @@
         {
 	#ifdef CONFIG_TI_PACKET_PROCESSOR
 	#if PUMA7_OR_NEWER_SOC_TYPE
-            kfree_skb_intel_cookie( SKB_GET_COOKIE_P(skb) );
+            kfree_pp_packet_info( skb->pp_packet_info );
         #endif
 	#endif
 		kmem_cache_free(skbuff_head_cache, skb);
@@ -721,8 +734,8 @@
         {
 	#ifdef CONFIG_TI_PACKET_PROCESSOR
 	#if PUMA7_OR_NEWER_SOC_TYPE
-            kfree_skb_intel_cookie( SKB_GET_COOKIE_P(skb  ) );
-            kfree_skb_intel_cookie( SKB_GET_COOKIE_P(skb+1) );
+            kfree_pp_packet_info( (skb  )->pp_packet_info );
+            kfree_pp_packet_info( (skb+1)->pp_packet_info );
         #endif
 	#endif
 			kmem_cache_free(skbuff_fclone_cache, skb);
@@ -742,8 +755,8 @@
         {
 	#ifdef CONFIG_TI_PACKET_PROCESSOR
 	#if PUMA7_OR_NEWER_SOC_TYPE
-            kfree_skb_intel_cookie( SKB_GET_COOKIE_P(skb  ) );
-            kfree_skb_intel_cookie( SKB_GET_COOKIE_P(skb-1) );
+            kfree_pp_packet_info( (skb  )->pp_packet_info );
+            kfree_pp_packet_info( (skb-1)->pp_packet_info );
         #endif
 	#endif
 			kmem_cache_free(skbuff_fclone_cache, other);
@@ -978,6 +991,13 @@
 #endif /* CONFIG_TI_L2_SELECTIVE_FORWARDER */
 #ifdef CONFIG_TI_PACKET_PROCESSOR
 memcpy((void *)SKB_GET_PP_INFO_P(n), (void *)SKB_GET_PP_INFO_P(skb), sizeof(*SKB_GET_PP_INFO_P(skb)));
+#ifdef PPP_DEBUG
+    SKB_GET_PP_INFO_P(n)->ppp_packet_info.num_clones++;
+#ifdef CONFIG_FTRACE
+    if (n->fclone == SKB_FCLONE_UNAVAILABLE)
+        SKB_GET_PP_INFO_P(n)->ppp_packet_info.allocTime = sched_clock();
+#endif  /* CONFIG_FTRACE */
+#endif  /* PPP_DEBUG */
 #endif  /* CONFIG_TI_PACKET_PROCESSOR */
 	return n;
 #undef C
@@ -1154,6 +1174,9 @@
 #endif /* CONFIG_TI_L2_SELECTIVE_FORWARDER */
 #ifdef CONFIG_TI_PACKET_PROCESSOR
     memcpy((void *)SKB_GET_PP_INFO_P(new), (void *)SKB_GET_PP_INFO_P(old), sizeof(*SKB_GET_PP_INFO_P(old)));
+#ifdef PPP_DEBUG
+    SKB_GET_PP_INFO_P(new)->ppp_packet_info.num_copies++;
+#endif
 #endif  /* CONFIG_TI_PACKET_PROCESSOR */
 }
 
@@ -3723,7 +3746,7 @@
 		skb_release_head_state(skb);
 	#ifdef CONFIG_TI_PACKET_PROCESSOR
 	#if PUMA7_OR_NEWER_SOC_TYPE
-    kfree_skb_intel_cookie( SKB_GET_COOKIE_P(skb) );
+	kfree_pp_packet_info( (skb)->pp_packet_info );
 	#endif
         #endif
 		kmem_cache_free(skbuff_head_cache, skb);
@@ -3942,4 +3965,5 @@
 	kfree_skb(skb);
 	return NULL;
 }
+EXPORT_SYMBOL(skb_vlan_untag);
 
diff -Naur a/net/core/ti_dev.c b/net/core/ti_dev.c
--- a/net/core/ti_dev.c	2017-10-11 10:17:39.957268000 +0530
+++ b/net/core/ti_dev.c	2017-10-11 09:38:02.130691000 +0530
@@ -511,4 +511,4 @@
 EXPORT_SYMBOL(ti_deregister_gw_egress_hook_handler);
 
 #endif /* CONFIG_TI_GW_EGRESS_HOOK */
- 
+
diff -Naur a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c
--- a/net/ipv4/fib_frontend.c	2017-10-11 10:17:41.911429000 +0530
+++ b/net/ipv4/fib_frontend.c	2017-10-11 09:38:03.902851000 +0530
@@ -978,7 +978,7 @@
 	portid = NETLINK_CB(skb).portid;      /* netlink portid */
 	NETLINK_CB(skb).portid = 0;        /* from kernel */
 	NETLINK_CB(skb).dst_group = 0;  /* unicast */
-	netlink_unicast(net->ipv4.fibnl, skb, portid, MSG_DONTWAIT, 0);
+	netlink_unicast(net->ipv4.fibnl, skb, portid, MSG_DONTWAIT);
 }
 
 static int __net_init nl_fib_lookup_init(struct net *net)
diff -Naur a/net/ipv4/igmp.c b/net/ipv4/igmp.c
--- a/net/ipv4/igmp.c	2017-10-11 10:17:41.705410000 +0530
+++ b/net/ipv4/igmp.c	2017-10-11 09:38:03.693811000 +0530
@@ -105,6 +105,7 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #endif
+
 #define IP_MAX_MEMBERSHIPS	20
 #define IP_MAX_MSF		10
 
diff -Naur a/net/ipv4/inet_diag.c b/net/ipv4/inet_diag.c
--- a/net/ipv4/inet_diag.c	2017-10-11 10:17:41.836422000 +0530
+++ b/net/ipv4/inet_diag.c	2017-10-11 09:38:03.831835000 +0530
@@ -356,7 +356,7 @@
 		goto out;
 	}
 	err = netlink_unicast(net->diag_nlsk, rep, NETLINK_CB(in_skb).portid,
-			      MSG_DONTWAIT, 0);
+			      MSG_DONTWAIT);
 	if (err > 0)
 		err = 0;
 
diff -Naur a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c
--- a/net/ipv4/ip_forward.c	2017-10-11 10:17:41.878427000 +0530
+++ b/net/ipv4/ip_forward.c	2017-10-11 09:38:03.876825000 +0530
@@ -182,7 +182,9 @@
 	    !skb_sec_path(skb))
 		ip_rt_send_redirect(skb);
 
+#ifndef CONFIG_LANTIQ_IPQOS
 	skb->priority = rt_tos2priority(iph->tos);
+#endif
 
 	return NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD, skb, skb->dev,
 		       rt->dst.dev, ip_forward_finish);
diff -Naur a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
--- a/net/ipv4/ip_input.c	2017-10-11 10:17:41.857422000 +0530
+++ b/net/ipv4/ip_input.c	2017-10-11 09:38:03.851826000 +0530
@@ -372,7 +372,7 @@
 
 drop:
 
-#if defined(CONFIG_APPCPU_GW_PP_HANDLE) || defined(CONFIG_TI_PACKET_PROCESSOR)
+#ifdef CONFIG_TI_PACKET_PROCESSOR
     /* Create a NULL PP device, to drop all dropped packets before they reach the host */
     ti_hil_pp_event (TI_IP_DISCARD_PKT_IPV4, (void *)skb);
 #endif
diff -Naur a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
--- a/net/ipv4/ip_output.c	2017-10-11 10:17:41.913423000 +0530
+++ b/net/ipv4/ip_output.c	2017-10-11 09:38:03.904841000 +0530
@@ -80,10 +80,6 @@
 #include <linux/netlink.h>
 #include <linux/tcp.h>
 
-#if defined(CONFIG_LTQ_PPA_API) || defined(CONFIG_LTQ_PPA_API_MODULE)
-  #include <net/ppa_api.h>
-#endif
-
 #if PUMA7_OR_NEWER_SOC_TYPE
 #ifdef CONFIG_ARM_AVALANCHE_SOC
 #include <asm-arm/arch-avalanche/generic/pal_cppi41.h>
@@ -91,6 +87,12 @@
 #include <linux/avalanche/generic/pal_cppi41.h>
 #endif
 #endif
+
+#if defined(CONFIG_LTQ_PPA_API) || defined(CONFIG_LTQ_PPA_API_MODULE)
+  #include <net/ppa_api.h>
+#endif
+
+
 #ifdef CONFIG_TI_DOCSIS_INPUT_DEV
 #define DBRIDGE_IFINDEX_CHK(__ifindex, format, args...) \
 { \
@@ -183,15 +185,6 @@
 		iph->ihl += opt->opt.optlen>>2;
 		ip_options_build(skb, &opt->opt, daddr, rt, 0);
 	}
-#ifdef CONFIG_TI_PACKET_PROCESSOR
-#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
-    const struct nf_conn *ct = (struct nf_conn *)skb->nfct;
-    if (ct != NULL)
-    {
-        ti_hil_pp_event( TI_CT_NETFILTER_CANCEL_DISCARD_ACCELERATION, (void *)ct );
-    }
-#endif
-#endif
 
 	skb->priority = sk->sk_priority;
 	skb->mark = sk->sk_mark;
@@ -229,6 +222,16 @@
 		consume_skb(skb);
 		skb = skb2;
 	}
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
+    const struct nf_conn *ct = (struct nf_conn *)skb->nfct;
+    if (ct != NULL)
+    {
+        ti_hil_pp_event( TI_CT_NETFILTER_CANCEL_DISCARD_ACCELERATION, (void *)ct );
+    }
+#endif
+#endif
+
 #if defined(CONFIG_LTQ_PPA_API) || defined(CONFIG_LTQ_PPA_API_MODULE)
         if ( ppa_hook_session_add_fn != NULL )
         {
@@ -502,6 +505,10 @@
 #if defined(CONFIG_IP_VS) || defined(CONFIG_IP_VS_MODULE)
 	to->ipvs_property = from->ipvs_property;
 #endif
+
+#ifdef CONFIG_APPCPU_GW_PP_HANDLE
+    memcpy((void *)SKB_GET_PP_INFO_P(to), (void *)SKB_GET_PP_INFO_P(from), sizeof(*SKB_GET_PP_INFO_P(from)));
+#endif
 #ifdef CONFIG_TI_DOCSIS_INPUT_DEV
     to->ti_docsis_input_dev = from->ti_docsis_input_dev;
     if (to->ti_docsis_input_dev)
@@ -517,7 +524,7 @@
 #endif /* CONFIG_TI_L2_SELECTIVE_FORWARDER */
 #ifdef CONFIG_TI_PACKET_PROCESSOR
     memcpy((void *)SKB_GET_PP_INFO_P(to), (void *)SKB_GET_PP_INFO_P(from), sizeof(*SKB_GET_PP_INFO_P(from)));
-#endif
+#endif /* CONFIG_TI_PACKET_PROCESSOR */
 	skb_copy_secmark(to, from);
 }
 
@@ -782,7 +789,6 @@
 
 		ip_send_check(iph);
 #ifdef CONFIG_TI_PACKET_PROCESSOR
-        /* If this is not the last frag, clear the PTID Flag */
         if (left > 0 )
         {
 #ifdef PUMA7_OR_NEWER_SOC_TYPE
diff -Naur a/net/ipv4/ip_tunnel.c b/net/ipv4/ip_tunnel.c
--- a/net/ipv4/ip_tunnel.c	2017-10-11 10:17:41.713413000 +0530
+++ b/net/ipv4/ip_tunnel.c	2017-10-11 09:38:03.704813000 +0530
@@ -645,10 +645,7 @@
 
 	df = tnl_params->frag_off;
 	if (skb->protocol == htons(ETH_P_IP))
-        /* change from '|' to '&' to support GREv4 outer packet ipv4
-         fragmentation based on the white paper recommendations
-         http://www.cisco.com/c/en/us/support/docs/ip/generic-routing-encapsulation-gre/25885-pmtud-ipfrag.html */
-		df &= (inner_iph->frag_off&htons(IP_DF));
+		df |= (inner_iph->frag_off&htons(IP_DF));
 
 	max_headroom = LL_RESERVED_SPACE(rt->dst.dev) + sizeof(struct iphdr)
 			+ rt->dst.header_len;
diff -Naur a/net/ipv4/netfilter/Kconfig b/net/ipv4/netfilter/Kconfig
--- a/net/ipv4/netfilter/Kconfig	2017-10-11 10:17:41.773432000 +0530
+++ b/net/ipv4/netfilter/Kconfig	2017-10-11 09:38:03.755825000 +0530
@@ -1,5 +1,3 @@
-# Includes Intel Corporation's changes/modifications dated: 2014.
-# Changed/modified portions - Copyright  2014, Intel Corporation.
 #
 # IP netfilter configuration
 #
@@ -144,16 +142,6 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
-config IP_NF_TARGET_TRIGGER
-	tristate "TRIGGER target support (port-trigger)"
-	depends on NF_NAT 
-	help
-         Port triggering is a specialized form of port forwarding in which
-         outbound traffic on predetermined ports "triggering ports") causes
-         inbound traffic to specific incoming ports to be dynamically
-         forwarded to the initiating host while the outbound ports are in use.
-         To compile it as a module, choose M here.  If unsure, say N.
-
 # NAT + specific targets: nf_conntrack
 config NF_NAT_IPV4
 	tristate "IPv4 NAT"
@@ -321,6 +309,18 @@
 	 
 	  If unsure, say N.
 
+config IP_NF_TARGET_TRIGGER
+       tristate 'TRIGGER target support (port-trigger)'
+       depends on NF_NAT
+       help
+         Port triggering is a specialized form of port forwarding in which
+         outbound traffic on predetermined ports "triggering ports") causes
+         inbound traffic to specific incoming ports to be dynamically
+         forwarded to the initiating host while the outbound ports are in use.
+
+         To compile it as a module, choose M here.  If unsure, say N.
+
+
 endif # IP_NF_IPTABLES
 
 # ARP tables
diff -Naur a/net/ipv4/netfilter/Makefile b/net/ipv4/netfilter/Makefile
--- a/net/ipv4/netfilter/Makefile	2017-10-11 10:17:41.772419000 +0530
+++ b/net/ipv4/netfilter/Makefile	2017-10-11 09:38:03.754826000 +0530
@@ -1,5 +1,3 @@
-# Includes Intel Corporation's changes/modifications dated: 2014.
-# Changed/modified portions - Copyright  2014, Intel Corporation.
 #
 # Makefile for the netfilter modules on top of IPv4.
 #
diff -Naur a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c
--- a/net/ipv4/netfilter/ip_tables.c	2017-10-11 10:17:41.782418000 +0530
+++ b/net/ipv4/netfilter/ip_tables.c	2017-10-11 09:38:03.770822000 +0530
@@ -9,13 +9,6 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-
-/*
-    Includes Intel Corporation's changes/modifications dated: [Mar.2017].
-    Changed/modified portions - Copyright  2017, Intel Corporation
-    1. PP Hook
-*/
-
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 #include <linux/cache.h>
 #include <linux/capability.h>
@@ -32,7 +25,7 @@
 #include <linux/proc_fs.h>
 #include <linux/err.h>
 #include <linux/cpumask.h>
-
+#include <linux/ti_hil.h>
 #include <linux/netfilter/x_tables.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <linux/ti_hil.h>
@@ -43,10 +36,6 @@
 #include <linux/ti_hil.h>
 #endif
 
-#ifdef CONFIG_TI_PACKET_PROCESSOR
-#include <linux/ti_hil.h>
-#endif
-
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
 MODULE_DESCRIPTION("IPv4 packet filter");
@@ -519,20 +508,6 @@
     }
 #endif
 
-#ifdef CONFIG_TI_PACKET_PROCESSOR
-    if (acpar.hotdrop)
-    {
-        ti_hil_pp_event (TI_CT_NETFILTER_DISCARD_PKT, (void *)skb);
-    }
-    else
-    {
-        if (verdict == NF_DROP)
-        {
-            ti_hil_pp_event(TI_CT_NETFILTER_DISCARD_PKT, (void *)skb);
-        }
-    }
-#endif
-
 #ifdef DEBUG_ALLOW_ALL
 	return NF_ACCEPT;
 #else
@@ -1349,7 +1324,7 @@
 	}
 	vfree(counters);
 	xt_table_unlock(t);
-#if defined(CONFIG_APPCPU_GW_PP_HANDLE) || defined(CONFIG_TI_PACKET_PROCESSOR)
+#ifdef CONFIG_TI_PACKET_PROCESSOR
         ti_hil_pp_event (TI_CT_NETFILTER_TABLE_UPDATE, (void *)t);
 #endif
 
diff -Naur a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
--- a/net/ipv4/tcp_input.c	2017-10-11 10:17:41.800415000 +0530
+++ b/net/ipv4/tcp_input.c	2017-10-11 09:38:03.787821000 +0530
@@ -87,7 +87,7 @@
 EXPORT_SYMBOL(sysctl_tcp_adv_win_scale);
 
 /* rfc5961 challenge ack rate limiting */
-int sysctl_tcp_challenge_ack_limit = 1000;
+int sysctl_tcp_challenge_ack_limit = 100;
 
 int sysctl_tcp_stdurg __read_mostly;
 int sysctl_tcp_rfc1337 __read_mostly;
@@ -3243,18 +3243,12 @@
 	static u32 challenge_timestamp;
 	static unsigned int challenge_count;
 	u32 now = jiffies / HZ;
-	u32 count;
 
 	if (now != challenge_timestamp) {
-		u32 half = (sysctl_tcp_challenge_ack_limit + 1) >> 1;
-
 		challenge_timestamp = now;
-		WRITE_ONCE(challenge_count, half +
-			   prandom_u32_max(sysctl_tcp_challenge_ack_limit));
+		challenge_count = 0;
 	}
-	count = READ_ONCE(challenge_count);
-	if (count > 0) {
-		WRITE_ONCE(challenge_count, count - 1);
+	if (++challenge_count <= sysctl_tcp_challenge_ack_limit) {
 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
 		tcp_send_ack(sk);
 	}
diff -Naur a/net/ipv4/udp_diag.c b/net/ipv4/udp_diag.c
--- a/net/ipv4/udp_diag.c	2017-10-11 10:17:41.818419000 +0530
+++ b/net/ipv4/udp_diag.c	2017-10-11 09:38:03.811867000 +0530
@@ -80,7 +80,7 @@
 		goto out;
 	}
 	err = netlink_unicast(net->diag_nlsk, rep, NETLINK_CB(in_skb).portid,
-			      MSG_DONTWAIT, 0);
+			      MSG_DONTWAIT);
 	if (err > 0)
 		err = 0;
 out:
diff -Naur a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
--- a/net/ipv6/ip6_output.c	2017-10-11 10:17:40.171283000 +0530
+++ b/net/ipv6/ip6_output.c	2017-10-11 09:38:02.403710000 +0530
@@ -868,7 +868,6 @@
 	kfree_skb(skb);
 	return err;
 }
-EXPORT_SYMBOL(ip6_fragment);
 
 static inline int ip6_rt_check(const struct rt6key *rt_key,
 			       const struct in6_addr *fl_addr,
diff -Naur a/net/ipv6/mcast.c b/net/ipv6/mcast.c
--- a/net/ipv6/mcast.c	2017-10-11 10:17:40.159284000 +0530
+++ b/net/ipv6/mcast.c	2017-10-11 09:38:02.389710000 +0530
@@ -46,6 +46,7 @@
 #include <linux/slab.h>
 #include <linux/pkt_sched.h>
 #include <net/mld.h>
+
 #include <linux/netfilter.h>
 #include <linux/netfilter_ipv6.h>
 
@@ -211,6 +212,7 @@
 	spin_unlock(&ipv6_sk_mc_lock);
 
 	rcu_read_unlock();
+
 	return 0;
 }
 
@@ -243,6 +245,7 @@
 			dev = dev_get_by_index_rcu(net, mc_lst->ifindex);
 			if (dev != NULL) {
 				struct inet6_dev *idev = __in6_dev_get(dev);
+
 				(void) ip6_mc_leave_src(sk, mc_lst, idev);
 				if (idev)
 					__ipv6_dev_mc_dec(idev, &mc_lst->addr);
diff -Naur a/net/ipv6/netfilter/nf_conntrack_reasm.c b/net/ipv6/netfilter/nf_conntrack_reasm.c
--- a/net/ipv6/netfilter/nf_conntrack_reasm.c	2017-10-11 10:17:40.097278000 +0530
+++ b/net/ipv6/netfilter/nf_conntrack_reasm.c	2017-10-11 09:38:02.313699000 +0530
@@ -55,6 +55,7 @@
 {
 	struct inet6_skb_parm	h;
 	int			offset;
+	struct sk_buff		*orig;
 };
 
 #define NFCT_FRAG6_CB(skb)	((struct nf_ct_frag6_skb_cb*)((skb)->cb))
@@ -151,6 +152,12 @@
 	return inet6_hash_frag(nq->id, &nq->saddr, &nq->daddr, nf_frags.rnd);
 }
 
+static void nf_skb_free(struct sk_buff *skb)
+{
+	if (NFCT_FRAG6_CB(skb)->orig)
+		kfree_skb(NFCT_FRAG6_CB(skb)->orig);
+}
+
 static void nf_ct_frag6_expire(unsigned long data)
 {
 	struct frag_queue *fq;
@@ -345,18 +352,17 @@
 
 /*
  *	Check if this packet is complete.
+ *	Returns NULL on failure by any reason, and pointer
+ *	to current nexthdr field in reassembled frame.
  *
  *	It is called with locked fq, and caller must check that
  *	queue is eligible for reassembly i.e. it is not COMPLETE,
  *	the last and the first frames arrived and all the bits are here.
- *
- *	returns true if *prev skb has been transformed into the reassembled
- *	skb, false otherwise.
  */
-static bool
-nf_ct_frag6_reasm(struct frag_queue *fq, struct sk_buff *prev,  struct net_device *dev)
+static struct sk_buff *
+nf_ct_frag6_reasm(struct frag_queue *fq, struct net_device *dev)
 {
-	struct sk_buff *fp, *head = fq->q.fragments;
+	struct sk_buff *fp, *op, *head = fq->q.fragments;
 	int    payload_len;
 	u8 ecn;
 
@@ -367,21 +373,22 @@
 
 	ecn = ip_frag_ecn_table[fq->ecn];
 	if (unlikely(ecn == 0xff))
-		return false;
+		goto out_fail;
 
 	/* Unfragmented part is taken from the first segment. */
 	payload_len = ((head->data - skb_network_header(head)) -
 		       sizeof(struct ipv6hdr) + fq->q.len -
 		       sizeof(struct frag_hdr));
 	if (payload_len > IPV6_MAXPLEN) {
-		net_dbg_ratelimited("nf_ct_frag6_reasm: payload len = %d\n",
-				    payload_len);
-		return false;
+		pr_debug("payload len is too large.\n");
+		goto out_oversize;
 	}
 
 	/* Head of list must not be cloned. */
-	if (skb_unclone(head, GFP_ATOMIC))
-		return false;
+	if (skb_unclone(head, GFP_ATOMIC)) {
+		pr_debug("skb is cloned but can't expand head");
+		goto out_oom;
+	}
 
 	/* If the first fragment is fragmented itself, we split
 	 * it to two chunks: the first with data and paged part
@@ -392,7 +399,7 @@
 
 		clone = alloc_skb(0, GFP_ATOMIC);
 		if (clone == NULL)
-			return false;
+			goto out_oom;
 
 		clone->next = head->next;
 		head->next = clone;
@@ -406,41 +413,10 @@
 		clone->csum = 0;
 		clone->ip_summed = head->ip_summed;
 
+		NFCT_FRAG6_CB(clone)->orig = NULL;
 		add_frag_mem_limit(&fq->q, clone->truesize);
 	}
 
-	/* morph head into last received skb: prev.
-	*
-	* This allows callers of ipv6 conntrack defrag to continue
-	* to use the last skb(frag) passed into the reasm engine.
-	* The last skb frag 'silently' turns into the full reassembled skb.
-	*
-	* Since prev is also part of q->fragments we have to clone it first.
-	*/
-	if (head != prev) {
-		struct sk_buff *iter;
-
-		fp = skb_clone(prev, GFP_ATOMIC);
-		if (!fp)
-			return false;
-
-		fp->next = prev->next;
-
-		iter = head;
-		while (iter) {
-			if (iter->next == prev) {
-				iter->next = fp;
-				break;
-			}
-			iter = iter->next;
-		}
-
-		skb_morph(prev, head);
-		prev->next = head->next;
-		consume_skb(head);
-		head = prev;
-	}
-
 	/* We have to remove fragment header from datagram and to relocate
 	 * header in order to calculate ICV correctly. */
 	skb_network_header(head)[fq->nhoffset] = skb_transport_header(head)[0];
@@ -481,7 +457,31 @@
 	fq->q.fragments = NULL;
 	fq->q.fragments_tail = NULL;
 
-	return true;
+	/* all original skbs are linked into the NFCT_FRAG6_CB(head).orig */
+	fp = skb_shinfo(head)->frag_list;
+	if (fp && NFCT_FRAG6_CB(fp)->orig == NULL)
+		/* at above code, head skb is divided into two skbs. */
+		fp = fp->next;
+
+	op = NFCT_FRAG6_CB(head)->orig;
+	for (; fp; fp = fp->next) {
+		struct sk_buff *orig = NFCT_FRAG6_CB(fp)->orig;
+
+		op->next = orig;
+		op = orig;
+		NFCT_FRAG6_CB(fp)->orig = NULL;
+	}
+
+	return head;
+
+out_oversize:
+	net_dbg_ratelimited("nf_ct_frag6_reasm: payload len = %d\n",
+			    payload_len);
+	goto out_fail;
+out_oom:
+	net_dbg_ratelimited("nf_ct_frag6_reasm: no memory for reassembly\n");
+out_fail:
+	return NULL;
 }
 
 /*
@@ -547,32 +547,44 @@
 	return 0;
 }
 
-int nf_ct_frag6_gather(struct sk_buff *skb, u32 user)
+struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)
 {
+	struct sk_buff *clone;
 	struct net_device *dev = skb->dev;
-	int fhoff, nhoff, ret;
 	struct net *net = skb_dst(skb) ? dev_net(skb_dst(skb)->dev)
 				       : dev_net(skb->dev);
 	struct frag_hdr *fhdr;
 	struct frag_queue *fq;
 	struct ipv6hdr *hdr;
+	int fhoff, nhoff;
 	u8 prevhdr;
+	struct sk_buff *ret_skb = NULL;
 
 	/* Jumbo payload inhibits frag. header */
 	if (ipv6_hdr(skb)->payload_len == 0) {
 		pr_debug("payload len = 0\n");
-		return -EINVAL;
+		return skb;
 	}
 
 	if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)
-		return -EINVAL;
+		return skb;
+
+	clone = skb_clone(skb, GFP_ATOMIC);
+	if (clone == NULL) {
+		pr_debug("Can't clone skb\n");
+		return skb;
+	}
+
+	NFCT_FRAG6_CB(clone)->orig = skb;
 
-	if (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))
-		return -ENOMEM;
+	if (!pskb_may_pull(clone, fhoff + sizeof(*fhdr))) {
+		pr_debug("message is too short.\n");
+		goto ret_orig;
+	}
 
-	skb_set_transport_header(skb, fhoff);
-	hdr = ipv6_hdr(skb);
-	fhdr = (struct frag_hdr *)skb_transport_header(skb);
+	skb_set_transport_header(clone, fhoff);
+	hdr = ipv6_hdr(clone);
+	fhdr = (struct frag_hdr *)skb_transport_header(clone);
 
 	local_bh_disable();
 	inet_frag_evictor(&net->nf_frag.frags, &nf_frags, false);
@@ -580,29 +592,46 @@
 
 	fq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,
 		     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));
-	if (fq == NULL)
-		return -ENOMEM;
+	if (fq == NULL) {
+		pr_debug("Can't find and can't create new queue\n");
+		goto ret_orig;
+	}
 
 	spin_lock_bh(&fq->q.lock);
 
-	if (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {
-		ret = -EINVAL;
-		goto out_unlock;
+	if (nf_ct_frag6_queue(fq, clone, fhdr, nhoff) < 0) {
+		spin_unlock_bh(&fq->q.lock);
+		pr_debug("Can't insert skb to queue\n");
+		inet_frag_put(&fq->q, &nf_frags);
+		goto ret_orig;
 	}
 
-	/* after queue has assumed skb ownership, only 0 or -EINPROGRESS
-	 * must be returned.
-	 */
-	ret = -EINPROGRESS;
 	if (fq->q.last_in == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&
-		fq->q.meat == fq->q.len &&
-		nf_ct_frag6_reasm(fq, skb, dev))
-			ret = 0;
-
-out_unlock:
+	    fq->q.meat == fq->q.len) {
+		ret_skb = nf_ct_frag6_reasm(fq, dev);
+		if (ret_skb == NULL)
+			pr_debug("Can't reassemble fragmented packets\n");
+	}
 	spin_unlock_bh(&fq->q.lock);
+
 	inet_frag_put(&fq->q, &nf_frags);
-	return ret;
+	return ret_skb;
+
+ret_orig:
+	kfree_skb(clone);
+	return skb;
+}
+
+void nf_ct_frag6_consume_orig(struct sk_buff *skb)
+{
+	struct sk_buff *s, *s2;
+
+	for (s = NFCT_FRAG6_CB(skb)->orig; s;) {
+		s2 = s->next;
+		s->next = NULL;
+		consume_skb(s);
+		s = s2;
+	}
 }
 
 static int nf_ct_net_init(struct net *net)
@@ -633,6 +662,7 @@
 	nf_frags.hashfn = nf_hashfn;
 	nf_frags.constructor = ip6_frag_init;
 	nf_frags.destructor = NULL;
+	nf_frags.skb_free = nf_skb_free;
 	nf_frags.qsize = sizeof(struct frag_queue);
 	nf_frags.match = ip6_frag_match;
 	nf_frags.frag_expire = nf_ct_frag6_expire;
diff -Naur a/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c b/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c
--- a/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c	2017-10-11 10:17:40.120288000 +0530
+++ b/net/ipv6/netfilter/nf_defrag_ipv6_hooks.c	2017-10-11 09:38:02.335722000 +0530
@@ -58,7 +58,7 @@
 				const struct net_device *out,
 				int (*okfn)(struct sk_buff *))
 {
-	int err;
+	struct sk_buff *reasm;
 
 #if IS_ENABLED(CONFIG_NF_CONNTRACK)
 	/* Previously seen (loopback)?	*/
@@ -66,12 +66,22 @@
 		return NF_ACCEPT;
 #endif
 
-	err = nf_ct_frag6_gather(skb, nf_ct6_defrag_user(hooknum, skb));
+	reasm = nf_ct_frag6_gather(skb, nf_ct6_defrag_user(hooknum, skb));
 	/* queued */
-	if (err == -EINPROGRESS)
+	if (reasm == NULL)
 		return NF_STOLEN;
 
-	return NF_ACCEPT;
+	/* error occurred or not fragmented */
+	if (reasm == skb)
+		return NF_ACCEPT;
+
+	nf_ct_frag6_consume_orig(reasm);
+
+	NF_HOOK_THRESH(NFPROTO_IPV6, hooknum, reasm,
+		       (struct net_device *) in, (struct net_device *) out,
+		       okfn, NF_IP6_PRI_CONNTRACK_DEFRAG + 1);
+
+	return NF_STOLEN;
 }
 
 static struct nf_hook_ops ipv6_defrag_ops[] = {
diff -Naur a/net/ipv6/netfilter.c b/net/ipv6/netfilter.c
--- a/net/ipv6/netfilter.c	2017-10-11 10:17:40.137281000 +0530
+++ b/net/ipv6/netfilter.c	2017-10-11 09:38:02.365714000 +0530
@@ -191,7 +191,6 @@
 
 static const struct nf_ipv6_ops ipv6ops = {
 	.chk_addr	= ipv6_chk_addr,
-	.fragment       = ip6_fragment,
 };
 
 static const struct nf_afinfo nf_ip6_afinfo = {
diff -Naur a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c
--- a/net/l2tp/l2tp_core.c	2017-10-11 10:17:42.473524000 +0530
+++ b/net/l2tp/l2tp_core.c	2017-10-11 09:38:04.496876000 +0530
@@ -17,10 +17,6 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-/*
- * Includes Intel Corporation's changes/modifications dated: [10/03/2016].
- * Changed/modified portions - Copyright  [2016], Intel Corporation.
- */
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
@@ -69,10 +65,6 @@
 
 #include "l2tp_core.h"
 
-#ifdef CONFIG_TI_PACKET_PROCESSOR
-#include <linux/ti_hil.h>
-#endif
-
 #define L2TP_DRV_VERSION	"V2.0"
 
 /* L2TP header constants */
@@ -1864,11 +1856,6 @@
  */
 int l2tp_session_delete(struct l2tp_session *session)
 {
-#ifdef CONFIG_TI_PACKET_PROCESSOR
-	/* For L2TPv3 - Generate the HIL Event indicating that the L2TPv3 session has been deleted. */
-	if (session->tunnel->version == L2TP_HDR_VER_3)
-		ti_hil_pp_event (TI_L2TP_ENTRY_DELETED, (void *)session);
-#endif// CONFIG_TI_PACKET_PROCESSOR
 	if (session->ref)
 		(*session->ref)(session);
 	__l2tp_session_unhash(session);
@@ -1983,14 +1970,8 @@
 		}
 
 		/* Ignore management session in session count value */
-		if (session->session_id != 0) {
+		if (session->session_id != 0)
 			atomic_inc(&l2tp_session_count);
-#ifdef CONFIG_TI_PACKET_PROCESSOR
-			/* For L2TPv3 (PP does not support send_seq option) - Generate the HIL Event indicating that the L2TPv3 session has been created. */
-			if ((tunnel->version == L2TP_HDR_VER_3) && (!session->send_seq))
-				ti_hil_pp_event (TI_L2TP_ENTRY_CREATED, (void *)session);
-#endif// CONFIG_TI_PACKET_PROCESSOR
-		}
 	}
 
 	return session;
diff -Naur a/net/netfilter/Kconfig b/net/netfilter/Kconfig
--- a/net/netfilter/Kconfig	2017-10-11 10:17:40.748328000 +0530
+++ b/net/netfilter/Kconfig	2017-10-11 09:38:02.990794000 +0530
@@ -854,14 +854,6 @@
 	  This option adds a "TCPOPTSTRIP" target, which allows you to strip
 	  TCP options from TCP packets.
 
-config NETFILTER_XT_TARGET_GWMETA
-	tristate "GWMETA target support"
-	depends on INTEL_NF_GWMETA_SUPPORT
-	help
-          This option allows to label skb data of ip packets or disable packet processor
-	  To compile it as a module, choose M here.  If unsure, say N.
-
-
 # alphabetically ordered list of matches
 
 comment "Xtables matches"
@@ -1370,14 +1362,6 @@
 
 	  Details and examples are in the kernel module source.
 
-config NETFILTER_XT_MATCH_WEBSTR
-        tristate "WEBSTR match support"
-        depends on IP_NF_FILTER && INTEL_NF_WEBSTR_SUPPORT
-        help
-          This option allows to match string in http web header
-          To compile it as a module, choose M here.  If unsure, say N.
-
-
 endif # NETFILTER_XTABLES
 
 endmenu
diff -Naur a/net/netfilter/Makefile b/net/netfilter/Makefile
--- a/net/netfilter/Makefile	2017-10-11 10:17:40.743338000 +0530
+++ b/net/netfilter/Makefile	2017-10-11 09:38:02.987789000 +0530
@@ -101,7 +101,6 @@
 obj-$(CONFIG_NETFILTER_XT_TARGET_TEE) += xt_TEE.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_TRACE) += xt_TRACE.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_IDLETIMER) += xt_IDLETIMER.o
-obj-$(CONFIG_NETFILTER_XT_TARGET_GWMETA) += xt_GWMETA.o
 
 # matches
 obj-$(CONFIG_NETFILTER_XT_MATCH_ADDRTYPE) += xt_addrtype.o
@@ -146,7 +145,6 @@
 obj-$(CONFIG_NETFILTER_XT_MATCH_TCPMSS) += xt_tcpmss.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_TIME) += xt_time.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_U32) += xt_u32.o
-obj-$(CONFIG_NETFILTER_XT_MATCH_WEBSTR) += xt_webstr.o
 
 # ipset
 obj-$(CONFIG_IP_SET) += ipset/
diff -Naur a/net/netfilter/core.c b/net/netfilter/core.c
--- a/net/netfilter/core.c	2017-10-11 10:17:40.493309000 +0530
+++ b/net/netfilter/core.c	2017-10-11 09:38:02.752737000 +0530
@@ -23,7 +23,7 @@
 #include <linux/slab.h>
 #include <net/net_namespace.h>
 #include <net/sock.h>
-#if defined(CONFIG_APPCPU_GW_PP_HANDLE) || defined(CONFIG_TI_PACKET_PROCESSOR)
+#ifdef CONFIG_TI_PACKET_PROCESSOR
 #include <linux/ti_hil.h>
 #endif /* CONFIG_APPCPU_GW_PP_HANDLE */
 #include "nf_internals.h"
@@ -32,6 +32,7 @@
   #include <net/ppa_api.h>
 #endif
 
+
 static DEFINE_MUTEX(afinfo_mutex);
 
 const struct nf_afinfo __rcu *nf_afinfo[NFPROTO_NUMPROTO] __read_mostly;
@@ -194,7 +195,7 @@
 		ret = 1;
 	} else if ((verdict & NF_VERDICT_MASK) == NF_DROP) {
 
-#if defined(CONFIG_APPCPU_GW_PP_HANDLE) || defined(CONFIG_TI_PACKET_PROCESSOR)
+#ifdef CONFIG_TI_PACKET_PROCESSOR
 #define MAC_ISMULTICAST( pa, hw )    ( ((pa)->hw[0] & 0x01)  )
 #define MAC_ISBROADCAST( pa, hw ) ( ~0xFF ==( (~(pa)->hw[0]) | \
                                               (~(pa)->hw[1]) | \
@@ -221,8 +222,7 @@
 	{
 	    ti_hil_pp_event (TI_CT_NETFILTER_DISCARD_PKT, (void *)skb);
 	}
-#endif /* CONFIG_APPCPU_GW_PP_HANDLE || CONFIG_TI_PACKET_PROCESSOR	*/
-
+#endif /* CONFIG_APPCPU_GW_PP_HANDLE */
 #if defined(CONFIG_LTQ_PPA_API) || defined(CONFIG_LTQ_PPA_API_MODULE)
         if ( ppa_hook_session_del_fn != NULL )
         {
@@ -233,7 +233,6 @@
             ppa_hook_session_del_fn(ct, PPA_F_SESSION_ORG_DIR | PPA_F_SESSION_REPLY_DIR);
         }
 #endif
-
                 kfree_skb(skb);
                 ret = NF_DROP_GETERR(verdict);
 		if (ret == 0)
diff -Naur a/net/netfilter/ipset/ip_set_core.c b/net/netfilter/ipset/ip_set_core.c
--- a/net/netfilter/ipset/ip_set_core.c	2017-10-11 10:17:40.799337000 +0530
+++ b/net/netfilter/ipset/ip_set_core.c	2017-10-11 09:38:03.021762000 +0530
@@ -1343,8 +1343,7 @@
 
 		*errline = lineno;
 
-		netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid,
-					MSG_DONTWAIT, 0);
+		netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);
 		/* Signal netlink not to send its ACK/errmsg.  */
 		return -EINTR;
 	}
@@ -1529,8 +1528,7 @@
 		goto nla_put_failure;
 	nlmsg_end(skb2, nlh2);
 
-	ret = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid,
-					MSG_DONTWAIT, 0);
+	ret = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);
 	if (ret < 0)
 		return ret;
 
@@ -1591,8 +1589,7 @@
 	nlmsg_end(skb2, nlh2);
 
 	pr_debug("Send TYPE, nlmsg_len: %u\n", nlh2->nlmsg_len);
-	ret = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid,
-					MSG_DONTWAIT, 0);
+	ret = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);
 	if (ret < 0)
 		return ret;
 
@@ -1636,8 +1633,7 @@
 		goto nla_put_failure;
 	nlmsg_end(skb2, nlh2);
 
-	ret = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid,
-					MSG_DONTWAIT, 0);
+	ret = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);
 	if (ret < 0)
 		return ret;
 
diff -Naur a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
--- a/net/netfilter/nf_conntrack_core.c	2017-10-11 10:17:40.496313000 +0530
+++ b/net/netfilter/nf_conntrack_core.c	2017-10-11 09:38:02.755745000 +0530
@@ -34,7 +34,7 @@
 #include <linux/mm.h>
 #include <linux/nsproxy.h>
 #include <linux/rculist_nulls.h>
-#if defined(CONFIG_APPCPU_GW_PP_HANDLE) && defined(CONFIG_MRPC_CONNTRACK_CLIENT) && !defined(CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL)
+#if defined(CONFIG_APPCPU_GW_PP_HANDLE) && defined(CONFIG_MRPC_CONNTRACK_CLIENT)
 #include <linux/mrpc.h>
 #endif
 #include <net/netfilter/nf_conntrack.h>
@@ -333,7 +333,6 @@
 #if defined(CONFIG_APPCPU_GW_PP_HANDLE) && defined(CONFIG_MRPC_CONNTRACK_CLIENT)
         unsigned long extend_ct_tmp_time;
         unsigned long extend_ct_time;
-        int ret;
         /* this is to differentiate conntrack_flush from regular timeout scenario.
            we don't need to check for ARM PP session status if the application requested
            to flush the connection.But, we need to be cautious about the CT records
@@ -382,24 +381,13 @@
 	}
 	else
 	{
-          ret = nf_conn_info_event(TI_CT_DEATH_BY_TIMEOUT, (void *)ct);
-          ret = notifier_to_errno(ret);
-          if (ret)
-          {
-             /*MRPC conntrack client will return -ENOSPC if the workQueue's circular
-               buffer is full for any reason. Go ahead and delete the connection tracking
-               record at ATOM side without checking for the PP session availability on ARM.
-               NOTE: This should never happen in a normal scenario. */
-             goto delete_record;
-          }
-          else
-          {
-            /* conntrack mrpc client is still working on to sync pp info from ARM */
-            extend_ct_tmp_time = (3 * HZ) + jiffies;
-            mod_timer(&ct->timeout,extend_ct_tmp_time);
-            ct->ct_tuple_arm_sync_wait=1;
-            return;
-          }
+	  /* Generate an event indicating the connection tracking entry is being deleted. */
+	  nf_conn_info_event(TI_CT_DEATH_BY_TIMEOUT, (void *)ct);
+	  /* conntrack mrpc client is still working on to sync pp info from ARM */
+	  extend_ct_tmp_time = (3 * HZ) + jiffies;
+	  mod_timer(&ct->timeout,extend_ct_tmp_time);
+	  ct->ct_tuple_arm_sync_wait=1;
+	  return;
 	}
 #else /*PP on ATOM specific conntrack ti_hil_pp_event has to go in here */
 #if defined(CONFIG_LTQ_PPA_API) || defined(CONFIG_LTQ_PPA_API_MODULE)
diff -Naur a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
--- a/net/netfilter/nf_conntrack_netlink.c	2017-10-11 10:17:40.741330000 +0530
+++ b/net/netfilter/nf_conntrack_netlink.c	2017-10-11 09:38:02.986753000 +0530
@@ -1116,8 +1116,7 @@
 	if (err <= 0)
 		goto free;
 
-	err = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid,
-					MSG_DONTWAIT, 0);
+	err = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);
 	if (err < 0)
 		goto out;
 
@@ -1967,8 +1966,7 @@
 	if (err <= 0)
 		goto free;
 
-	err = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid,
-					MSG_DONTWAIT, 0);
+	err = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);
 	if (err < 0)
 		goto out;
 
@@ -2640,8 +2638,7 @@
 	if (err <= 0)
 		goto free;
 
-	err = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid,
-					MSG_DONTWAIT, 0);
+	err = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid, MSG_DONTWAIT);
 	if (err < 0)
 		goto out;
 
diff -Naur a/net/netfilter/nf_queue.c b/net/netfilter/nf_queue.c
--- a/net/netfilter/nf_queue.c	2017-10-11 10:17:40.834340000 +0530
+++ b/net/netfilter/nf_queue.c	2017-10-11 09:38:03.046762000 +0530
@@ -15,9 +15,9 @@
 #include <net/protocol.h>
 #include <net/netfilter/nf_queue.h>
 #include <net/dst.h>
-#if defined(CONFIG_APPCPU_GW_PP_HANDLE) || defined(CONFIG_TI_PACKET_PROCESSOR)
+#ifdef CONFIG_TI_PACKET_PROCESSOR
 #include <linux/ti_hil.h>
-#endif /* CONFIG_APPCPU_GW_PP_HANDLE || CONFIG_TI_PACKET_PROCESSOR*/
+#endif /* CONFIG_APPCPU_GW_PP_HANDLE */
 #include "nf_internals.h"
 
 /*
@@ -222,7 +222,7 @@
 	case NF_STOLEN:
 		break;
 	default:
-#if defined(CONFIG_APPCPU_GW_PP_HANDLE) || defined(CONFIG_TI_PACKET_PROCESSOR)
+#ifdef CONFIG_TI_PACKET_PROCESSOR
                 {
 			int skip_pp_discard=0;
 			struct ethhdr* ptr_ethhdr = NULL;
@@ -253,7 +253,7 @@
 				ti_hil_pp_event (TI_CT_NETFILTER_DISCARD_PKT, (void *)skb);
 			}
 		}
-#endif /* CONFIG_APPCPU_GW_PP_HANDLE || CONFIG_TI_PACKET_PROCESSOR*/
+#endif /* CONFIG_APPCPU_GW_PP_HANDLE */
 		kfree_skb(skb);
 	}
 	rcu_read_unlock();
diff -Naur a/net/netfilter/nfnetlink.c b/net/netfilter/nfnetlink.c
--- a/net/netfilter/nfnetlink.c	2017-10-11 10:17:40.609325000 +0530
+++ b/net/netfilter/nfnetlink.c	2017-10-11 09:38:02.883757000 +0530
@@ -135,7 +135,7 @@
 int nfnetlink_unicast(struct sk_buff *skb, struct net *net, u32 portid,
 		      int flags)
 {
-	return netlink_unicast(net->nfnl, skb, portid, flags, 0);
+	return netlink_unicast(net->nfnl, skb, portid, flags);
 }
 EXPORT_SYMBOL_GPL(nfnetlink_unicast);
 
diff -Naur a/net/netfilter/nfnetlink_acct.c b/net/netfilter/nfnetlink_acct.c
--- a/net/netfilter/nfnetlink_acct.c	2017-10-11 10:17:40.857341000 +0530
+++ b/net/netfilter/nfnetlink_acct.c	2017-10-11 09:38:03.073775000 +0530
@@ -209,7 +209,7 @@
 			break;
 		}
 		ret = netlink_unicast(nfnl, skb2, NETLINK_CB(skb).portid,
-					MSG_DONTWAIT, 0);
+					MSG_DONTWAIT);
 		if (ret > 0)
 			ret = 0;
 
diff -Naur a/net/netfilter/nfnetlink_cthelper.c b/net/netfilter/nfnetlink_cthelper.c
--- a/net/netfilter/nfnetlink_cthelper.c	2017-10-11 10:17:40.638346000 +0530
+++ b/net/netfilter/nfnetlink_cthelper.c	2017-10-11 09:38:02.900754000 +0530
@@ -559,7 +559,7 @@
 			}
 
 			ret = netlink_unicast(nfnl, skb2, NETLINK_CB(skb).portid,
-						MSG_DONTWAIT, 0);
+						MSG_DONTWAIT);
 			if (ret > 0)
 				ret = 0;
 
diff -Naur a/net/netfilter/nfnetlink_cttimeout.c b/net/netfilter/nfnetlink_cttimeout.c
--- a/net/netfilter/nfnetlink_cttimeout.c	2017-10-11 10:17:40.612344000 +0530
+++ b/net/netfilter/nfnetlink_cttimeout.c	2017-10-11 09:38:02.885759000 +0530
@@ -283,7 +283,7 @@
 			break;
 		}
 		ret = netlink_unicast(ctnl, skb2, NETLINK_CB(skb).portid,
-					MSG_DONTWAIT, 0);
+					MSG_DONTWAIT);
 		if (ret > 0)
 			ret = 0;
 
diff -Naur a/net/netfilter/xt_GWMETA.c b/net/netfilter/xt_GWMETA.c
--- a/net/netfilter/xt_GWMETA.c	2017-10-11 10:17:40.486324000 +0530
+++ b/net/netfilter/xt_GWMETA.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,162 +0,0 @@
-/* Kernel module to set flags in ti_gw_meta field of skb.
- * 
- *
- * 
- *
- * Copyright (C) 2011-2014, Intel Ltd.
- * All Rights Reserved.
- ** Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *  notice, this list of conditions, and the following disclaimer,
- *  without modification.
- * 2. The name of the author may not be used to endorse or promote products
- *  derived from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL").
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- *
- * 
- *
-   You should have received a copy of the GNU General Public License 
-   along with this program; if not, write to the Free Software 
-   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
-   The full GNU General Public License is included in this distribution 
-   in the file called LICENSE.GPL.
-  
-    Contact Information:
-    Intel Corporation
-    2200 Mission College Blvd.
-    Santa Clara, CA  97052
- * Description:
- *   This module provide extends netfilter feature to set a bitmask on a packets.
- *   In difference from netfiltyer this masks lasts till packet leaves GateWay TCP stack 
- *
- *   The module follows the Netfilter framework, called extended packet
- *   matching modules.
- * Usage :
- *  iptables -t mangle -I POSTROUTING 1 -o rndbr1 -p tcp --dport 6800:6866 -j GWMETA --gwmeta-gwmask 0x00000020
- *  iptables -t mangle -I OUTPUT 1 -o rndbr1 -p tcp --dport 6800:6866 -j GWMETA --gwmeta-gwmask 0x00000002
- *  Packet will have resulted ti_gw_meta ORed mask 0x22 
- */
-
-#include <linux/types.h>
-#include <linux/module.h>
-#include <linux/skbuff.h>
-
-#include <linux/netfilter/x_tables.h>
-#include <linux/netfilter_ipv4/ip_tables.h>
-#include <linux/netfilter_ipv6/ip6_tables.h>
-#include <linux/netfilter/xt_GWMETA.h>
-
-//#define GWMETA_DEBUG
-#ifdef GWMETA_DEBUG
-    #define DEBUGP printk
-    #define DEBUG_LEVEL KERN_CRIT
-#else
-    #define DEBUGP(DEBUG_LEVEL, format, args...)
-#endif
-
-/* Define macros to convert to/from HIL endian-ness */
-/* If HIL is running on Atom, no need to do byte swap */
-#ifdef CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL
-    #define cpu_to_hil32(val) val
-    #define hil_to_cpu32(val) val
-#else
-    #define cpu_to_hil32(val) cpu_to_be32(val)
-    #define hil_to_cpu32(val) be32_to_cpu(val)
-#endif
-
-static unsigned int
-do_target_job(struct sk_buff *skb, const struct xt_action_param *par)
-{
-
-    const struct xt_gw_skb_rule_info *info = par->targinfo;
-    unsigned int host_val;
-
-    if (info->type == XT_GW_META)
-    {
-        DEBUGP( DEBUG_LEVEL " %s: mark with i %x \n", __FUNCTION__, info->gwmask);
-        host_val = hil_to_cpu32(skb->ti_gw_meta);
-        host_val |= info->gwmask;
-        skb->ti_gw_meta = cpu_to_hil32(host_val);
-    }
-    else if (info->type == XT_GW_DIS_PP)
-    {
-        /*DISABLE PP */
-        TI_HIL_ADD_PP_INFO_FLAGS(skb, TI_HIL_PACKET_FLAG_PP_SESSION_BYPASS);
-    }
-    else if (info->type == XT_GW_EN_PP)
-    {
-        /*ENABLE PP */
-        TI_HIL_SET_PP_INFO_FLAGS(skb, TI_HIL_GET_PP_INFO_FLAGS(skb) & ~(TI_HIL_PACKET_FLAG_PP_SESSION_BYPASS));
-    }
-
-    return XT_CONTINUE;
-}
-
-static int
-check_usage(const struct xt_tgchk_param *par )
-{
-    //const struct ipt_entry *e = (struct ipt_entry*)e_void;
-    //const struct ipt_gw_skb_rule_info *info = targinfo;
-
-    /* this module might be used at any table and chain
-       no check is needed */
-
-    DEBUGP( DEBUG_LEVEL "%s: \n", __FUNCTION__);
-
-
-    return 0;
-}
-
-static struct xt_target redirect_tg_reg[] __read_mostly = {
-    {
-        .name          = "GWMETA",
-        .family      = NFPROTO_IPV4,
-        .target      = do_target_job,
-        .targetsize  = sizeof(struct xt_gw_skb_rule_info),
-        .checkentry  = check_usage,
-        .me          = THIS_MODULE,
-    },
-#if IS_ENABLED(CONFIG_IPV6)
-    {
-        .name          = "GWMETA",
-        .family      = NFPROTO_IPV6,
-        .target      = do_target_job,
-        .targetsize  = sizeof(struct xt_gw_skb_rule_info),
-        .checkentry  = check_usage,
-        .me          = THIS_MODULE,
-    }
-#endif
-};
-
-static int __init ipt_gwmeta_init(void)
-{
-    return xt_register_targets(redirect_tg_reg,
-                   ARRAY_SIZE(redirect_tg_reg));
-}
-
-static void __exit ipt_gwmeta_fini(void)
-{
-    xt_unregister_targets(redirect_tg_reg, ARRAY_SIZE(redirect_tg_reg));
-}
-
-module_init(ipt_gwmeta_init);
-module_exit(ipt_gwmeta_fini);
-
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("ip6t_GWMETA");
-MODULE_ALIAS("ipt_GWMETA");
-
diff -Naur a/net/netfilter/xt_webstr.c b/net/netfilter/xt_webstr.c
--- a/net/netfilter/xt_webstr.c	2017-10-11 10:17:40.481307000 +0530
+++ b/net/netfilter/xt_webstr.c	1970-01-01 05:30:00.000000000 +0530
@@ -1,493 +0,0 @@
-/* Kernel module to match a string into a packet.
- *
- * Copyright (C) 2000 Emmanuel Roger  <winfield@freegates.be>
- *
- * ChangeLog
- *	19.02.2002: Gianni Tedesco <gianni@ecsc.co.uk>
- *		Fixed SMP re-entrancy problem using per-cpu data areas
- *		for the skip/shift tables.
- *	02.05.2001: Gianni Tedesco <gianni@ecsc.co.uk>
- *		Fixed kernel panic, due to overrunning boyer moore string
- *		tables. Also slightly tweaked heuristic for deciding what
- * 		search algo to use.
- * 	27.01.2001: Gianni Tedesco <gianni@ecsc.co.uk>
- * 		Implemented Boyer Moore Sublinear search algorithm
- * 		alongside the existing linear search based on memcmp().
- * 		Also a quick check to decide which method to use on a per
- * 		packet basis.
- * Download location
- *               http://svn.dd-wrt.com:8000/browser//src/linux/xscale/linux-2.6.34.6/net/ipv4/netfilter
- */
-
-/* Kernel module to match a http header string into a packet.
- *
- * Copyright (C) 2009 - 2010, CyberTAN Corporation
- *
- * All Rights Reserved.
- * You can redistribute it and/or modify it under the terms of the GPL v2
- *
- * THIS SOFTWARE IS OFFERED "AS IS", AND CYBERTAN GRANTS NO WARRANTIES OF ANY
- * KIND, EXPRESS OR IMPLIED, BY STATUTE, COMMUNICATION OR OTHERWISE. CYBERTAN
- * SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
- * FOR A SPECIFIC PURPOSE OR NON INFRINGEMENT CONCERNING THIS SOFTWARE.
- *
- * Description:
- *   This is kernel module for web content inspection. It was derived from
- *   'string' match module, declared as above.
- *
- *   The module follows the Netfilter framework, called extended packet
- *   matching modules.
- * Restriction:
- *            Can not search https headers, higly recomended to use  tinyproxy server to block contents
- ******************************************************************************************************
- Includes Intel Corporation's changes/modifications dated: 02.11.2011
- Changed/modified portions :
- * -  X-tables API adapted for kernel 2.6.39
- * - added, improved Debug prints
- * - Kernel warning /complains of a too big stack size in the xt_webstr_match() function fixed
- * - copy from packet sk_buff removed, search is done directly in the tcp payload (optimization)
- * Copyright  2011-2014, Intel Corporation.
- ******************************************************************************************************
-
- */
-
-
-
-#include <linux/module.h>
-#include <linux/skbuff.h>
-#include <linux/ip.h>
-#include <linux/tcp.h>
-
-#include <linux/netfilter/x_tables.h>
-#include <linux/netfilter_ipv4/ip_tables.h>
-#include <linux/netfilter_ipv6/ip6_tables.h>
-#include <linux/netfilter/xt_webstr.h>
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Gianni Tedesco <gianni@ecsc.co.uk>");
-MODULE_ALIAS("ip6t_webstr");
-MODULE_ALIAS("ipt_webstr");
-
-//MODULE_DESCRIPTION("Xtables: match --url or --host parameter in http header IPv4");
-#define	isdigit(x) ((x) >= '0' && (x) <= '9')
-#define	isupper(x) (((unsigned)(x) >= 'A') && ((unsigned)(x) <= 'Z'))
-#define	islower(x) (((unsigned)(x) >= 'a') && ((unsigned)(x) <= 'z'))
-#define	isalpha(x) (isupper(x) || islower(x))
-#define	toupper(x) (isupper(x) ? (x) : (x) - 'a' + 'A')
-#define tolower(x) (isupper(x) ? ((x) - 'A' + 'a') : (x))
-
-#define split(word, wordlist, next, delim) \
-    for (next = wordlist, \
-	strncpy(word, next, sizeof(word)), \
-	word[(next=strstr(next, delim)) ? strstr(word, delim) - word : sizeof(word) - 1] = '\0', \
-	next = next ? next + sizeof(delim) - 1 : NULL ; \
-	strlen(word); \
-	next = next ? : "", \
-	strncpy(word, next, sizeof(word)), \
-	word[(next=strstr(next, delim)) ? strstr(word, delim) - word : sizeof(word) - 1] = '\0', \
-	next = next ? next + sizeof(delim) - 1 : NULL)
-
-#define URLSIZE 	1024
-#define WORDSIZE 	256
-#define HOSTSIZE 	256
-
-
-/* Flags for get_http_info() */
-#define HTTP_HOST	0x01
-#define HTTP_URL	0x02
-/* Flags for mangle_http_header() */
-#define HTTP_COOKIE	0x04
-
-//#define DEBUG
-#ifdef DEBUG
-#define DEBUGP printk
-#define PRINTK_LEVEL KERN_CRIT
-#else
-#define PRINTK_LEVEL
-#define DEBUGP( PRINTK_LEVEL, format, args...)
-#endif
-
-typedef struct httpinfo {
-    char  host[HOSTSIZE];
-    int hostlen;
-    char  url[URLSIZE];
-    int urllen;
-} httpinfo_t;
-static httpinfo_t htinfo;
-
-/* Return 1 for match, 0 for accept, -1 for partial. */
-static int find_pattern2(const char *data, size_t dlen,
-	const char *pattern, size_t plen,
-	char term,
-	unsigned int *numoff,
-	unsigned int *numlen)
-{
-    size_t i, j, k;
-    int state = 0;
-    *numoff = *numlen = 0;
-
-    DEBUGP( PRINTK_LEVEL "%s: pattern = '%s', dlen = %u\n",__FUNCTION__, pattern, dlen);
-    if (dlen == 0)
-	return 0;
-
-    if (dlen <= plen) {	/* Short packet: try for partial? */
-	if (strnicmp(data, pattern, dlen) == 0)
-	    return -1;
-	else 
-	    return 0;
-    }
-    for (i = 0; i <= (dlen - plen); i++) {
-	/* DFA : \r\n\r\n :: 1234 */
-	if (*(data + i) == '\r') {
-	    if (!(state % 2)) state++;	/* forwarding move */
-	    else state = 0;		/* reset */
-	}
-	else if (*(data + i) == '\n') {
-	    if (state % 2) state++;
-	    else state = 0;
-	}
-	else state = 0;
-
-	if (state >= 4)
-	    break;
-
-	/* pattern compare */
-	if (memcmp(data + i, pattern, plen ) != 0)
-	    continue;
-
-	/* Here, it means patten match!! */
-	*numoff=i + plen;
-	for (j = *numoff, k = 0; data[j] != term; j++, k++)
-	    if (j > dlen) return -1 ;	/* no terminal char */
-
-	*numlen = k;
-	return 1;
-    }
-    return 0;
-}
-
-static int mangle_http_header(int flags, unsigned char *data, unsigned int datalen)
-{
-    int found, offset, len;
-    int ret = 0;
-
-
-    DEBUGP( PRINTK_LEVEL "%s: seq=%u\n", __FUNCTION__, ntohl(tcph->seq));
-
-    /* Basic checking, is it HTTP packet? */
-    if (datalen < 10)
-	return ret;	/* Not enough length, ignore it */
-    if (memcmp(data, "GET ", sizeof("GET ") - 1) != 0 &&
-        memcmp(data, "POST ", sizeof("POST ") - 1) != 0 &&
-        memcmp(data, "HEAD ", sizeof("HEAD ") - 1) != 0)
-	return ret;	/* Pass it */
-
-    /* COOKIE modification */
-    if (flags & HTTP_COOKIE) {
-	found = find_pattern2(data, datalen, "Cookie: ", 
-		sizeof("Cookie: ")-1, '\r', &offset, &len);
-	if (found) {
-	    char c;
-	    offset -= (sizeof("Cookie: ") - 1);
-	    /* Swap the 2rd and 4th bit */
-	    c = *(data + offset + 2) ;
-	    *(data + offset + 2) = *(data + offset + 4) ;
-	    *(data + offset + 4) = c ;
-	    ret++;
-	}
-    }
-
-    return ret;
-}
-
-static int get_http_info(int flags, httpinfo_t *info, const unsigned char *data, unsigned int datalen)
-{
-    int found, offset;
-    int hostlen, pathlen;
-    int ret = 0;
-
-    /* Basic checking, is it HTTP packet? */
-    if (datalen < 10)
-    {
-        #ifdef DEBUG
-            DEBUGP( PRINTK_LEVEL "%s: Error ?SYN? datalen <10 datalen=%d\n", __FUNCTION__ ,datalen);
-        #endif
-	return ret;	/* Not enough length, ignore it */
-    }
-    if (memcmp(data, "GET ", sizeof("GET ") - 1) != 0 &&
-        memcmp(data, "POST ", sizeof("POST ") - 1) != 0 &&
-        memcmp(data, "HEAD ", sizeof("HEAD ") - 1) != 0)
-    {
-        #ifdef DEBUG
-            DEBUGP( PRINTK_LEVEL "%s: Error no GET/POST clause\n", __FUNCTION__ );
-        #endif
-	    return ret;	/* Pass it */
-    }
-    if (!(flags & (HTTP_HOST | HTTP_URL)))
-    {
-        #ifdef DEBUG
-            DEBUGP( PRINTK_LEVEL "%s: Error nor HOST nor URL match\n", __FUNCTION__ );
-        #endif
-	    return ret;
-    }
-
-    if ( flags & HTTP_HOST )  /* it is always true because MATCH parameter parser adds HTTP__HOST when HTTP_URL is specified */ 
-    {
-        /* find the 'Host: ' value */
-         found = find_pattern2(data, datalen, "Host: ", 
-        	    sizeof("Host: ") - 1, '\r', &offset, &hostlen);
-        #ifdef DEBUG
-        if (found )
-            DEBUGP( PRINTK_LEVEL "Host found at offset=%d, with hostlen=%d\n", offset, hostlen);
-        #endif
-
-        if (!found || !hostlen)
-        	return ret;
-
-        ret++;	/* Host found, increase the return value */
-		hostlen = (hostlen < HOSTSIZE) ? hostlen : HOSTSIZE;
-        strncpy(info->host, data + offset, hostlen);
-		 *(info->host + hostlen) = 0;		/* null-terminated */
-        info->hostlen = hostlen;
-        DEBUGP( PRINTK_LEVEL "HOST=%s, hostlen=%d\n", info->host, info->hostlen);
-    }
-
-    if (!(flags & HTTP_URL))
-	return ret;
-
-    /* find the ['GET ' | 'POST ' | 'HEAD'] parameter value, i.e find url */
-    found = find_pattern2(data, datalen, "GET ",
-	    sizeof("GET ") - 1, '\r', &offset, &pathlen);
-    DEBUGP( PRINTK_LEVEL "HTTP GET found=%d\n", found);
-    if (!found)
-	found = find_pattern2(data, datalen, "POST ",
-		sizeof("POST ") - 1, '\r', &offset, &pathlen);
-    if (!found) 
-        found = find_pattern2(data, datalen, "HEAD ", 
-                sizeof("HEAD ") - 1, '\r', &offset, &pathlen);      
-    DEBUGP( PRINTK_LEVEL "HTTP POST found=%d\n", found);
-
-    if (!found || (pathlen -= (sizeof(" HTTP/x.x") - 1)) <= 0) /* ignore this field */
-	   return ret;
-    DEBUGP( PRINTK_LEVEL " pathlen - (sizeof(' HTTP/x.x') %d\n", pathlen - (sizeof(" HTTP/x.x") - 1));
-
-    ret++;	/* GET/POST found, increase the return value */
-    pathlen = ((pathlen + hostlen) < URLSIZE) ? pathlen : URLSIZE - hostlen;
-	DEBUGP( PRINTK_LEVEL " Make url start from host hostlen %d\n", hostlen);
-	strncpy(info->url, info->host, hostlen);
-	
-	
-    strncpy(info->url + hostlen, data + offset, pathlen);
-    *(info->url + hostlen + pathlen) = 0;	/* null-terminated */
-	/* in a regular http reguest, host is after url */
-    DEBUGP( PRINTK_LEVEL " Append Url  to host sits at address of %p, offset=%d from tcp payload to \n", data + offset, offset);
-    info->urllen = hostlen + pathlen;
-    DEBUGP( PRINTK_LEVEL "URL=%s, urllen=%d\n", info->url, info->urllen);
-
-    return ret;
-}
-
-/* Linear string search based on memcmp() */
-static char *search_linear (char *needle, char *haystack, int needle_len, int haystack_len) 
-{
-	char *k = haystack + (haystack_len-needle_len);
-	char *t = haystack;
-	
-	DEBUGP( PRINTK_LEVEL "%s: haystack=%s, needle=%s\n", __FUNCTION__, t, needle);
-	for(; t <= k; t++) {
-		DEBUGP( PRINTK_LEVEL "%s: haystack=%s, needle=%s\n", __FUNCTION__, t, needle);
-		if (strnicmp(t, needle, needle_len) == 0) return t;
-		//if ( memcmp(t, needle, needle_len) == 0 ) return t;
-	}
-
-	return NULL;
-}
-
-#define TOKEN   "<&nbsp;>" 
-
-static bool xt_webstr_match(const struct sk_buff *skb,  struct xt_action_param *par)
-{
-	const struct xt_webstr_info *info = par->matchinfo;
-	unsigned char *data;
-	unsigned int datalen;
-	struct tcphdr *tcph;
-	char *wordlist = (char *)&info->string;
-	int flags = 0;
-	int found = 0;
-	long int opt = 0;
-
-	if (info->len < 1)
-	    return 0;
-
-	if (par->family == NFPROTO_IPV4) {
-		struct iphdr *iph = ip_hdr(skb);
-		if (!iph) {
-			return 0;
-		}
-		tcph = (void *)iph + iph->ihl*4;
-		data = (void *)tcph + tcph->doff*4;
-		datalen = (skb)->len - (iph->ihl*4) - (tcph->doff*4);
-	}
-#if IS_ENABLED(CONFIG_IPV6)
-	else if (par->family == NFPROTO_IPV6) {
-		struct ipv6hdr *iph = ipv6_hdr(skb);
-		if (!iph) {
-			return 0;
-		}
-		tcph = (void *)iph + sizeof(struct ipv6hdr);
-		data = (void *)tcph + tcph->doff*4;
-		datalen = (skb)->len - sizeof(struct ipv6hdr) - (tcph->doff*4);
-	}
-#endif
-	else
-		return 0;
-
-	DEBUGP( PRINTK_LEVEL "\n************************************************\n"
-		"%s: type=%s\n", __FUNCTION__, (info->type == XT_WEBSTR_URL) 
-		? "XT_WEBSTR_URL"  : (info->type == XT_WEBSTR_HOST) 
-		? "XT_WEBSTR_HOST" : "XT_WEBSTR_CONTENT" );
-	
-	/* Determine the flags value for get_http_info(), and mangle packet 
-	 * if needed. */
-	switch(info->type)
-	{
-	    case XT_WEBSTR_URL:
-		flags |= HTTP_URL;
-       /* add both flags because we construct url from host name first, then url
-       adds HTTP__HOST when HTTP_URL is specified */
-	    case XT_WEBSTR_HOST:
-		flags |= HTTP_HOST;
-		break;
-
-	    case XT_WEBSTR_CONTENT:
-		opt = simple_strtol(wordlist, (char **)NULL, 10);
-		DEBUGP( PRINTK_LEVEL "%s: string=%s, opt=%#lx\n", __FUNCTION__, wordlist, opt);
-
-		if (opt & (BLK_JAVA | BLK_ACTIVE | BLK_PROXY))
-		    flags |= HTTP_URL;
-		if (opt & BLK_PROXY)
-		    flags |= HTTP_HOST;
-		if (opt & BLK_COOKIE)
-		    mangle_http_header(HTTP_COOKIE, data, datalen);
-		break;
-
-	    default:
-		printk( KERN_ERR "%s: Sorry! Cannot find  match type.\n", __FILE__);
-		return 0;
-	}
-
-	/* Get the http header info */
-
-    DEBUGP( PRINTK_LEVEL "%s:, skb->len=%d, datalen=%d seq=%u\n", __FUNCTION__,skb->len, datalen, ntohl(tcph->seq));
-	if (get_http_info(flags, &htinfo, data, datalen) < 1)
-	    return 0;
-
-	/* Check if the http header content contains the forbidden keyword */
-	if (info->type == XT_WEBSTR_HOST || info->type == XT_WEBSTR_URL) {
-	    int nlen = 0, hlen = 0;
-	    char needle[WORDSIZE], *haystack = NULL;
-	    char *next;
-	    char *chtemp;
-
-	    if (info->type == XT_WEBSTR_HOST) {
-		haystack = htinfo.host;
-		hlen = htinfo.hostlen;
-	    }
-	    else {
-		haystack = htinfo.url;
-		hlen = htinfo.urllen;
-	    }
-	    split(needle, wordlist, next, TOKEN) {
-	        /* Don't include '://' as part of the word being searched for */
-	        chtemp = strstr(needle, "://");
-	        if (NULL != chtemp)
-	            strcpy(needle, chtemp + 3);
-		nlen = strlen(needle);
-		DEBUGP( PRINTK_LEVEL "keyword=%s, nlen=%d, hlen=%d\n", needle, nlen, hlen);
-		if (!nlen || !hlen || nlen > hlen) continue;
-		if (search_linear(needle, haystack, nlen, hlen) != NULL) {
-		    found = 1;
-		    break;
-		}
-	    }
-	}
-	else {		/* XT_WEBSTR_CONTENT */
-	    int vicelen;
-
-	    if (opt & BLK_JAVA) {
-		vicelen = sizeof(".js") - 1;
-		if (strnicmp(htinfo.url + htinfo.urllen - vicelen, ".js", vicelen) == 0) {
-		    DEBUGP( PRINTK_LEVEL "%s: MATCH....java\n", __FUNCTION__);
-		    found = 1;
-		    goto match_ret;
-		}
-		vicelen = sizeof(".class") - 1;
-		if (strnicmp(htinfo.url + htinfo.urllen - vicelen, ".class", vicelen) == 0) {
-		    DEBUGP( PRINTK_LEVEL "%s: MATCH....java\n", __FUNCTION__);
-		    found = 1;
-		    goto match_ret;
-		}
-	    }
-	    if (opt & BLK_ACTIVE){
-		vicelen = sizeof(".ocx") - 1;
-		if (strnicmp(htinfo.url + htinfo.urllen - vicelen, ".ocx", vicelen) == 0) {
-		    DEBUGP( PRINTK_LEVEL "%s: MATCH....activex\n", __FUNCTION__);
-		    found = 1;
-		    goto match_ret;
-		}
-		vicelen = sizeof(".cab") - 1;
-		if (strnicmp(htinfo.url + htinfo.urllen - vicelen, ".cab", vicelen) == 0) {
-		    DEBUGP( PRINTK_LEVEL "%s: MATCH....activex\n", __FUNCTION__);
-		    found = 1;
-		    goto match_ret;
-		}
-	    }
-	    if (opt & BLK_PROXY){
-		if (strnicmp(htinfo.url + htinfo.hostlen, "http://", sizeof("http://") - 1) == 0) {
-		    DEBUGP( PRINTK_LEVEL "%s: MATCH....proxy\n", __FUNCTION__);
-		    found = 1;
-		    goto match_ret;
-		}
-	    }
-	}
-
-match_ret:
-	DEBUGP( PRINTK_LEVEL "%s: Verdict =======> %s \n",__FUNCTION__
-		, found ? "MATCH FOUND" : "MATCH NOT FOUND");
-
-	return (found ^ info->invert);
-}
-
-
-static struct xt_match webstr_match[] __read_mostly = {
-	{
-		.name		= "webstr",
-		.family		= NFPROTO_IPV4,
-		.match		= xt_webstr_match,
-		.matchsize      = sizeof(struct xt_webstr_info),
-		.me		= THIS_MODULE,
-	},
-#if IS_ENABLED(CONFIG_IPV6)
-	{
-		.name		= "webstr",
-		.family		= NFPROTO_IPV6,
-		.match		= xt_webstr_match,
-		.matchsize      = sizeof(struct xt_webstr_info),
-		.me		= THIS_MODULE,
-	}
-#endif
-};
-
-
-static int __init xt_webstr_init(void)
-{
-	return xt_register_matches(webstr_match, ARRAY_SIZE(webstr_match));
-}
-
-static void __exit xt_webstr_fini(void)
-{
-	xt_unregister_matches(webstr_match, ARRAY_SIZE(webstr_match));
-}
-
-module_init(xt_webstr_init);
-module_exit(xt_webstr_fini);
diff -Naur a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c
--- a/net/netlink/af_netlink.c	2017-10-11 10:17:42.064436000 +0530
+++ b/net/netlink/af_netlink.c	2017-10-11 09:38:04.085843000 +0530
@@ -776,7 +776,7 @@
 					  GFP_KERNEL);
 		}
 		err = netlink_unicast(sk, skb, dst_portid,
-				msg->msg_flags & MSG_DONTWAIT, 0);
+				      msg->msg_flags & MSG_DONTWAIT);
 		if (err < 0)
 			goto out;
 		len += err;
@@ -1771,13 +1771,13 @@
 }
 
 int netlink_unicast(struct sock *ssk, struct sk_buff *skb,
-		    u32 portid, int nonblock, gfp_t allocation)
+		    u32 portid, int nonblock)
 {
 	struct sock *sk;
 	int err;
 	long timeo;
 
-	skb = netlink_trim(skb, allocation ? allocation : gfp_any());
+	skb = netlink_trim(skb, gfp_any());
 
 	timeo = sock_sndtimeo(ssk, nonblock);
 retry:
@@ -2346,8 +2346,7 @@
 		atomic_inc(&skb->users);
 		netlink_broadcast(sk, skb, dst_portid, dst_group, GFP_KERNEL);
 	}
-	err = netlink_unicast(sk, skb, dst_portid,
-			msg->msg_flags&MSG_DONTWAIT, 0);
+	err = netlink_unicast(sk, skb, dst_portid, msg->msg_flags&MSG_DONTWAIT);
 
 out:
 	scm_destroy(siocb->scm);
@@ -2804,8 +2803,7 @@
 	errmsg = nlmsg_data(rep);
 	errmsg->error = err;
 	memcpy(&errmsg->msg, nlh, err ? nlh->nlmsg_len : sizeof(*nlh));
-	netlink_unicast(in_skb->sk, skb, NETLINK_CB(in_skb).portid,
-					MSG_DONTWAIT, 0);
+	netlink_unicast(in_skb->sk, skb, NETLINK_CB(in_skb).portid, MSG_DONTWAIT);
 }
 EXPORT_SYMBOL(netlink_ack);
 
@@ -2881,7 +2879,7 @@
 	if (report) {
 		int err2;
 
-		err2 = nlmsg_unicast(sk, skb, portid, flags);
+		err2 = nlmsg_unicast(sk, skb, portid);
 		if (!err || err == -ESRCH)
 			err = err2;
 	}
diff -Naur a/net/packet/af_packet.c b/net/packet/af_packet.c
--- a/net/packet/af_packet.c	2017-10-11 10:17:42.677489000 +0530
+++ b/net/packet/af_packet.c	2017-10-11 09:38:04.812902000 +0530
@@ -1178,7 +1178,7 @@
 				     struct sk_buff *skb,
 				     unsigned int num)
 {
-	return prandom_u32_max(num);
+	return reciprocal_divide(prandom_u32(), num);
 }
 
 static unsigned int fanout_demux_rollover(struct packet_fanout *f,
diff -Naur a/net/sched/sch_choke.c b/net/sched/sch_choke.c
--- a/net/sched/sch_choke.c	2017-10-11 10:17:42.740493000 +0530
+++ b/net/sched/sch_choke.c	2017-10-11 09:38:04.876910000 +0530
@@ -14,6 +14,7 @@
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/skbuff.h>
+#include <linux/reciprocal_div.h>
 #include <linux/vmalloc.h>
 #include <net/pkt_sched.h>
 #include <net/inet_ecn.h>
@@ -76,6 +77,12 @@
 	struct sk_buff **tab;
 };
 
+/* deliver a random number between 0 and N - 1 */
+static u32 random_N(unsigned int N)
+{
+	return reciprocal_divide(prandom_u32(), N);
+}
+
 /* number of elements in queue including holes */
 static unsigned int choke_len(const struct choke_sched_data *q)
 {
@@ -226,7 +233,7 @@
 	int retrys = 3;
 
 	do {
-		*pidx = (q->head + prandom_u32_max(choke_len(q))) & q->tab_mask;
+		*pidx = (q->head + random_N(choke_len(q))) & q->tab_mask;
 		skb = q->tab[*pidx];
 		if (skb)
 			return skb;
diff -Naur a/net/socket.c b/net/socket.c
--- a/net/socket.c	2017-10-11 10:17:42.912507000 +0530
+++ b/net/socket.c	2017-10-11 09:38:05.051923000 +0530
@@ -361,7 +361,6 @@
 	struct qstr name = { .name = "" };
 	struct path path;
 	struct file *file;
-	struct pid *toe_pid;
 
 	if (dname) {
 		name.name = dname;
@@ -390,14 +389,12 @@
 	sock->file = file;
 	file->f_flags = O_RDWR | (flags & O_NONBLOCK);
 	file->private_data = sock;
-    if (sock->sk) {
-        if (toe_acceleration_flag_set_hook) {
-            toe_pid = find_get_pid(task_pid_nr(current));
-            toe_acceleration_flag_set_hook(sock->sk, toe_pid, SOCKET_ALLOCATE);
-            put_pid(toe_pid);
-        }
-    }
-    return file;
+	if (sock->sk) {
+		if (toe_acceleration_flag_set_hook) {
+			toe_acceleration_flag_set_hook(sock->sk, find_get_pid(task_pid_nr(current)), SOCKET_ALLOCATE);
+		}
+	}
+	return file;
 }
 EXPORT_SYMBOL(sock_alloc_file);
 
@@ -595,14 +592,11 @@
 
 void sock_release(struct socket *sock)
 {
-    struct pid * toe_pid;
-    if (sock->sk) {
-        if (toe_acceleration_flag_set_hook) {
-            toe_pid = find_get_pid(task_pid_nr(current));
-            toe_acceleration_flag_set_hook(sock->sk, toe_pid, SOCKET_RELEASE);
-            put_pid(toe_pid);
-        }
-    }
+	if (sock->sk) {
+		if (toe_acceleration_flag_set_hook) {
+			toe_acceleration_flag_set_hook(sock->sk, find_get_pid(task_pid_nr(current)), SOCKET_RELEASE);
+		}
+	}
 	if (sock->ops) {
 		struct module *owner = sock->ops->owner;
 
diff -Naur a/net/ti/pp/ti_hil_core.c b/net/ti/pp/ti_hil_core.c
--- a/net/ti/pp/ti_hil_core.c	2017-10-11 10:17:40.444317000 +0530
+++ b/net/ti/pp/ti_hil_core.c	2017-10-11 09:38:02.717730000 +0530
@@ -105,6 +105,7 @@
 int create_drop_session(struct sk_buff* skb, unsigned long event)
 {
     struct hil_core_notifier_param param;
+    unsigned int flags;
 
     TI_HIL_NETDEV_SET_EVENT(skb, event);
 
@@ -170,6 +171,15 @@
 EXPORT_SYMBOL(ti_hil_delete_session_notification_cb);
 #endif /* CONFIG_TI_PACKET_PROCESSOR_STATS */
 
+#ifdef CONFIG_INTEL_L2VPN_MAC_AGING
+/* DOCSIS Packet processor MAC AGING start session notification Callback */
+TI_HIL_MAC_AGING_START_SESSION ti_hil_mac_aging_start_session_notification_cb = NULL;
+EXPORT_SYMBOL(ti_hil_mac_aging_start_session_notification_cb);
+/* DOCSIS Packet processor MAC AGING delete session notification Callback */
+TI_HIL_MAC_AGING_DELETE_SESSION ti_hil_mac_aging_delete_session_notification_cb = NULL;
+EXPORT_SYMBOL(ti_hil_mac_aging_delete_session_notification_cb);
+#endif
+
 /**************************************************************************
  ******************************* Functions  *******************************
  **************************************************************************/
@@ -371,6 +381,7 @@
 int ti_hil_pp_event(unsigned long event, void *v)
 {
     struct sk_buff*              skb;
+    unsigned int                 flags;
     struct xt_table              *xt;
     /* Handle only the events currently supported in Atom SDK */
     switch (event)
@@ -383,8 +394,15 @@
              *  c) Multicast packet but no layer2 extensions eg IGMP snooping exists */
             skb = (struct sk_buff*) v;
 
+            /* Convert existing flags to host byte order */
+            flags = ntohl(skb->pp_packet_info->flags);
+
             /* In the intrusive mode profile these packets are not considered as candidates for acceleration so mark the packet BYPASS mode so that the egress hook is bypassed */
-            TI_HIL_ADD_PP_INFO_FLAGS(skb, TI_HIL_PACKET_FLAG_PP_SESSION_BYPASS);
+            flags |= TI_HIL_PACKET_FLAG_PP_SESSION_BYPASS;
+
+            /* Convert new flags back to network byte order */
+            skb->pp_packet_info->flags = htonl(flags);
+
             break;
         }
 #ifdef CONFIG_APPCPU_GW_PP_HANDLE
@@ -412,7 +430,7 @@
                 break;
             }
 
-        if (SKB_GET_PP_INFO_P(skb)->input_device_index == 0)
+	    if (skb->pp_packet_info->input_device_index == 0)
             {
 		break;
             }
@@ -429,7 +447,7 @@
 		break;
 	    }
 
-            memcpy(SKB_GET_COOKIE_P(new_skb), SKB_GET_COOKIE_P(skb), sizeof(SKB_INTEL_COOKIE));
+            memcpy(new_skb->pp_packet_info, skb->pp_packet_info, sizeof(PP_PACKET_INFO_t));
             memcpy(new_skb->data, skb->data, skb->len);
             skb_put(new_skb, skb->len);
 
@@ -647,6 +665,104 @@
 }
 #endif /* CONFIG_TI_PACKET_PROCESSOR_STATS */
 
+#ifdef CONFIG_INTEL_L2VPN_MAC_AGING
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_register_mac_aging_start_session_notification
+ **************************************************************************
+ * DESCRIPTION   :
+ *  Register the DOCSIS Packet Processor start session notification for mac aging feature
+ *  callback function
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ **************************************************************************/
+int ti_hil_register_mac_aging_start_session_notification(
+	TI_HIL_MAC_AGING_START_SESSION ti_hil_start_session_notification)
+{
+	if (ti_hil_mac_aging_start_session_notification_cb != NULL) {
+		pr_err("Error: DOCSIS Packet Processor mac aging start session notification callback already exist\n");
+		return -1;
+	}
+
+	ti_hil_mac_aging_start_session_notification_cb =
+		ti_hil_start_session_notification;
+
+	return 0;
+}
+
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_unregister_mac_aging_start_session_notification
+ **************************************************************************
+ * DESCRIPTION   :
+ *  Un-Register the DOCSIS Packet Processor start session notification for mac aging feature
+ *  callback function
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ **************************************************************************/
+int ti_hil_unregister_mac_aging_start_session_notification(void)
+{
+	if (ti_hil_mac_aging_start_session_notification_cb == NULL) {
+		pr_err("Error: DOCSIS Packet Processor mac aging start session notification callback empty\n");
+		return -1;
+	}
+
+	ti_hil_mac_aging_start_session_notification_cb = NULL;
+
+	return 0;
+}
+
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_register_mac_aging_delete_session_notification
+ **************************************************************************
+ * DESCRIPTION   :
+ *  Register the DOCSIS Packet processor delete session notification for mac aging feature
+ *  callback function
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ **************************************************************************/
+int ti_hil_register_mac_aging_delete_session_notification(
+	TI_HIL_MAC_AGING_DELETE_SESSION ti_hil_delete_session_notification)
+{
+	if (ti_hil_mac_aging_delete_session_notification_cb != NULL) {
+		pr_err("Error: DOCSIS Packet Processor delete session notification callback already exist\n");
+		return -1;
+	}
+
+	ti_hil_mac_aging_delete_session_notification_cb =
+		ti_hil_delete_session_notification;
+
+	return 0;
+}
+
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_unregister_mac_aging_delete_session_notification
+ **************************************************************************
+ * DESCRIPTION   :
+ *  Un-Register the DOCSIS Packet processor delete session notification for mac aging feature
+ *  callback function
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ **************************************************************************/
+int ti_hil_unregister_mac_aging_delete_session_notification(void)
+{
+	if (ti_hil_mac_aging_delete_session_notification_cb == NULL) {
+		pr_err("Error: DOCSIS Packet Processor mac aging delete session notification callback empty\n");
+		return -1;
+	}
+
+	ti_hil_mac_aging_delete_session_notification_cb = NULL;
+
+	return 0;
+}
+#endif CONFIG_INTEL_L2VPN_MAC_AGING
+
 /* Export all the Symbols for Linux; so that these can be called from modules. */
 EXPORT_SYMBOL(ti_hil_initialize);
 EXPORT_SYMBOL(ti_hil_register_profile);
@@ -658,4 +774,11 @@
 EXPORT_SYMBOL(ti_hil_register_delete_session_notification);
 EXPORT_SYMBOL(ti_hil_unregister_delete_session_notification);
 #endif /* CONFIG_TI_PACKET_PROCESSOR_STATS */
+#ifdef CONFIG_INTEL_L2VPN_MAC_AGING
+/* DOCSIS Packet processor start/delete session notification API */
+EXPORT_SYMBOL(ti_hil_register_mac_aging_start_session_notification);
+EXPORT_SYMBOL(ti_hil_unregister_mac_aging_start_session_notification);
+EXPORT_SYMBOL(ti_hil_register_mac_aging_delete_session_notification);
+EXPORT_SYMBOL(ti_hil_unregister_mac_aging_delete_session_notification);
+#endif /* CONFIG_INTEL_L2VPN_MAC_AGING */
 
diff -Naur a/net/ti/pp/ti_hil_core_gw.c b/net/ti/pp/ti_hil_core_gw.c
--- a/net/ti/pp/ti_hil_core_gw.c	2017-10-11 10:17:40.442305000 +0530
+++ b/net/ti/pp/ti_hil_core_gw.c	2017-10-11 09:38:02.715739000 +0530
@@ -25,30 +25,20 @@
 */
 
 /**************************************************************************
- *************************** Include Files ********************************
+ * FUNCTION NAME : ti_hil_pp_event
+ **************************************************************************
+ * DESCRIPTION   :
+ *  Placeholder for the hil event notifyer.  Remove when full hil layer
+ *  is ported to the Atom SDK.
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
  **************************************************************************/
 
-#include <linux/types.h>
 #include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/string.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/netdevice.h>
-#include <linux/inetdevice.h>
-#include <linux/rtnetlink.h>
 #include <linux/byteorder/generic.h>
 #include <linux/ti_hil.h>
-#include <linux/notifier.h>
-
-#if PUMA7_OR_NEWER_SOC_TYPE
-#ifdef CONFIG_ARM_AVALANCHE_SOC
-#include "synopsys_gbe_interface.h"
-#else
-#include <linux/avalanche/puma7/synopsys_gbe_interface.h>
-#include <linux/avalanche/puma7/puma7_defs.h>
-#endif
-#endif
 #ifdef CONFIG_NETFILTER
 #include <linux/netfilter.h>
 #include <net/netfilter/nf_conntrack.h>
@@ -59,12 +49,7 @@
 #ifdef CONFIG_APPCPU_GW_PP_HANDLE
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
-#endif
 
-/**************************************************************************
- ***************************** Static Declarations  ***********************
- **************************************************************************/
-#ifdef CONFIG_APPCPU_GW_PP_HANDLE
 static unsigned int notifier_list_was_init = 0;
 static struct   atomic_notifier_head notifier_list;
 static unsigned int dropped_packets_bit_map;
@@ -122,260 +107,6 @@
 }
 #endif /* CONFIG_APPCPU_GW_PP_HANDLE */
 
-/* HIL Core Event Handler for all networking events. */
-static int ti_hil_net_event_handler(struct notifier_block *chain, unsigned long event, void *ptr);
-
-/* Dev Notifier Block for the HIL; this will get notifications for all the dev related events. */
-static struct notifier_block hil_dev_notifier_block =
-{
-    .notifier_call = ti_hil_net_event_handler,
-};
-
-/* INET Addr Notifier Block for the PPM; this will get notifications for all the INET related events. */
-static struct notifier_block hil_inetaddr_notifier_block =
-{
-    .notifier_call = ti_hil_net_event_handler,
-};
-
-/* PP Notifier Block for the PP; this will get notifications for all the PP related events. */
-static struct notifier_block hil_pp_notifier_block =
-{
-    .notifier_call = ti_hil_net_event_handler,
-};
-
-/**************************************************************************
- * STRUCTURE NAME : TI_HIL_MCB
- **************************************************************************
- * DESCRIPTION   :
- *  The structure describes the HIL Master control block which is used
- *  to keep track of the HIL profiles which are active.
- **************************************************************************/
-typedef struct TI_HIL_MCB
-{
-    /* HIL Status   */
-    int              initialized;
-
-    /* Active HIL Profile. */
-    TI_HIL_PROFILE*  active_profile;
-}TI_HIL_MCB;
-
-/**************************************************************************
- ********************************* Globals ********************************
- **************************************************************************/
-
-/* HIL Master Control Block. */
-TI_HIL_MCB             hil_mcb;
-
-/* Packet Processor Notifier Chain */
-ATOMIC_NOTIFIER_HEAD(pp_chain);
-
-#ifdef CONFIG_TI_PACKET_PROCESSOR_STATS
-/* DOCSIS Packet processor start session notification Callback */
-TI_HIL_START_SESSION ti_hil_start_session_notification_cb = NULL;
-EXPORT_SYMBOL(ti_hil_start_session_notification_cb);
-/* DOCSIS Packet processor delete session notification Callback */
-TI_HIL_DELETE_SESSION ti_hil_delete_session_notification_cb = NULL;
-EXPORT_SYMBOL(ti_hil_delete_session_notification_cb);
-#endif /* CONFIG_TI_PACKET_PROCESSOR_STATS */
-
-/**************************************************************************
- ******************************* Functions  *******************************
- **************************************************************************/
-
-/**************************************************************************
- * FUNCTION NAME : ti_hil_net_event_handler
- **************************************************************************
- * DESCRIPTION   :
- *  HIL Core registered event handler. This function receives event from all
- *  over the networking subsystem.
- *
- * RETURNS       :
- *  Always returns NOTIFY_DONE
- **************************************************************************/
-static int ti_hil_net_event_handler(struct notifier_block *chain, unsigned long event, void *ptr)
-{
-    unsigned int    module;
-
-    /* Check if there exists an active profile. */
-    if (hil_mcb.active_profile)
-    {
-        /* Use the chain to identify the module */
-        if (chain == &hil_dev_notifier_block)
-        {
-            /* Device Interface Management Module. */
-            module = TI_DEVICE;
-        }
-        else if (chain == &hil_inetaddr_notifier_block)
-        {
-            /* Inet address Management Module. */
-            module = TI_INET;
-        }
-        else if (chain == &hil_pp_notifier_block)
-        {
-            /* PP Chain Management Module. */
-            module = TI_PP;
-        }
-        else
-        {
-            /* Unrecognized chain: This is a FATAL Error and should not happen. */
-            printk ("FATAL HIL Core Error: Received event from unknown chain 0x%p\n", chain);
-            return NOTIFY_DONE;
-        }
-
-        /* Pass the event to the profile handler. */
-        hil_mcb.active_profile->profile_handler (module, event, ptr);
-    }
-
-    /* Work is succesfully completed. */
-    return NOTIFY_DONE;
-}
-
-/**************************************************************************
- * FUNCTION NAME : ti_hil_load_profile
- **************************************************************************
- * DESCRIPTION   :
- *  The function is used to load the specific HIL Profile.
- *
- * RETURNS       :
- *  0   -   Success
- *  <0  -   Error
- **************************************************************************/
-static int ti_hil_load_profile (TI_HIL_PROFILE* ptr_profile)
-{
-    /* Unload and deinitialize the profile. */
-    if (ptr_profile->profile_init() < 0)
-    {
-        printk ("HIL Core: Unable to load profile %s\n", ptr_profile->name);
-        return -1;
-    }
-
-    /* Profile has been succesfully loaded. */
-    printk ("HIL Core: Profile %s has been Loaded.\n", ptr_profile->name);
-    return 0;
-}
-
-/**************************************************************************
- * FUNCTION NAME : ti_hil_unload_profile
- **************************************************************************
- * DESCRIPTION   :
- *  The function is used to unload the specific HIL Profile.
- *
- * RETURNS       :
- *  0   -   Success
- *  <0  -   Error
- **************************************************************************/
-static int ti_hil_unload_profile (TI_HIL_PROFILE* ptr_profile)
-{
-    /* Unload and deinitialize the profile. */
-    if (ptr_profile->profile_deinit() < 0)
-    {
-        printk ("HIL Core: Unable to unload profile %s\n", ptr_profile->name);
-        return -1;
-    }
-
-    /* Profile has been succesfully unloaded. */
-    printk ("HIL Core: Profile %s has been unloaded.\n", ptr_profile->name);
-    return 0;
-}
-
-/**************************************************************************
- * FUNCTION NAME : ti_hil_register_profile
- **************************************************************************
- * DESCRIPTION   :
- *  The function is used to register the HIL Profile.
- *
- * RETURNS       :
- *  0   -   Success
- *  <0  -   Error
- **************************************************************************/
-int ti_hil_register_profile (TI_HIL_PROFILE* ptr_profile)
-{
-    /* Ensure that the HIL has been initialized before proceeding. */
-    if (hil_mcb.initialized == 0)
-        return -1;
-
-    /* Validate the arguments. */
-    if (ptr_profile == NULL)
-        return -1;
-
-    /* Check if a profile already exists? */
-    if (hil_mcb.active_profile != NULL)
-    {
-        /* Profile already exists. We need to unload the profile and load the
-         * new one instead. */
-        ti_hil_unload_profile (hil_mcb.active_profile);
-
-        /* Cleanup the memory associated with the active profile. */
-        kfree (hil_mcb.active_profile);
-    }
-
-    /* Allocate memory for the HIL Profile. */
-    hil_mcb.active_profile = (TI_HIL_PROFILE *)kmalloc(sizeof(TI_HIL_PROFILE), GFP_KERNEL);
-    if (hil_mcb.active_profile == NULL)
-    {
-        /* Memory Allocation Failed. */
-        printk ("HIL Core: Unable to allocate memory for the HIL Profile %s\n", ptr_profile->name);
-        return -1;
-    }
-
-    /* Copy the profile into the active profile. */
-    memcpy ((void *)hil_mcb.active_profile, (void *)ptr_profile, sizeof(TI_HIL_PROFILE));
-
-    /* Initialize the profile. */
-    if (ti_hil_load_profile (hil_mcb.active_profile) == 0)
-        return 0;
-
-    /* Error: Unable to initialize the profile. */
-    printk ("HIL Core: HIL Profile %s failed to initialize.\n", hil_mcb.active_profile->name);
-    return -1;
-}
-
-/**************************************************************************
- * FUNCTION NAME : ti_hil_initialize
- **************************************************************************
- * DESCRIPTION   :
- *  Initialize the HIL Core Layer.
- *
- * RETURNS       :
- *  0   -   Success
- *  <0  -   Error
- **************************************************************************/
-int ti_hil_initialize (void)
-{
-    /* Initialize the HIL Master Control Block */
-    memset ((void *)&hil_mcb, 0, sizeof(TI_HIL_MCB));
-
-    /* Register the HIL core to receive netdevice events */
-    register_netdevice_notifier(&hil_dev_notifier_block);
-
-    /* Register the HIL core to receive inet events */
-    register_inetaddr_notifier(&hil_inetaddr_notifier_block);
-
-    /* Register the HIL core to receive events */
-    atomic_notifier_chain_register(&pp_chain, &hil_pp_notifier_block);
-
-    /* The HIL core is operational now. */
-    hil_mcb.initialized = 1;
-    return 0;
-}
-
-
-/**************************************************************************
- * FUNCTION NAME : ti_hil_pp_event
- **************************************************************************
- * DESCRIPTION   :
- *  Notify the HIL of a PP event.
- *
- * RETURNS       :
- *  0   -   Success
- *  <0  -   Error
- **************************************************************************/
-#ifdef CONFIG_TI_PACKET_PROCESSOR
-int ti_hil_pp_event(unsigned long val, void *v)
-{
-    return atomic_notifier_call_chain(&pp_chain, val, v);
-}	
-#else //CONFIG_TI_PACKET_PROCESSOR
 int ti_hil_pp_event(unsigned long event, void *v)
 {
     struct sk_buff*              skb;
@@ -480,197 +211,3 @@
     }
     return 0;
 }
-#endif //else TI_PACKET_PROCESSOR
-
-
-#if PUMA7_OR_NEWER_SOC_TYPE
-/**************************************************************************
- * FUNCTION NAME : ti_hil_is_gbe_device
- **************************************************************************
- * DESCRIPTION   :
- *  Return true if this is a gbe device
- *
- * RETURNS       :
- *  None
- **************************************************************************/
-int ti_hil_is_gbe_device(struct net_device *origDev)
-{
-    if (0 == strcmp(origDev->name, NSGMII0_NAME))
-    {
-        return 1;
-    }
-
-    if (0 == strcmp(origDev->name, NSGMII1_NAME))
-    {
-        return 1;
-    }
-
-    if (0 == strcmp(origDev->name, NRGMII2_NAME))
-    {
-        return 1;
-    }
-
-    if (0 == strcmp(origDev->name, NRGMII3_NAME))
-    {
-        return 1;
-    }
-
-    if (0 == strcmp(origDev->name, NGMII_TO_ATOM_NAME))
-    {
-        return 1;
-    }
-
-    return 0;
-}
-#endif
-
-/**************************************************************************
- * FUNCTION NAME : ti_hil_clone_netdev_pp_info
- **************************************************************************
- * DESCRIPTION   :
- *  Copies all the relevant PP PID information from one network device to another
- *
- * RETURNS       :
- *  None
- **************************************************************************/
-void ti_hil_clone_netdev_pp_info(struct net_device *newDev, struct net_device *origDev)
-{
-    newDev->pid_handle              = origDev->pid_handle;
-    memcpy((void *)&newDev->vpid_block, (void *)&origDev->vpid_block, sizeof(origDev->vpid_block));
-#if PUMA7_OR_NEWER_SOC_TYPE
-    strncpy(newDev->vpid_block.devName, newDev->name, VPID_IF_NAME_SIZE);
-#endif
-    newDev->qos_setup_hook          = origDev->qos_setup_hook;
-    newDev->qos_shutdown_hook       = origDev->qos_shutdown_hook;
-    newDev->qos_select_hook         = origDev->qos_select_hook;
-#if PUMA7_OR_NEWER_SOC_TYPE
-    newDev->qos_get_params_hook       = origDev->qos_get_params_hook;
-#endif
-    newDev->qos_virtual_scheme_idx  = origDev->qos_virtual_scheme_idx;
-    newDev->devInstance             = origDev->devInstance;
-
-#if PUMA7_OR_NEWER_SOC_TYPE
-#ifdef CONFIG_ARM_AVALANCHE_SOC
-    if (ti_hil_is_gbe_device(origDev))
-#endif
-    {
-        if (origDev->netdev_copy_priv_hook)
-        {
-            origDev->netdev_copy_priv_hook(newDev, origDev);
-	        newDev->netdev_copy_priv_hook = origDev->netdev_copy_priv_hook;
-        }
-    }
-#endif
-}
-EXPORT_SYMBOL(ti_hil_clone_netdev_pp_info);
-
-#ifdef CONFIG_TI_PACKET_PROCESSOR_STATS
-/**************************************************************************
- * FUNCTION NAME : ti_hil_register_start_session_notification
- **************************************************************************
- * DESCRIPTION   :
- *  Register the DOCSIS Packet Processor start session notification
- *  callback function
- *
- * RETURNS       :
- *  0   -   Success
- *  <0  -   Error
- **************************************************************************/
-int ti_hil_register_start_session_notification(TI_HIL_START_SESSION ti_hil_start_session_notification)
-{
-    if (ti_hil_start_session_notification_cb != NULL)
-    {
-        printk ("Error: DOCSIS Packet Processor start session notification callback already exist\n");
-        return -1;
-    }
-
-    ti_hil_start_session_notification_cb = ti_hil_start_session_notification;
-
-    return 0;
-}
-
-/**************************************************************************
- * FUNCTION NAME : ti_hil_unregister_start_session_notification
- **************************************************************************
- * DESCRIPTION   :
- *  Un-Register the DOCSIS Packet Processor start session notification
- *  callback function
- *
- * RETURNS       :
- *  0   -   Success
- *  <0  -   Error
- **************************************************************************/
-int ti_hil_unregister_start_session_notification(void)
-{
-    if (ti_hil_start_session_notification_cb == NULL)
-    {
-        printk ("Error: DOCSIS Packet Processor start session notification callback empty\n");
-        return -1;
-    }
-
-    ti_hil_start_session_notification_cb = NULL;
-
-    return 0;
-}
-
-/**************************************************************************
- * FUNCTION NAME : ti_hil_register_delete_session_notification
- **************************************************************************
- * DESCRIPTION   :
- *  Register the DOCSIS Packet processor delete session notification
- *  callback function
- *
- * RETURNS       :
- *  0   -   Success
- *  <0  -   Error
- **************************************************************************/
-int ti_hil_register_delete_session_notification(TI_HIL_DELETE_SESSION ti_hil_delete_session_notification)
-{
-    if (ti_hil_delete_session_notification_cb != NULL)
-    {
-        printk ("Error: DOCSIS Packet Processor delete session notification callback already exist\n");
-        return -1;
-    }
-
-    ti_hil_delete_session_notification_cb = ti_hil_delete_session_notification;
-
-    return 0;
-}
-
-/**************************************************************************
- * FUNCTION NAME : ti_hil_unregister_delete_session_notification
- **************************************************************************
- * DESCRIPTION   :
- *  Un-Register the DOCSIS Packet processor delete session notification
- *  callback function
- *
- * RETURNS       :
- *  0   -   Success
- *  <0  -   Error
- **************************************************************************/
-int ti_hil_unregister_delete_session_notification(void)
-{
-    if (ti_hil_delete_session_notification_cb == NULL)
-    {
-        printk ("Error: DOCSIS Packet Processor delete session notification callback empty\n");
-        return -1;
-    }
-
-    ti_hil_delete_session_notification_cb = NULL;
-
-    return 0;
-}
-#endif /* CONFIG_TI_PACKET_PROCESSOR_STATS */
-
-/* Export all the Symbols for Linux; so that these can be called from modules. */
-EXPORT_SYMBOL(ti_hil_initialize);
-EXPORT_SYMBOL(ti_hil_register_profile);
-EXPORT_SYMBOL(ti_hil_pp_event);
-#ifdef CONFIG_TI_PACKET_PROCESSOR_STATS
-/* DOCSIS Packet processor start/delete session notification API */
-EXPORT_SYMBOL(ti_hil_register_start_session_notification);
-EXPORT_SYMBOL(ti_hil_unregister_start_session_notification);
-EXPORT_SYMBOL(ti_hil_register_delete_session_notification);
-EXPORT_SYMBOL(ti_hil_unregister_delete_session_notification);
-#endif /* CONFIG_TI_PACKET_PROCESSOR_STATS */
-
diff -Naur a/net/ti.Kconfig b/net/ti.Kconfig
--- a/net/ti.Kconfig	2017-10-11 10:17:42.785496000 +0530
+++ b/net/ti.Kconfig	2017-10-11 09:38:04.924922000 +0530
@@ -186,12 +186,6 @@
 
 menu "TI Packet Processor Subsystem"
 
-config NPCPU_HARDCODED_OFFCHIP_INFO
-	bool "Hard coded address and size of NPCPU"
-	default n
-	help
-		Force Mapping NPCPU DDR in a hardcoded manner
-		Address and size will be hardcoded
 
 config NPCPU_HARDCODED_OFFCHIP_INFO
 	bool "Hard coded address and size of NPCPU"
@@ -274,29 +268,13 @@
       Enable this to support L2TPv3 and GRE-MPLS tunnels by PP.
       This tunnels should be configured statically and regular session will not be created by PP.
 
-config PP_SANITY_TESTS
-    	bool "Enable SanityTestModule"
-    	default n
-	depends on TI_PACKET_PROCESSOR
-    help
-      Select if Sanity test module support is needed
-      
-config NP_APP_DATAPIPE
-        bool "NP-CPU APP-CPU Datapipe network device"
-        default y
-        ---help---
-          If gateway capabilities is on APP-CPU(Atom)
-          than select yes.
-          If gateway capabilities is on NP-CPU(Arm11)
-          than select no.
-
 config SESS_TIMEOUT_BY_THRESH
-    	bool "Enable Session timeout by thresholds mechanism"
-    	default n
-	depends on TI_PACKET_PROCESSOR
+        bool "Enable Session timeout by thresholds mechanism"
+        default n
+        depends on TI_PACKET_PROCESSOR
     help
       Select if Sessions should be timedout according to high and low thresholds
-
+      
 endmenu
 config INTEL_IRQ_THREAD_CHANGE_PRIORITY
 	bool "Change scheduler policy and priority "
diff -Naur a/net/unix/diag.c b/net/unix/diag.c
--- a/net/unix/diag.c	2017-10-11 10:17:41.035353000 +0530
+++ b/net/unix/diag.c	2017-10-11 09:38:03.232778000 +0530
@@ -279,7 +279,7 @@
 		goto again;
 	}
 	err = netlink_unicast(net->diag_nlsk, rep, NETLINK_CB(in_skb).portid,
-			      MSG_DONTWAIT, 0);
+			      MSG_DONTWAIT);
 	if (err > 0)
 		err = 0;
 out:
diff -Naur a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c
--- a/net/xfrm/xfrm_user.c	2017-10-11 10:17:42.258453000 +0530
+++ b/net/xfrm/xfrm_user.c	2017-10-11 09:38:04.272858000 +0530
@@ -1004,7 +1004,7 @@
 	if (build_spdinfo(r_skb, net, sportid, seq, *flags) < 0)
 		BUG();
 
-	return nlmsg_unicast(net->xfrm.nlsk, r_skb, sportid, 0);
+	return nlmsg_unicast(net->xfrm.nlsk, r_skb, sportid);
 }
 
 static inline size_t xfrm_sadinfo_msgsize(void)
@@ -1061,7 +1061,7 @@
 	if (build_sadinfo(r_skb, net, sportid, seq, *flags) < 0)
 		BUG();
 
-	return nlmsg_unicast(net->xfrm.nlsk, r_skb, sportid, 0);
+	return nlmsg_unicast(net->xfrm.nlsk, r_skb, sportid);
 }
 
 static int xfrm_get_sa(struct sk_buff *skb, struct nlmsghdr *nlh,
@@ -1081,8 +1081,7 @@
 	if (IS_ERR(resp_skb)) {
 		err = PTR_ERR(resp_skb);
 	} else {
-		err = nlmsg_unicast(net->xfrm.nlsk, resp_skb,
-				NETLINK_CB(skb).portid, 0);
+		err = nlmsg_unicast(net->xfrm.nlsk, resp_skb, NETLINK_CB(skb).portid);
 	}
 	xfrm_state_put(x);
 out_noput:
@@ -1163,8 +1162,7 @@
 		goto out;
 	}
 
-	err = nlmsg_unicast(net->xfrm.nlsk, resp_skb,
-			NETLINK_CB(skb).portid, 0);
+	err = nlmsg_unicast(net->xfrm.nlsk, resp_skb, NETLINK_CB(skb).portid);
 
 out:
 	xfrm_state_put(x);
@@ -1675,7 +1673,7 @@
 			err = PTR_ERR(resp_skb);
 		} else {
 			err = nlmsg_unicast(net->xfrm.nlsk, resp_skb,
-					    NETLINK_CB(skb).portid, 0);
+					    NETLINK_CB(skb).portid);
 		}
 	} else {
 		kuid_t loginuid = audit_get_loginuid(current);
@@ -1837,7 +1835,7 @@
 
 	if (build_aevent(r_skb, x, &c) < 0)
 		BUG();
-	err = nlmsg_unicast(net->xfrm.nlsk, r_skb, NETLINK_CB(skb).portid, 0);
+	err = nlmsg_unicast(net->xfrm.nlsk, r_skb, NETLINK_CB(skb).portid);
 	spin_unlock_bh(&x->lock);
 	xfrm_state_put(x);
 	return err;
