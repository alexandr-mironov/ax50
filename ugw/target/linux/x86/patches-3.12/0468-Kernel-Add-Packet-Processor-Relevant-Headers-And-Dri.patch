From ed7b5fd2eb4825b44f7a05c53bc7c3846ab4633e Mon Sep 17 00:00:00 2001
From: ofirbitt <ofir1.bitton@intel.com>
Date: Mon, 22 Aug 2016 13:26:37 +0300
Subject: [PATCH 468/639] Kernel: Add Packet Processor Relevant Headers And
 Drivers

- Headers and sources added to support pp features.
- Kconfigs modified to support pp features.

Signed-off-by: Ofir Bitton <ofir1.bitton@intel.com>
---
 Kconfig                                            |     7 +
 arch/x86/Kconfig                                   |    46 +-
 arch/x86/Makefile                                  |     3 +
 arch/x86/NetIP_SubSystem/Makefile                  |     2 +
 arch/x86/NetIP_SubSystem/avalanche_intc.c          |    64 +
 arch/x86/NetIP_SubSystem/netip_mem_util.c          |   252 +
 arch/x86/NetIP_SubSystem/netip_subsystem_config.c  |   132 +
 arch/x86/NetIP_SubSystem/netip_subsystem_config.h  |    35 +
 arch/x86/NetIP_SubSystem/netip_subsystem_lld.c     |   113 +-
 arch/x86/avalanche_intd/Makefile                   |    19 +
 arch/x86/avalanche_intd/avalanche_intd.c           |   271 +
 arch/x86/pal_cppi41/Makefile                       |    25 +
 arch/x86/pal_cppi41/cppi41_hw_mbox_if.h            |   131 +
 arch/x86/pal_cppi41/cru_ctrl.c                     |   306 +
 arch/x86/pal_cppi41/pal_cppi41.c                   |   606 +
 arch/x86/pp_init/Kconfig                           |    12 +
 arch/x86/pp_init/Makefile                          |    19 +
 arch/x86/pp_init/puma7_pp_init.c                   |   492 +
 drivers/mmc/host/sdhci-pci.c                       |     3 -
 drivers/mrpc/Kconfig                               |     7 +
 drivers/mrpc/Makefile                              |     6 +-
 drivers/mrpc/core/Makefile                         |    10 +-
 drivers/mrpc/handshake_client.c                    |   218 +
 drivers/mrpc/modphy_client.c                       |   307 +
 drivers/net/Kconfig                                |     4 +-
 drivers/net/ethernet/Kconfig                       |     1 +
 drivers/net/ethernet/Makefile                      |     1 +
 drivers/net/ethernet/lantiq/Kconfig                |    27 +
 drivers/net/ethernet/lantiq/Makefile               |     3 +
 drivers/net/ethernet/lantiq/lantiq_pcie.h          |   107 +
 .../ethernet/lantiq/lantiq_pcie_ep_vrx320_test.c   |   694 ++
 .../ethernet/lantiq/lantiq_pcie_ep_vrx320_test.h   |   264 +
 drivers/net/ethernet/lantiq/ltq_vrx320.c           |   657 +
 drivers/net/ethernet/lantiq/ltq_vrx320.h           |   157 +
 drivers/net/ethernet/lantiq/ltq_wrapper.h          |    28 +
 drivers/net/ethernet/lantiq/pcie-lantiq.h          |  1378 +++
 drivers/net/ethernet/synopsys/DWC_ETH_QOS_desc.c   |     2 +-
 drivers/net/ethernet/synopsys/DWC_ETH_QOS_mdio.c   |    27 +-
 drivers/net/ethernet/synopsys/DWC_ETH_QOS_pci.c    |     2 +
 .../net/ethernet/synopsys/DWC_ETH_QOS_yheader.h    |     2 +
 drivers/net/lpal_api/lpal_directpath.c             |     4 +-
 include/linux/avalanche/generic/_tistdtypes.h      |    58 +-
 include/linux/avalanche/generic/avalanche_intd.h   |   165 +
 .../linux/avalanche/generic/avalanche_pdsp_api.h   |   437 +
 include/linux/avalanche/generic/avalanche_pp_api.h |   674 +-
 include/linux/avalanche/generic/modphy_mrpc_api.h  |   159 +
 include/linux/avalanche/generic/pal.h              |    96 +
 include/linux/avalanche/generic/pal_cppi41.h       |   742 ++
 include/linux/avalanche/generic/pal_defs.h         |   270 +
 include/linux/avalanche/generic/pal_os.h           |   217 +
 include/linux/avalanche/generic/pal_osCfg.h        |    98 +
 include/linux/avalanche/generic/pal_osMem.h        |   346 +
 include/linux/avalanche/generic/pal_osMem_inline.h |   305 +
 include/linux/avalanche/generic/pal_osProtect.h    |   161 +
 .../linux/avalanche/generic/pal_osProtect_inline.h |   127 +
 include/linux/avalanche/generic/pal_sys.h          |   278 +
 include/linux/avalanche/generic/pp_qos_p7.h        |   572 +
 include/linux/avalanche/generic/ramtest.h          |    84 +
 include/linux/avalanche/puma7/puma7.h              |   266 +
 include/linux/avalanche/puma7/puma7_cppi.h         |   106 +-
 .../linux/avalanche/puma7/puma7_cppi_dsgqmgr_q.h   |   126 +
 .../linux/avalanche/puma7/puma7_cppi_gqmgr0_q.h    |  1842 +++
 .../linux/avalanche/puma7/puma7_cppi_gqmgr1_q.h    |   574 +
 .../linux/avalanche/puma7/puma7_cppi_gqmgr2_q.h    |   574 +
 include/linux/avalanche/puma7/puma7_cppi_lqmgr_q.h |    95 +
 include/linux/avalanche/puma7/puma7_cppi_prv.h     |  1962 ++-
 .../linux/avalanche/puma7/puma7_cppi_usqmgr_q.h    |   574 +
 include/linux/avalanche/puma7/puma7_cru_ctrl.h     |   125 +
 include/linux/avalanche/puma7/puma7_defs.h         |    69 +
 include/linux/avalanche/puma7/puma7_interrupts.h   |   180 +
 include/linux/avalanche/puma7/puma7_pp.h           |   641 +
 .../linux/avalanche/puma7/synopsys_gbe_interface.h |    87 +
 include/linux/hw_mbox_defs.h                       |     5 -
 include/linux/ipv6.h                               |     5 +
 include/linux/mmzone.h                             |     2 +-
 include/linux/netdevice.h                          |   113 +-
 include/linux/netip_mem_util.h                     |    36 +
 include/linux/netip_subsystem.h                    |    64 +-
 include/linux/proc_fs_macros.h                     |    41 +
 include/linux/skbuff.h                             |    37 +-
 include/linux/ti_hil.h                             |   216 +
 include/net/addrconf.h                             |     5 +
 include/net/ip.h                                   |     3 +
 include/net/netfilter/nf_conntrack.h               |     9 +-
 include/net/netfilter/nf_conntrack_tuple.h         |    19 +
 include/uapi/linux/in.h                            |    16 +
 include/uapi/linux/in6.h                           |    13 +
 include/uapi/linux/mii.h                           |     7 +
 include/uapi/linux/netfilter.h                     |     3 +
 net/8021q/vlan.c                                   |    11 +-
 net/8021q/vlan_core.c                              |     8 +
 net/Kconfig                                        |     2 +
 net/bridge/Makefile                                |     5 +-
 net/bridge/br_device.c                             |     3 +
 net/bridge/br_fdb.c                                |    37 +
 net/bridge/br_input.c                              |    40 +-
 net/bridge/br_notify.c                             |     9 +
 net/bridge/br_private.h                            |    23 +
 net/bridge/intel_br_l2vpn.c                        |   136 +
 net/bridge/ti_br_notify.c                          |    77 +
 net/bridge/ti_br_sf.c                              |   150 +
 net/bridge/ti_br_sph.c                             |   275 +
 net/ipv4/fib_trie.c                                |     7 +
 net/ipv4/icmp.c                                    |    10 +
 net/ipv4/ip_input.c                                |     5 +-
 net/ipv4/ip_output.c                               |    82 +-
 net/ipv4/ip_sockglue.c                             |    68 +
 net/ipv4/ipmr.c                                    |    23 +-
 net/ipv4/netfilter/ip_tables.c                     |     5 +-
 net/ipv4/raw.c                                     |     3 +
 net/ipv4/udp.c                                     |     4 +-
 net/ipv6/datagram.c                                |    13 +
 net/ipv6/ip6_input.c                               |    13 +
 net/ipv6/ip6_output.c                              |     9 +
 net/ipv6/ipv6_sockglue.c                           |    11 +
 net/ipv6/route.c                                   |    10 +-
 net/netfilter/core.c                               |     6 +-
 net/netfilter/nf_conntrack_core.c                  |    39 +-
 net/netfilter/nf_conntrack_proto_tcp.c             |    59 +-
 net/netfilter/nf_conntrack_standalone.c            |    22 +
 net/netfilter/nf_nat_core.c                        |     3 +
 net/netfilter/nf_queue.c                           |     8 +-
 net/netfilter/nfnetlink_queue_core.c               |     6 +
 net/ti.Kconfig                                     |   318 +
 net/ti/pp/ti_hil_core.c                            |   481 +-
 167 files changed, 82950 insertions(+), 218 deletions(-)
 create mode 100644 arch/x86/NetIP_SubSystem/netip_mem_util.c
 create mode 100644 arch/x86/NetIP_SubSystem/netip_subsystem_config.c
 create mode 100644 arch/x86/NetIP_SubSystem/netip_subsystem_config.h
 create mode 100644 arch/x86/avalanche_intd/Makefile
 create mode 100644 arch/x86/avalanche_intd/avalanche_intd.c
 create mode 100644 arch/x86/pal_cppi41/Makefile
 create mode 100644 arch/x86/pal_cppi41/cppi41_hw_mbox_if.h
 create mode 100644 arch/x86/pal_cppi41/cru_ctrl.c
 create mode 100644 arch/x86/pal_cppi41/pal_cppi41.c
 create mode 100644 arch/x86/pp_init/Kconfig
 create mode 100644 arch/x86/pp_init/Makefile
 create mode 100644 arch/x86/pp_init/puma7_pp_init.c
 create mode 100644 drivers/mrpc/handshake_client.c
 create mode 100644 drivers/mrpc/modphy_client.c
 create mode 100644 drivers/net/ethernet/lantiq/Kconfig
 create mode 100644 drivers/net/ethernet/lantiq/Makefile
 create mode 100644 drivers/net/ethernet/lantiq/lantiq_pcie.h
 create mode 100644 drivers/net/ethernet/lantiq/lantiq_pcie_ep_vrx320_test.c
 create mode 100644 drivers/net/ethernet/lantiq/lantiq_pcie_ep_vrx320_test.h
 create mode 100644 drivers/net/ethernet/lantiq/ltq_vrx320.c
 create mode 100644 drivers/net/ethernet/lantiq/ltq_vrx320.h
 create mode 100644 drivers/net/ethernet/lantiq/ltq_wrapper.h
 create mode 100644 drivers/net/ethernet/lantiq/pcie-lantiq.h
 create mode 100644 include/linux/avalanche/generic/avalanche_intd.h
 create mode 100755 include/linux/avalanche/generic/avalanche_pdsp_api.h
 create mode 100644 include/linux/avalanche/generic/modphy_mrpc_api.h
 create mode 100755 include/linux/avalanche/generic/pal.h
 create mode 100644 include/linux/avalanche/generic/pal_cppi41.h
 create mode 100755 include/linux/avalanche/generic/pal_defs.h
 create mode 100755 include/linux/avalanche/generic/pal_os.h
 create mode 100755 include/linux/avalanche/generic/pal_osCfg.h
 create mode 100755 include/linux/avalanche/generic/pal_osMem.h
 create mode 100755 include/linux/avalanche/generic/pal_osMem_inline.h
 create mode 100755 include/linux/avalanche/generic/pal_osProtect.h
 create mode 100755 include/linux/avalanche/generic/pal_osProtect_inline.h
 create mode 100755 include/linux/avalanche/generic/pal_sys.h
 create mode 100755 include/linux/avalanche/generic/pp_qos_p7.h
 create mode 100755 include/linux/avalanche/generic/ramtest.h
 create mode 100644 include/linux/avalanche/puma7/puma7.h
 create mode 100755 include/linux/avalanche/puma7/puma7_cppi_dsgqmgr_q.h
 create mode 100755 include/linux/avalanche/puma7/puma7_cppi_gqmgr0_q.h
 create mode 100755 include/linux/avalanche/puma7/puma7_cppi_gqmgr1_q.h
 create mode 100755 include/linux/avalanche/puma7/puma7_cppi_gqmgr2_q.h
 create mode 100755 include/linux/avalanche/puma7/puma7_cppi_lqmgr_q.h
 create mode 100755 include/linux/avalanche/puma7/puma7_cppi_usqmgr_q.h
 create mode 100755 include/linux/avalanche/puma7/puma7_cru_ctrl.h
 create mode 100644 include/linux/avalanche/puma7/puma7_defs.h
 create mode 100755 include/linux/avalanche/puma7/puma7_interrupts.h
 create mode 100755 include/linux/avalanche/puma7/puma7_pp.h
 create mode 100755 include/linux/avalanche/puma7/synopsys_gbe_interface.h
 create mode 100644 include/linux/netip_mem_util.h
 create mode 100644 include/linux/proc_fs_macros.h
 create mode 100644 net/bridge/intel_br_l2vpn.c
 create mode 100644 net/bridge/ti_br_notify.c
 create mode 100644 net/bridge/ti_br_sf.c
 create mode 100644 net/bridge/ti_br_sph.c
 create mode 100644 net/ti.Kconfig

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index ebb0159..c398935 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -458,7 +458,7 @@ config NET_SUBSYSTEM_SYSFS
           Exposes sysfs interface to get and set NET-IP subsystem attributes.
 
 menu "Intel Puma7 LitePath Support"
-    config PPA_PUMA7
+    config PPA_PUMA7
        bool "Configures Partial Offload feature in LitePath"
        depends on X86_PUMA7
        default n
@@ -469,7 +469,7 @@ menu "Intel Puma7 LitePath Support"
           Offload feature.
     config WIFI_MUX
        tristate "Enable WiFi Mux driver."
-       depends on PPA_PUMA7
+       depends on PPA_PUMA7
        default n
        ---help---
           Builds WiFi Mux driver, which is interface between datapipe
@@ -2634,3 +2674,5 @@ source "crypto/Kconfig"
 source "arch/x86/kvm/Kconfig"
 
 source "lib/Kconfig"
+
+source "arch/x86/pp_init/Kconfig"
diff --git a/arch/x86/Makefile b/arch/x86/Makefile
index 14cbb62..3b0a850 100644
--- a/arch/x86/Makefile
+++ b/arch/x86/Makefile
@@ -178,6 +178,8 @@ core-y += arch/x86/
 drivers-$(CONFIG_MATH_EMULATION) += arch/x86/math-emu/
 drivers-$(CONFIG_PCI)            += arch/x86/pci/
 drivers-$(CONFIG_NET_SUBSYSTEM)  += arch/x86/NetIP_SubSystem/
+drivers-$(CONFIG_AVALANCHE_INTD_APPCPU) += arch/x86/avalanche_intd/
+drivers-$(CONFIG_PAL_CPPI41_APPCPU) += arch/x86/pal_cppi41/
 drivers-$(CONFIG_HW_MUTEXES)     += arch/x86/hw_mutex/
 drivers-$(CONFIG_HW_MAILBOX)     += arch/x86/hw_mailbox/
 

diff --git a/arch/x86/NetIP_SubSystem/Makefile b/arch/x86/NetIP_SubSystem/Makefile
index dc44709..1bb1683 100644
--- a/arch/x86/NetIP_SubSystem/Makefile
+++ b/arch/x86/NetIP_SubSystem/Makefile
@@ -21,4 +21,6 @@ obj-$(CONFIG_NET_SUBSYSTEM) := netip_subsystem.o
 netip_subsystem-objs += netip_subsystem_lld.o
 netip_subsystem-objs += netip_subsystem_pm.o
 netip_subsystem-objs += avalanche_intc.o
+netip_subsystem-objs += netip_mem_util.o
+netip_subsystem-objs += netip_subsystem_config.o
 obj-$(CONFIG_NET_SUBSYSTEM_SYSFS) += netip_subsystem_sysfs.o
diff --git a/arch/x86/NetIP_SubSystem/avalanche_intc.c b/arch/x86/NetIP_SubSystem/avalanche_intc.c
index 924cf71..cc90321 100755
--- a/arch/x86/NetIP_SubSystem/avalanche_intc.c
+++ b/arch/x86/NetIP_SubSystem/avalanche_intc.c
@@ -95,6 +95,70 @@ inline unsigned char  get_reg_index( unsigned int irq )
     return((unsigned char )( irq / NUM_INTS_PER_REG ));
 }
 
+int avalanche_intc_set_interrupt_type( unsigned int irq,
+                                       unsigned char  int_type)
+{
+    unsigned int int_reg_indx = get_reg_index( irq );
+    unsigned int irq_bit = get_bit_position( irq );
+	
+    if (int_type)
+    {
+       avalanche_hw0_icregs->ictypr[int_reg_indx] |=
+           cpu_to_be32((1 << irq_bit));
+    }
+    else
+    {
+       avalanche_hw0_icregs->ictypr[int_reg_indx] &=
+           ~(cpu_to_be32((1 << irq_bit)));
+    }
+    return(0);
+}
+
+/* low level INTC type get */
+int avalanche_intc_get_interrupt_type( unsigned int irq )
+{
+    unsigned int int_reg_indx = get_reg_index( irq );
+    unsigned int irq_bit = get_bit_position( irq );
+	
+    return(unsigned char)((be32_to_cpu(avalanche_hw0_icregs->ictypr[int_reg_indx]) >>
+                                irq_bit)&0x1);
+}
+
+/* low level INTC pol set */
+int avalanche_intc_set_interrupt_polarity( unsigned int irq,
+                                           unsigned char int_polarity)
+{
+    unsigned int int_reg_indx =  get_reg_index( irq );
+    unsigned int irq_bit = get_bit_position( irq );
+	
+    if(int_polarity)
+    {
+        avalanche_hw0_icregs->icpolr[int_reg_indx] |=
+                        cpu_to_be32((1 << irq_bit));
+    }
+    else
+    {
+        avalanche_hw0_icregs->icpolr[int_reg_indx] &=
+                        ~(cpu_to_be32((1 << irq_bit)));
+    }
+    return(0);
+}
+
+/* low level INTC pol get */
+int avalanche_intc_get_interrupt_polarity ( unsigned int irq )
+{
+    unsigned int int_reg_indx = get_reg_index( irq );
+    unsigned int irq_bit = get_bit_position( irq );
+
+    return(unsigned char)((be32_to_cpu(avalanche_hw0_icregs->icpolr[int_reg_indx]) >>
+                            irq_bit)&0x1);
+}
+
+EXPORT_SYMBOL(avalanche_intc_set_interrupt_type);
+EXPORT_SYMBOL(avalanche_intc_get_interrupt_type);
+EXPORT_SYMBOL(avalanche_intc_set_interrupt_polarity);
+EXPORT_SYMBOL(avalanche_intc_get_interrupt_polarity);
+
 
 /********************************/
 /**  functions Implementation  **/
diff --git a/arch/x86/NetIP_SubSystem/netip_mem_util.c b/arch/x86/NetIP_SubSystem/netip_mem_util.c
new file mode 100644
index 0000000..f0d5b8b
--- /dev/null
+++ b/arch/x86/NetIP_SubSystem/netip_mem_util.c
@@ -0,0 +1,252 @@
+/*----------------------------------------------------------------------
+ * File Name:      mem_utils.c
+ *----------------------------------------------------------------------
+ This file is provided under a dual BSD/GPLv2 license.  When using or
+ redistributing this file, you may do so under either license.
+
+ GPL LICENSE SUMMARY
+
+ Copyright(c) 2005-2015 Intel Corporation. All rights reserved.
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of version 2 of the GNU General Public License as
+ published by the Free Software Foundation.
+
+ This program is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ The full GNU General Public License is included in this distribution
+ in the file called LICENSE.GPL.
+
+ Contact Information:
+ Intel Corporation
+
+ 2200 Mission College Blvd.
+ Santa Clara, CA  97052
+
+ BSD LICENSE
+
+ Copyright(c) 2015 Intel Corporation. All rights reserved.
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+
+ * Redistributions of source code must retain the above copyright
+ notice, this list of conditions and the following disclaimer.
+ * Redistributions in binary form must reproduce the above copyright
+ notice, this list of conditions and the following disclaimer in
+ the documentation and/or other materials provided with the
+ distribution.
+ * Neither the name of Intel Corporation nor the names of its
+ contributors may be used to endorse or promote products derived
+ from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+#include <linux/kernel.h>
+#include <asm/io.h>
+#include <asm/cacheflush.h>
+#include <linux/netip_mem_util.h>
+#include <linux/netip_subsystem.h>
+#include "netip_subsystem_config.h"
+
+/*************************************************************************/
+/*      Define                                                          */
+/*************************************************************************/
+#define CACHE_LINE_SIZE 64
+
+/* following address are for debug use will be removed in final solution */
+/* After final solution following address range will go in exact map for descriptors in shared memory */
+#define NPCPU_DESCRIPTOR_PHYSICAL_MEM_BASE  0xFC00000
+#define NPCPU_DESCRIPTOR_PHYSICAL_MEM_SIZE  (0xBF00000 - 0x100000)
+void *NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE = NULL;
+
+struct netip_mem_rgion_device {
+    netss_dev_t subdevice;
+    volatile void *virtual_base_address;
+    volatile bool ioremapped;
+    unsigned long arm_start_address;
+    unsigned long arm_end_address;
+    char* name;
+};
+
+static struct netip_mem_rgion_device mem_util_dev[] =
+{
+    {NETSS_DEV_PACKET_PROCESSOR1, NULL, false, 0xF3000000, NULL, "NETSS_DEV_PACKET_PROCESSOR1"},
+    {NETSS_DEV_PACKET_PROCESSOR2, NULL, false, 0xF9000000, NULL, "NETSS_DEV_PACKET_PROCESSOR2"},
+    {NETSS_DEV_GBE, NULL, false, 0xF0318000, NULL, "NETSS_DEV_GBE_GENERAL"},
+    {NETSS_DEV_GBE5, NULL, false, 0xF0314000, NULL, "NETSS_DEV_GBE5"},
+    {NETSS_DEV_GBE4, NULL, false, 0xF0310000, NULL, "NETSS_DEV_GBE4"},
+    {NETSS_DEV_GBE3, NULL, false, 0xF030C000, NULL, "NETSS_DEV_GBE3"},
+    {NETSS_DEV_GBE2, NULL, false, 0xF0308000, NULL, "NETSS_DEV_GBE2"},
+    {NETSS_DEV_GBE1, NULL, false, 0xF0304000, NULL, "NETSS_DEV_GBE1"},
+    {NETSS_DEV_GBE0, NULL, false, 0xF0300000, NULL, "NETSS_DEV_GBE0"},
+    {NETSS_DEV_CLK, NULL, false, 0xF00D0000, NULL, "NETSS_DEV_CLK"},
+    {NETSS_DEV_BOOTCFG, NULL, false, 0xF00C0000, NULL, "NETSS_DEV_BOOTCFG"},
+    {NETSS_DEV_TDM, NULL, false, 0xF0100000, NULL, "NETSS_DEV_TDM"},
+    {NETSS_DEV_TIMER0, NULL, false, 0xF0030000, NULL, "NETSS_DEV_TIMER0"},
+    {NETSS_DEV_TIMER1, NULL, false, 0xF0110000, NULL, "NETSS_DEV_TIMER1"},
+    {NETSS_DEV_TDM1, NULL, false, 0xF0120000, NULL, "NETSS_DEV_TDM1"},
+    {NETSS_DEV_TIMER2, NULL, false, 0xF0130000, NULL, "NETSS_DEV_TIMER2"},
+    {NETSS_DEV_TDM2, NULL, false, 0xF0180000, NULL, "NETSS_DEV_TDM2"},
+    {NETSS_DEV_VCODEC, NULL, false, 0xF00F6000, NULL, "NETSS_DEV_VCODEC"},    
+};
+
+int netip_memmap_init(void)
+{
+    int i, ret = 0;
+    netss_dev_info_t mmio_dev_info;
+
+    if(!netss_driver_ready()) {
+        pr_err("netss driver is not ready!\n");
+        return -1;
+    }
+
+    for (i=0; i < ARRAY_SIZE(mem_util_dev); i++) {
+        if (mem_util_dev[i].ioremapped) {
+            /* Already mapped */
+            continue;
+        }
+        if (netss_device_get_info(mem_util_dev[i].subdevice, &mmio_dev_info)) {
+            pr_err("Get device info failed for region %s\n", mem_util_dev[i].name);
+            ret = -2;
+            continue;
+        }
+
+        mem_util_dev[i].arm_end_address = mem_util_dev[i].arm_start_address + mmio_dev_info.size;
+        mem_util_dev[i].virtual_base_address = ioremap_nocache(mmio_dev_info.base, mmio_dev_info.size);
+        if (mem_util_dev[i].virtual_base_address) {
+                mem_util_dev[i].ioremapped = true;
+        } else {
+            pr_err("ioremap failed for region %s\n", mem_util_dev[i].name);
+            ret = -2;
+        }
+    }
+
+    if (NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE != NULL)
+	return ret;
+
+    NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE = (void *)ioremap_nocache(NPCPU_DESCRIPTOR_PHYSICAL_MEM_BASE, NPCPU_DESCRIPTOR_PHYSICAL_MEM_SIZE);
+    if(!NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE) {
+        pr_err(" NPCPU_VIRTUAL_MEM_BASE IOREMAP  error \n");
+        return -2;
+    }
+
+    netss_bootcfg_init();
+#ifdef CONFIG_NET_SUBSYSTEM_SNOOPED_MODE
+    netss_enable_snooped_mode();
+#endif
+
+    return ret;
+}
+EXPORT_SYMBOL(netip_memmap_init);
+
+void netip_memmap_cleanup(void)
+{
+    int i;
+
+    pr_info("cleaningup mapped descriptor memory \n");
+
+    if(NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE)
+    {
+        iounmap(NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE);
+        NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE = NULL;
+    }
+    for (i=0; i < ARRAY_SIZE(mem_util_dev); i++) {
+        if(mem_util_dev[i].ioremapped) {
+            iounmap(mem_util_dev[i].virtual_base_address);
+            mem_util_dev[i].ioremapped = false;
+            mem_util_dev[i].virtual_base_address = NULL;
+        }
+    }
+
+}
+EXPORT_SYMBOL(netip_memmap_cleanup);
+
+void *netip_mmio_to_virtual(unsigned long netip_phys_addr)
+{
+    unsigned long offset = 0;
+    int i;
+
+    if( (netip_phys_addr >= NPCPU_DESCRIPTOR_PHYSICAL_MEM_BASE) && (netip_phys_addr < (NPCPU_DESCRIPTOR_PHYSICAL_MEM_BASE + NPCPU_DESCRIPTOR_PHYSICAL_MEM_SIZE))) {
+        offset = (netip_phys_addr - NPCPU_DESCRIPTOR_PHYSICAL_MEM_BASE);
+        pr_debug(" netip_phys_addr=%p virt_addr=%p offset=%x\n", netip_phys_addr, (NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE + offset), offset);
+        return (void *)(NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE + offset);
+    }
+
+    for (i=0; i < ARRAY_SIZE(mem_util_dev); i++) {
+
+        if (!mem_util_dev[i].ioremapped)
+            continue;
+
+        if (netip_phys_addr > mem_util_dev[i].arm_end_address)
+            continue;
+
+        if (netip_phys_addr < mem_util_dev[i].arm_start_address)
+            continue;
+
+        offset = netip_phys_addr - mem_util_dev[i].arm_start_address;
+        pr_debug("Physical to virtual called netip_phys_addr=%p virt _addr=%p offset=%x\n", netip_phys_addr, (mem_util_dev[i].virtual_base_address + offset), offset);
+        return (mem_util_dev[i].virtual_base_address + offset);
+    }
+
+    pr_debug("%s:%d: No region found for 0x%p, return as Kernel map instead\n", __func__, __LINE__, netip_phys_addr);
+    return phys_to_virt(netip_phys_addr);
+}
+EXPORT_SYMBOL(netip_mmio_to_virtual);
+
+void *netip_mmio_to_physical(void* virt_addr)
+{
+    unsigned long offset = 0;
+    int i;
+
+    if( (virt_addr >= NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE) && (virt_addr < ((unsigned long)NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE + (unsigned long)NPCPU_DESCRIPTOR_PHYSICAL_MEM_SIZE))) {
+        offset = (virt_addr - NPCPU_DESCRIPTOR_VIRTUAL_MEM_BASE);
+        pr_debug("virt_addr=%p phys_addr=%p offset=%x\n",virt_addr,(NPCPU_DESCRIPTOR_PHYSICAL_MEM_BASE + offset),offset);
+        return (void*)(NPCPU_DESCRIPTOR_PHYSICAL_MEM_BASE + offset);
+    }
+
+    for (i=0; i < ARRAY_SIZE(mem_util_dev); i++) {
+
+        if (!mem_util_dev[i].ioremapped)
+            continue;
+
+        if (virt_addr > mem_util_dev[i].virtual_base_address + (mem_util_dev[i].arm_end_address - mem_util_dev[i].arm_start_address))
+            continue;
+
+        if (virt_addr < mem_util_dev[i].virtual_base_address)
+            continue;
+
+        offset = virt_addr - mem_util_dev[i].virtual_base_address;
+        pr_debug("Virtual to physical called virtual address=%p phy_addr=%p  offset=%x\n", virt_addr, (mem_util_dev[i].arm_start_address + offset) , offset);
+        return (mem_util_dev[i].arm_start_address + offset);
+    }
+
+    pr_debug("%s:%d: No region found for 0x%p, return as Kernel map instead\n", __func__, __LINE__, virt_addr);
+    return virt_to_phys(virt_addr);
+}
+EXPORT_SYMBOL(netip_mmio_to_physical);
+
+void cache_flush_buffer(void *bufptr, int size)
+{
+	clflush_cache_range(bufptr, size);
+}
+EXPORT_SYMBOL(cache_flush_buffer);
diff --git a/arch/x86/NetIP_SubSystem/netip_subsystem_config.c b/arch/x86/NetIP_SubSystem/netip_subsystem_config.c
new file mode 100644
index 0000000..7b4504c
--- /dev/null
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_config.c
@@ -0,0 +1,132 @@
+/*
+ * netip_subsystem_config.c
+ *
+ *  GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2015-2016 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *    Intel Corporation
+ *    2200 Mission College Blvd.
+ *    Santa Clara, CA  97052
+ *
+ */
+#include <linux/netip_subsystem.h>
+#include <linux/netip_mem_util.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#define NETSS_DEV_BOOTCFG_BASE 0xF00C0000
+
+#define MAX_DOMAIN_REGS             (38)
+#define LOCK_REG1_OFF               (0x007c)
+#define LOCK_REG2_OFF               (0x0080)
+#define DOMAIN_BASE_REG_OFF         (0x028c)
+#define SECURITY_MODULE_REG_OFF     (0x0268)
+#define ENABLE_SNOOPED_MODE         (0x00008000)
+#define UNLOCK1_VALUE               (0x20406080)
+#define UNLOCK2_VALUE               (0x10305070)
+#define LOCK1_VALUE                 (0x0204060f)
+#define DOCSIS_FUSE_1               (0x0148)
+#define DISABLE_IPSEC_BIT_OFFSET    (24)
+
+static bool snooped_en = false;
+static struct proc_dir_entry *g_netss_subsystem_proc_dir;
+
+static int netss_subsystem_proc_read_ipsec(struct seq_file *seq, void *v)
+{
+    unsigned int mask, readBit;
+    unsigned long *docsisFuseReg;
+
+    docsisFuseReg = netip_mmio_to_virtual(NETSS_DEV_BOOTCFG_BASE + DOCSIS_FUSE_1);
+
+    mask = (1 << DISABLE_IPSEC_BIT_OFFSET);
+
+    readBit = be32_to_cpu(*docsisFuseReg) & mask;
+
+    seq_printf(seq, "%d\n", readBit);
+
+    return 0;
+}
+
+static int netss_subsystem_proc_open_ipsec(struct inode *inode, struct file *file)
+{
+    return single_open(file, netss_subsystem_proc_read_ipsec, NULL);
+}
+
+static struct file_operations g_proc_file_ipsec_seq_fops = {
+    .owner = THIS_MODULE,
+    .open = netss_subsystem_proc_open_ipsec,
+    .read = seq_read,
+    .llseek = seq_lseek,
+    .release = single_release,
+};
+
+void netss_bootcfg_init(void)
+{
+    /* Check if bootcfg folder already exists */
+    if (g_netss_subsystem_proc_dir) {
+        return;
+    }
+
+    g_netss_subsystem_proc_dir = proc_mkdir("bootcfg", NULL);
+
+    if (!g_netss_subsystem_proc_dir) {
+        pr_err("Can't create bootcfg folder\n");
+        return;
+    }
+
+    proc_create("ipsec_disable", S_IRUGO, g_netss_subsystem_proc_dir, &g_proc_file_ipsec_seq_fops);
+}
+
+void netss_enable_snooped_mode(void)
+{
+    int i;
+    unsigned long *lock1;
+    unsigned long *lock2;
+    unsigned long *domain_base;
+    unsigned int reg_val;
+
+    if (snooped_en)
+        return;
+
+    lock1 = netip_mmio_to_virtual(NETSS_DEV_BOOTCFG_BASE + LOCK_REG1_OFF);
+    lock2 = netip_mmio_to_virtual(NETSS_DEV_BOOTCFG_BASE + LOCK_REG2_OFF);
+    domain_base = netip_mmio_to_virtual(NETSS_DEV_BOOTCFG_BASE + DOMAIN_BASE_REG_OFF);
+
+    *lock1 = cpu_to_be32(UNLOCK1_VALUE);
+    *lock2 = cpu_to_be32(UNLOCK2_VALUE);
+
+    for (i=0; i < MAX_DOMAIN_REGS; i++) {
+        reg_val  = be32_to_cpu(*domain_base);
+        reg_val |= ENABLE_SNOOPED_MODE;
+        *domain_base = cpu_to_be32(reg_val);
+        domain_base++;
+    }
+
+    domain_base = netip_mmio_to_virtual(NETSS_DEV_BOOTCFG_BASE + SECURITY_MODULE_REG_OFF);
+    reg_val  = be32_to_cpu(*domain_base);
+    reg_val |= ENABLE_SNOOPED_MODE;
+    *domain_base = cpu_to_be32(reg_val);
+
+    *lock1 = cpu_to_be32(LOCK1_VALUE);
+
+    snooped_en = true;
+    pr_info("netip snooped mode enabled!\n");
+}
+
diff --git a/arch/x86/NetIP_SubSystem/netip_subsystem_config.h b/arch/x86/NetIP_SubSystem/netip_subsystem_config.h
new file mode 100644
index 0000000..3ad4daf
--- /dev/null
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_config.h
@@ -0,0 +1,35 @@
+/*
+ * netip_subsystem_config.h
+ *
+ *  GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2015-2016 Intel Corporation. All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *    Intel Corporation
+ *    2200 Mission College Blvd.
+ *    Santa Clara, CA  97052
+ *
+ */
+#ifndef _NETIP_SUBSYSTEM_CONFIG_H
+#define _NETIP_SUBSYSTEM_CONFIG_H
+
+void netss_bootcfg_init(void);
+void netss_enable_snooped_mode(void);
+
+#endif
diff --git a/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c b/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c
index 3149097..88850b0 100644
--- a/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c
+++ b/arch/x86/NetIP_SubSystem/netip_subsystem_lld.c
@@ -151,6 +151,35 @@ void netss_interrupt_register(netss_interrupt_t intrpt, int arm11_int_id, netss_
 
 EXPORT_SYMBOL(netss_interrupt_register);
 
+int netss_request_npcpu_irq(int irq_num, char* irq_name, netss_subdevice_irq_func func, void *args)
+{
+    netss_interrupt_info_t irq_info = {.func = func, .args = args};
+
+    NETSS_DBG_PRINT("requesting irq #%d, %s", irq_num, irq_name);
+
+    /* request RX IRQs */
+    /*Check netss driver before requesting RX IRQs */
+    if(!netss_driver_ready())
+    {
+        pr_err("unable to get IRQ from netss netss_driver_ready() failed #%d", irq_num);
+        return -1;
+    }
+
+    irq_info.func = func;
+    irq_info.args = args;
+
+    /* request IRQ from IOSF bridge driver */
+    netss_interrupt_register(NETSS_INTERUPT_ARM11, irq_num, &irq_info);
+    NETSS_DBG_PRINT("IRQ #%d for %s", irq_num, irq_name);
+
+    //TODO: check if need to enable or not
+    /* enabling IRQ at INTC */
+    avalanche_intc_enable_irq(irq_num);
+
+    return 0;
+}
+EXPORT_SYMBOL(netss_request_npcpu_irq);
+
 bool netss_driver_ready(void)
 {
    if(pnetss_drv_data != NULL) {
@@ -167,6 +196,11 @@ int netss_device_get_info(netss_dev_t subdevice, netss_dev_info_t *mmio)
    int ret = -1;
    switch (subdevice)
    {
+      case NETSS_DEV_GPIO:
+          mmio->base = net_ip_mmios.region1_base + NETSS_DEV_GPIO_MMIO_OFFSET;
+          mmio->size = NETSS_DEV_GPIO_MMIO_SIZE;
+          ret = 0;
+      break;
       case NETSS_DEV_HW_MUTEX:
           mmio->base = net_ip_mmios.region1_base + NETSS_DEV_HWMUTEX_MMIO_OFFSET;
           mmio->size = NETSS_DEV_HWMUTEX_MMIO_SIZE;
@@ -203,8 +237,43 @@ int netss_device_get_info(netss_dev_t subdevice, netss_dev_info_t *mmio)
          ret = 0;
       break;
       case NETSS_DEV_GBE:
-         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_GBE_MMIO_OFFSET;
-         mmio->size = NETSS_DEV_GBE_MMIO_SIZE;
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_GBEG_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_GBEG_MMIO_SIZE;
+         ret = 0;
+      break;
+      case NETSS_DEV_GBE5:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_GBE5_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_GBE5_MMIO_SIZE;
+         ret = 0;
+      break;
+      case NETSS_DEV_GBE4:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_GBE4_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_GBE4_MMIO_SIZE;
+         ret = 0;
+      break;
+      case NETSS_DEV_GBE3:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_GBE3_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_GBE3_MMIO_SIZE;
+         ret = 0;
+      break;
+      case NETSS_DEV_GBE2:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_GBE2_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_GBE2_MMIO_SIZE;
+         ret = 0;
+      break;
+      case NETSS_DEV_GBE1:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_GBE1_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_GBE1_MMIO_SIZE;
+         ret = 0;
+      break;
+      case NETSS_DEV_GBE0:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_GBE0_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_GBE0_MMIO_SIZE;
+         ret = 0;
+      break;
+      case NETSS_DEV_CLK:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_CLK_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_CLK_MMIO_SIZE;
          ret = 0;
       break;
       case NETSS_DEV_CLK_CTRL:
@@ -222,6 +291,46 @@ int netss_device_get_info(netss_dev_t subdevice, netss_dev_info_t *mmio)
          mmio->size = NETSS_DEV_PERIPHERAL_SRAM_MMIO_SIZE;
          ret = 0;
       break;
+      case NETSS_DEV_BOOTCFG:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_BOOTCFG_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_BOOTCFG_MMIO_SIZE;
+         ret = 0;
+      break;
+      case NETSS_DEV_TDM:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_TDM_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_TDM_MMIO_SIZE;
+         ret = 0;
+      break;
+      case NETSS_DEV_TIMER0:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_TIMER0_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_TIMER0_MMIO_SIZE;
+         ret = 0;
+      break;
+      case NETSS_DEV_TIMER1:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_TIMER1_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_TIMER1_MMIO_SIZE;
+         ret = 0;
+      break;
+      case NETSS_DEV_TDM1:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_TDM1_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_TDM1_MMIO_SIZE;
+         ret = 0;
+      break;
+      case NETSS_DEV_TIMER2:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_TIMER2_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_TIMER2_MMIO_SIZE;
+         ret = 0;
+      break;
+      case NETSS_DEV_TDM2:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_TDM2_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_TDM2_MMIO_SIZE;
+         ret = 0;
+      break;
+      case NETSS_DEV_VCODEC:
+         mmio->base = net_ip_mmios.region1_base + NETSS_DEV_VCODEC_MMIO_OFFSET;
+         mmio->size = NETSS_DEV_VCODEC_MMIO_SIZE;
+         ret = 0;
+      break;
       default:
          ret = -1;
    }
diff --git a/arch/x86/avalanche_intd/Makefile b/arch/x86/avalanche_intd/Makefile
new file mode 100644
index 0000000..7df3403
--- /dev/null
+++ b/arch/x86/avalanche_intd/Makefile
@@ -0,0 +1,19 @@
+#
+# Copyright (c) 2016, Intel Corporation and its suppliers.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#
+#
+obj-$(CONFIG_AVALANCHE_INTD_APPCPU) := avalanche_intd.o
+
diff --git a/arch/x86/avalanche_intd/avalanche_intd.c b/arch/x86/avalanche_intd/avalanche_intd.c
new file mode 100644
index 0000000..19165ad
--- /dev/null
+++ b/arch/x86/avalanche_intd/avalanche_intd.c
@@ -0,0 +1,271 @@
+/*
+ *
+ * avalanche_intd.h
+ * Description:
+ * interrupt distributor header file
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2015 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2008-2015 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+/****************/
+/**  Includes  **/
+/****************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <linux/avalanche/generic/avalanche_intd.h>
+#include <linux/avalanche/puma7/puma7.h>
+#include <linux/netip_subsystem.h>
+/***************/
+/**  Defines  **/
+/***************/
+#define INTD_MAX_ENABLE_REGS       ( 32 )
+#define INTD_MAX_STATUS_REGS       ( 32 )
+#define INTD_MAX_POLARITY_REGS     ( 32 )
+#define INTD_MAX_TYPE_REGS         ( 32 )
+#define INTD_MAX_COUNT_REGS        ( 64 )
+#define INTD_MAX_PACER_REGS        ( 50 )
+#define INTD_MAX_VECT_VAL          ( 255 )
+#define INTD_MAX_INTERRUPT_COUNT   ( 255 )
+#define INTD_SET_BIT_0             ( 0x00000001 )
+#define INTD_CLEAR_BIT_0           ( 0xFFFFFFFE )
+
+/*Avalanche Interrupt Distributor registers */
+/*This IO region is in Packet Processor1 region Avalanche Interrupt Distributor registers */
+/**
+ * Interrupts Distributor 1 (INTD1) base address, has 16 ip
+ * interrupts to 12 system interrupts.
+ */
+#define ATOM_INTD1_BASE (0xF3C23000)
+
+/**
+ * INTD0 interrupt0's line in the system interrupt controller
+ * (INTC).
+ */
+#define ATOM_INTD_BASE  (0xF3C22000)
+
+
+/* uncomment to enable debug prints */
+//#define PAL_CPPI4_DBG
+
+#ifdef PAL_CPPI4_DBG
+/* Debug print, also print function name and line number */
+#  define DPRINTK(fmt, args...) printk("%s(%d): " fmt "\n", __FUNCTION__ , __LINE__, ## args)
+#else
+#  define DPRINTK(fmt, args...)
+#endif
+
+/* Error print, also print function name and line number */
+#define EPRINTK(fmt, args...) printk(KERN_ERR "****** %s(%d): " fmt " ******\n", __FUNCTION__ , __LINE__, ## args)
+
+/***************/
+/**  Globals  **/
+/***************/
+
+avalanche_idist_regs_t *intd_regs;
+avalanche_idist_regs_t *intd1_regs;
+
+SOC_HOST_INFO host_info = {
+    .host_num = 0,
+    .max_ip_ints_mapped = (AVALANCHE_IDIST_IP_INT_NUM + AVALANCHE_IDIST1_IP_INT_NUM),
+};
+
+/********************************/
+/**  functions Implementation  **/
+/********************************/
+
+static int __init avalanche_intd_init(void)
+{
+    /* NETSS mmio structure */
+    netss_dev_info_t cppiMemIO_pp1;
+    intd_regs = NULL;
+    intd1_regs = NULL;
+    if(!netss_device_get_info(NETSS_DEV_PACKET_PROCESSOR1, &cppiMemIO_pp1))
+    {
+        DPRINTK("DBG: Physical Address of NETSS_PP_DPIPROXY=%p \n", (cppiMemIO_pp1.base ));
+
+        /*initilize AVALANCHE controller register memory map INTD addresses */
+        intd_regs = (avalanche_idist_regs_t *)ioremap_nocache( (cppiMemIO_pp1.base + (ATOM_INTD_BASE & 0x00FFFFFF)), sizeof(avalanche_idist_regs_t));
+        if(!intd_regs)
+        {
+            EPRINTK("ERROR: could not mapped AVALANCHE_INTD_BASE region in \n");
+            return 1;
+        }
+        DPRINTK("DBG: Physical Address of AVALANCHE_INTD_BASE=%p Virtual address of AVALANCHE_INTD_BASE=%p\n", (cppiMemIO_pp1.base + (ATOM_INTD_BASE & 0x00FFFFFF)), intd_regs);
+        /*initilize AVALANCHE INTD1 controller register memory map addresses */
+        intd1_regs = (avalanche_idist_regs_t *)ioremap_nocache( (cppiMemIO_pp1.base  + (ATOM_INTD1_BASE & 0x00FFFFFF)), sizeof(avalanche_idist_regs_t));
+        if(!intd1_regs)
+        {
+            EPRINTK("ERROR: could not mapped AVALANCHE_INTD1_BASE region in \n");
+            return 1;
+        }
+        DPRINTK("DBG: Physical Address of AVALANCHE_INTD1_BASE=%p Virtual address of AVALANCHE_INTD1_BASE=%p\n", (cppiMemIO_pp1.base + (ATOM_INTD1_BASE & 0x00FFFFFF)), intd1_regs);
+
+    }
+    else
+    {
+        EPRINTK(" netss_get_subdevice_mmio_info() error for PP2 \n");
+    }
+
+
+    /* reading revision registers of INTD and INTD1 */
+    DPRINTK("AVALANCHE_INTD Interrupt distributor revision : %x", be32_to_cpu(intd_regs->idrevr));
+    DPRINTK("AVALANCHE_INTD1 Interrupt distributor revision : %x", be32_to_cpu(intd1_regs->idrevr));
+
+    return 0;
+}
+
+static void __exit avalanche_intd_cleanup(void)
+{
+
+    /* cleanup AVALANCHE INTD addresses */
+
+    if(intd_regs !=  NULL )
+    {
+        iounmap(intd_regs);
+        intd_regs = NULL;
+    }
+
+    /*cleanup AVALANCHE INTD1 addresses */
+    if(intd1_regs !=  NULL )
+    {
+        iounmap(intd1_regs);
+        intd1_regs= NULL;
+    }
+}
+
+int avalanche_intd_get_interrupt_count( unsigned int host_num, unsigned int ip_int_num )
+{
+    DPRINTK("start");
+
+    if( (host_num   == host_info.host_num) &&
+            (ip_int_num <  INTD_MAX_COUNT_REGS )&&
+            (ip_int_num <  host_info.max_ip_ints_mapped ))
+    {
+        unsigned int counter_reg_indx = ip_int_num;
+
+        counter_reg_indx -= (AVALANCHE_IDIST_IP_INT_NUM <= ip_int_num) ? AVALANCHE_IDIST_IP_INT_NUM : 0;
+
+        if (AVALANCHE_IDIST_IP_INT_NUM <= ip_int_num)
+        {
+            return be32_to_cpu(intd1_regs->idcounterr[counter_reg_indx]);
+        }
+
+        return be32_to_cpu(intd_regs->idcounterr[counter_reg_indx]);
+    }
+    DPRINTK("end");
+
+    return (-1);
+}
+EXPORT_SYMBOL(avalanche_intd_get_interrupt_count);
+
+int avalanche_intd_set_interrupt_count(unsigned int host_num, unsigned int ip_int_num, unsigned int count_val)
+{
+    if ((host_num   == host_info.host_num) &&
+        (ip_int_num <  INTD_MAX_COUNT_REGS) &&
+        (ip_int_num <  host_info.max_ip_ints_mapped) &&
+        (count_val  <  INTD_MAX_INTERRUPT_COUNT))
+    {
+        unsigned int counter_reg_indx = ip_int_num;
+
+        counter_reg_indx -= (AVALANCHE_IDIST_IP_INT_NUM <= ip_int_num) ? AVALANCHE_IDIST_IP_INT_NUM : 0;
+
+        if (AVALANCHE_IDIST_IP_INT_NUM < ip_int_num)
+        {
+            intd1_regs->idcounterr[counter_reg_indx] = cpu_to_be32(count_val);
+        }
+        else
+        {
+            intd_regs->idcounterr[counter_reg_indx] = cpu_to_be32(count_val);
+        }
+        return 0;
+    }
+
+    return (-1);
+}
+EXPORT_SYMBOL(avalanche_intd_set_interrupt_count);
+
+int avalanche_intd_write_eoi(unsigned int vect_val)
+{
+    if (vect_val <= INTD_MAX_VECT_VAL)
+    {
+        if (AVALANCHE_IDIST_SYS_INT_NUM <= vect_val)
+        {
+            intd1_regs->ideoir = cpu_to_be32(vect_val - AVALANCHE_IDIST_SYS_INT_NUM);
+        }
+        else
+        {
+            intd_regs->ideoir = cpu_to_be32(vect_val);
+        }
+        return 0;
+    }
+
+    return (-1);
+}
+EXPORT_SYMBOL(avalanche_intd_write_eoi);
+
+module_init(avalanche_intd_init);
+module_exit(avalanche_intd_cleanup);
+
diff --git a/arch/x86/pal_cppi41/Makefile b/arch/x86/pal_cppi41/Makefile
new file mode 100644
index 0000000..273bfa8
--- /dev/null
+++ b/arch/x86/pal_cppi41/Makefile
@@ -0,0 +1,28 @@
+#
+# Copyright (c) 2011, Intel Corporation and its suppliers.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#
+#
+#       	-I $(INTELCE_LINUX_HEADER_DIR) -I$../include -I$(src)/../include
+
+obj-$(CONFIG_PAL_CPPI41_APPCPU) := pal_cppi41.o
+obj-$(CONFIG_PAL_CPPI41_APPCPU) += cru_ctrl.o
+
+ccflags-y := -Werror \
+		-DCONFIG_X86_AVALANCHE_SOC \
+		-DPUMA7_OR_NEWER_SOC_TYPE\
+		-DCONFIG_TI_META_DATA\
+		-DCONFIG_INET_LRO
+
diff --git a/arch/x86/pal_cppi41/cppi41_hw_mbox_if.h b/arch/x86/pal_cppi41/cppi41_hw_mbox_if.h
new file mode 100644
index 0000000..2d65884
--- /dev/null
+++ b/arch/x86/pal_cppi41/cppi41_hw_mbox_if.h
@@ -0,0 +1,131 @@
+/*
+ *
+ * cppi41_hw_mbox_if.h
+ * Description:
+ * CPPI access via HW mailbox
+ *
+ *
+ * GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2015 Intel Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *  Intel Corporation
+ *  2200 Mission College Blvd.
+ *  Santa Clara, CA  97052
+ */
+
+ /************************************************/
+/*                 Structures                   */
+/************************************************/
+#ifndef _PPI41_HW_MBOX_IF_H
+#define  _PPI41_HW_MBOX_IF_H
+
+/*! \enum hw_mbox_Masters_e
+  \brief Enumerate all HW_MBOX Master with MID value.
+  \note name of the Masters is according to HW_MBOX_MASTER_TABLE_AS_ENUM Macro.
+ */
+
+typedef enum npcpu_appcpu_hw_mbox_tags
+{
+    NPCPU_APPCPU_HW_MBOX_MID_INVALID = -1,
+    NPCPU_APPCPU_HW_MBOX_TAG_NET_IP_DRV,
+    NPCPU_APPCPU_HW_MBOX_TAG_PM,
+    NPCPU_APPCPU_HW_MBOX_TAG_CM,
+    NPCPU_APPCPU_HW_MBOX_TAG_RPC,
+    NPCPU_APPCPU_HW_MBOX_TAG_MUX,
+    NPCPU_APPCPU_HW_MBOX_TAG_VLAN,
+    NPCPU_APPCPU_HW_MBOX_TAG_PP,
+    NPCPU_APPCPU_HW_MBOX_TAG_NETDEV,
+    NPCPU_APPCPU_HW_MBOX_TAG_CPPI41_MBX,
+    NPCPU_APPCPU_HW_MBOX_TAG_DATAPIPE_MBX,
+    NPCPU_APPCPU_HW_LAST_ENTRY
+} npcpu_appcpu_hw_mbox_tags_e;
+
+
+
+/* CPPI HW mailbox commands enum */
+typedef enum
+{
+    CPPI41_HWMBOX_CMD_ACC_CH_OPEN = 0           ,    /* Accumulator open command */
+    CPPI41_HWMBOX_CMD_ACC_CH_OPEN_REPLY         ,    /* Accumulator open reply command */
+    CPPI41_HWMBOX_CMD_ACC_CH_CLOSE              ,    /* Accumulator close command */
+    CPPI41_HWMBOX_CMD_GET_REGION_MEM_INFO       ,    /* Descriptors region memory info command */
+    CPPI41_HWMBOX_CMD_GET_REGION_MEM_INFO_REPLY ,    /* Descriptors region memory info reply command */
+    CPPI41_HWMBOX_CMD_FAILED                    ,    /* command processing failed command, use only for reply - the error code is from the type Cppi41HwMboxRetCode_e */
+    CPPI41_HWMBOX_CMD_COUNT
+}Cppi41HwMboxCmd_e;
+
+/* error codes for CPPI41_HWMBOX_CMD_FAILED command */
+typedef enum
+{
+    CPPI41_HWMBOX_RET_CODE_OK = 0,
+    CPPI41_HWMBOX_RET_CODE_UNSUPPORTED_CMD,
+    CPPI41_HWMBOX_RET_CODE_CMD_ERROR,
+    CPPI41_HWMBOX_RET_CODE_COUNT,
+}Cppi41HwMboxRetCode_e;
+
+/* Cppi HW mailbox fail message */
+typedef struct
+{
+    Cppi41HwMboxCmd_e       cmd;        /* command type - must be CPPI41_HWMBOX_CMD_FAILED */
+    Cppi41HwMboxRetCode_e   failCode;   /* fail code */
+} Cppi41HwMboxFailMsg_t;
+
+/* Cppi HW mailbox message to open accumulator channel */
+typedef struct
+{
+    Cppi41HwMboxCmd_e       cmd;        /* command type - must be CPPI41_HWMBOX_CMD_ACC_CH_OPEN  */
+    Cppi4AccumulatorCfg     initCfg;    /* The accumulator channel init configuration */
+} Cppi41HwMboxAccChOpenMsg_t;
+
+/* Cppi HW mailbox response message to open accumulator channel */
+typedef struct
+{
+    Cppi41HwMboxCmd_e   cmd;            /* command type - must be CPPI41_HWMBOX_CMD_ACC_CH_OPEN_REPLY */
+    Ptr                 curPage;        /* Current accumulator page physical address */
+    PAL_Cppi4AccChHnd   accChHnd;       /* handle to accumulator channel handle, this field is mandatory for closing the channel */
+}Cppi41HwMboxAccChOpenReplyMsg_t;
+
+/* Cppi HW mailbox message to close accumulator channel */
+typedef struct
+{
+    Cppi41HwMboxCmd_e   cmd;        /* command type */
+    PAL_Cppi4AccChHnd   accChHnd;   /* The accumulator channel init configuration */
+} Cppi41HwMboxAccChCloseMsg_t;
+
+/* Cppi HW mailbox message to get descriptor region memory info, phyical address and length */
+typedef struct
+{
+    Cppi41HwMboxCmd_e           cmd;    /* command type */
+    //PAL_CPPI_PP_DESC_REGIONs_e  region; /* region number */
+    unsigned int                region; /* region number */
+    Uint32                      qMgr;   /* queue manager */
+} Cppi41HwMboxDescRegionMemInfoGetMsg_t;
+
+/* Cppi HW mailbox message to reply to a get descriptor region memory info message */
+typedef struct
+{
+    Cppi41HwMboxCmd_e   cmd;            /* command type */
+    Ptr                 regionPhyAddr;  /* region memory physical address */
+    Uint32              length;         /* region memory length in bytes */
+} Cppi41HwMboxDescRegionMemInfoReplyMsg_t;
+
+
+#endif
diff --git a/arch/x86/pal_cppi41/cru_ctrl.c b/arch/x86/pal_cppi41/cru_ctrl.c
new file mode 100644
index 0000000..4b94c76
--- /dev/null
+++ b/arch/x86/pal_cppi41/cru_ctrl.c
@@ -0,0 +1,306 @@
+
+/*
+  BSD LICENSE
+
+  Copyright(c) 2011-2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+/** \file   cru_ctrl.c (formerly puma6_cru_ctrl.c)
+ *  \brief  PAL reset and power control APIs
+ *          The Clock & Reset unit (CRU) enables power control
+ *          of all the modules and peripherals. Power savings
+ *          can be achieved by disabling modules (clock gating).
+ *
+ *  \author     Intel
+ *
+ *  \version    0.1     Amihay Tabul   		Created
+ */
+
+
+#include <linux/avalanche/generic/pal.h>
+
+#ifndef CONFIG_ARM_AVALANCHE_SOC
+#include <linux/avalanche/puma7/puma7_defs.h>
+#endif
+
+#if PUMA7_SOC_TYPE
+#include <linux/avalanche/puma7/puma7.h>
+#include <linux/avalanche/puma7/puma7_cru_ctrl.h>
+#include <linux/avalanche/puma7/puma7_cppi_prv.h>
+#endif
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+
+/* CRU - Clock and Reset Unit               */
+/* Docsis IP has 33 CRUs                    */
+/* Clock Control registers set memory map:  */
+
+/* Start address 0x000D_0000                */
+/* End address   0x000D_FFFF                */
+#define CRU_MOD_STATE_BASE    (AVALANCHE_CRU_BASE)
+#define CRU_MOD_STATUS_BASE   (CRU_MOD_STATE_BASE + 0x4)
+#define CRU_RSTN_CLK_EN_BASE  (CRU_MOD_STATE_BASE + 0x8) /* should not be used, for debug only */
+
+/* CRU_MOD_STATE register fields */
+/* 31:2 Reserved (R) */
+/* 1:0  MOD_STATE_REG (R/W) */
+#define CRU_MOD_STATE_DISABLED      (0)
+#define CRU_MOD_STATE_SYNC_RST      (1)
+#define CRU_MOD_STATE_CLK_DISABLE   (2)
+#define CRU_MOD_STATE_ENABLE        (3)
+
+/* CRU_MOD_STATUS register fields */
+/* 31:10 Reserved (R) */
+/* 9:6	CRU_CG_EN_1-4 (R) - Module CG status (4 lines) */
+/* 5:2	CRU_RST_N_1-4 (R) - Module resets status (4 lines) */
+/* 1:0	CRU_SM_STATE (R)  - Module State Machine State (same as in CRU_MOD_STATE values) */
+
+/* CRU_RSTN_CLK_EN register fields */
+/* 31:1 Reserved (R) */
+/* 0    CRU_RSTN_CLK_EN_FORCE (R/W) Force module reset and opens the clock gater */
+
+#define CRU_MAX_STATUS_LOOP         (1000)
+
+
+/* Macros to configure the CRU REGs */
+#define CRU_MOD_STATE(cru_num)     *((volatile unsigned int *)(CRU_MOD_STATE_BASE   | ((cru_num)<<4)))
+#define CRU_MOD_STATUS(cru_num)    *((volatile unsigned int *)(CRU_MOD_STATUS_BASE  | ((cru_num)<<4)))
+#define CRU_RSTN_CLK_EN(cru_num)   *((volatile unsigned int *)(CRU_RSTN_CLK_EN_BASE | ((cru_num)<<4)))
+#define CRU_GET_SM_STATE(cru_num)  (be32_to_cpu(CRU_MOD_STATUS(cru_num)) & (0x3)) /* bits 0-1 are the SM_STATE */
+
+#define DEVICE_NAME         "CruCtrl"
+#define DEVICE_MAJOR        23
+
+//extern void avalanche_system_reset(PAL_SYS_SYSTEM_RST_MODE_T mode);
+
+/*****************************************************************************
+ * Reset Control Module.
+ *****************************************************************************/
+/*! \fn void PAL_sysResetCtrl(unsigned int cru_module_id, PAL_SYS_RESET_CTRL_T reset_ctrl)
+    \brief This API is used to assert or de-assert reset for a module. It will block the caller.
+    \param cru_module_id Unique module id to assert/de-assert reset
+    \param reset_ctrl assert/de-assert reset (IN_RESET, OUT_OF_RESET)
+*/
+void PAL_sysResetCtrl(unsigned int cru_module_id, PAL_SYS_RESET_CTRL_T reset_ctrl)
+{
+    PAL_SYS_CRU_MODULE_T module_id = (PAL_SYS_CRU_MODULE_T)(cru_module_id);
+    Uint32 loop_cnt = 0;
+    Uint32 cru_status = CRU_MOD_STATE_DISABLED;
+
+    switch (reset_ctrl)
+    {
+        case IN_RESET:
+        {
+            cru_status = CRU_MOD_STATE_DISABLED;
+            break;
+        }
+        case OUT_OF_RESET:
+        {
+            cru_status = CRU_MOD_STATE_ENABLE;
+            break;
+        }
+        case CLK_DISABLE:
+        {
+            cru_status = CRU_MOD_STATE_CLK_DISABLE;
+            break;
+        }
+        case CLK_ENABLE:
+        {
+            cru_status = CRU_MOD_STATE_SYNC_RST;
+            break;
+        }
+    }
+
+    if (CRU_GET_SM_STATE(module_id) == cru_status)
+    {
+        printk (KERN_NOTICE "CRU %d is allready in CRU state %d [ignore operation]\n",cru_module_id,cru_status);
+        return; /* If the current cru status is the same as the user ask for, we ignore the operation.*/
+    }
+
+    CRU_MOD_STATE(module_id) = cpu_to_be32(cru_status);
+
+    /* Make sure that the CRU module is indeed in the correct ask state (OUT_OF_RESET or IN_RESET or CRU_MOD_STATE_CLK_DISABLE) */
+    /* This loop will block the caller for some time! */
+    do
+    {
+        if (++loop_cnt >= CRU_MAX_STATUS_LOOP)
+        {
+            printk (KERN_CRIT "CRU %d is not functional, current cru status %d !! [loop_cnt=%d ; ask_status=%d]\n",cru_module_id, CRU_GET_SM_STATE(module_id), loop_cnt, reset_ctrl);
+            return;
+        }
+    } while (CRU_GET_SM_STATE(module_id) != cru_status);
+}
+EXPORT_SYMBOL(PAL_sysResetCtrl);
+
+/*! \fn PAL_SYS_RESET_CTRL_T PAL_sysGetResetStatus(unsigned int cru_module_id)
+    \brief This API returns the status reset status of a module
+    \param cru_module_id Unique module id whose reset status has to be read
+    \return Reset assert/de-assert (IN_RESET, OUT_OF_RESET)
+*/
+PAL_SYS_RESET_CTRL_T PAL_sysGetResetStatus(unsigned int cru_module_id)
+{
+    PAL_SYS_CRU_MODULE_T module_id = (PAL_SYS_CRU_MODULE_T)(cru_module_id);
+
+
+    if ( CRU_GET_SM_STATE(module_id) == CRU_MOD_STATE_ENABLE )
+    {
+        return OUT_OF_RESET;
+    }
+    else if (CRU_GET_SM_STATE(module_id) == CRU_MOD_STATE_CLK_DISABLE)
+    {
+        return CLK_DISABLE;
+    }
+    else
+    {
+        return IN_RESET;
+    }
+}
+EXPORT_SYMBOL(PAL_sysGetResetStatus);
+
+/*! \fn void PAL_sysSystemReset(PAL_SYS_SYSTEM_RST_MODE_T mode)
+    \brief This API is used the reset the system
+    \param mode system reset mode
+*/
+void PAL_sysSystemReset(PAL_SYS_SYSTEM_RST_MODE_T mode)
+{
+    /* This is processor specific so should be implemented in avalanche_misc.c */
+    // avalanche_system_reset(mode);
+}
+
+
+void PAL_sysPowerCtrl(unsigned int power_module,  PAL_SYS_POWER_CTRL_T power_ctrl)
+{
+    return;
+}
+/*! \fn static int PAL_sysCruCtrlOpen ( struct inode *inode , struct file *filp )
+    \brief This API is used for opening the CruCtrl driver
+    \param struct inode *inode , struct file *filp
+*/
+static int PAL_sysCruCtrlOpen ( struct inode *inode , struct file *filp )
+{
+    /* Success */
+    return 0;
+}
+/*! \fn static int PAL_sysCruCtrlRelease ( struct inode *inode , struct file *filp )
+    \brief This function is used for rleasing the CruCtrl driver
+    \param struct inode *inode , struct file *filp
+*/
+static int PAL_sysCruCtrlRelease ( struct inode *inode , struct file *filp )
+{
+    /* Success */
+    return 0;
+}
+
+
+/*! \fn static long PAL_sysCruCtrlIOCTL ( struct file * filp , unsigned int cmd , unsigned long arg )
+    \brief This function is used to ioctl the CruCtrl driver
+    \param struct file * filp , unsigned int cmd , unsigned long arg
+*/
+static long PAL_sysCruCtrlIOCTL ( struct file * filp , unsigned int cmd , unsigned long arg )
+{
+#if 0
+    void __user *p = (void __user *)arg;
+    switch ( cmd )
+    {
+    case TIOCUARTINRESET:/*Disable the CRU clock*/
+        {
+            unsigned int val;
+            if(get_user(val,(int *)p))
+            {
+                printk(KERN_ERR "Failed in get_user\n");
+                return -EFAULT;
+            }
+            PAL_sysResetCtrl(val,CLK_DISABLE);
+        }
+        break;
+    case TIOCUARTOUTOFRESET:/*Enable the CRU*/
+        {
+        unsigned int val;
+        if(get_user(val,(int *)p))
+        {
+            printk(KERN_ERR "Failed in get_user\n");
+            return -EFAULT;
+        }
+        PAL_sysResetCtrl(val,OUT_OF_RESET);
+        }
+        break;
+    }
+#endif
+    return 0;
+}
+
+/* Structure that declares the usual file */
+/* Access functions */
+static struct file_operations fops =
+{
+    .open            = PAL_sysCruCtrlOpen    ,
+    .release         = PAL_sysCruCtrlRelease   ,
+    .unlocked_ioctl  = PAL_sysCruCtrlIOCTL   ,
+};
+/*! \fn static int __init PAL_sysCruCtrl_init(void)
+    \brief This function is used for init the CruCtrl driver
+    \param none
+*/
+static int __init PAL_sysCruCtrl_init(void)
+{
+    printk ( KERN_INFO "Initializing Cru Control  module\n");
+    /* Registering device */
+    if (register_chrdev ( DEVICE_MAJOR, DEVICE_NAME , &fops ) < 0 )
+    {
+
+        printk ( KERN_WARNING "memory: cannot obtain major number %d\n", DEVICE_MAJOR );
+        return -EIO;
+    }
+    return 0;
+
+}
+/*! \fn static int __init PAL_sysCruCtrl_init(void)
+    \brief This function is used for exit the CruCtrl driver
+    \param none
+*/
+static void __exit PAL_sysCru_exit(void)
+{
+    /* Freeing the major number */
+    unregister_chrdev ( DEVICE_MAJOR , DEVICE_NAME );
+    printk ( KERN_INFO "Removing Cru Control module\n");
+}
+
+
+/* Declaration of the init and exit functions */
+module_init ( PAL_sysCruCtrl_init );
+module_exit ( PAL_sysCru_exit );
+
+
+MODULE_AUTHOR ("Intel Corporation");
+MODULE_LICENSE ("GPL");
+MODULE_DESCRIPTION ("Cable Modem Cru Control");
diff --git a/arch/x86/pal_cppi41/pal_cppi41.c b/arch/x86/pal_cppi41/pal_cppi41.c
new file mode 100644
index 0000000..6423b31
--- /dev/null
+++ b/arch/x86/pal_cppi41/pal_cppi41.c
@@ -0,0 +1,606 @@
+/*
+ *
+ * pal_cppi41.c
+ * Description:
+ * see below
+ *
+ This file is provided under a dual BSD/GPLv2 license.  When using or
+ redistributing this file, you may do so under either license.
+
+ GPL LICENSE SUMMARY
+
+ Copyright(c) 2015 Intel Corporation.
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of version 2 of the GNU General Public License as
+ published by the Free Software Foundation.
+
+ This program is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ The full GNU General Public License is included in this distribution
+ in the file called LICENSE.GPL.
+
+
+ Contact Information:
+ Intel Corporation
+ 2200 Mission College Blvd.
+ Santa Clara, CA  97052
+
+ BSD LICENSE
+
+ Copyright(c) 2015 Intel Corporation. All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+
+ * Redistributions of source code must retain the above copyright
+ notice, this list of conditions and the following disclaimer.
+
+ * Redistributions in binary form must reproduce the above copyright
+ notice, this list of conditions and the following disclaimer in
+ the documentation and/or other materials provided with the
+ distribution.
+
+ * Neither the name of Intel Corporation nor the names of its
+ contributors may be used to endorse or promote products derived
+ from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+**/
+
+/**
+ * \file pal_cppi41.c
+ * \brief PAL CPPI 4 Source file, contains the minimum PAL
+ *  implementation for NPCPU APPCPU datapipe.
+ *
+ *
+ */
+
+/****************/
+/**  Includes  **/
+/****************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <linux/avalanche/puma7/puma7.h>
+#include <linux/avalanche/puma7/puma7_cppi_prv.h>
+#include <linux/avalanche/generic/avalanche_pp_api.h>
+#include <linux/avalanche/generic/pal_cppi41.h>
+#include <linux/avalanche/generic/pal_os.h>
+
+#include "cppi41_hw_mbox_if.h"
+#include <linux/hw_mailbox.h>
+/***************/
+/**  Defines  **/
+/***************/
+/* uncomment to enable debug prints */
+//#define PAL_CPPI4_DBG
+
+#ifdef PAL_CPPI4_DBG
+/* Debug print, also print function name and line number */
+#  define DPRINTK(fmt, args...) printk("%s(%d): " fmt "\n", __FUNCTION__ , __LINE__, ## args)
+#else
+#  define DPRINTK(fmt, args...)
+#endif
+
+#ifdef PAL_CPPI4_DBG
+#define ACCUM_CH_PARAM_DEBUG(initCfg)  printk("\n accChanNum=%d\n\
+        mode=%d\nqMg=%d\n qNum=%d \n pacingTickCnt=%d \n list.istBase=%p\n\
+        list.axPageEntry=%d\n list.acingMode=%d\n list.tallAvoidance=%d\n\
+        list.istCountMode=%d\n list.istEntrySize=%d\n list.axPageCnt=%d\n\
+        monitor.pktCountThresh=%d\n monitor.pacingMode=%d \n",\
+        initCfg.accChanNum, initCfg.mode, initCfg.queue.qMgr,\
+        initCfg.queue.qNum,initCfg.pacingTickCnt,initCfg.list.listBase\
+        ,initCfg.list.maxPageEntry,initCfg.list.pacingMode,\
+        initCfg.list.stallAvoidance,initCfg.list.listCountMode,\
+        initCfg.list.listEntrySize,initCfg.list.maxPageCnt,\
+        initCfg.monitor.pktCountThresh,initCfg.monitor.pacingMode)
+#else
+#define ACCUM_CH_PARAM_DEBUG(initCfg)
+#endif
+
+
+/* Error print, also print function name and line number */
+#define EPRINTK(fmt, args...) printk(KERN_ERR "****** %s(%d): " fmt " ******\n", __FUNCTION__ , __LINE__, ## args)
+
+#define QUEUE_MNG_TO_QUEUE_STAT_OFFSET                      (0x10000)
+#define QUEUE_MNG_TO_QMGR_REGS_OFFSET                       (-0x20000)
+#define QUEUE_NUMBER_TO_QUEUE_ADDR_SHIFT                    (sizeof(CSL_Queue_Mgmt_Regs) / 4)
+#define QUEUE_NUM_TO_QUEUE_BASE_ADDR(qMgr_base, qNum)       ((qMgr_base) + ((qNum) << QUEUE_NUMBER_TO_QUEUE_ADDR_SHIFT))
+
+/***************/
+/**  Globals  **/
+/***************/
+unsigned int qMgrs_qMngBase [PAL_CPPI41_NUM_QUEUE_MGR] = { 0 };     /* queue manager's queue management base */
+unsigned int qMgrs_qStatBase[PAL_CPPI41_NUM_QUEUE_MGR] = { 0 };     /* queue manager's queue stats base */
+unsigned int qMgrs_regsBase [PAL_CPPI41_NUM_QUEUE_MGR] = { 0 };     /* queue manager's managment registers */
+static bool initialized = false;
+static spinlock_t init_lock;
+
+/***************************************/
+/*  enum for endianness conversion    **/
+/**************************************/
+typedef enum
+{
+    DataPipeBig,
+    DataPipeLittle
+}dataPipeEndianNess_e;
+
+/*ADP accumulator HW Mailbox message format*/
+/*******************************************/
+/* ------------------------------------
+ * |header including Opcode -4bytes   |
+ * |----------------------------------|
+ * |Cppi4AccumulatorCfg    56 bytes   |
+ * |                                  |
+ * |                                  |
+ * |                                  |
+ * |                                  |
+ * |----------------------------------|
+ * | Current page (curPage).          |
+ * |           4bytes                 |
+ * |----------------------------------|
+ * | general purpose field            |
+ * | from ATOM->ARM: PAL_Handle       |
+ * | from ARM->ATOM: npcpu address    |
+ * |                                  |
+ * |           4bytes                 |
+ * |----------------------------------|
+ *-----------------------------------*/
+/***************************************/
+
+
+
+/*********************************/
+/**  local Functions declaration  **/
+/*********************************/
+
+/*********************************/
+/**  Functions Implementations  **/
+/*********************************/
+PAL_Handle PAL_cppi4Init (void * initCfg, Ptr param)
+{
+    unsigned long flags;
+    unsigned long qMgr1Base;
+    unsigned long qMgr2Base;
+
+    /* currently on ATOM, only pp domain is suported */
+    BUG_ON(param != CPPI41_DOMAIN_PP);
+
+    spin_lock_irqsave(&init_lock, flags);
+
+    if (initialized)
+        goto done;
+
+    qMgr1Base = PAL_CPPI_PP_QMGR_G1_QUEUES_BASE;
+    qMgr2Base = PAL_CPPI_PP_QMGR_G2_QUEUES_BASE;
+
+    DPRINTK("qMgr1Base = 0x%08x, qMgr2Base = 0x%08x", qMgr1Base, qMgr2Base);
+
+    qMgrs_qMngBase [PAL_CPPI_PP_QMGR_G1] = (unsigned long)(qMgr1Base);
+    qMgrs_qStatBase[PAL_CPPI_PP_QMGR_G1] = (unsigned long)(qMgr1Base) + QUEUE_MNG_TO_QUEUE_STAT_OFFSET;
+    qMgrs_regsBase [PAL_CPPI_PP_QMGR_G1] = (unsigned long)(qMgr1Base) + QUEUE_MNG_TO_QMGR_REGS_OFFSET;
+    qMgrs_qMngBase [PAL_CPPI_PP_QMGR_G2] = (unsigned long)(qMgr2Base);
+    qMgrs_qStatBase[PAL_CPPI_PP_QMGR_G2] = (unsigned long)(qMgr2Base) + QUEUE_MNG_TO_QUEUE_STAT_OFFSET;
+    qMgrs_regsBase [PAL_CPPI_PP_QMGR_G2] = (unsigned long)(qMgr2Base) + QUEUE_MNG_TO_QMGR_REGS_OFFSET;
+
+    DPRINTK("qMgrs_qMngBase[PAL_CPPI_PP_QMGR_G1] = 0x%08x, qMgrs_qStatBase[PAL_CPPI_PP_QMGR_G1] = 0x%08x, qMgrs_regsBase[PAL_CPPI_PP_QMGR_G1] = 0x%08x\n",
+	    qMgrs_qMngBase[PAL_CPPI_PP_QMGR_G1], qMgrs_qStatBase[PAL_CPPI_PP_QMGR_G1], qMgrs_regsBase [PAL_CPPI_PP_QMGR_G1]);
+    DPRINTK("qMgrs_qMngBase[PAL_CPPI_PP_QMGR_G2] = 0x%08x, qMgrs_qStatBase[PAL_CPPI_PP_QMGR_G2] = 0x%08x, Mgrs_regsBase[PAL_CPPI_PP_QMGR_G2] = 0x%08x",
+	    qMgrs_qMngBase[PAL_CPPI_PP_QMGR_G2], qMgrs_qStatBase[PAL_CPPI_PP_QMGR_G2], qMgrs_regsBase [PAL_CPPI_PP_QMGR_G2]);
+
+    initialized = true;
+
+    /* pal handle is not used in ATOM implementation, return dummy value
+       to avoid the null checks in shared code */
+done:
+
+    spin_unlock_irqrestore(&init_lock, flags);
+
+    return 0xDEADBEEF;
+}
+EXPORT_SYMBOL(PAL_cppi4Init);
+
+int PAL_cppi4Exit(PAL_Handle hnd, void *param)
+{
+    return 0;
+}
+EXPORT_SYMBOL(PAL_cppi4Exit);
+
+PAL_Cppi4QueueHnd PAL_cppi4QueueOpen(PAL_Handle hnd, Cppi4Queue  queue)
+{
+    PAL_Cppi4QueueHnd qHnd;
+    if (!qMgrs_qMngBase[queue.qMgr])
+    {
+        EPRINTK("PAL is not initialized, first call init function");
+        return NULL;
+    }
+    qHnd = (PAL_Cppi4QueueHnd *) QUEUE_NUM_TO_QUEUE_BASE_ADDR(qMgrs_qMngBase[queue.qMgr], queue.qNum);
+    DPRINTK("Open queue G%d.%d, qHnd = %p", queue.qMgr, queue.qNum, qHnd);
+
+    return qHnd;
+}
+EXPORT_SYMBOL(PAL_cppi4QueueOpen);
+
+int PAL_cppi4QueueClose(PAL_Handle hnd, PAL_Cppi4QueueHnd qHnd)
+{
+    DPRINTK("Close queue %p", qHnd);
+    return 0;
+}
+EXPORT_SYMBOL(PAL_cppi4QueueClose);
+
+int PAL_cppi4QueuePush(PAL_Cppi4QueueHnd hnd, void *dAddr, unsigned int dSize, unsigned int pSize)
+{
+    volatile unsigned int tmp;
+    CSL_Queue_Mgmt_Regs *qRegs;
+    Cppi4HostDescLinux *desc;
+
+    qRegs = (CSL_Queue_Mgmt_Regs *) hnd;
+    desc = (Cppi4HostDescLinux *) dAddr;
+    tmp = (dSize << QMGR_QUEUE_N_REG_D_DESCSZ_SHIFT) & QMGR_QUEUE_N_REG_D_DESCSZ_MASK;
+    tmp|= ((volatile unsigned int)dAddr & QMGR_QUEUE_N_REG_D_DESC_ADDR_MASK);
+
+    DPRINTK("Pushing desc %p to queue 0x%08x", dAddr, IO_VIRT2PHY(qRegs));
+
+   /* handle associated with ADP0 Queue */
+#ifdef DEBUG_PAL_CPPI
+    if(((int)hnd & 0xFFFF) == 0x1b30)
+    {
+        DPRINTK("%s: Qhandle=%p Desc=%p\n", __FUNCTION__, hnd, desc);
+    }
+#endif
+
+    /* refered from NPCPU pal_cpp:  Similar logic here what is there in NPCPU side */
+    /* qRegs->Queue_Reg_C = cpu_to_be32(pSize); */
+
+/* Swap endianness*/
+    qRegs->Queue_Reg_D = cpu_to_be32(tmp);
+
+    return 0;
+}
+EXPORT_SYMBOL(PAL_cppi4QueuePush);
+
+PAL_Cppi4BD *PAL_cppi4QueuePop(PAL_Cppi4QueueHnd hnd)
+{
+    PAL_Cppi4BD *bd;
+
+    CSL_Queue_Mgmt_Regs *qRegs = (CSL_Queue_Mgmt_Regs *) hnd;
+
+    bd = (PAL_Cppi4BD *)( (be32_to_cpu(qRegs->Queue_Reg_D)) & QMGR_QUEUE_N_REG_D_DESC_ADDR_MASK);
+
+    DPRINTK("Popped desc %p from queue 0x%08x", bd, netip_mmio_to_physical(qRegs));
+    return bd;
+}
+EXPORT_SYMBOL(PAL_cppi4QueuePop);
+
+int PAL_cppi4QueueGetEntryCount(PAL_Handle hnd, Cppi4Queue queue, unsigned int *entryCount)
+{
+    CSL_Queue_Status_Regs *qStatRegs;
+    qStatRegs = (CSL_Queue_Status_Regs *) QUEUE_NUM_TO_QUEUE_BASE_ADDR(qMgrs_qStatBase[queue.qMgr], queue.qNum);
+    DPRINTK("qStatRegs = 0x%08x", IO_VIRT2PHY(qStatRegs));
+    *entryCount = be32_to_cpu(qStatRegs->Queue_Status_Reg_A);
+
+    return 0;
+}
+EXPORT_SYMBOL(PAL_cppi4QueueGetEntryCount);
+
+#define SIZE_IN_WORD(p) ((sizeof(p) + 0x3) >> 2)
+
+static Int32 (*__pdsp_cmd_send)(pdsp_id_t, pdsp_cmd_t, void *, Uint32, void *, Uint32) = NULL;
+
+PAL_Result PAL_cppi4PdspCmdSendUnregister(void)
+{
+    BUG_ON(!__pdsp_cmd_send);
+
+    __pdsp_cmd_send = NULL;
+
+    printk("%s:%d: pdsp_cmd_send unregister done.", __func__, __LINE__);
+    return (PAL_SOK);
+}
+EXPORT_SYMBOL(PAL_cppi4PdspCmdSendUnregister);
+
+PAL_Result PAL_cppi4PdspCmdSendRegister(Int32 (*cb)(pdsp_id_t, pdsp_cmd_t, void *, Uint32, void *, Uint32))
+{
+    BUG_ON(__pdsp_cmd_send);
+
+    __pdsp_cmd_send = cb;
+
+    printk("%s:%d: pdsp_cmd_send register done.", __func__, __LINE__);
+    return (PAL_SOK);
+}
+EXPORT_SYMBOL(PAL_cppi4PdspCmdSendRegister);
+
+#define PDSP_PREP_CMD(cmd, option, index)           \
+                        (((cmd) & 0xffu) << 0) |    \
+                        (((option) & 0xffu) << 8) | \
+                        (((index) & 0xffffu) << 16)
+
+static inline AVALANCHE_PP_ACC_CH_INFO_t
+PAL_cppi4AccChInfo_cpu_to_be(AVALANCHE_PP_ACC_CH_INFO_t *src)
+{
+    AVALANCHE_PP_ACC_CH_INFO_t dst;
+
+    memset(&dst, 0, sizeof(AVALANCHE_PP_ACC_CH_INFO_t));
+
+    dst.Index = cpu_to_be16(src->Index);
+    dst.Channel = src->Channel;
+    dst.Command = src->Command;
+    dst.Param0Ret = cpu_to_be32(src->Param0Ret);
+    dst.Param1 = cpu_to_be32(src->Param1);
+    dst.Param2 = cpu_to_be32(src->Param2);
+
+    return dst;
+}
+
+static AVALANCHE_PP_RET_e __cppi4AccChClose(AVALANCHE_PP_ACC_CH_INFO_t *ptr_ch_cfg)
+{
+    pdsp_cmd_t pdsp_cmd = cpu_to_be32(PDSP_PREP_CMD(PDSP_ACCUMULATOR_DISABLE_CH, ptr_ch_cfg->Channel, ptr_ch_cfg->Index));
+    AVALANCHE_PP_RET_e rc;
+
+    BUG_ON(!__pdsp_cmd_send);
+
+    rc = __pdsp_cmd_send(PDSP_ID_Accumulator,
+                         pdsp_cmd,
+                         NULL, 0, NULL, 0);
+    if (rc)
+    {
+        printk("%s:%d ERROR !!! Failed to close accumulator channel !!!\n",__FUNCTION__,__LINE__);
+        return (rc + PP_RC_FAILURE);
+    }
+
+	return (PP_RC_SUCCESS);
+}
+
+static AVALANCHE_PP_RET_e __cppi4AccChOpen(AVALANCHE_PP_ACC_CH_INFO_t *ptr_ch_cfg)
+{
+    AVALANCHE_PP_ACC_CH_INFO_t info = PAL_cppi4AccChInfo_cpu_to_be(ptr_ch_cfg);
+    pdsp_cmd_t pdsp_cmd = cpu_to_be32(PDSP_PREP_CMD(PDSP_ACCUMULATOR_ENABLE_CH, ptr_ch_cfg->Channel, ptr_ch_cfg->Index));
+    AVALANCHE_PP_RET_e rc;
+
+    BUG_ON(!__pdsp_cmd_send);
+
+    rc = __pdsp_cmd_send(PDSP_ID_Accumulator,
+                         pdsp_cmd,
+                         &(info.Param0Ret),
+                         SIZE_IN_WORD(AVALANCHE_PP_ACC_CH_INFO_t) - SIZE_IN_WORD(Int32) /* Size of the parameters = total size - command size*/,
+                         NULL,   0);
+
+    if (rc)
+    {
+        printk("%s:%d ERROR !!! Failed to open accumulator channel !!!\n",__FUNCTION__,__LINE__);
+        __cppi4AccChClose(ptr_ch_cfg);
+        return (rc + PP_RC_FAILURE);
+    }
+
+	return (PP_RC_SUCCESS);
+}
+
+PAL_Cppi4AccChHnd PAL_cppi4AccChOpen(PAL_Handle hnd, Cppi4AccumulatorCfg* accCfg)
+{
+    Uint32 cookie;
+    PAL_Cppi4AccChObj *accChObj;
+#if PUMA7_OR_NEWER_SOC_TYPE
+    AVALANCHE_PP_ACC_CH_INFO_t ptr_ch_cfg;
+    AVALANCHE_PP_RET_e rc;
+#else
+    Uint32 i;
+    Cppi4PALObj *palCppi4Obj = (Cppi4PALObj *) hnd;
+    Cppi4InitCfg * initCfg = palCppi4Obj->initCfg;
+    APDSP_Command_Status_RegsOvly cmdRegs = initCfg->apdspInfo.pdspCmdBase;
+#endif
+    if (PAL_osMemAlloc(0, sizeof(PAL_Cppi4AccChObj), 0, (Ptr *) &accChObj) != PAL_SOK) {
+        EPRINTK ("\nERROR:PAL: PAL_cppi4AccChOpen: Failed to allocate Acc channel object structure.");
+        return NULL;
+    }
+
+    PAL_osMemSet (accChObj, 0, sizeof (PAL_Cppi4AccChObj));
+
+    PAL_osMemCopy(&accChObj->initCfg, accCfg, sizeof(Cppi4AccumulatorCfg));
+
+    accChObj->palCppi4Obj = hnd;
+
+    /* Need to protect the accumulator register writes. They are shared with pre-fetcher */
+    PAL_osProtectEntry(PAL_OSPROTECT_INTERRUPT, &cookie);
+
+#if PUMA7_OR_NEWER_SOC_TYPE
+    ptr_ch_cfg.Channel      =   accCfg->accChanNum ;
+    ptr_ch_cfg.Command      =   0 ;
+    ptr_ch_cfg.Param0Ret    =   (Uint32)PAL_CPPI4_VIRT_2_PHYS((void *)accCfg->list.listBase) ;
+    ptr_ch_cfg.Param1       =   (accCfg->queue.qNum) | (accCfg->queue.qMgr << 12) | (accCfg->list.maxPageEntry << 16);
+    ptr_ch_cfg.Param2       =   (accCfg->pacingTickCnt)             |
+                                (accCfg->list.maxPageCnt    << 16)  | (accCfg->list.listEntrySize  << 18)|
+                                (accCfg->list.listCountMode << 20)  | (accCfg->list.stallAvoidance << 21)|
+                                (accCfg->list.pacingMode    << 22   | (accCfg->mode << 31)); 
+
+    rc = __cppi4AccChOpen ( &ptr_ch_cfg);
+    if (PP_RC_SUCCESS != rc)
+    {
+        EPRINTK("Error: Accumulator PDSP is not responding, return code: %u\n", rc);
+        PAL_osProtectExit(PAL_OSPROTECT_INTERRUPT, cookie);
+
+        PAL_osMemFree( 0, accChObj, sizeof(PAL_Cppi4AccChObj) );
+        return NULL;
+    }
+#else
+
+    if(accCfg->mode) {
+        /* monitor mode */
+        cmdRegs->Config_A = (accCfg->queue.qNum) | (accCfg->queue.qMgr << 8) | (accCfg->monitor.pktCountThresh << 16);
+        cmdRegs->Config_B = (accCfg->pacingTickCnt) | (accCfg->monitor.pacingMode << 22) | (0x1 << 31);
+    } else {
+        /* list mode */
+        cmdRegs->List_Buffer_Address = PAL_CPPI4_VIRT_2_PHYS(accCfg->list.listBase);
+        cmdRegs->Config_A = (accCfg->queue.qNum) | (accCfg->queue.qMgr << 8) | (accCfg->list.maxPageEntry << 16);
+        cmdRegs->Config_B = (accCfg->pacingTickCnt) | (accCfg->list.maxPageCnt << 16)
+                | (accCfg->list.listEntrySize << 18) | (accCfg->list.listCountMode << 20)
+                | (accCfg->list.stallAvoidance << 21)| (accCfg->list.pacingMode << 22);
+    }
+    cmdRegs->Command = (accCfg->accChanNum) | (APDSP_CMD_ENABLE << 8);
+
+    dbgPrint("APDSP config @%p, value %x\n", &cmdRegs->List_Buffer_Address, cmdRegs->List_Buffer_Address);
+    dbgPrint("APDSP config @%p, value %x\n", &cmdRegs->Config_A, cmdRegs->Config_A);
+    dbgPrint("APDSP config @%p, value %x\n", &cmdRegs->Config_B, cmdRegs->Config_B);
+    dbgPrint("APDSP config @%p, value %x\n", &cmdRegs->Command, cmdRegs->Command);
+
+    /* TODO: 1000000 is a magic word picked up from mike's code. Need to understand
+     * timeout values and fix the code
+     */
+    for(i=0; (i < 1000000) && (cmdRegs->Command & (0xFF << 8)); i++);
+
+    if( i==1000000 )
+    {
+        EPRINTK("Error: APDSP firmware not responding!, APDSP return code: 0x%02X\n", (cmdRegs->Command & (0xFF << 24)));
+        PAL_osProtectExit(PAL_OSPROTECT_INTERRUPT, cookie);
+
+        PAL_osMemFree( 0, accChObj, sizeof(PAL_Cppi4AccChObj) );
+
+        return NULL;
+    }
+#endif
+
+    accChObj->curPage = 0;
+
+    PAL_osProtectExit(PAL_OSPROTECT_INTERRUPT, cookie);
+
+    return (PAL_Cppi4AccChHnd) accChObj;
+}
+EXPORT_SYMBOL(PAL_cppi4AccChOpen);
+
+int PAL_cppi4AccChClose(PAL_Cppi4AccChHnd hnd, void *closeArgs)
+{
+    PAL_Cppi4AccChObj *accChObj = (PAL_Cppi4AccChObj *) hnd;
+#if PUMA7_OR_NEWER_SOC_TYPE
+    AVALANCHE_PP_ACC_CH_INFO_t ptr_ch_cfg;
+    AVALANCHE_PP_RET_e rc; //return code
+
+    ptr_ch_cfg.Channel      =   accChObj->initCfg.accChanNum ;
+    ptr_ch_cfg.Command      =   0 ;
+    ptr_ch_cfg.Param0Ret    =   0 ;
+    ptr_ch_cfg.Param1       =   0 ;
+    ptr_ch_cfg.Param2       =   0 ;
+
+    if ((rc = __cppi4AccChClose ( &ptr_ch_cfg)) !=  PP_RC_SUCCESS )
+    {
+        DPRINTK("\nError: APDSP firmware not responding!");
+        DPRINTK("APDSP return code: %d\n", rc);
+        return PAL_ERROR_FLAG;
+    }
+#else
+    Cppi4PALObj *palCppi4Obj = accChObj->palCppi4Obj;
+    Cppi4InitCfg * initCfg = palCppi4Obj->initCfg;
+    Uint32 i;
+    APDSP_Command_Status_RegsOvly cmdRegs = initCfg->apdspInfo.pdspCmdBase;
+    cmdRegs->List_Buffer_Address = 0;
+    cmdRegs->Config_A = 0;
+    cmdRegs->Config_B = 0;
+    cmdRegs->Command = (accChObj->initCfg.accChanNum) | (APDSP_CMD_DISABLE << 8);
+
+    /* TODO: 1000000 is a magic word picked up from mike's code. Need to understand
+     * timeout values and fix the code
+     */
+    for(i=0; (i < 1000000) && (cmdRegs->Command & (0xFF << 8)); i++);
+    if( i==1000000 ) {
+        dbgPrint("\nError: APDSP firmware not responding!");
+        dbgPrint("APDSP return code: %x\n", (cmdRegs->Command & (0xFF << 24)));
+        return PAL_ERROR_FLAG;
+    }
+#endif
+    PAL_osMemFree(0, hnd, sizeof(PAL_Cppi4AccChObj));
+
+    return PAL_SOK;
+}
+EXPORT_SYMBOL(PAL_cppi4AccChClose);
+
+void* PAL_cppi4AccChGetNextList(PAL_Cppi4AccChHnd hnd)
+{
+    PAL_Cppi4AccChObj *accChObj = (PAL_Cppi4AccChObj *) hnd;
+    Cppi4AccumulatorCfg* initCfg = &accChObj->initCfg;
+    Ptr ret = 0;
+
+    if(initCfg->mode) return NULL; /* no lists in monitor mode */
+
+    /* data available at base + (current page * number of entries per page * size of each entry) */
+    DPRINTK("accChObj->curPage= %d initCfg->list.listBase=%p initCfg->list.maxPageEntry=%d initCfg->list.listEntrySize=%d \n",
+    accChObj->curPage,initCfg->list.listBase,initCfg->list.maxPageEntry,initCfg->list.listEntrySize );
+    ret = initCfg->list.listBase + (accChObj->curPage * initCfg->list.maxPageEntry * (initCfg->list.listEntrySize + 1) * sizeof(Uint32));
+
+    /* cache flush of list page */
+    PAL_CPPI4_CACHE_INVALIDATE(ret, initCfg->list.maxPageEntry * (initCfg->list.listEntrySize + 1) * sizeof(Uint32));
+
+    accChObj->curPage++;
+    DPRINTK("****accChObj->curPage= %d \n",  accChObj->curPage );
+    if(accChObj->curPage >= initCfg->list.maxPageCnt)
+    {
+        accChObj->curPage = 0;
+    }
+    return ret;
+}
+EXPORT_SYMBOL(PAL_cppi4AccChGetNextList);
+
+
+int PAL_cppi4Control (PAL_Handle hnd, Uint32 cmd, Ptr cmdArg, Ptr param)
+{
+    PAL_CPPI_PP_QMGRs_e qMgr = *(Uint32 *)param;
+    switch (cmd)
+    {
+        case PAL_CPPI41_IOCTL_QUEUE_DIVERT:
+        {
+            CSL_Queue_Manager_Region_RegsOvly regs;
+            if (qMgr != PAL_CPPI_PP_QMGR_G1 && qMgr != PAL_CPPI_PP_QMGR_G2) {
+                pr_err("%s:%d: unsupported queue manager!\n", __func__, __LINE__);
+                return 1;
+            }
+            regs = (CSL_Queue_Manager_Region_RegsOvly)qMgrs_regsBase[qMgr];
+            if (!regs) {
+                pr_err("%s:%d: queue manager %d not initialized!\n",__func__, __LINE__, qMgr);
+                return 1;
+            }
+            regs->Queue_Diversion = cpu_to_be32((Uint32)cmdArg);
+            break;
+        }
+        default:
+        {
+            pr_err("%s:%d:: Unsupported ioctl code %d",__func__, __LINE__, cmd);
+            return 1;
+        }
+    }
+    return 0;
+}
+EXPORT_SYMBOL(PAL_cppi4Control);
+
+static int __init pal_cppi41_init(void)
+{
+    spin_lock_init(&init_lock);
+    DPRINTK("pal_cppi41_init\n");
+    return 0;
+}
+
+static void __exit pal_cppi41_exit(void)
+{
+    DPRINTK("pal_cppi41_exit\n");
+}
+
+module_init(pal_cppi41_init);
+module_exit(pal_cppi41_exit);
+
diff --git a/arch/x86/pp_init/Kconfig b/arch/x86/pp_init/Kconfig
new file mode 100644
index 0000000..048c6a7
--- /dev/null
+++ b/arch/x86/pp_init/Kconfig
@@ -0,0 +1,12 @@
+#
+# PP init driver configuration
+#
+
+config PP_TX_INIT
+	tristate "PP tx init driver support"
+	default m
+	depends on X86
+	---help---
+	  Remap NP CPU memory to APP CPU and initialize PP tx
+
+
diff --git a/arch/x86/pp_init/Makefile b/arch/x86/pp_init/Makefile
new file mode 100644
index 0000000..398fb02
--- /dev/null
+++ b/arch/x86/pp_init/Makefile
@@ -0,0 +1,19 @@
+#
+# Copyright (c) 2016, Intel Corporation and its suppliers.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+#
+#
+
+obj-$(CONFIG_PP_TX_INIT) := puma7_pp_init.o
diff --git a/arch/x86/pp_init/puma7_pp_init.c b/arch/x86/pp_init/puma7_pp_init.c
new file mode 100644
index 0000000..a0ba5f2
--- /dev/null
+++ b/arch/x86/pp_init/puma7_pp_init.c
@@ -0,0 +1,492 @@
+/*
+ * puma7_pp_init.c
+ *  Description:
+ * Puma-7 Packet Processor initialization.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2016 Intel Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *  Intel Corporation
+ *  2200 Mission College Blvd.
+ *  Santa Clara, CA  97052
+ */
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/avalanche/generic/avalanche_pp_api.h>
+#include <linux/avalanche/puma7/puma7_pp.h>
+#include <linux/avalanche/generic/pal.h>
+#include <linux/avalanche/generic/pal_cppi41.h>
+#include <linux/avalanche/puma7/puma7_cppi.h>
+#include <linux/avalanche/puma7/puma7_cppi_prv.h>
+#include <linux/avalanche/puma7/puma7.h>
+#include <linux/avalanche/generic/avalanche_intc.h>
+#include <linux/netdevice.h>
+#include <linux/unistd.h>
+#include <linux/interrupt.h>
+#include <linux/netip_subsystem.h>
+
+
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+/* interrupts NPCPU*/
+#define DWC_REQUEST_IRQ(irq, handler, flags, name, dev) \
+                                    request_irq(irq, handler, flags, name, dev)
+#define DWC_FREE_IRQ(irq, dev)      free_irq(irq, dev)
+#define DWC_ENABLE_IRQ(irq)         enable_irq(irq)
+#define DWC_DISABLE_IRQ(irq)        disable_irq(irq)
+#define DWC_DISABLE_IRQ_NOSYC(irq)  disable_irq_nosync(irq)
+#define DWC_ACK_IRQ(irq)            ack_irq(irq)
+
+#else
+
+/* interrupts APPCPU */
+#define DWC_REQUEST_IRQ(irq, handler, flags, name, dev) \
+                                    netss_request_npcpu_irq(irq, name, handler, dev)
+#define DWC_FREE_IRQ(irq, dev)      do {} while(0) /* TODO: need to implement free_irq for netss module */
+#define DWC_ENABLE_IRQ(irq)         avalanche_intc_enable_irq(irq)
+#define DWC_DISABLE_IRQ(irq)        avalanche_intc_disable_irq(irq)
+#define DWC_DISABLE_IRQ_NOSYC(irq)  avalanche_intc_disable_irq(irq)
+#define DWC_ACK_IRQ(irq)            avalanche_intc_clear_status(irq)
+#endif
+
+#define PAL_CPPI41_ACC_MAX_PAGE_ENTRIES                32
+#define PAL_CPPI41_ACC_LIST_NULL_TERM                  0
+#define PAL_CPPI41_ACC_PACE_MODE_LASTINTR              1
+#define PAL_CPPI41_ACC_PACE_TICK_CNT                   40
+#define PAL_CPPI41_ACC_MAX_PAGE_COUNT                  2
+#define NETDEV_TX_SERVICE_MAX                          ((PAL_CPPI41_ACC_MAX_PAGE_ENTRIES - 1) * 2)
+
+//#define TX_COMPLETE_NETDEV_USE_TASKLET
+#define TX_COMPLETE_NETDEV_USE_NAPI
+#if defined(TX_COMPLETE_NETDEV_USE_NAPI)
+    struct napi_struct      gTxCompleteNapi;
+    struct net_device       dummyDev;
+    static int              netdev_tx_poll(struct napi_struct *napi , int budget);
+#elif defined(TX_COMPLETE_NETDEV_USE_TASKLET)
+    struct tasklet_struct   gTxCompleteTasklet;     /* Tx completion processing tasklet */
+#endif
+
+static int __init_acc_channel(PAL_Handle pal_hnd, int chan_num, Cppi4Queue queue, PAL_Cppi4AccChHnd *acc_hnd);
+irqreturn_t tx_complete_interrupt(int irq, void *dev);
+Int32 __setup_txcomplete(PAL_Handle palHnd);
+static int replace_npcpu_memory_for_queue(PAL_Handle palHnd, int qnum);
+static int replace_npcpu_memory(PAL_Handle palHnd);
+static int __init tx_comp_init(void);
+static void __exit tx_comp_cleanup (void);
+PAL_Cppi4AccChHnd       gTxCompleteAccChHnd[PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_COUNT];
+Ptr                     gTxCompleteAccListBase[PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_COUNT];
+Cppi4HostDescLinux**    gTxCompleteAccList[PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_COUNT];
+
+PAL_Cppi4QueueHnd       gHost2ppFreeHostDescQueueHnd[PAL_CPPI_PP_HOST2PP_INFRA_DMA_CH_COUNT];
+
+static unsigned int q_info[] = {
+    PAL_CPPI_PP_QMGR_G2_SHARED_LOW_INFRA_HOST_FD_Q_NUM,
+    PAL_CPPI_PP_QMGR_G2_ATOM_HI_INFRA_HOST_FD_Q_NUM,
+    PAL_CPPI_PP_QMGR_G2_WIFI_INFRA_HOST_RX_FD_Q_NUM,
+    PAL_CPPI_PP_QMGR_G2_RGMII0_HI_INFRA_HOST_FD_Q_NUM,
+    PAL_CPPI_PP_QMGR_G2_RGMII1_HI_INFRA_HOST_FD_Q_NUM,
+    PAL_CPPI_PP_QMGR_G2_SGMII0_HI_INFRA_HOST_FD_Q_NUM,
+    PAL_CPPI_PP_QMGR_G2_SGMII1_HI_INFRA_HOST_FD_Q_NUM,
+    PAL_CPPI_PP_QMGR_G2_HOST2PP_LOW_HOST_FD_Q_NUM,
+    PAL_CPPI_PP_QMGR_G2_HOST2PP_HI_HOST_FD_Q_NUM,
+};
+
+#ifndef CONFIG_ARM_AVALANCHE_SOC
+static inline int get_list_entry_count(int priority)
+{
+    int list_entry_count;
+    unsigned long long timeout = 1<<31; /* long timeout */
+
+            do {
+                PAL_CPPI4_CACHE_INVALIDATE(gTxCompleteAccList[priority], sizeof(int *));
+                list_entry_count = be32_to_cpu((unsigned long)*gTxCompleteAccList[priority]);
+            pr_debug("%s:%d: list_entry_count %x\n", __func__, __LINE__, list_entry_count);
+    } while(!list_entry_count && --timeout);
+
+    BUG_ON(!timeout);
+
+            *gTxCompleteAccList[priority] = NULL;
+            PAL_CPPI4_CACHE_INVALIDATE(gTxCompleteAccList[priority], sizeof(int *));
+            gTxCompleteAccList[priority]++;
+    return list_entry_count;
+}
+#endif
+
+#if defined(TX_COMPLETE_NETDEV_USE_NAPI)
+static int  __do_tx_complete(struct net_device* dev, int budget)
+#elif defined(TX_COMPLETE_NETDEV_USE_TASKLET)
+static void __do_tx_complete(unsigned long data)
+#else
+#error "Please choose packet processing framework"
+#endif // TX_COMPLETE_NETDEV_USE_NAPI
+{
+    Cppi4HostDescLinux* hostDesc;
+    Uint32      packets_processed = 0;
+    Int32       priority;
+
+    /* Start with high priority channel */
+	for (priority = PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_COUNT - 1; priority >= 0; priority--) {
+        /* While there are ready pages... */
+		while (avalanche_intd_get_interrupt_count(0, PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_NUM(priority)) &&
+                       (packets_processed <= NETDEV_TX_SERVICE_MAX)) {
+#ifndef CONFIG_ARM_AVALANCHE_SOC
+        int list_entry_count = get_list_entry_count(priority);
+
+        BUG_ON(list_entry_count > PAL_CPPI41_ACC_MAX_PAGE_ENTRIES);
+
+            while(list_entry_count--) {
+                do {
+                    PAL_CPPI4_CACHE_INVALIDATE(gTxCompleteAccList[priority], sizeof(int *));
+                    hostDesc = (Cppi4HostDescLinux*)(be32_to_cpu((unsigned long)*gTxCompleteAccList[priority]) & QMGR_QUEUE_N_REG_D_DESC_ADDR_MASK);
+                    pr_debug("%s:%d: hostDesc 0x%x\n", __func__, __LINE__, (unsigned long)hostDesc);
+                } while (!hostDesc);
+
+                *gTxCompleteAccList[priority] = NULL;
+                PAL_CPPI4_CACHE_INVALIDATE(gTxCompleteAccList[priority], sizeof(int *));
+
+#else
+            /* While there are descriptors in the page... */
+            while((hostDesc = (Cppi4HostDescLinux*)((unsigned long)*gTxCompleteAccList[priority] & QMGR_QUEUE_N_REG_D_DESC_ADDR_MASK))) {
+#endif
+
+                hostDesc = PAL_CPPI4_PHYS_2_VIRT(hostDesc);
+                PAL_CPPI4_CACHE_INVALIDATE(hostDesc, PAL_CPPI_PP_QMGR_GLOBAL_DEFAULT_DESC_SIZE);
+
+                dev_kfree_skb_any(be32_to_cpu(hostDesc->skb));
+                hostDesc->skb = NULL;
+
+                /* Queue back the hostDesc to free pool */
+                PAL_cppi4QueuePush(gHost2ppFreeHostDescQueueHnd[priority], (Ptr)PAL_CPPI4_VIRT_2_PHYS(hostDesc), PAL_CPPI4_DESCSIZE_2_QMGRSIZE(PAL_CPPI_PP_QMGR_GLOBAL_DEFAULT_DESC_SIZE), 0);
+
+                packets_processed++;
+                gTxCompleteAccList[priority]++;
+            }
+
+            /* Update the list entry for next time */
+            gTxCompleteAccList[priority] = PAL_cppi4AccChGetNextList(gTxCompleteAccChHnd[priority]);
+
+            /* Decrement number of pages by 1 */
+            avalanche_intd_set_interrupt_count(0, PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_NUM(priority), 1);
+
+#if defined(TX_COMPLETE_NETDEV_USE_NAPI)
+            /* thats it, we did enough. Jump out now! */
+            if(packets_processed >= budget)
+            {
+                return packets_processed;
+            }
+#endif // TX_COMPLETE_NETDEV_USE_NAPI
+        }
+    }
+#if defined(TX_COMPLETE_NETDEV_USE_TASKLET)
+    /* First clear the IRQ in order not to get a false interrupt since INTD is level */
+    DWC_ACK_IRQ(MAP_INTD_TO_INTC(PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_INTV_NUM));
+
+    /* Send INTD EOI */
+    avalanche_intd_write_eoi(PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_INTV_NUM);
+
+    /* It could be that between INTD count decrement and EOI the accumulator will issue another interrupt.
+       The logic of INTD is such that level will remain active high even after EOI is set, so INTC will
+       lose the interrupt after ack_irq is done (it now expects INTD polarity change).
+       Therefore we must check INTD count and if it is not 0 - reschedule the tasklet */
+	for (priority = PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_COUNT - 1; priority >= 0; priority--) {
+		if (avalanche_intd_get_interrupt_count(0, PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_NUM(priority))) {
+            tasklet_schedule(&gTxCompleteTasklet);
+            return;
+        }
+	}
+
+    DWC_ENABLE_IRQ(MAP_INTD_TO_INTC(PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_INTV_NUM));
+#endif
+#if defined(TX_COMPLETE_NETDEV_USE_NAPI)
+    return packets_processed;
+#endif
+}
+
+static int __init_acc_channel(PAL_Handle pal_hnd, int chan_num, Cppi4Queue queue, PAL_Cppi4AccChHnd* acc_hnd)
+{
+    Cppi4AccumulatorCfg cfg;
+    unsigned int accListSize;
+
+    *acc_hnd = NULL;
+
+    cfg.accChanNum             = chan_num;
+    cfg.list.maxPageEntry      = PAL_CPPI41_ACC_MAX_PAGE_ENTRIES;   /* This is entries per page (and we have 2 pages) */
+    cfg.list.listEntrySize     = PAL_CPPI41_ACC_ENTRY_TYPE_D;   /* Only interested in register 'D' which has the desc pointer */
+#ifndef CONFIG_ARM_AVALANCHE_SOC
+    cfg.list.listCountMode     = PAL_CPPI41_ACC_PACE_MODE_LASTINTR;    /* One indicates Entry Count Mode */
+#else
+    cfg.list.listCountMode     = PAL_CPPI41_ACC_LIST_NULL_TERM;        /* Zero indicates null terminated list. */
+#endif
+    cfg.list.pacingMode        = PAL_CPPI41_ACC_PACE_MODE_LASTINTR; /* Wait for time since last interrupt */
+    cfg.pacingTickCnt          = PAL_CPPI41_ACC_PACE_TICK_CNT;      /* Wait for 1000uS == 1ms */
+    cfg.list.maxPageCnt        = PAL_CPPI41_ACC_MAX_PAGE_COUNT;     /* Use two pages */
+    cfg.list.stallAvoidance    = 1;                             /* Use the stall avoidance feature */
+    cfg.queue                  = queue;
+    cfg.mode                   = 0;
+
+    accListSize = (cfg.list.maxPageEntry * (cfg.list.listEntrySize + 1)) * cfg.list.maxPageCnt * sizeof(Uint32);
+	if (!(cfg.list.listBase = kzalloc(accListSize, GFP_KERNEL))) {
+		pr_err("Unable to allocate list page of size %d\n", accListSize);
+        return -1;
+    }
+
+    PAL_CPPI4_CACHE_WRITEBACK((unsigned long)cfg.list.listBase, accListSize);
+
+	if (!(*acc_hnd = PAL_cppi4AccChOpen(pal_hnd, &cfg))) {
+		pr_err("Unable to open accumulator channel #%d\n", chan_num);
+        kfree(cfg.list.listBase);
+        return -1;
+    }
+
+    return 0;
+}
+
+irqreturn_t tx_complete_interrupt(int irq, void *dev)
+{
+    DWC_DISABLE_IRQ_NOSYC(MAP_INTD_TO_INTC(PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_INTV_NUM));
+
+#if defined(TX_COMPLETE_NETDEV_USE_NAPI)
+    napi_schedule(&gTxCompleteNapi);
+#elif defined(TX_COMPLETE_NETDEV_USE_TASKLET)
+    tasklet_schedule(&gTxCompleteTasklet);
+#endif
+
+    return IRQ_RETVAL(1);
+}
+
+
+Int32 __setup_txcomplete(PAL_Handle palHnd)
+{
+    Cppi4Queue  txCmplQ;
+    Cppi4Queue  fdHostQ;
+    Uint8       priority;
+
+	for (priority = 0; priority < PAL_CPPI_PP_HOST2PP_INFRA_DMA_CH_COUNT; priority++) {
+        /************************************************/
+        /* reset Tx complete queue                      */
+        /************************************************/
+        txCmplQ.qMgr = PAL_CPPI_PP_QMGR_G2;
+        txCmplQ.qNum = PAL_CPPI_PP_HOST2PP_TX_COMPLETE_Q_NUM(priority);
+        PAL_cppi4QueueClose(palHnd, PAL_cppi4QueueOpen(palHnd, txCmplQ));
+
+        fdHostQ.qMgr = PAL_CPPI_PP_QMGR_G2;
+        fdHostQ.qNum = PAL_CPPI_PP_HOST2PP_HOST_FD_Q_NUM(priority);
+
+		if (!(gHost2ppFreeHostDescQueueHnd[priority] = PAL_cppi4QueueOpen(palHnd, fdHostQ))) {
+			pr_err("unable to open FD Host Queue #%d for TX Complete task\n", fdHostQ.qNum);
+            return -1;
+        }
+
+        /************************************************/
+        /* Init the Tx complete accumulator channel     */
+        /************************************************/
+		if (__init_acc_channel(palHnd, PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_NUM(priority), txCmplQ, &gTxCompleteAccChHnd[priority])) {
+			pr_err("unable to open accumulator channel #%d for TX Complete task\n", PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_NUM(priority));
+            return -1;
+        }
+
+        gTxCompleteAccListBase[priority] = gTxCompleteAccList[priority] = PAL_cppi4AccChGetNextList(gTxCompleteAccChHnd[priority]);
+
+        /* request the Tx Complete IRQs - one IRQ per all TX complete priorities */
+		if (priority == 0) {
+#if defined(TX_COMPLETE_NETDEV_USE_NAPI)
+            init_dummy_netdev(&dummyDev);
+            netif_napi_add(&dummyDev, &gTxCompleteNapi, netdev_tx_poll, NETDEV_TX_SERVICE_MAX); 
+            napi_enable(&gTxCompleteNapi); 
+#elif defined(TX_COMPLETE_NETDEV_USE_TASKLET)
+            tasklet_init(&gTxCompleteTasklet, __do_tx_complete, 0);
+#endif
+            if(DWC_REQUEST_IRQ(MAP_INTD_TO_INTC(PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_INTV_NUM), tx_complete_interrupt, IRQF_DISABLED, "TX Complete", NULL))
+            {
+				pr_err("unable to get IRQ #%d for TX Complete task\n", MAP_INTD_TO_INTC(PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_INTV_NUM));
+                return -1;
+            }
+        }
+    }
+
+    return 0;
+}
+EXPORT_SYMBOL(__setup_txcomplete);
+
+#if defined(TX_COMPLETE_NETDEV_USE_NAPI)
+/**************************************************************************/
+/*! \fn         netdev_tx_poll
+ **************************************************************************
+ *
+ *
+ *  \param[in]  Net Device
+ *  \param[in]  Processed packets budget
+ *  \return     Number of processed packets
+ **************************************************************************/
+static int netdev_tx_poll(struct napi_struct *napi , int budget)
+{
+    int work_done, priority;
+    unsigned long flags;
+
+    work_done = __do_tx_complete(NULL, budget);
+
+    if (likely(work_done >= budget))
+        return budget;
+
+    /* order is important here. If we do EOI before calling netif_tx_complete, an interrupt
+     * can occur just before we take ourselves out of the poll list; we will not
+     * schedule NAPI thread on that interrupt, no further Tx interrupts and
+     * Tx will stall forever. Scary...
+     * */
+    napi_complete(napi);
+
+    /* Accumulator looks at INTD counter in order to know if it can issue another interrupt.
+       Since we decrement the counter at l2sw_netdev_tx_complete it is possible that accumulator issued another interrupt.
+       Due to the fact that interrupt is level and we do not want to get a false interrupt, we clear the INTC at the end of l2sw_netdev_tx_complete.
+       Next time INTC will wait for INTD to become active.
+       But, since INTD is level there is a possibility that INTD will remain active.
+       This can happen if accumulator issues an interrupt before the host sent EOI (this is done in next line of code).
+       So, in this case we have INTD status not changed - still active, while INTC now waits for it to become active.
+       This can lead to not getting the interrupt forever. This is why we must check if counter>0 and if so re-schedule NAPI.
+       We lock the interrupts b4 doing EOI and up until NAPI schedule in order not to get double interrupt in the case that
+       an interrupt is really issued between EOI and checking INTD count - we are going to reschedule NAPI anyway... */
+
+    DWC_ACK_IRQ(MAP_INTD_TO_INTC(PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_INTV_NUM));
+    avalanche_intd_write_eoi(PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_INTV_NUM);
+
+    /* It could be that between INTD count decrement and EOI the accumulator will issue another interrupt.
+       The logic of INTD is such that level will remain active high even after EOI is set, so INTC will
+       lose the interrupt after ack_irq is done (it now expects INTD polarity change).
+       Therefore we must check INTD count and if it is not 0 - reschedule the tasklet */
+
+    for (priority = PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_COUNT - 1; priority >= 0; priority--)
+    {
+        if (avalanche_intd_get_interrupt_count(0, PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_NUM(priority)))
+        {
+                napi_schedule(napi);
+                return work_done;
+        }
+    }
+
+    DWC_ENABLE_IRQ(MAP_INTD_TO_INTC(PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_INTV_NUM));
+    return work_done;
+}
+
+#endif
+
+static int replace_npcpu_memory_for_queue(PAL_Handle palHnd, int qnum)
+{
+
+    Cppi4HostDescLinux*    currDesc;
+    unsigned int i, descCount;
+    Cppi4Queue          tmpQ;
+    PAL_Cppi4QueueHnd   tmpQHnd;
+
+    tmpQ.qMgr = PAL_CPPI_PP_QMGR_G2;
+    tmpQ.qNum = qnum;
+    tmpQHnd = PAL_cppi4QueueOpen(NULL, tmpQ);
+
+
+    PAL_cppi4QueueGetEntryCount(palHnd, tmpQ, &descCount);
+    if (0 == descCount)
+    {
+        pr_err("queue num %d is empty, packet data descriptors init failed", qnum);
+        return -1;
+    }
+
+    pr_info("replace_npcpu_memory_for_queue: queue %d has %d descriptors\n", qnum, descCount);
+
+    for (i = 0; i < descCount; i++)
+    {
+        struct sk_buff *skb;
+        /* get a free RX descriptor */
+        if(!(currDesc = (Cppi4HostDescLinux *)PAL_cppi4QueuePop(tmpQHnd)) )
+            return -1;
+
+        currDesc = (Cppi4HostDescLinux *)PAL_CPPI4_PHYS_2_VIRT(currDesc);
+        skb = dev_alloc_skb(PAL_CPPI_PP_QMGR_GLOBAL_DEFAULT_BUFF_SIZE);
+        if (!skb) {
+            pr_err("%s:%d: SKB allocation FAILED\n", __func__, __LINE__);
+            return -1;
+        }
+        skb_reserve (skb, NET_IP_ALIGN);    /* 16 bit align the IP fields. */
+        currDesc->hw.orgBuffLen  = cpu_to_be32(PAL_CPPI_PP_QMGR_GLOBAL_DEFAULT_BUFF_SIZE - NET_IP_ALIGN);
+        currDesc->hw.orgBufPtr   = cpu_to_be32(PAL_CPPI4_VIRT_2_PHYS(skb->data));
+        currDesc->skb = cpu_to_be32(skb);
+
+
+        //PAL_CPPI4_CACHE_WRITEBACK(currDesc, gPpFDqueues[i].descSize);
+        PAL_cppi4QueuePush(tmpQHnd, (Uint32 *)PAL_CPPI4_VIRT_2_PHYS(currDesc), PAL_CPPI4_DESCSIZE_2_QMGRSIZE(PAL_CPPI_PP_QMGR_GLOBAL_DEFAULT_DESC_SIZE), 0);
+    }
+
+    return 0;
+}
+
+static int replace_npcpu_memory(PAL_Handle palHnd)
+{
+    unsigned int qcount;
+
+    for (qcount = 0; qcount < ARRAY_SIZE(q_info); qcount++)
+    {
+        if (replace_npcpu_memory_for_queue(palHnd, q_info[qcount]) < 0) {
+            pr_err("replace memory for queue %d FAILED!\n", q_info[qcount]);
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+static int __init tx_comp_init(void)
+{
+    int ret = 0;
+    PAL_Handle palHnd;
+    printk("Starting tx driver init\n");
+    
+    if (netip_memmap_init()) {
+        pr_err("%s:%d ERROR; netip memmap failed!\n", __func__, __LINE__);
+        ret = -1;
+        goto tx_comp_exit;
+    }
+    palHnd = PAL_cppi4Init(NULL, CPPI41_DOMAIN_PP);
+    if (replace_npcpu_memory(palHnd))
+    {
+        pr_err("%s(%d): Error - replace_npcpu_memory failed!\n", __FUNCTION__, __LINE__);
+    	goto tx_comp_exit;
+    }
+
+    if (__setup_txcomplete(palHnd)) {
+        pr_err("%s(%d): Error - setup_txcomplete failed!\n", __FUNCTION__, __LINE__);
+        goto tx_comp_exit;
+    }
+
+tx_comp_exit:
+    return ret;
+}
+
+static void __exit tx_comp_cleanup (void)
+{
+    pr_info("pp init driver cleanup done\n");
+}
+
+module_init(tx_comp_init);
+module_exit(tx_comp_cleanup);
+
+
+MODULE_AUTHOR ("Intel Corporation");
+MODULE_DESCRIPTION ("pp_init");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
diff --git a/drivers/mmc/host/sdhci-pci.c b/drivers/mmc/host/sdhci-pci.c
index d408382..11fcc18 100644
--- a/drivers/mmc/host/sdhci-pci.c
+++ b/drivers/mmc/host/sdhci-pci.c
@@ -28,9 +28,6 @@
 #include <linux/gpio.h>
 #include <linux/pm_runtime.h>
 #include <linux/mmc/sdhci-pci-data.h>
-#ifdef CONFIG_HW_MUTEXES
-#include <linux/hw_mutex.h>
-#endif
 #include "sdhci.h"
 
 /*
diff --git a/drivers/mrpc/Kconfig b/drivers/mrpc/Kconfig
index 9fd282d..812b652 100755
--- a/drivers/mrpc/Kconfig
+++ b/drivers/mrpc/Kconfig
@@ -33,6 +33,13 @@ config MRPC_CONNTRACK_CLIENT
     help
        Enable Puma7 conntrack MRPC between ATOM and ARM
 
+config MRPC_MODPHY_CLIENT
+    tristate "modphy mrpc client"
+    depends on MRPC
+    default n
+    help
+       modphy mrpc client
+
 config MRPC_PP_CLIENT
     bool "ATOM to ARM PP PROC over HW Mailbox"
     depends on MRPC
diff --git a/drivers/mrpc/Makefile b/drivers/mrpc/Makefile
index de9f205..f20e0cd 100755
--- a/drivers/mrpc/Makefile
+++ b/drivers/mrpc/Makefile
@@ -1,2 +1,4 @@
-obj-$(CONFIG_MRPC)		+= core/
-obj-$(CONFIG_MRPC_EXAMPLES)	+= examples/
+obj-$(CONFIG_MRPC)		 += core/
+obj-$(CONFIG_MRPC_EXAMPLES)	 += examples/
+obj-$(CONFIG_MRPC_MODPHY_CLIENT) += modphy_client.o
+obj-$(CONFIG_MRPC_HANDSHAKE)     += handshake_client.o
diff --git a/drivers/mrpc/core/Makefile b/drivers/mrpc/core/Makefile
index 5c818d4..f83021b 100644
--- a/drivers/mrpc/core/Makefile
+++ b/drivers/mrpc/core/Makefile
@@ -1,5 +1,9 @@
 obj-$(CONFIG_MRPC) += mrpc.o
-obj-$(CONFIG_MRPC_CONNTRACK_CLIENT) += conntrack_client.o
-obj-$(CONFIG_MRPC_PP_CLIENT) += pp_client.o
-obj-$(CONFIG_MRPC_HIL_CMDS_CLIENT) += hil_cmds_client.o
+
+ifneq ($(CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL),y)
+	obj-$(CONFIG_MRPC_CONNTRACK_CLIENT) += conntrack_client.o
+	obj-$(CONFIG_MRPC_PP_CLIENT) += pp_client.o
+	obj-$(CONFIG_MRPC_HIL_CMDS_CLIENT) += hil_cmds_client.o
+endif
+
 obj-$(CONFIG_MRPC_WIFI_PROXY_CLIENT) += wifi_proxy_client.o
diff --git a/drivers/mrpc/handshake_client.c b/drivers/mrpc/handshake_client.c
new file mode 100644
index 0000000..ebaeee3
--- /dev/null
+++ b/drivers/mrpc/handshake_client.c
@@ -0,0 +1,218 @@
+/*
+ *
+ * handshake_client.c
+ * Description:
+ * handshake mrpc client driver
+ *
+ *
+ * GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2016 Intel Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *  Intel Corporation
+ *  2200 Mission College Blvd.
+ *  Santa Clara, CA  97052
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ":%s:%d " fmt "\n", __func__, __LINE__
+
+/************************************************/
+/**                    Includes                 */
+/************************************************/
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/byteorder/generic.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/netdevice.h>
+#include <linux/mrpc.h>
+
+#ifdef DEBUG
+#define DBG(fmt, ...) pr_err(fmt, ##__VA_ARGS__)
+#else
+#define DBG(fmt, ...) pr_debug(fmt, ##__VA_ARGS__)
+#endif
+
+/* driver private database */
+struct handshake_private {
+    struct platform_device *pdev;   /* platform device */
+    struct mrpc_client *mrpc;       /* mrpc client handle */
+};
+
+static struct handshake_private *this;
+
+static inline int handshake_mrpc_poll(void)
+{
+    struct handshake_private *priv = this;
+    int status, ret, errcode;
+
+    if (!priv) {
+        pr_err("ERROR: mrpc handshake not initialized");
+        return -1;
+    }
+
+    ret = mrpc_call(priv->mrpc, 0, NULL, 0, &status, sizeof(status), 0, &errcode);
+
+    if (ret || errcode) {
+        pr_err("ERROR: ret=%d, errcode=%d", ret, errcode);
+        return -2;
+    }
+
+    return ntohl(status);
+}
+
+static ssize_t status_show(struct device *dev,
+                           struct device_attribute *attr, char *buf)
+{
+    struct handshake_private *priv = dev_get_drvdata(dev);
+    int ret;
+
+    if (!priv)
+        return -EINVAL;
+    ret = handshake_mrpc_poll();
+    return scnprintf(buf, PAGE_SIZE, "%d\n", ret);
+}
+
+static DEVICE_ATTR(status, S_IRUGO, status_show, NULL);
+
+static struct attribute *handshake_attrs[] = {
+    &dev_attr_status.attr,
+    NULL
+};
+
+static struct attribute_group handshake_attrs_group = {
+    .attrs = handshake_attrs,
+};
+
+/**
+ * handshake_mrpc_probe
+ *
+ * @param pdev   platform device
+ *
+ * @return 0 for success, error code otherwise
+ */
+static int handshake_mrpc_probe(struct platform_device *pdev)
+{
+    struct handshake_private *priv;
+    int ret;
+
+    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+    if (!priv) {
+        pr_err("memory allocation failed");
+        return -ENOMEM;
+    }
+
+    dev_set_drvdata(&pdev->dev, priv);
+    priv->pdev = pdev;
+
+    ret = sysfs_create_group(&priv->pdev->dev.kobj, &handshake_attrs_group);
+    if (ret) {
+        pr_err("sysfs_create_group failed (ret=%d)", ret);
+        return ret;
+    }
+
+    priv->mrpc = mrpc_client_register(MRPC_RESERVED_ID_HANDSHAKE, "handshake");
+    if (!priv->mrpc) {
+        pr_err("failed to register handshake");
+        ret = -ENODEV;
+        goto out_remove_group;
+    }
+
+    this = priv;
+    return 0;
+
+out_remove_group:
+    sysfs_remove_group(&priv->pdev->dev.kobj, &handshake_attrs_group);
+    return 0;
+}
+
+/**
+ * handshake_mrpc_remove
+ *
+ * This function is called when the handshake mrpc driver is
+ * removed.
+ *
+ * @param pdev   platform device
+ *
+ * @return 0 for success, error code otherwise
+ */
+static int handshake_mrpc_remove(struct platform_device *pdev)
+{
+    struct handshake_private *priv = platform_get_drvdata(pdev);
+    mrpc_client_unregister(priv->mrpc);
+    sysfs_remove_group(&priv->pdev->dev.kobj, &handshake_attrs_group);
+    dev_set_drvdata(&pdev->dev, NULL);
+    this = NULL;
+
+    return 0;
+}
+
+static struct platform_driver handshake_driver = {
+    .driver = {
+        .name   = "handshake",
+    },
+    .probe = handshake_mrpc_probe,
+    .remove = handshake_mrpc_remove,
+};
+
+static struct platform_device *handshake_device;
+
+static int __init handshake_mrpc_init(void)
+{
+    int ret;
+
+    ret = platform_driver_register(&handshake_driver);
+    if (ret < 0) {
+        pr_err("Failed to register handshake platform driver: %d\n", ret);
+        return ret;
+    }
+
+    handshake_device = platform_device_register_simple("handshake", -1, NULL, 0);
+    if (IS_ERR(handshake_device)) {
+        ret = PTR_ERR(handshake_device);
+        pr_err("Failed to register handshake platform device: %d\n", ret);
+        platform_driver_unregister(&handshake_driver);
+        return ret;
+    }
+
+    return 0;
+}
+
+static void __exit handshake_mrpc_exit(void)
+{
+    platform_device_unregister(handshake_device);
+    platform_driver_unregister(&handshake_driver);
+}
+
+/******************************************************/
+/**    Module Declarations                           **/
+/******************************************************/
+module_init(handshake_mrpc_init);
+module_exit(handshake_mrpc_exit);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_AUTHOR("Tzviel Lemberger tzviel.lemberger@intel.com");
+MODULE_DESCRIPTION("handshake mrpc client");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
diff --git a/drivers/mrpc/modphy_client.c b/drivers/mrpc/modphy_client.c
new file mode 100644
index 0000000..939af71
--- /dev/null
+++ b/drivers/mrpc/modphy_client.c
@@ -0,0 +1,307 @@
+/*
+ *
+ * modphy_client.c
+ * Description:
+ * modphy mrpc client driver
+ *
+ *
+ * GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2016 Intel Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *  Intel Corporation
+ *  2200 Mission College Blvd.
+ *  Santa Clara, CA  97052
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ":%s:%d " fmt "\n", __func__, __LINE__
+
+/************************************************/
+/**                    Includes                 */
+/************************************************/
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/byteorder/generic.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/err.h>
+#include <linux/netdevice.h>
+#include <linux/ethtool.h>
+#include <linux/mrpc.h>
+#include <linux/avalanche/generic/modphy_mrpc_api.h>
+
+#ifdef DEBUG
+#define DBG(fmt, ...) pr_err(fmt, ##__VA_ARGS__)
+#else
+#define DBG(fmt, ...) pr_debug(fmt, ##__VA_ARGS__)
+#endif
+
+/* driver private database */
+struct modphy_private {
+    struct platform_device *pdev;   /* platform device */
+    struct mrpc_client *mrpc;       /* mrpc client handle */
+};
+
+static struct modphy_private *this;
+
+struct modphy_args {
+    unsigned int client;
+    unsigned int lane;
+};
+
+enum {
+    MODPHY_INIT_PROC = 0,
+    MODPHY_LANE_CONFIGURE_PROC,
+    MODPHY_TX_DISABLE_PROC,
+    MODPHY_RESET_K_ALIGN_PROC,
+    MODPHY_RESET_CLIENT_PROC,
+};
+
+static inline int modphy_mrpc_call(__u8 procid,
+                                   ModphyLanes_e lane,
+                                   ModphyController_e modphyClientId)
+{
+    struct modphy_private *priv = this;
+    struct modphy_args args;
+    int ret, errcode;
+
+    if (!priv) {
+        pr_err("ERROR: mrpc modphy not initialized");
+        return MODPHY_FAIL;
+    }
+
+    args.client = htonl(modphyClientId);
+    args.lane = htonl(lane);
+
+    ret = mrpc_call(priv->mrpc, procid, &args, sizeof(struct modphy_args), NULL, 0, 0, &errcode);
+
+    if (ret || errcode) {
+        pr_err("ERROR: ret=%d, errcode=%d", ret, errcode);
+        return MODPHY_FAIL;
+    }
+
+    return MODPHY_OK;
+}
+
+/*********************************************************************************************************/
+/*! \fn int modphy_init(ModphyController_e modphyClientId)
+ *********************************************************************************************************
+ *  \brief  This function inits the modphy for a specific client.
+ *  \param[in] modphyClientId : Client ID
+ *  \return MODPHY_OK if writing succeed otherwise MODPHY_FAIL
+ ********************************************************************************************************/
+int modphy_init(ModphyController_e modphyClientId)
+{
+    return modphy_mrpc_call(MODPHY_INIT_PROC, -1, modphyClientId);
+}
+EXPORT_SYMBOL(modphy_init);
+
+/*********************************************************************************************************/
+/*! \fn int modphy_configure(ModphyController_e modphyClientId)
+ *********************************************************************************************************
+ *  \brief  This function configure the modphy for a specific client.
+ *  \param[in] modphyClientId : Client ID
+ *  \return MODPHY_OK if writing succeed otherwise MODPHY_FAIL
+ ********************************************************************************************************/
+int modphy_lane_configure(ModphyLanes_e lane,
+                          ModphyController_e modphyClientId)
+{
+    return modphy_mrpc_call(MODPHY_LANE_CONFIGURE_PROC, lane, modphyClientId);
+}
+EXPORT_SYMBOL(modphy_lane_configure);
+
+/*********************************************************************************************************/
+/*! \fn int modphy_tx_disable(ModphyLanes_e lane, ModphyController_e modphyClientId)
+ *********************************************************************************************************
+ *  \brief  This function disable TX lanes
+ *  \param[in] modphyClientId : Client ID
+ *  \return MODPHY_OK if writing succeed otherwise MODPHY_FAIL
+ ********************************************************************************************************/
+int modphy_tx_disable(ModphyLanes_e lane,
+                      ModphyController_e modphyClientId)
+{
+    return modphy_mrpc_call(MODPHY_TX_DISABLE_PROC, lane, modphyClientId);
+}
+EXPORT_SYMBOL(modphy_tx_disable);
+
+/*********************************************************************************************************/
+/*! \fn int modphy_reset_k_align(ModphyController_e modphyClientId)
+ *********************************************************************************************************
+ *  \brief  This function reset K alignment in modphy
+ *  \param[in] modphyClientId : Client ID
+ *  \return MODPHY_OK if writing succeed otherwise MODPHY_FAIL
+ ********************************************************************************************************/
+int modphy_reset_k_align(ModphyController_e modphyClientId)
+{
+    return modphy_mrpc_call(MODPHY_RESET_K_ALIGN_PROC, -1, modphyClientId);
+}
+EXPORT_SYMBOL(modphy_reset_k_align);
+
+/*********************************************************************************************************/
+/*! \fn void modphy_reset_client(ModphyController_e modphyClientId)
+ *********************************************************************************************************
+ *  \brief  This function resets ModPhy client. Used for ext.switches WA. Can be scheduled out.
+ *  \param[in] modphyClientId : Client ID
+ *  \return void
+ ********************************************************************************************************/
+void modphy_reset_client(ModphyController_e modphyClientId)
+{
+    modphy_mrpc_call(MODPHY_RESET_CLIENT_PROC, -1, modphyClientId);
+}
+EXPORT_SYMBOL(modphy_reset_client);
+
+/* sysfs for future use */
+static ssize_t status_show(struct device *dev,
+                           struct device_attribute *attr, char *buf)
+{
+    struct modphy_private *priv = dev_get_drvdata(dev);
+
+    if (!priv)
+        return -EINVAL;
+
+    return scnprintf(buf, PAGE_SIZE, "status ok");
+}
+
+static DEVICE_ATTR(status, S_IRUGO, status_show, NULL);
+
+static struct attribute *modphy_attrs[] = {
+    &dev_attr_status.attr,
+    NULL
+};
+
+static struct attribute_group modphy_attrs_group = {
+    .attrs = modphy_attrs,
+};
+
+/**
+ * modphy_mrpc_probe
+ *
+ * @param pdev   platform device
+ *
+ * @return 0 for success, error code otherwise
+ */
+static int modphy_mrpc_probe(struct platform_device *pdev)
+{
+    struct modphy_private *priv;
+    int ret;
+
+    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+    if (!priv) {
+        pr_err("memory allocation failed");
+        return -ENOMEM;
+    }
+
+    dev_set_drvdata(&pdev->dev, priv);
+    priv->pdev = pdev;
+
+    ret = sysfs_create_group(&priv->pdev->dev.kobj, &modphy_attrs_group);
+    if (ret) {
+        pr_err("sysfs_create_group failed (ret=%d)", ret);
+        return ret;
+    }
+
+    priv->mrpc = mrpc_client_register(MRPC_RESERVED_ID_MODPHY, "modphy");
+    if (!priv->mrpc) {
+        pr_err("failed to register modphy");
+        ret = -ENODEV;
+        goto out_remove_group;
+    }
+
+    this = priv;
+    return 0;
+
+out_remove_group:
+    sysfs_remove_group(&priv->pdev->dev.kobj, &modphy_attrs_group);
+    return 0;
+}
+
+/**
+ * modphy_mrpc_remove
+ *
+ * This function is called when the modphy mrpc driver is
+ * removed.
+ *
+ * @param pdev   platform device
+ *
+ * @return 0 for success, error code otherwise
+ */
+static int modphy_mrpc_remove(struct platform_device *pdev)
+{
+    struct modphy_private *priv = platform_get_drvdata(pdev);
+    mrpc_client_unregister(priv->mrpc);
+    sysfs_remove_group(&priv->pdev->dev.kobj, &modphy_attrs_group);
+    dev_set_drvdata(&pdev->dev, NULL);
+    this = NULL;
+
+    return 0;
+}
+
+static struct platform_driver modphy_driver = {
+    .driver = {
+        .name   = "modphy",
+    },
+    .probe = modphy_mrpc_probe,
+    .remove = modphy_mrpc_remove,
+};
+
+static struct platform_device *modphy_device;
+
+static int __init modphy_mrpc_init(void)
+{
+    int ret;
+
+    ret = platform_driver_register(&modphy_driver);
+    if (ret < 0) {
+        pr_err("Failed to register modphy platform driver: %d\n", ret);
+        return ret;
+    }
+
+    modphy_device = platform_device_register_simple("modphy", -1, NULL, 0);
+    if (IS_ERR(modphy_device)) {
+        pr_err("Failed to register modphy platform device\n");
+        platform_driver_unregister(&modphy_driver);
+        return PTR_ERR(modphy_device);
+    }
+
+    return 0;
+}
+
+static void __exit modphy_mrpc_exit(void)
+{
+    platform_device_unregister(modphy_device);
+    platform_driver_unregister(&modphy_driver);
+}
+
+/******************************************************/
+/**    Module Declarations                           **/
+/******************************************************/
+module_init(modphy_mrpc_init);
+module_exit(modphy_mrpc_exit);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_AUTHOR("Tomer Eliyahu tomer.b.eliyahu@intel.com");
+MODULE_DESCRIPTION("modphy mrpc client");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index d56cc83..b0c8906 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -391,7 +391,7 @@ config VMXNET3
 
 config LTQ_PPA_API_DIRECTPATH
 	bool "Enables Litepath API"
-	depends on PPA_PUMA7
+	depends on PPA_PUMA7
 	default n
 	help
 	  Configures API support for partial offload. This symbol
@@ -401,7 +401,7 @@ config LTQ_PPA_API_DIRECTPATH
 
 config LTQ_PPA_API_DIRECTPATH_HAS_NEW_API
 	bool "Enables Litepath Extended API"
-	depends on PPA_PUMA7
+	depends on PPA_PUMA7
 	default n
 	help
 	  Configures new API support for partial offload. This
diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
index 64e8189..74ebcd7 100755
--- a/drivers/net/ethernet/Kconfig
+++ b/drivers/net/ethernet/Kconfig
@@ -35,6 +35,7 @@ source "drivers/net/ethernet/chelsio/Kconfig"
 source "drivers/net/ethernet/cirrus/Kconfig"
 source "drivers/net/ethernet/cisco/Kconfig"
 source "drivers/net/ethernet/davicom/Kconfig"
+source "drivers/net/ethernet/lantiq/Kconfig"
 
 config DNET
 	tristate "Dave ethernet support (DNET)"
diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
index 72d6823..695ce00 100755
--- a/drivers/net/ethernet/Makefile
+++ b/drivers/net/ethernet/Makefile
@@ -78,3 +78,4 @@ obj-$(CONFIG_NET_VENDOR_VIA) += via/
 obj-$(CONFIG_NET_VENDOR_WIZNET) += wiznet/
 obj-$(CONFIG_NET_VENDOR_XILINX) += xilinx/
 obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
+obj-$(CONFIG_NET_VENDOR_LANTIQ) += lantiq/
diff --git a/drivers/net/ethernet/lantiq/Kconfig b/drivers/net/ethernet/lantiq/Kconfig
new file mode 100644
index 0000000..315752d
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/Kconfig
@@ -0,0 +1,25 @@
+
+
+config NET_VENDOR_LANTIQ
+        bool "Lantiq network devices"
+        default y
+        ---help---
+          If you have a network (Ethernet) card belonging to this class, say Y
+          and read the Ethernet-HOWTO, available from
+          <http://www.tldp.org/docs.html#howto>.
+
+if NET_VENDOR_LANTIQ
+
+config LANTIQ_VRX320
+	tristate "VRX320 SmartPHY PCIe EP driver"
+	default n
+	---help---
+	Supported VRX320 smartPHY PCIe EP
+
+config LANTIQ_VRX320_TEST
+	tristate "VRX320 SmartPHY PCIe EP driver test module"
+	default n
+	---help---
+	VRX320 smartPHY PCIe EP test module
+
+endif # NET_VENDOR_LANTIQ
diff --git a/drivers/net/ethernet/lantiq/Makefile b/drivers/net/ethernet/lantiq/Makefile
new file mode 100644
index 0000000..5faf870
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_LANTIQ_VRX320) += ltq_vrx320.o 
+obj-$(CONFIG_LANTIQ_VRX320_TEST) += lantiq_pcie_ep_vrx320_test.o 
diff --git a/drivers/net/ethernet/lantiq/lantiq_pcie.h b/drivers/net/ethernet/lantiq/lantiq_pcie.h
new file mode 100644
index 0000000..c33a82d
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/lantiq_pcie.h
@@ -0,0 +1,107 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2011~2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+
+/** \defgroup IFX_PCIE_EP_VRX320 PCIE EP Functions Reference
+    This chapter describes the entire interfaces to the PCIE EP interface.
+*/
+#ifndef LANTIQ_PCIE_H
+#define LANTIQ_PCIE_H
+#include <linux/types.h>
+#include <linux/pci.h>
+
+/* @{ */
+
+/*! \def IFX_PCIE_EP_MAX_PEER
+    \brief how many EP partners existed. In most cases, this number should be
+    one for bonding application For the future extension, it could be bigger
+    value. For example, multiple bonding
+ */
+#define IFX_PCIE_EP_MAX_PEER     1
+
+/** Structure used to specify interrupt source so that EP can assign unique
+    interruot to it */
+typedef enum ltq_pcie_ep_int_module {
+	IFX_PCIE_EP_INT_PPE, /*!< PPE2HOST_INT 0/1 */
+	IFX_PCIE_EP_INT_MEI, /*!< DSL MEI_IRQ */
+	IFX_PCIE_EP_INT_DYING_GASP, /*!< DSL Dying_Gasp */
+	IFX_PCIE_EP_INT_EDMA, /*!< PCIe eDMA */
+	IFX_PCIE_EP_INT_FPI_BCU, /*!< FPI BUC */
+	IFX_PCIE_EP_INT_ARC_LED0, /*!< ARC LED0 */
+	IFX_PCIE_EP_INT_ARC_LED1, /*!< ARC LED1 */
+	IFX_PCIE_EP_INT_DMA, /*!< Central DMA */
+	IFX_PCIE_EP_INT_MODULE_MAX,
+} ltq_pcie_ep_int_module_t;
+
+/** Structure used to extract attached EP detailed information
+    for PPE/DSL_MEI driver/Bonding */
+typedef struct pcie_ep_dev {
+	u32 irq;          /*!< MSI interrupt number for this device */
+	/*!< The EP inbound memory base address derived from BAR0, SoC
+	     virtual address for PPE/DSL_MEI driver */
+	u8 __iomem *membase;
+	u32 phy_membase;  /*!< The EP inbound memory base address derived
+				from BAR0, physical address for PPE FW */
+	u32 peer_num;    /*!< Bonding peer number available */
+	/*!< The bonding peer EP inbound memory base address derived from
+	     its BAR0, SoC virtual address for PPE/DSL_MEI driver */
+	u8 __iomem *peer_membase[IFX_PCIE_EP_MAX_PEER];
+	/*!< The bonding peer EP inbound memory base address derived from
+	     its BAR0, physical address for PPE FW */
+	u32 peer_phy_membase[IFX_PCIE_EP_MAX_PEER];
+} ltq_pcie_ep_dev_t;
+
+/**
+   This function returns the total number of EPs attached. Normally,
+   the number should be one <standard smartPHY EP> or two <smartPHY
+   off-chip bonding cases>. Extended case is also considered
+
+   \param[in/out]  dev_num   Pointer to detected EP numbers in total.
+   \return         -EIO      Invalid total EP number which means this
+			     module is not initialized properly
+   \return         0         Successfully return the detected EP numbers
+*/
+int ltq_pcie_ep_dev_num_get(int *dev_num);
+
+/**
+   This function returns detailed EP device information for PPE/DSL/Bonding
+   partner by its logical index obtained
+   by \ref ltq_pcie_ep_dev_num_get and its interrupt module number
+   \ref ltq_pcie_ep_int_module_t
+
+   \param[in]      dev_idx   Logical device index referred to the related
+			     device
+   \param[in]      module    EP interrupt module user<PPE/MEI/eDMA/CDMA>
+   \param[in/out]  dev       Pointer to returned detail device structure
+			     \ref ltq_pcie_ep_dev_t
+   \return         -EIO      Invalid logical device index or too many modules
+			     referred to this module
+   \return         0         Successfully return required device information
+
+   \remarks This function normally will be called to trace the detailed device
+	    information after calling \ref ltq_pcie_ep_dev_num_get
+*/
+int ltq_pcie_ep_dev_info_req(int dev_idx, ltq_pcie_ep_int_module_t module,
+			ltq_pcie_ep_dev_t *dev);
+
+/**
+   This function releases the usage of this module by PPE/DSL
+
+   \param[in]  dev_idx   Logical device index referred to the related device
+   \return     -EIO      Invalid logical device index or release too many
+			 times to refer to this module
+   \return     0         Successfully release the usage of this module
+
+   \remarks This function should be called once their reference is over.
+	    The reference usage must matches \ref ltq_pcie_ep_dev_info_req
+*/
+int ltq_pcie_ep_dev_info_release(int dev_idx);
+
+/* @} */
+#endif /* LANTIQ_PCIE_H */
+
+
diff --git a/drivers/net/ethernet/lantiq/lantiq_pcie_ep_vrx320_test.c b/drivers/net/ethernet/lantiq/lantiq_pcie_ep_vrx320_test.c
new file mode 100644
index 0000000..c4dd18d
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/lantiq_pcie_ep_vrx320_test.c
@@ -0,0 +1,694 @@
+/****************************************************************************
+                              Copyright (c) 2011
+                            Lantiq Deutschland GmbH
+                     Am Campeon 3; 85579 Neubiberg, Germany
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+ *****************************************************************************/
+#ifndef EXPORT_SYMTAB
+#define EXPORT_SYMTAB
+#endif
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <asm/types.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/byteorder/generic.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-direction.h>
+#include <asm/dma-mapping.h>
+
+
+#include "lantiq_pcie.h"
+#include "lantiq_pcie_ep_vrx320_test.h"
+
+/* compilation fixes ...*/
+#include <asm/io.h>
+#define IFX_REG_R32(_r)                    __raw_readl((volatile unsigned int *)(_r))
+#define IFX_REG_W32(_v, _r)               __raw_writel((_v), (volatile unsigned int *)(_r))
+#define IFX_REG_W32_MASK(_clr, _set, _r)   IFX_REG_W32((IFX_REG_R32((_r)) & ~(_clr)) | (_set), (_r))
+#define CPHYSADDR		__virt_to_phys
+int read_c0_count() 
+{
+	return 0;
+}
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+#define MODULE_PARM(a, b)         module_param(a, int, 0)
+#endif
+
+#define REG32(addr)         (*((volatile u32*)(addr)))
+void *tx=NULL, *rx=NULL;
+void *txphy, *rxphy;
+extern struct dma_map_ops arm_dma_ops;
+static int test_module = CDMA_TEST;
+static int dma_data_length = 1024;
+static int dma_mode = 0;
+static int dma_burst = 8;
+static int desc_num = 32;
+static int tx_byte_offset = 0;
+static int rx_byte_offset = 0;
+static int byte_enabled = 1;
+
+static ltq_pcie_ep_dev_t pcie_dev[2] = {{0}, {0}};
+static int ppe_irq_num = 0;
+
+static int txw1 = 0xb0000400;
+static int txw0 = 0x8e7a0000;
+static int rxw1 = 0xb0000400;
+static int rxw0 = 0x1e08c000;
+
+module_param(txw1, int, S_IRUGO);
+module_param(txw0, int, S_IRUGO);
+module_param(rxw1, int, S_IRUGO);
+module_param(rxw0, int, S_IRUGO);
+
+MODULE_PARM(test_module, "i");
+MODULE_PARM_DESC(test_module, "0 -- PPE, 1 -- CDMA");
+
+MODULE_PARM(dma_data_length, "i");
+MODULE_PARM_DESC(dma_data_length, "Single packet length");
+
+MODULE_PARM(dma_mode,"i");
+MODULE_PARM_DESC(dma_mode, "mode 0 -- Soc->EP, mode 1-- EP->SoC");
+
+MODULE_PARM(dma_burst,"i");
+MODULE_PARM_DESC(dma_burst, "dma burst 2, 4, 8");
+
+MODULE_PARM(desc_num,"i");
+MODULE_PARM_DESC(desc_num, "desc number 8, 16, 32");
+
+MODULE_PARM(tx_byte_offset,"i");
+MODULE_PARM_DESC(tx_byte_offset, "DMA tx byte offset 1, 2, 3");
+
+MODULE_PARM(rx_byte_offset,"i");
+MODULE_PARM_DESC(rx_byte_offset, "DMA rx byte offset 1, 2, 3");
+
+MODULE_PARM(byte_enabled,"i");
+MODULE_PARM_DESC(byte_enabled, "DMA byte enabled or not");
+mydump(void * desc, int len)
+{
+	int i;
+	char *c =desc;
+	printk("dumping desc located at virtual=%#x\n", c);
+	for(i=0; i<len; i+=8) {
+		printk("%02x %02x %02x %02x %02x %02x %02x %02x\n", 
+			c[i], c[i+1], c[i+2], c[i+3], c[i+4], c[i+5], c[i+6], c[i+7]);
+	}
+		
+}
+
+
+static irqreturn_t
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
+ltq_pcie_ep_ppe_intr(int irq, void *dev_id)
+#else
+ltq_pcie_ep_ppe_intr(int irq, void *dev_id, struct pt_regs *regs)
+#endif
+{
+    ltq_pcie_ep_dev_t *dev = dev_id;
+    u32 membase = (u32)(dev->membase);
+    ppe_irq_num++;
+    if (IFX_REG_R32(PPE_MBOX_IGU0_ISR(membase)) == 0) {
+        printk("Fatal error, dummy interrupt\n");
+    }
+    IFX_REG_W32(PPE_MBOX_TEST_BIT, PPE_MBOX_IGU0_ISRC(membase));
+    return IRQ_HANDLED;
+}
+
+static void ppe_mbox_reg_dump(u32 membase)
+{
+    printk("PPE_MBOX_IGU0_ISRS addr 0x%08x data 0x%08x\n", PPE_MBOX_IGU0_ISRS(membase), IFX_REG_R32(PPE_MBOX_IGU0_ISRS(membase)));
+    printk("PPE_MBOX_IGU0_ISRC addr 0x%08x data 0x%08x\n", PPE_MBOX_IGU0_ISRC(membase), IFX_REG_R32(PPE_MBOX_IGU0_ISRC(membase)));
+    printk("PPE_MBOX_IGU0_ISR  addr 0x%08x data 0x%08x\n", PPE_MBOX_IGU0_ISR(membase), IFX_REG_R32(PPE_MBOX_IGU0_ISR(membase)));
+    printk("PPE_MBOX_IGU0_IER  addr 0x%08x data 0x%08x\n", PPE_MBOX_IGU0_IER(membase), IFX_REG_R32(PPE_MBOX_IGU0_IER(membase)));
+    printk("PPE_MBOX_IGU1_ISRS addr 0x%08x data 0x%08x\n", PPE_MBOX_IGU1_ISRS(membase), IFX_REG_R32(PPE_MBOX_IGU1_ISRS(membase)));
+    printk("PPE_MBOX_IGU1_ISRC addr 0x%08x data 0x%08x\n", PPE_MBOX_IGU1_ISRC(membase), IFX_REG_R32(PPE_MBOX_IGU1_ISRC(membase)));
+    printk("PPE_MBOX_IGU1_ISR  addr 0x%08x data 0x%08x\n", PPE_MBOX_IGU1_ISR(membase), IFX_REG_R32(PPE_MBOX_IGU1_ISR(membase)));                    
+    printk("PPE_MBOX_IGU1_IER  addr 0x%08x data 0x%08x\n", PPE_MBOX_IGU1_IER(membase), IFX_REG_R32(PPE_MBOX_IGU1_IER(membase)));
+    printk("PPE_MBOX_IGU2_ISRS addr 0x%08x data 0x%08x\n", PPE_MBOX_IGU2_ISRS(membase), IFX_REG_R32(PPE_MBOX_IGU2_ISRS(membase)));
+    printk("PPE_MBOX_IGU2_ISRC addr 0x%08x data 0x%08x\n", PPE_MBOX_IGU2_ISRC(membase), IFX_REG_R32(PPE_MBOX_IGU2_ISRC(membase)));
+    printk("PPE_MBOX_IGU2_ISR  addr 0x%08x data 0x%08x\n", PPE_MBOX_IGU2_ISR(membase), IFX_REG_R32(PPE_MBOX_IGU2_ISR(membase)));
+    printk("PPE_MBOX_IGU2_IER  addr 0x%08x data 0x%08x\n", PPE_MBOX_IGU2_IER(membase), IFX_REG_R32(PPE_MBOX_IGU2_IER(membase)));
+}
+
+#define PPE_INT_TIMEOUT 100
+static int ppe_mbox_int_stress_test(ltq_pcie_ep_dev_t *dev)
+{
+    int i;
+    int j;
+    int ret;
+    u32 membase = (u32)(dev->membase);
+    
+    IFX_REG_W32(PPE_MBOX_TEST_BIT, PPE_MBOX_IGU0_IER(membase));
+    /* Clear it first */
+    IFX_REG_W32(PPE_MBOX_TEST_BIT, PPE_MBOX_IGU0_ISRC(membase));
+
+    ret = request_irq(dev->irq, ltq_pcie_ep_ppe_intr, IRQF_DISABLED, "PPE_MSI", dev);
+    if (ret) {
+        printk(KERN_ERR "%s request irq %d failed\n", __func__, dev->irq);
+        return -1;
+    }
+    printk("PPE test\n");
+    /* Purposely trigger interrupt */
+    for (i = 0; i < PPE_MBOX_IRQ_TEST_NUM; i++) {
+        j = 0;
+        while((IFX_REG_R32(PPE_MBOX_IGU0_ISR(membase)) & PPE_MBOX_TEST_BIT)) {
+            udelay(10);
+            j++;
+            if (j > PPE_INT_TIMEOUT) {
+                break;
+            }
+        }
+        IFX_REG_W32(PPE_MBOX_TEST_BIT, PPE_MBOX_IGU0_ISRS(membase));
+    }
+    udelay(100);
+    printk("irq triggered %d expected %d\n", ppe_irq_num, PPE_MBOX_IRQ_TEST_NUM);
+    ppe_mbox_reg_dump(membase);
+    ppe_irq_num = 0;
+    return 0;
+}
+
+static void icu_im_enable(u32 membase, int module)
+{
+    u32 reg;
+    
+    reg = REG32(ICU_IM_ER(membase));
+
+    reg |= (1 << module);
+    
+    REG32(ICU_IM_ER(membase)) = reg;
+}
+
+static void cdma_module_reset (u32 membase)
+{
+    REG32(PMU_PWDCR(membase)) &= ~CGU_DMA_CLK_EN;
+    printk("PMU_SR addr 0x%08x data 0x%08x\n", (u32)PMU_SR(membase), REG32(PMU_SR(membase)));
+    /* Enable/disable the DMA*/
+    REG32(RCU_RST_REQ(membase)) |= (0x00000200) ;  /*DMA(9) */
+    udelay(10);
+    REG32(CDMA_CTRL(membase)) |= (1);  /*Reset DMA module */
+    udelay(10);
+    REG32(CDMA_CLC(membase)) = 0x00000000;
+    printk("CDMA_CLC addr 0x%08x data 0x%08x\n", (u32)CDMA_CLC(membase), REG32(CDMA_CLC(membase)));
+
+    /* Enable central DMA interrupts */
+    icu_im_enable(membase, CDMA_CH0);
+    icu_im_enable(membase, CDMA_CH1);
+    printk("Reset DMA module done\n");
+}
+
+static void cdma_flush_memcopy_buf (u32 membase)
+{
+    REG32(CDMA_PS(membase)) = CDMA_MEMCOPY_PORT;
+    REG32(CDMA_PCTRL(membase)) |= 0x10000; 
+    udelay(2);
+    REG32(CDMA_PCTRL(membase)) &= ~(0x10000); 
+}
+
+static void reset_cdma_channel(u32 membase, int channel)
+{
+    /*reset all DMA channel to PPE Switch*/
+    REG32(CDMA_CS(membase)) = channel;
+    REG32(CDMA_CCTRL(membase)) = 0x2; 
+    while ( REG32(CDMA_CCTRL(membase)) & 0x01 ) { 
+        udelay(10);
+        printk("Reset DMA channel not done\n");
+    } 
+}   
+
+static void cdma_memory_port_cfg(u32 membase, int burstlen)
+{
+    REG32(CDMA_PS(membase)) = CDMA_MEMCOPY_PORT;
+    REG32(CDMA_PCTRL(membase)) &= ~0xf3F;  
+    
+    if (burstlen == 2 ) { 
+        REG32(CDMA_PCTRL(membase)) |= 0x14;  
+    } 
+    else if (burstlen == 4 ) { 
+        REG32(CDMA_PCTRL(membase)) |= 0x28;  
+    } 
+    else if (burstlen == 8) {
+        REG32(CDMA_PCTRL(membase)) |= 0x3c; 
+    }
+}  
+
+static void cdma_byte_enable_cfg(u32 membase, int enable)
+{
+    if (enable) {
+        REG32(CDMA_CTRL(membase)) |= (1 << 9); /* Default one */
+    }
+    else {
+        REG32(CDMA_CTRL(membase)) &= ~(1 << 9); /* Disable byte enable bit */
+    }
+}
+
+static void cdma_memory_copy_init(u32 membase)
+{
+    cdma_module_reset(membase);
+    reset_cdma_channel(membase, CDMA_MEMCOPY_TX_CHAN); /* TX */
+    reset_cdma_channel(membase, CDMA_MEMCOPY_RX_CHAN); /* RX */
+    cdma_flush_memcopy_buf(membase);
+}
+static void cdma_tx_ch_cfg (u32 membase, int dir, int ch_num, u32 desc_ptr_base, u32 data_ptr_base, int desc_num) 
+{
+    unsigned int i;
+    cdma_tx_descriptor_t *tx_desc;
+    printk("txphy = %#x\n", txphy);
+
+    for (i = 0; i < desc_num; i++) {
+        tx_desc = (cdma_tx_descriptor_t *)(desc_ptr_base + (i * sizeof(cdma_tx_descriptor_t)));
+        /* Trick !!! */
+#if 0
+        tx_desc->status.word = 0;
+        tx_desc->status.field.OWN = 1;
+        tx_desc->status.field.C = 0;
+        tx_desc->status.field.Sop = 1;
+        tx_desc->status.field.Eop = 1;
+        tx_desc->status.field.Byteoffset = tx_byte_offset;
+        tx_desc->status.field.DataLen = cpu_to_be16(dma_data_length);
+	/* tx_desc->status.word = cpu_to_be32(0xb0000400); */
+        if (dir == SOC_TO_EP) { /* src is SoC, dst is VRX218 */
+            tx_desc->DataPtr = cpu_to_be32(((((u32)(txphy + ( i * dma_data_length ))) + PCIE_EP_OUTBOUND_INTERNAL_BASE)));
+        }
+        else {
+            tx_desc->DataPtr = VRX218_ADDR(((u32)(txphy + ( i * dma_data_length ))));
+        }
+#else
+	/*FIXME tx/rx dma descriptors are defined for bigendian
+	 reorder descriptor structure for little endian */
+	memset(tx_desc, '\0', 8);
+	memcpy((char *)tx_desc, &txw1, 4);
+        if (dir == SOC_TO_EP) { /* src is SoC, dst is VRX218 */
+		int txaddr=(PCIE_EP_OUTBOUND_INTERNAL_BASE + txphy + i*dma_data_length);
+		memcpy((char *)tx_desc+4, &txaddr, 4);
+	} else {
+            	int txaddr = VRX218_ADDR(((u32)(data_ptr_base + ( i * dma_data_length ))));
+		memcpy((char *)tx_desc+4, &txaddr, 4);
+        }
+#endif
+	
+        printk("Tx desc num %d word 0x%08x data pointer 0x%08x\n",
+            i, tx_desc->status.word, tx_desc->DataPtr);
+    }
+    
+    REG32(CDMA_CS(membase)) = ch_num;
+#if 0
+    REG32(CDMA_CDBA(membase)) = VRX218_ADDR(CPHYSADDR(desc_ptr_base));
+#else
+    REG32(CDMA_CDBA(membase)) = VRX218_ADDR((desc_ptr_base));
+#endif
+    REG32(CDMA_CDLEN(membase)) = desc_num;
+    REG32(CDMA_CIE(membase)) = 0;
+    REG32(CDMA_CPOLL(membase)) = 0x80000020;
+    REG32(CDMA_CCTRL(membase)) |= (0x1 << 8); /* TX DIR */
+}
+
+static void cdma_rx_ch_cfg (u32 membase, int dir, int ch, u32 desc_ptr_base, unsigned int data_ptr_base, int desc_num) 
+{
+
+    unsigned int i;
+    cdma_rx_descriptor_t *rx_desc;
+    
+    for(i = 0; i < desc_num; i++) {
+        /* Trick !!! */
+        rx_desc = (cdma_rx_descriptor_t *)(desc_ptr_base + (i * sizeof(cdma_rx_descriptor_t)));
+        rx_desc->status.word = 0; 
+#if 0
+        rx_desc->status.field.OWN = 1;
+        rx_desc->status.field.Sop = 1;
+        rx_desc->status.field.Eop = 1;
+        rx_desc->status.field.Byteoffset = rx_byte_offset;
+        rx_desc->status.field.DataLen = roundup(dma_data_length, dma_burst << 2);
+        /* rx_desc->status.word = cpu_to_be32(0xb0000400); */
+        if (dir == SOC_TO_EP) { /* src is VRX218, dst is SoC */
+	    u32	rx_data_addr = (u32)(membase + VRX218_MASK_ADDR(REMOTE_RX1_DATA_LOC));
+            rx_desc->DataPtr = cpu_to_be32(VRX218_ADDR(((u32)(rx_data_addr + (i * roundup(dma_data_length, dma_burst << 2))))));
+        }
+        else {
+            rx_desc->DataPtr = ((u32)(rxphy + (i * roundup(dma_data_length, dma_burst << 2)))) + PCIE_EP_OUTBOUND_INTERNAL_BASE;
+        }
+
+#else
+	memset(rx_desc, '\0', 8);
+	memcpy((char *)rx_desc, &rxw1, 4);
+        if (dir == SOC_TO_EP) { /* src is VRX218, dst is SoC */
+		u32	rx_data_addr = (u32)(membase + VRX218_MASK_ADDR(REMOTE_RX1_DATA_LOC));
+		u32	dataptr = VRX218_ADDR(((u32)(rx_data_addr + (i * roundup(dma_data_length, dma_burst << 2)))));
+		memcpy((char *)rx_desc+4, &dataptr, 4);
+	} else {
+		int rxaddr = ((u32)(rxphy + (i * roundup(dma_data_length, dma_burst << 2)))) + PCIE_EP_OUTBOUND_INTERNAL_BASE;
+		memcpy((char *)rx_desc+4, &rxaddr, 4);
+	}
+#endif
+         printk("Rx desc num %d word 0x%08x data pointer 0x%08x\n",
+            i, rx_desc->status.word, rx_desc->DataPtr);       
+	//mydump(rx_desc, sizeof(cdma_rx_descriptor_t));
+    }
+    REG32(CDMA_CS(membase)) = ch;
+    REG32(CDMA_CDBA(membase)) = VRX218_ADDR((desc_ptr_base));
+    REG32(CDMA_CDLEN(membase)) = desc_num;
+    REG32(CDMA_CIE(membase)) = 0;
+    REG32(CDMA_CPOLL(membase)) = 0x80000020;
+    REG32(CDMA_CCTRL(membase)) &= ~(0x1 << 8); /* RX DIR */
+    return;
+}
+
+static void cdma_reg_dump(u32 membase)
+{
+    printk("CDMA_CLC   addr 0x%08x data 0x%08x\n", (u32)CDMA_CLC(membase), REG32(CDMA_CLC(membase)));
+    printk("CDMA_ID    addr 0x%08x data 0x%08x\n", (u32)CDMA_ID(membase), REG32(CDMA_ID(membase)));
+    printk("CDMA_CTRL  addr 0x%08x data 0x%08x\n", (u32)CDMA_CTRL(membase), REG32(CDMA_CTRL(membase)));
+    printk("CDMA_CPOLL addr 0x%08x data 0x%08x\n", (u32)CDMA_CPOLL(membase), REG32(CDMA_CPOLL(membase)));
+    printk("CDMA_CS    addr 0x%08x data 0x%08x\n", (u32)CDMA_CS(membase), REG32(CDMA_CS(membase)));
+    printk("CDMA_CCTRL addr 0x%08x data 0x%08x\n", (u32)CDMA_CCTRL(membase), REG32(CDMA_CCTRL(membase)));
+    printk("CDMA_CDBA  addr 0x%08x data 0x%08x\n", (u32)CDMA_CDBA(membase), REG32(CDMA_CDBA(membase)));
+    printk("CDMA_CDLEN addr 0x%08x data 0x%08x\n", (u32)CDMA_CDLEN(membase), REG32(CDMA_CDLEN(membase)));
+    printk("CDMA_CIS   addr 0x%08x data 0x%08x\n", (u32)CDMA_CIS(membase), REG32(CDMA_CIS(membase)));
+    printk("CDMA_CIE   addr 0x%08x data 0x%08x\n", (u32)CDMA_CIE(membase), REG32(CDMA_CIE(membase)));
+    printk("CDMA_CGBL  addr 0x%08x data 0x%08x\n", (u32)CDMA_CGBL(membase), REG32(CDMA_CGBL(membase)));
+    printk("CDMA_PS    addr 0x%08x data 0x%08x\n", (u32)CDMA_PS(membase), REG32(CDMA_PS(membase)));
+    printk("CDMA_PCTRL addr 0x%08x data 0x%08x\n", (u32)CDMA_PCTRL(membase), REG32(CDMA_PCTRL(membase)));
+    printk("CDMA_IRNEN addr 0x%08x data 0x%08x\n", (u32)CDMA_IRNEN(membase), REG32(CDMA_IRNEN(membase)));
+    printk("CDMA_IRNCR addr 0x%08x data 0x%08x\n", (u32)CDMA_IRNCR(membase), REG32(CDMA_IRNCR(membase)));
+    printk("CDMA_IRNICR addr 0x%08x data 0x%08x\n", (u32)CDMA_CLC(membase), REG32(CDMA_IRNICR(membase)));
+}
+
+/* Trigger MSI interrupt */
+static void cdma_channel_irq_en(u32 membase, u8 channel)
+{
+    u32 reg = DMA_CIE_DEFAULT;
+
+    REG32(CDMA_CS(membase)) = channel;
+    REG32(CDMA_CIS(membase)) = DMA_CIS_ALL;
+    REG32(CDMA_CIE(membase)) = reg;
+
+    reg = REG32(CDMA_IRNEN(membase));
+    reg |= (1 << channel);
+    REG32(CDMA_IRNEN(membase)) = reg;
+
+    //printk("CDMA_IRNEN addr 0x%08x data 0x%08x\n", (u32)CDMA_IRNEN(membase), REG32(CDMA_IRNEN(membase))); 
+}
+
+static void cdma_channel_irq_dis(u32 membase, u8 channel)
+{
+    u32 reg = DMA_CIE_DEFAULT;
+    
+    REG32(CDMA_CS(membase)) = channel;
+    REG32(CDMA_CIE(membase)) = DMA_CIE_DISABLE_ALL;
+    REG32(CDMA_CIS(membase)) = DMA_CIS_ALL;
+    reg = REG32(CDMA_IRNEN(membase));
+    reg &= ~(1 << channel);
+    REG32(CDMA_IRNEN(membase)) = reg;
+    //printk("CDMA_IRNEN addr 0x%08x data 0x%08x\n", (u32)CDMA_IRNEN(membase), REG32(CDMA_IRNEN(membase)));
+}
+
+static void cdma_channel_on(u32 membase, u8 channel)
+{
+    REG32(CDMA_CS(membase)) = channel;
+    REG32(CDMA_CCTRL(membase)) |= ((0x3<<16)| 0x1);
+    cdma_channel_irq_en(membase, channel);
+}
+
+static void cdma_channel_off(u32 membase, u8 channel)
+{
+    REG32(CDMA_CS(membase)) = channel;
+    REG32(CDMA_CCTRL(membase)) &= ~0x1;
+    udelay(10);
+    while (REG32(CDMA_CCTRL(membase)) & 0x01 ) { 
+        REG32(CDMA_CS(membase)) = channel;
+        udelay(10);
+    } 
+    cdma_channel_irq_dis(membase, channel);
+}
+
+#define DEFAULT_TEST_PATTEN 0x12345678
+
+static void cdma_sdram_preload(u32 sdram_data_tx_ptr, u32 sdram_data_rx_ptr )
+{
+    u32 i=0,j;
+    u32 testaddr = sdram_data_tx_ptr;
+
+    for (i = 0; i < desc_num; i++) {
+        for (j = 0; j <dma_data_length; j = j + 4 ) {
+            REG32(testaddr + i * dma_data_length + j) = DEFAULT_TEST_PATTEN;
+        }
+    }
+    
+    printk("SDR Preload(0x55aa00ff) with Data on Memcopy Tx location done\n");
+
+    testaddr = sdram_data_rx_ptr; 
+    printk("RX Preload start address:0x%08x\n",(u32)(testaddr));
+
+    for (i = 0; i < desc_num; i++) {
+        for (j = 0; j <roundup(dma_data_length, dma_burst << 2); j = j + 4 ) {
+            REG32(testaddr + i * dma_data_length + j) = 0xcccccccc;
+        }
+    }
+    printk("SDR locations for Memcopy RX preset to 0xcccccccc done\n");
+}
+
+static int memcopy_data_check(u32 rx_data_addr)
+{
+    int i, j;
+    u32 read_data;
+    int count=0;
+    int c=0;
+    int tc=0;
+    
+    for (i = 0; i < desc_num; i++) {
+        for(j = 0; j < dma_data_length; j = j + 4) {
+            read_data = REG32(rx_data_addr + i * dma_data_length + j);
+            if(read_data != DEFAULT_TEST_PATTEN) {
+		if(count <= 10 ) {
+                	printk("\nMemcopy ERROR at addr 0x%08x data 0x%08x\n", (rx_data_addr + j),(read_data));;
+		}
+		count++;
+
+            }  else { 
+		if(c <= 10) {
+		printk("Memory copied successfully : content at %#x = %#x \n", (rx_data_addr + j), read_data);
+		}
+		 c++;
+	}
+	tc++;
+		
+        }
+    }
+    printk("total dwords = %d , error dwords=%d, success dwords=%d\n", tc, count, c);
+    return 0;
+}
+
+static irqreturn_t
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
+ltq_pcie_ep_cdma_intr(int irq, void *dev_id)
+#else
+ltq_pcie_ep_cdma_intr(int irq, void *dev_id, struct pt_regs *regs)
+#endif
+{
+    printk("DMA interrupt %d received\n", irq);
+    return IRQ_HANDLED;
+}
+
+static void vrx218_central_dma_test(ltq_pcie_ep_dev_t *dev)
+{
+    int ret;
+    u8 burstlen;
+    u32 delay = 0;
+    u32 tx_data_addr, rx_data_addr;
+    u32 start, end;
+    u32 cycles;
+    u32 rx_desc_base;
+    u32 tx_desc_base;
+    u32 last_tx_desc_base;
+    u32 last_rx_desc_base;
+    u32 membase = (u32)(dev->membase);
+    int count=0;
+    int k=0;
+    int r=-1;
+
+    tx = pci_alloc_consistent(NULL, 64*1024, &txphy);
+    if(tx == NULL) {
+	printk("Unable to allocate tx memory\n");
+	return;
+    }
+    rx = pci_alloc_consistent(NULL, 64*1024, &rxphy);
+    if(rx == NULL) {
+	printk("Unable to allocate rx memory\n");
+	pci_free_consistent(NULL, 64*1024, tx, txphy);
+	return;
+    }
+    printk("*******************************************\n");
+    printk("  tx=%#x, txphy=%#x, rx=%#x & rxphy=%#x\n", tx,txphy, rx,rxphy);
+    printk("*******************************************\n");
+
+    if (dma_mode == SOC_TO_EP) { /* Read from SoC DDR to local PDBRAM  */
+        tx_desc_base = (u32)(membase + VRX218_MASK_ADDR(VRX218_TX_DESC));
+        rx_desc_base = (u32)(membase + VRX218_MASK_ADDR(VRX218_RX_DESC));
+        tx_data_addr = (u32)tx;
+        rx_data_addr = (u32)(membase + VRX218_MASK_ADDR(REMOTE_RX1_DATA_LOC));
+    }
+    else if (dma_mode == EP_TO_SOC) { /* Write from local PDBRAM to remote DDR */
+        tx_desc_base = (u32)(membase + VRX218_MASK_ADDR(VRX218_TX_DESC));
+        rx_desc_base = (u32)(membase + VRX218_MASK_ADDR(VRX218_RX_DESC));
+        tx_data_addr = (u32)(membase + VRX218_MASK_ADDR(REMOTE_TX1_DATA_LOC));
+        rx_data_addr = (u32) rx;
+    }
+    else {
+        return;
+    }
+
+    printk("tx_desc_base 0x%08x tx_data_addr 0x%08x rx_desc_base 0x%08x rx_data_addr 0x%08x\n",
+        tx_desc_base, tx_data_addr, rx_desc_base, rx_data_addr);
+
+
+    printk("dma burst %d desc number %d packet size %d\n", dma_burst, desc_num, dma_data_length);
+    burstlen = dma_burst;
+    last_tx_desc_base = tx_desc_base + (desc_num - 1) * sizeof (cdma_tx_descriptor_t);
+    last_rx_desc_base = rx_desc_base + (desc_num - 1) * sizeof (cdma_tx_descriptor_t);
+
+    cdma_memory_copy_init(membase);
+    cdma_memory_port_cfg(membase, burstlen);
+    cdma_byte_enable_cfg(membase, byte_enabled);
+    
+    cdma_sdram_preload(tx_data_addr, rx_data_addr);
+
+    cdma_tx_ch_cfg(membase, dma_mode, CDMA_MEMCOPY_TX_CHAN, tx_desc_base, tx_data_addr, desc_num);
+    cdma_rx_ch_cfg(membase, dma_mode, CDMA_MEMCOPY_RX_CHAN, rx_desc_base, rx_data_addr, desc_num);
+   
+    ret = request_irq(dev->irq, ltq_pcie_ep_cdma_intr, IRQF_DISABLED, "CDMA_MSI", dev);
+    if (ret) {
+        printk(KERN_ERR "%s request irq %d failed\n", __func__, dev->irq);
+        return;
+    }
+    printk("request irq %d is successfull\n", dev->irq);
+    udelay(5); /* Make sure that RX descriptor prefetched */
+    
+    start = read_c0_count();
+    cdma_channel_on(membase, CDMA_MEMCOPY_RX_CHAN);        
+    cdma_channel_on(membase, CDMA_MEMCOPY_TX_CHAN);
+   
+    while((REG32(last_tx_desc_base) & 0x80000000) == 0x80000000){
+        
+        delay++;
+        udelay(1);
+    }
+    end = read_c0_count();
+    cycles = end - start;
+    printk("cylces %d data amount %dbytes\n", cycles, ((u32)(dma_data_length *desc_num * 8 * 1000 )) >> 2);
+    printk("loop times %d\n", delay);
+    while((REG32(last_rx_desc_base) & 0x80000000) == 0x80000000){
+        delay++;
+        udelay(1);
+    }
+
+    r = memcopy_data_check(rx_data_addr);
+    if(r==0) {
+	printk("******Memory Copy Successfull******\n");
+    }
+    
+    printk(" Before stopping DMA\n");
+    cdma_reg_dump(membase);
+    cdma_channel_off(membase, CDMA_MEMCOPY_RX_CHAN);
+    cdma_channel_off(membase, CDMA_MEMCOPY_TX_CHAN);
+    printk(" After stopping DMA\n");
+    cdma_reg_dump(membase);
+}
+
+static int __init 
+ltq_pcie_ep_test_init(void)
+{
+    int i;
+    int j;
+    char ver_str[128] = {0};
+    int dev_num;
+    ltq_pcie_ep_dev_t dev;
+    int module;
+    
+    if (ltq_pcie_ep_dev_num_get(&dev_num)) {
+        printk("%s failed to get total device number\n", __func__);
+        return -EIO;
+    }
+
+    printk(KERN_INFO "%s: total %d EPs found\n", __func__, dev_num);
+
+    for (i = 0; i < dev_num; i++) {
+        if (test_module == PPE_TEST) {
+            module = IFX_PCIE_EP_INT_PPE;
+        }
+        else if (test_module == CDMA_TEST) {
+            module = IFX_PCIE_EP_INT_DMA;
+        }
+        else {
+            module = IFX_PCIE_EP_INT_PPE;
+        }
+        if (ltq_pcie_ep_dev_info_req(i, module, &dev)) {
+            printk("%s failed to get pcie ep %d information\n", __func__, i);
+        }
+        printk("irq %d\n", dev.irq);
+        printk("phyiscal membase 0x%08x virtual membase 0x%p\n", dev.phy_membase, dev.membase);
+        if (dev_num > 1) {
+            for (j = 0; j < dev.peer_num; j++) {
+                printk("phyiscal peer membase 0x%08x virtual peer membase 0x%p\n", 
+                    dev.peer_phy_membase[j], dev.peer_membase[j]);
+            }
+        }
+
+        pcie_dev[i].irq = dev.irq;
+        pcie_dev[i].membase = dev.membase;
+        pcie_dev[i].phy_membase = dev.phy_membase;
+        if (module == IFX_PCIE_EP_INT_PPE) {
+            ppe_mbox_int_stress_test(&pcie_dev[i]);
+        }
+        else if (module == IFX_PCIE_EP_INT_DMA) {
+            vrx218_central_dma_test(&pcie_dev[i]);
+        }
+    }
+    printk(KERN_INFO "%s", ver_str);
+    return 0;
+}
+
+static void __exit 
+ltq_pcie_ep_test_exit(void)
+{
+    int i;
+    int dev_num;
+    if(rx != NULL) {
+	printk("freeing rx memory\n");
+	pci_free_consistent(NULL, 64*1024, rx, rxphy);
+    }
+
+    if(tx != NULL) {
+	printk("freeing tx memory\n");
+	pci_free_consistent(NULL, 64*1024, tx, txphy);
+    }
+
+    if (ltq_pcie_ep_dev_num_get(&dev_num)) {
+        printk("%s failed to get total device number\n", __func__);
+        return;
+    }    
+    printk(KERN_INFO "%s: total %d EPs found\n", __func__, dev_num);
+    for (i = 0; i < dev_num; i++) {
+        
+        free_irq(pcie_dev[i].irq, &pcie_dev[i]);
+
+        if (ltq_pcie_ep_dev_info_release(i)) {
+            printk("%s failed to release pcie ep %d information\n", __func__, i);
+        }
+    }
+}
+
+module_init(ltq_pcie_ep_test_init);
+module_exit(ltq_pcie_ep_test_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("LeiChuanhua <Chuanhua.lei@lantiq.com>");
+MODULE_DESCRIPTION("Lantiq VRX218 PCIe EP Address Mapping test driver");
+MODULE_SUPPORTED_DEVICE ("Lantiq VRX218 SmartPHY PCIe EP");
+
diff --git a/drivers/net/ethernet/lantiq/lantiq_pcie_ep_vrx320_test.h b/drivers/net/ethernet/lantiq/lantiq_pcie_ep_vrx320_test.h
new file mode 100644
index 0000000..caea6378
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/lantiq_pcie_ep_vrx320_test.h
@@ -0,0 +1,264 @@
+#ifndef IFXMIPS_PCIE_EP_VRX320_TEST_H
+#define IFXMIPS_PCIE_EP_VRX320_TEST_H
+#include <linux/types.h>
+
+/* PPE interrupt */
+#define PPE_MBOX_TEST_BIT     0x1
+#define PPE_MBOX_IRQ_TEST_NUM 10000
+
+#define PPE_MBOX_OFFSET       0x200000
+#define PEE_MBOX_ATU(X)       (((X) - 0x7000 + 0xd000) << 2)
+
+#define PPE_MBOX_IGU0_ISRS(__mem_base)   ((__mem_base) + PPE_MBOX_OFFSET + PEE_MBOX_ATU(0x7200))
+#define PPE_MBOX_IGU0_ISRC(__mem_base)   ((__mem_base) + PPE_MBOX_OFFSET + PEE_MBOX_ATU(0X7201))
+#define PPE_MBOX_IGU0_ISR(__mem_base)    ((__mem_base) + PPE_MBOX_OFFSET + PEE_MBOX_ATU(0X7202))
+#define PPE_MBOX_IGU0_IER(__mem_base)    ((__mem_base) + PPE_MBOX_OFFSET + PEE_MBOX_ATU(0X7203))
+#define PPE_MBOX_IGU1_ISRS(__mem_base)   ((__mem_base) + PPE_MBOX_OFFSET + PEE_MBOX_ATU(0X7204))
+#define PPE_MBOX_IGU1_ISRC(__mem_base)   ((__mem_base) + PPE_MBOX_OFFSET + PEE_MBOX_ATU(0X7205))
+#define PPE_MBOX_IGU1_ISR(__mem_base)    ((__mem_base) + PPE_MBOX_OFFSET + PEE_MBOX_ATU(0X7206))
+#define PPE_MBOX_IGU1_IER(__mem_base)    ((__mem_base) + PPE_MBOX_OFFSET + PEE_MBOX_ATU(0X7207))
+#define PPE_MBOX_IGU2_ISRS(__mem_base)   ((__mem_base) + PPE_MBOX_OFFSET + PEE_MBOX_ATU(0X7210))
+#define PPE_MBOX_IGU2_ISRC(__mem_base)   ((__mem_base) + PPE_MBOX_OFFSET + PEE_MBOX_ATU(0X7211))
+#define PPE_MBOX_IGU2_ISR(__mem_base)    ((__mem_base) + PPE_MBOX_OFFSET + PEE_MBOX_ATU(0X7212))
+#define PPE_MBOX_IGU2_IER(__mem_base)    ((__mem_base) + PPE_MBOX_OFFSET + PEE_MBOX_ATU(0X7213))
+
+/* Central DMA */
+
+/* Inbound address translation for iATU0 */
+#define PCIE_EP_INBOUND_INTERNAL_BASE          0x1E000000
+#define PCIE_EP_OUTBOUND_INTERNAL_BASE         0x20000000
+#define PCIE_EP_OUTBOUND_MEMSIZE               0x80000000
+
+#define VRX218_MASK_ADDR(X)  (0x00FFFFFF & (X))
+#define VRX218_ADDR(X)       ((0x00FFFFFF & (X)) | 0x1e000000)
+
+/* VRX218 internal address */
+#define VRX218_PDRAM_BASE    0x1e080000
+#define PPE_SB_RAM_BLOCK0    (0x1e200000 + (0x8000 << 2))
+#define PPE_SB_RAM_BLOCK1    (0x1e200000 + (0x9000 << 2))
+#define PPE_SB_RAM_BLOCK2    (0x1e200000 + (0xa000 << 2))
+#define PPE_SB_RAM_BLOCK3    (0x1e200000 + (0xb000 << 2))
+
+#define LOCAL_DRAMBASE  0x40800000
+
+#define DATA_DDR /* SoC data in DDR instead of SRAM */
+
+#ifdef DATA_DDR
+#define LOCAL_TX1_DATA_LOC  (LOCAL_DRAMBASE + 0x00000) 
+#define LOCAL_RX1_DATA_LOC  (LOCAL_DRAMBASE + 0x10000) /* 64K */
+#else
+#define LOCAL_TX1_DATA_LOC  (0xBF107400) 
+#define LOCAL_RX1_DATA_LOC  (0xBF107400) /* 16K */
+#endif
+
+/* Special test case for bonding */
+#define BONDING_TX1_DATA_LOC  (VRX218_PDRAM_BASE + 0x0000) 
+#define BONDING_RX1_DATA_LOC  (VRX218_PDRAM_BASE + 0x8000) /* 64K */
+
+#define DESC_SB /* Descriptor in VRX218 PPE SB, instead of PDRAM */
+//#define DESC_DATA_SB /* Descriptor/ Data in VRX218 PPE SB */
+
+#ifdef DESC_SB
+#define REMOTE_TX1_DATA_LOC    VRX218_PDRAM_BASE
+#define REMOTE_RX1_DATA_LOC    VRX218_PDRAM_BASE + 0xc000
+#define VRX218_TX_DESC         PPE_SB_RAM_BLOCK0
+#define VRX218_RX_DESC         PPE_SB_RAM_BLOCK1
+#elif defined (DESC_DATA_SB)
+#define REMOTE_TX1_DATA_LOC    PPE_SB_RAM_BLOCK0
+#define REMOTE_RX1_DATA_LOC    PPE_SB_RAM_BLOCK1
+#define VRX218_TX_DESC         PPE_SB_RAM_BLOCK2
+#define VRX218_RX_DESC         PPE_SB_RAM_BLOCK2 + 0x800
+#else
+#define REMOTE_TX1_DATA_LOC    VRX218_PDRAM_BASE
+#define REMOTE_RX1_DATA_LOC    VRX218_PDRAM_BASE + 0x8000
+#define VRX218_TX_DESC         VRX218_PDRAM_BASE + 0x10000
+#define VRX218_RX_DESC         VRX218_PDRAM_BASE + 0x11000
+#endif
+
+#define VRX218_CDMA_OFFSET                0x00104100
+#define CDMA_CLC(__membase)                   ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0000))
+#define CDMA_ID(__membase)                    ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0008))
+#define CDMA_CTRL(__membase)                  ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0010))
+
+#define CDMA_PS(__membase)                    ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0040))
+#define CDMA_PCTRL(__membase)                 ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0044))
+#define CDMA_IRNEN(__membase)                 ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x00F4))
+#define CDMA_IRNCR(__membase)                 ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x00F8))
+#define CDMA_IRNICR(__membase)                ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x00FC))
+
+#define CDMA_CS(__membase)                    ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0018))
+#define CDMA_CCTRL(__membase)                 ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x001C))
+#define CDMA_CDBA(__membase)                  ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0020))
+#define CDMA_CGBL(__membase)                  ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0030))
+#define CDMA_CDPTNRD(__membase)               ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0034))
+#define CDMA_CDPTNRD1(__membase)              ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0038))
+#define CDMA_CIE(__membase)                   ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x002C))
+#define CDMA_CIS(__membase)                   ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0028))
+#define CDMA_CDLEN(__membase)                 ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0024))
+#define CDMA_CPOLL(__membase)                 ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0014))
+#define CDMA_CPDCNT(__membase)                ((volatile u32*)((__membase) + VRX218_CDMA_OFFSET + 0x0080))
+
+#define CDMA_MEMCOPY_PORT         0
+
+#define CDMA_MEMCOPY_RX_CHAN      0
+#define CDMA_MEMCOPY_TX_CHAN      1
+
+
+/** End of packet interrupt */
+#define DMA_CIS_EOP  	 				0x00000002	
+/** Descriptor Under-Run Interrupt  */
+#define DMA_CIS_DUR 					0x00000004	
+/** Descriptor Complete Interrupt  */
+#define DMA_CIS_DESCPT 					0x00000008	
+/** Channel Off Interrupt  */
+#define DMA_CIS_CHOFF   				0x00000010	
+/** SAI Read Error Interrupt */
+#define DMA_CIS_RDERR 					0x00000020	
+/** all interrupts */
+#define DMA_CIS_ALL     				( DMA_CIS_EOP		\
+										| DMA_CIS_DUR 		\
+										| DMA_CIS_DESCPT 	\
+										| DMA_CIS_CHOFF 	\
+										| DMA_CIS_RDERR	)
+
+/** End of packet interrupt enable */
+#define DMA_CIE_EOP 	 	 			0x00000002	
+/** Descriptor Under-Run Interrupt enable  */
+#define DMA_CIE_DUR                     0x00000004	
+/** Descriptor Complete Interrupt  enable*/
+#define DMA_CIE_DESCPT 					0x00000008
+/** Channel Off Interrupt enable */
+#define DMA_CIE_CHOFF   				0x00000010	
+/** SAI Read Error Interrupt enable*/
+#define DMA_CIE_RDERR 					0x00000020
+
+
+#define DMA_CIE_ALL                     (DMA_CIE_EOP 		\
+										| DMA_CIE_DUR 		\
+										| DMA_CIE_DESCPT 	\
+										| DMA_CIE_CHOFF		\
+										| DMA_CIE_RDERR	)
+
+/** default enabled interrupts */
+#define DMA_CIE_DEFAULT                     ( DMA_CIE_DESCPT    \
+                                            | DMA_CIE_EOP )
+/** disable all interrupts */
+#define DMA_CIE_DISABLE_ALL                 0 
+
+typedef struct
+{
+    union {
+        struct {
+            volatile u32 OWN                 :1;
+            volatile u32 C                   :1;
+            volatile u32 Sop                 :1;
+            volatile u32 Eop                 :1;
+            volatile u32 reserved            :3;
+            volatile u32 Byteoffset          :2;
+            volatile u32 rx_sideband         :4;
+            volatile u32 reserve             :3;
+            volatile u32 DataLen             :16;
+        }field;
+
+        volatile u32 word;
+    }status;
+
+    volatile u32 DataPtr;
+} cdma_rx_descriptor_t;
+typedef struct
+{
+    union {
+        struct {
+            volatile u32 OWN                 :1;
+            volatile u32 C                   :1;
+            volatile u32 Sop                 :1;
+            volatile u32 Eop                 :1;
+            volatile u32 Byteoffset          :5;
+            volatile u32 reserved            :7;
+            volatile u32 DataLen             :16;
+        }field;
+
+        volatile u32 word;
+    }status;
+
+    volatile u32 DataPtr;
+} cdma_tx_descriptor_t;
+
+enum {
+    SOC_TO_EP = 0,
+    EP_TO_SOC,
+};
+
+/* ICU */
+#define VRX218_ICU_OFFSET 0x00000000
+
+#define ICU_IM_SR(__membase)    ((volatile u32*)((__membase) + VRX218_ICU_OFFSET + 0x0040))
+#define ICU_IM_ER(__membase)    ((volatile u32*)((__membase) + VRX218_ICU_OFFSET + 0x0044))
+#define ICU_IM_OSR(__membase)   ((volatile u32*)((__membase) + VRX218_ICU_OFFSET + 0x0048))
+
+
+#define PPE2HOST_INT_0      0
+#define PPE2HOST_INT_1      1
+#define DSL_DYING_GASP      3
+
+#define DSL_MEI_IRQ         8
+#define EDMA_INT            9
+#define FPI_BCU_INT         12
+#define ARC_LED0            13
+#define ARC_LED1            14
+#define CDMA_CH0            16
+#define CDMA_CH1            17
+#define CDMA_CH2            18
+#define CDMA_CH3            19
+#define CDMA_CH4            20
+#define CDMA_CH5            21
+#define CDMA_CH6            22
+#define CDMA_CH7            23
+
+#define VRX218_CGU_OFFSET 0x00003000
+
+#define PMU_PWDCR(__membase)    ((volatile u32*)((__membase) + VRX218_CGU_OFFSET + 0x011C))
+#define PMU_SR(__membase)       ((volatile u32*)((__membase) + VRX218_CGU_OFFSET + 0x0120))
+#define CGU_CLKFSR(__membase)   ((volatile u32*)((__membase) + VRX218_CGU_OFFSET + 0x0010))
+#define CGU_CLKGSR(__membase)   ((volatile u32*)((__membase) + VRX218_CGU_OFFSET + 0x0014))
+#define CGU_CLKGCR0(__membase)  ((volatile u32*)((__membase) + VRX218_CGU_OFFSET + 0x0018))
+#define CGU_CLKGCR1(__membase)  ((volatile u32*)((__membase) + VRX218_CGU_OFFSET + 0x001C))
+#define CGU_IF_CLK(__membase)   ((volatile u32*)((__membase) + VRX218_CGU_OFFSET + 0x0024))
+#define CGU_PLL_CFG(__membase)  ((volatile u32*)((__membase) + VRX218_CGU_OFFSET + 0x0060))
+
+#define CGU_DMA_CLK_EN      0x00000004
+
+#define VRX218_RCU_OFFSET 0x00002000
+
+#define RCU_RST_REQ(__membase)    ((volatile u32*)((__membase) + VRX218_RCU_OFFSET + 0x0010))
+#define RCU_RST_STAT(__membase)   ((volatile u32*)((__membase) + VRX218_RCU_OFFSET + 0x0014))
+
+#define RCU_RST_REQ_DMA          (1 << 9)
+
+#define RCU_AHB_ENDIAN(__membase) ((volatile u32*)((__membase) + VRX218_RCU_OFFSET + 0x004C))
+
+/* Endian control bit for enable or pin strapping */
+#define VRX218_XBAR_AHB_PCIEM_EN   0x00010000
+#define VRX218_XBAR_AHBM_PCIE_EN   0x00020000
+#define VRX218_XBAR_AHBS_DSL_EN    0x00040000
+#define VRX218_XBAR_AHBS_PCIE_EN   0x00080000
+#define VRX218_XBAR_AHB_PCIES_EN   0x00100000
+#define VRX218_XBAR_AHB_DBI_EN     0x00200000
+
+#define VRX218_XBAR_AHB_PCI_EN_ALL (VRX218_XBAR_AHB_PCIEM_EN | VRX218_XBAR_AHBM_PCIE_EN | \
+                                    VRX218_XBAR_AHBS_PCIE_EN |  VRX218_XBAR_AHB_PCIES_EN | \
+                                    VRX218_XBAR_AHB_DBI_EN | VRX218_XBAR_AHBS_DSL_EN)
+
+#define VRX218_XBAR_AHB_PCIEM   0x00000001
+#define VRX218_XBAR_AHBM_PCIE   0x00000002
+#define VRX218_XBAR_AHBS_DSL    0x00000004
+#define VRX218_XBAR_AHBS_PCIE   0x00000008
+#define VRX218_XBAR_AHB_PCIES   0x00000010
+#define VRX218_XBAR_AHB_DBI     0x00000020
+
+enum {
+    PPE_TEST = 0,
+    CDMA_TEST,
+};
+
+#endif /* IFXMIPS_PCIE_EP_VRX320_TEST_H */
diff --git a/drivers/net/ethernet/lantiq/ltq_vrx320.c b/drivers/net/ethernet/lantiq/ltq_vrx320.c
new file mode 100644
index 0000000..a8bd77a
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ltq_vrx320.c
@@ -0,0 +1,657 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2011~2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+/*!
+  \defgroup VRX320_INTERNAL Internal functions
+  \ingroup VRX320
+  \brief IFX PCIe EP internal driver functions
+*/
+
+/*!
+  \defgroup VRX320_OS OS APIs
+  \ingroup VRX320
+  \brief IFX PCIe EP OS APIs for driver interface
+*/
+
+/*!
+   \file ltqmips_pcie_ep_vrx320.c
+   \ingroup VRX320
+   \brief SmartPHY PCIe EP address mapping driver source file
+*/
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/atomic.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/pci.h>
+#include <linux/pci_regs.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+
+#include "lantiq_pcie.h"
+#include "ltq_vrx320.h"
+#include "ltq_wrapper.h"
+
+#define ltq_vrx320_r32    ltq_r32
+#define ltq_vrx320_w32    ltq_w32
+#define MS(_v, _f)  (((_v) & (_f)) >> _f##_S)
+#define SM(_v, _f)  (((_v) << _f##_S) & (_f))
+
+#define LTQ_EP_DBG
+
+#define VRX320_DRV_VERSION "2.0.0 "
+const char vrx320_driver_version[] = VRX320_DRV_VERSION;
+
+static struct pcie_ep_info g_pcie_ep_info;
+static const char ltq_pcie_driver_name[] = "ltq_pcie";
+static DEFINE_SPINLOCK(pcie_ep_lock);
+
+int ltq_pcie_ep_dev_num_get(int *dev_num)
+{
+	if ((g_pcie_ep_info.dev_num <= 0)
+		|| (g_pcie_ep_info.dev_num > IFX_PCIE_EP_MAX_NUM)) {
+		return -EIO;
+	}
+
+	*dev_num = g_pcie_ep_info.dev_num;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ltq_pcie_ep_dev_num_get);
+
+int ltq_pcie_ep_dev_info_req(int dev_idx, ltq_pcie_ep_int_module_t module,
+			ltq_pcie_ep_dev_t *dev)
+{
+	int i;
+
+	if ((dev_idx < 0) || (dev_idx >= IFX_PCIE_EP_MAX_NUM)) {
+		pr_err("%s invalid device index %d\n",
+			__func__, dev_idx);
+		return -EIO;
+	}
+
+	if (atomic_read(&g_pcie_ep_info.pcie_ep[dev_idx].refcnt) >=
+		PCIE_EP_MAX_REFCNT) {
+		pr_err("%s mismatch request/release module usage\n",
+			__func__);
+		return -EIO;
+	}
+
+	switch (module) {
+	case IFX_PCIE_EP_INT_PPE:
+		dev->irq = g_pcie_ep_info.pcie_ep[dev_idx].irq_base;
+		break;
+
+	case IFX_PCIE_EP_INT_MEI:
+		dev->irq = g_pcie_ep_info.pcie_ep[dev_idx].irq_base + 1;
+		/* XXX, Hardcode workaround for PCIe switch bonding for RC0 */
+		if (dev->irq == 158)
+			dev->irq = 30;
+		else if (dev->irq == 166)
+			dev->irq = 38;
+
+		break;
+
+	case IFX_PCIE_EP_INT_DYING_GASP:
+	case IFX_PCIE_EP_INT_EDMA:
+	case IFX_PCIE_EP_INT_FPI_BCU:
+	case IFX_PCIE_EP_INT_ARC_LED0:
+	case IFX_PCIE_EP_INT_ARC_LED1:
+		dev->irq = g_pcie_ep_info.pcie_ep[dev_idx].irq_base + 2;
+		break;
+
+	case IFX_PCIE_EP_INT_DMA:
+		dev->irq =
+			g_pcie_ep_info.pcie_ep[dev_idx].irq_base + 3;
+		if (dev->irq == 158)
+			dev->irq = 30;
+		else if (dev->irq == 166)
+			dev->irq = 38;
+
+		break;
+
+	default:
+		dev->irq = g_pcie_ep_info.pcie_ep[dev_idx].irq_base;
+		break;
+	}
+
+	dev->membase = g_pcie_ep_info.pcie_ep[dev_idx].membase;
+	dev->phy_membase = g_pcie_ep_info.pcie_ep[dev_idx].phy_membase;
+	dev->peer_num = g_pcie_ep_info.pcie_ep[dev_idx].peer_num;
+	for (i = 0; i < dev->peer_num; i++) {
+		dev->peer_membase[i] =
+			g_pcie_ep_info.pcie_ep[dev_idx].peer_membase[i];
+		dev->peer_phy_membase[i] =
+			g_pcie_ep_info.pcie_ep[dev_idx].peer_phy_membase[i];
+	}
+	atomic_inc(&g_pcie_ep_info.pcie_ep[dev_idx].refcnt);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ltq_pcie_ep_dev_info_req);
+
+int ltq_pcie_ep_dev_info_release(int dev_idx)
+{
+	if ((dev_idx < 0) || (dev_idx >= IFX_PCIE_EP_MAX_NUM)) {
+		pr_err("%s invalid device index %d\n",
+			__func__, dev_idx);
+		return -EIO;
+	}
+
+	if (atomic_read(&g_pcie_ep_info.pcie_ep[dev_idx].refcnt) <= 0) {
+		pr_err("%s mismatch request/release module usage\n",
+			__func__);
+		return -EIO;
+	}
+	atomic_dec(&g_pcie_ep_info.pcie_ep[dev_idx].refcnt);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ltq_pcie_ep_dev_info_release);
+
+static DEFINE_PCI_DEVICE_TABLE(ltq_pcie_id_table) = {
+	{0x1bef, 0x0020, PCI_ANY_ID, PCI_ANY_ID}, /* SmartPHY */
+	{0},
+};
+
+/**
+ * \fn  static int pci_msi_max_vector_get(struct pci_dev *dev, int *nvec)
+ *
+ * \brief  This function tries to get device's MSI interrupt vector number
+ *
+ * \param  dev      Device to operate
+ * \param  nvec     Numer of interrupts to get
+ * \return 0        on success
+ * \return -EINVAL  The device doesn't support MSI capability
+ *
+ * \ingroup IFX_PCIE_EP_VRX320_INTERNAL
+ */
+static int pci_msi_max_vector_get(struct pci_dev *dev, int *nvec)
+{
+	int pos, maxvec;
+	u16 msgctl;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
+	if (!pos)
+		return -EINVAL;
+
+	pci_read_config_word(dev, pos + PCI_MSI_FLAGS, &msgctl);
+	maxvec = 1 << ((msgctl & PCI_MSI_FLAGS_QMASK) >> 1);
+	*nvec = maxvec;
+	return 0;
+}
+
+/**
+ * \fn  static int pci_msi_max_vector_set(struct pci_dev *dev, int nvec)
+ *
+ * \brief  This function tries to set device's MSI interrupt vector number
+ *
+ * \param  dev      Device to operate
+ * \param  nvec     Numer of interrupts to set
+ * \return 0        on success
+ * \return -EINVAL  The device doesn't support MSI capability or invalid
+ *                  interrupt number
+ *
+ * \remark smartPHY only supports 1 or 2 or 4 interrupts depend on other
+ *         module usage
+ * \ingroup IFX_PCIE_EP_VRX320_INTERNAL
+ */
+static int pci_msi_max_vector_set(struct pci_dev *dev, int nvec)
+{
+	int pos;
+	u16 msgctl;
+
+	if ((nvec != 1) && (nvec != 2) && (nvec != 4))
+		return -EINVAL;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
+	if (!pos)
+		return -EINVAL;
+
+	pci_read_config_word(dev, pos + PCI_MSI_FLAGS, &msgctl);
+	msgctl &= ~PCI_MSI_FLAGS_QSIZE;
+	msgctl |= (nvec >> 1) << 4;
+	pci_write_config_word(dev, pos + PCI_MSI_FLAGS, msgctl);
+	pci_read_config_word(dev, pos + PCI_MSI_FLAGS, &msgctl);
+	/* ICU control if necessary */
+	return 0;
+}
+
+#ifdef LTQ_EP_DBG
+static void ltq_pcie_iatu_dump(struct pci_dev *pdev, int outbound)
+{
+	u32 val;
+
+	switch (outbound) {
+	case 0:
+		/* Inbound iATU0 */
+		pci_read_config_dword(pdev, PCIE_PL_IATU_VIEWPORT, &val);
+		val &= ~PCIE_PL_IATU_REGION_IDX;
+		/* Inbound, region0 */
+		val |= PCIE_PL_IATU_REGION_INBOUND |
+			SM(PCIE_PL_IATU_REGION0, PCIE_PL_IATU_REGION_IDX);
+		pci_write_config_dword(pdev, PCIE_PL_IATU_VIEWPORT, val);
+		break;
+	case 1:
+	default:
+		pci_read_config_dword(pdev, PCIE_PL_IATU_VIEWPORT, &val);
+		val &= ~PCIE_PL_IATU_REGION_IDX;
+		/* Outbound, region1 */
+		val &= ~PCIE_PL_IATU_REGION_INBOUND;
+		val |= SM(PCIE_PL_IATU_REGION0, PCIE_PL_IATU_REGION_IDX);
+		pci_write_config_dword(pdev, PCIE_PL_IATU_VIEWPORT, val);
+		break;
+	}
+	pr_info("iATU %s\n", outbound ? "Outbound" : "Inbound");
+	pci_read_config_dword(pdev, PCIE_PL_IATU_VIEWPORT, &val);
+	pr_info("PCIE_PL_IATU_VIEWPORT: %08x\n", val);
+	pci_read_config_dword(pdev, PCIE_PL_IATU_REGION_LOWER_BASE_ADDR, &val);
+	pr_info("PCIE_PL_IATU_REGION_LOWER_BASE_ADDR: %08x\n", val);
+	pci_read_config_dword(pdev, PCIE_PL_IATU_REGION_UPPER_BASE_ADDR, &val);
+	pr_info("PCIE_PL_IATU_REGION_UPPER_BASE_ADDR: %08x\n", val);
+	pci_read_config_dword(pdev, PCIE_PL_IATU_REGION_LIMIT, &val);
+	pr_info("PCIE_PL_IATU_REGION_LIMIT: %08x\n", val);
+	pci_read_config_dword(pdev, PCIE_PL_IATU_REGION_LOWER_TARGET_ADDR,
+			&val);
+	pr_info("PCIE_PL_IATU_REGION_LOWER_TARGET_ADDR: %08x\n", val);
+	pci_read_config_dword(pdev, PCIE_PL_IATU_REGION_UPPER_TARGET_ADDR,
+			&val);
+	pr_info("PCIE_PL_IATU_REGION_UPPER_TARGET_ADDR: %08x\n", val);
+	pci_read_config_dword(pdev, PCIE_PL_IATU_REGION_CTRL1, &val);
+	pr_info("PCIE_PL_IATU_REGION_CTRL1: %08x\n", val);
+	pci_read_config_dword(pdev, PCIE_PL_IATU_REGION_CTRL2, &val);
+	pr_info("PCIE_PL_IATU_REGION_CTRL2: %08x\n", val);
+}
+#endif /* LTQ_EP_DBG */
+
+/**
+ * \fn  static void  ltq_pcie_iatu_setup(struct pci_dev *pdev)
+ *
+ * \brief  This function configures smartPHY PCIe EP inbound address
+ *         translation iATU0 and Outbound address translation <iATU1>.
+ *         Detailed information, please refer to related design
+ *         documentation.
+ *
+ * \param  dev      PCI device to configure
+ * \return none
+ *
+ * \ingroup IFX_PCIE_EP_VRX320_INTERNAL
+ */
+static void ltq_pcie_iatu_setup(struct pci_dev *pdev)
+{
+	u32 val;
+
+	/* Inbound iATU0 */
+	pci_read_config_dword(pdev, PCIE_PL_IATU_VIEWPORT, &val);
+	val &= ~PCIE_PL_IATU_REGION_IDX;
+	/* Inbound, region0 */
+	val |= PCIE_PL_IATU_REGION_INBOUND | SM(PCIE_PL_IATU_REGION0,
+		PCIE_PL_IATU_REGION_IDX);
+	pci_write_config_dword(pdev, PCIE_PL_IATU_VIEWPORT, val);
+
+	/* BAR match used, there is no need to configure
+	 * base and limit register
+	 */
+	pci_write_config_dword(pdev, PCIE_PL_IATU_REGION_LOWER_TARGET_ADDR,
+		(u32) PCIE_EP_INBOUND_INTERNAL_BASE);
+
+	pci_write_config_dword(pdev, PCIE_PL_IATU_REGION_UPPER_TARGET_ADDR, 0);
+
+	pci_write_config_dword(pdev, PCIE_PL_IATU_REGION_CTRL1, 0);
+	/* Inbound BAR match, BAR0 used only */
+	val = PCIE_PL_IATU_REGION_MATCH_EN | PCIE_PL_IATU_REGION_EN |
+		SM(PCIE_PL_IATU_REGION_BAR0, PCIE_PL_IATU_REGION_BAR);
+	pci_write_config_dword(pdev, PCIE_PL_IATU_REGION_CTRL2, val);
+
+	/* Outbound iATU1 */
+	pci_read_config_dword(pdev, PCIE_PL_IATU_VIEWPORT, &val);
+	val &= ~PCIE_PL_IATU_REGION_IDX;
+	/* Outbound, region0 */
+	val &= ~PCIE_PL_IATU_REGION_INBOUND;
+	val |= SM(PCIE_PL_IATU_REGION0, PCIE_PL_IATU_REGION_IDX);
+	pci_write_config_dword(pdev, PCIE_PL_IATU_VIEWPORT, val);
+
+	/* 32 bit only, base address  */
+	pci_write_config_dword(pdev, PCIE_PL_IATU_REGION_LOWER_BASE_ADDR,
+		(u32) PCIE_EP_OUTBOUND_INTERNAL_BASE);
+	pci_write_config_dword(pdev, PCIE_PL_IATU_REGION_UPPER_BASE_ADDR,
+		0);
+
+	/* Region limit from phymem to phymem + memsize -1 */
+	pci_write_config_dword(pdev, PCIE_PL_IATU_REGION_LIMIT,
+		(u32) PCIE_EP_OUTBOUND_INTERNAL_BASE +
+		PCIE_EP_OUTBOUND_MEMSIZE - 1);
+
+	/* Mapped to 0x00000000 ~ 0x7FFFFFFF, total 2GB */
+	pci_write_config_dword(pdev, PCIE_PL_IATU_REGION_LOWER_TARGET_ADDR, 0);
+
+	pci_write_config_dword(pdev, PCIE_PL_IATU_REGION_UPPER_TARGET_ADDR, 0);
+
+	pci_write_config_dword(pdev, PCIE_PL_IATU_REGION_CTRL1, 0);
+	/* Outbound, address match */
+	val = PCIE_PL_IATU_REGION_EN;
+	pci_write_config_dword(pdev, PCIE_PL_IATU_REGION_CTRL2, val);
+
+#ifdef LTQ_EP_DBG
+	ltq_pcie_iatu_dump(pdev, 0); /* Inbound */
+	ltq_pcie_iatu_dump(pdev, 1); /* Outbound */
+#endif /* LTQ_EP_DBG */
+}
+
+/**
+ * \fn  static int ltq_pcie_probe(struct pci_dev *pdev,
+ *	const struct pci_device_id *id)
+ *
+ * \brief This function initializes an adapter identified by
+ *	  a pci_dev structure. The OS initialization, configuring
+ *	  of the adapter private structure.
+ *
+ * \param  pdev     PCI device information struct
+ * \param  id       entry in ltq_pcie_id_table
+ * \return 0        OK
+ * \return -ENODEV  Failed to initialize an adapter identified by pci_dev
+ *
+ * \ingroup IFX_PCIE_EP_VRX320_OS
+ */
+static int
+ltq_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	int i;
+	int j;
+	int k;
+	unsigned long phymem;
+	void __iomem *mem;
+	size_t memsize;
+	static int cards_found;
+	int nvec, err;
+	struct pcie_ep_adapter *adapter;
+	struct pci_bus *bus;
+	int peer_num;
+	u32 reg;
+
+	bus = pdev->bus;
+
+	err = pci_enable_device(pdev);
+	if (err)
+		return err;
+
+	/* XXX 32-bit addressing only */
+	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {
+		pr_err("%s: 32-bit DMA not available\n",
+			__func__);
+		err = -ENODEV;
+		goto bad;
+	}
+
+	pci_set_master(pdev);
+
+	/* Physical address */
+	phymem = pci_resource_start(pdev, 0); /* BAR zero */
+	memsize = pci_resource_len(pdev, 0);
+	if (!request_mem_region(phymem, memsize, ltq_pcie_driver_name)) {
+		pr_err("%s: cannot reserve PCI memory region\n",
+			__func__);
+		err = -ENOMEM;
+		goto bad;
+	}
+
+	/* Virtual address */
+	mem = ioremap_nocache(phymem, memsize);
+	if (!mem) {
+		pr_err("%s: cannot remap PCI memory region\n",
+			__func__);
+		err = -ENOMEM;
+		goto bad1;
+	}
+
+	adapter = kmalloc(sizeof(struct pcie_ep_adapter), GFP_KERNEL);
+	if (adapter == NULL) {
+		err = -ENOMEM;
+		goto err_mem;
+	}
+
+	pci_set_drvdata(pdev, adapter);
+
+	err = pci_msi_max_vector_get(pdev, &nvec);
+	if (err) {
+		pr_err("%s: device doesn't support MSI, error code: %d",
+			__func__, err);
+		goto err_msi;
+	}
+
+	/* Overwrite maximum vector number according to
+	 * the specific requirement
+	 */
+	if (nvec > PCIE_EP_DEFAULT_MSI_VECTOR)
+		nvec = PCIE_EP_DEFAULT_MSI_VECTOR;
+
+	pci_msi_max_vector_set(pdev, nvec);
+
+	/* err = pci_enable_msi_block(pdev, nvec); */ /*Puma(x86) native_setup_msi_irqs: Multiple MSI vectors only supported with interrupt remapping */
+	err = pci_enable_msi(pdev); 
+	if (err) {
+		pr_err("%s: Failed to enable MSI interrupts for the device error code: %d\n",
+			__func__, err);
+		goto err_msi;
+	}
+
+	pci_msi_max_vector_set(pdev, nvec);
+
+	/* Enough information to configure address translation */
+	ltq_pcie_iatu_setup(pdev);
+
+	adapter->pdev = pdev;
+	adapter->device_id = pdev->device;
+	adapter->mem = mem;
+	adapter->phy_mem = phymem;
+	adapter->memsize = memsize;
+	adapter->msi_nvec = nvec;
+	adapter->irq_base = pdev->irq;
+	adapter->card_num = cards_found++; /* Logical index */
+	/* EMI control stuff */
+	reg = ltq_vrx320_r32(adapter->mem + PCIE_EP_IF_CLK);
+	reg |= PCIE_EP_IF_CLK_NO_36MHZ_CLKOUT;
+	ltq_vrx320_w32(reg, adapter->mem + PCIE_EP_IF_CLK);
+
+	reg = ltq_vrx320_r32(adapter->mem + PCIE_EP_P0_ALTSEL1);
+	reg &= ~PCIE_EP_P0_ALTSEL1_PIN1_SET;
+	ltq_vrx320_w32(reg, adapter->mem + PCIE_EP_P0_ALTSEL1);
+
+	spin_lock(&pcie_ep_lock);
+	g_pcie_ep_info.dev_num = cards_found; /* Existing cards */
+	atomic_set(&g_pcie_ep_info.pcie_ep[adapter->card_num].refcnt, 0);
+	g_pcie_ep_info.pcie_ep[adapter->card_num].card_idx =
+		adapter->card_num;
+	g_pcie_ep_info.pcie_ep[adapter->card_num].membase = adapter->mem;
+	g_pcie_ep_info.pcie_ep[adapter->card_num].phy_membase =
+		adapter->phy_mem;
+	g_pcie_ep_info.pcie_ep[adapter->card_num].memsize =
+		adapter->memsize;
+	g_pcie_ep_info.pcie_ep[adapter->card_num].irq_base =
+		adapter->irq_base;
+	g_pcie_ep_info.pcie_ep[adapter->card_num].irq_num =
+		adapter->msi_nvec;
+
+	/* More cards supported, exchange address information
+	 * For example, suppose three cards dected.
+	 * 0, <1, 2>
+	 * 1, <0, 2>
+	 * 2, <0, 1>
+	 * For four cards detected
+	 * 0, <1, 2, 3>
+	 * 1, <0, 2, 3>
+	 * 2, <0, 1, 3>
+	 * 3, <0, 1, 2>
+	 * and etc
+	 */
+	if (cards_found > 1) {
+		peer_num = cards_found - 1;
+		for (i = 0; i < cards_found; i++) {
+			j = 0;
+			k = 0;
+			g_pcie_ep_info.pcie_ep[i].peer_num = peer_num;
+			do {
+				if (j == i) {
+					j++;
+					continue;
+				}
+				g_pcie_ep_info.pcie_ep[i].peer_membase[k] =
+					g_pcie_ep_info.pcie_ep[j].membase;
+				g_pcie_ep_info.pcie_ep[i].peer_phy_membase[k] =
+					g_pcie_ep_info.pcie_ep[j].phy_membase;
+				g_pcie_ep_info.pcie_ep[i].peer_memsize[k] =
+					g_pcie_ep_info.pcie_ep[j].memsize;
+				k++;
+				j++;
+			} while ((k < peer_num) && (j < cards_found));
+		}
+	}
+	spin_unlock(&pcie_ep_lock);
+
+/* for device tree create a device there */
+#ifndef CONFIG_OF
+	adapter->mei_dev = platform_device_register_data(&pdev->dev, "mei_cpe",
+							 PLATFORM_DEVID_AUTO,
+							 NULL, 0);
+	if (IS_ERR(adapter->mei_dev)) {
+		dev_err(&pdev->dev, "can not register mei device, err: %li, ignore this\n",
+			PTR_ERR(adapter->mei_dev));
+		err = PTR_ERR(adapter->mei_dev);
+		goto err_msi;
+	}
+#endif
+
+#ifdef LTQ_EP_DBG
+	pr_info("Total cards found %d\n", cards_found);
+	/* Dump detailed debug information */
+	for (i = 0; i < cards_found; i++) {
+		pr_info("card %d attached\n",
+			g_pcie_ep_info.pcie_ep[i].card_idx);
+		pr_info("irq base %d irq numbers %d\n",
+			g_pcie_ep_info.pcie_ep[i].irq_base,
+			g_pcie_ep_info.pcie_ep[i].irq_num);
+		pr_info("its own phy membase  0x%08x virtual membase 0x%p size 0x%08x\n",
+			g_pcie_ep_info.pcie_ep[i].phy_membase,
+			g_pcie_ep_info.pcie_ep[i].membase,
+			g_pcie_ep_info.pcie_ep[i].memsize);
+		if (cards_found > 1) {
+			for (j = 0; j < g_pcie_ep_info.pcie_ep[i].peer_num;
+				j++)
+				pr_info("its peer phy membase 0x%08x virtual membase 0x%p size 0x%08x\n",
+				g_pcie_ep_info.pcie_ep[i].peer_phy_membase[j],
+				g_pcie_ep_info.pcie_ep[i].peer_membase[j],
+				g_pcie_ep_info.pcie_ep[i].peer_memsize[j]);
+		}
+	}
+#endif /* LTQ_EP_DBG */
+	return 0;
+err_msi:
+	kfree(adapter);
+err_mem:
+	iounmap(mem);
+bad1:
+	release_mem_region(phymem, memsize);
+bad:
+	pci_disable_device(pdev);
+	return err;
+}
+
+/**
+ * \fn  static void ltq_pcie_remove(struct pci_dev *pdev)
+ *
+ * \brief  This function is called by the PCI subsystem to alert the driver
+ *         that it should release a PCI device because the driver is going
+ *         to be removed from memory.
+ *
+ * \param  pdev     PCI device information struct
+ * \return none
+ *
+ * \ingroup IFX_PCIE_EP_VRX320_OS
+ */
+static void ltq_pcie_remove(struct pci_dev *pdev)
+{
+	struct pcie_ep_adapter *adapter =
+		(struct pcie_ep_adapter *) pci_get_drvdata(pdev);
+
+#ifndef CONFIG_OF
+	platform_device_unregister(adapter->mei_dev);
+#endif
+
+	if (atomic_read(&g_pcie_ep_info.pcie_ep[adapter->card_num].refcnt)
+		!= 0) {
+		pr_err("%s still being used, can't remove\n",
+			__func__);
+	}
+
+	iounmap(adapter->mem);
+	release_mem_region(adapter->phy_mem, adapter->memsize);
+	pci_disable_msi(pdev);
+	pci_disable_device(pdev);
+	kfree(adapter);
+	adapter = NULL;
+}
+
+MODULE_DEVICE_TABLE(pci, ltq_pcie_id_table);
+
+static struct pci_driver ltq_pcie_driver = {
+	.name = (char *) ltq_pcie_driver_name,
+	.id_table = ltq_pcie_id_table,
+	.probe = ltq_pcie_probe,
+	.remove = ltq_pcie_remove,
+	/* PM not supported */
+	/* AER is controlled by RC */
+};
+
+/**
+ * \fn  static int __init init_ltq_pcie(void)
+ *
+ * \brief  This function registered PCIe EP device driver with OS PCI subsystem
+ *         and initializes PCIe EP address mapping driver.
+ *
+ * \return 0 on success
+ * \return -ENODEV No related PCIe EP found
+ *
+ * \ingroup IFX_PCIE_EP_VRX320_OS
+ */
+static int __init init_ltq_pcie(void)
+{
+	memset(&g_pcie_ep_info, 0, sizeof(struct pcie_ep_info));
+
+	if (pci_register_driver(&ltq_pcie_driver) < 0) {
+		pr_err("%s: No devices found, driver not installed.\n",
+			__func__);
+		return -ENODEV;
+	}
+	pr_info("Lantiq VRX320 Version %s", vrx320_driver_version);
+	return 0;
+}
+
+module_init(init_ltq_pcie);
+
+/**
+ * \fn  static void __exit exit_ltq_pcie(void)
+ *
+ * \brief  This function unregister PCIe EP device driver with OS PCI subsystem
+ *
+ * \return none
+ *
+ * \ingroup IFX_PCIE_EP_VRX320_OS
+ */
+static void __exit exit_ltq_pcie(void)
+{
+	pci_unregister_driver(&ltq_pcie_driver);
+
+	pr_info("%s: %s driver unloaded\n", __func__,
+		ltq_pcie_driver_name);
+}
+
+module_exit(exit_ltq_pcie);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Chuanhua.Lei@lantiq.com");
+MODULE_SUPPORTED_DEVICE("Lantiq SmartPHY PCIe EP");
+MODULE_DESCRIPTION("Lantiq SmartPHY PCIe EP address mapping driver");
+
+
diff --git a/drivers/net/ethernet/lantiq/ltq_vrx320.h b/drivers/net/ethernet/lantiq/ltq_vrx320.h
new file mode 100644
index 0000000..feff3bf
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ltq_vrx320.h
@@ -0,0 +1,157 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2011~2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+ /*!
+ \file ltq_vrx320.h
+ \ingroup VRX320
+ \brief header file for SmartPHY PCIe EP address mapping driver internal
+  definition
+*/
+#ifndef LTQ_VRX320_H
+#define LTQ_VRX320_H
+
+#include <linux/types.h>
+#include <linux/pci.h>
+
+#include "lantiq_pcie.h"
+
+#define IFX_PCIE_EP_MAX_NUM                    (IFX_PCIE_EP_MAX_PEER + 1)
+
+/* Maximum 4, if PCIe switch attached, 2 is used. 2 is also default one */
+#ifdef CONFIG_LANITQ_VRX320_PCIE_SWITCH_DSL_BONDING
+#define PCIE_EP_DEFAULT_MSI_VECTOR         2
+#else
+#define PCIE_EP_DEFAULT_MSI_VECTOR         4
+#endif /*  CONFIG_LANITQ_VRX320_PCIE_SWITCH_DSL_BONDING */
+
+#define PCIE_EP_MAX_REFCNT                 IFX_PCIE_EP_INT_MODULE_MAX
+
+/* iATU specific register offset definition */
+
+/* View Point Register */
+#define PCIE_PL_IATU_VIEWPORT                  0x900
+
+#define PCIE_PL_IATU_REGION_IDX                0x0000000F
+#define PCIE_PL_IATU_REGION_IDX_S              0
+
+/* Inbound and outbound has seperate regions,
+ * each one has 8 regions from index 0
+ */
+enum {
+	PCIE_PL_IATU_REGION0 = 0,
+	PCIE_PL_IATU_REGION1,
+	PCIE_PL_IATU_REGION2,
+	PCIE_PL_IATU_REGION3,
+	PCIE_PL_IATU_REGION4,
+	PCIE_PL_IATU_REGION5,
+	PCIE_PL_IATU_REGION6,
+	PCIE_PL_IATU_REGION7,
+};
+#define PCIE_PL_IATU_REGION_INBOUND            0x80000000
+
+/* Region control registe for all kinds of types */
+#define PCIE_PL_IATU_REGION_CTRL1              0x904
+
+#define PCIE_PL_IATU_REGION_CTRL2              0x908
+#define PCIE_PL_IATU_REGION_BAR                0x00000700
+#define PCIE_PL_IATU_REGION_BAR_S              8
+
+enum {
+	PCIE_PL_IATU_REGION_BAR0 = 0,
+	PCIE_PL_IATU_REGION_BAR1,
+	PCIE_PL_IATU_REGION_BAR2,
+	PCIE_PL_IATU_REGION_BAR3,
+	PCIE_PL_IATU_REGION_BAR4,
+	PCIE_PL_IATU_REGION_BAR5,
+};
+#define PCIE_PL_IATU_REGION_MATCH_EN           0x40000000
+#define PCIE_PL_IATU_REGION_EN                 0x80000000
+
+#define PCIE_PL_IATU_REGION_LOWER_BASE_ADDR    0x90C
+#define PCIE_PL_IATU_REGION_UPPER_BASE_ADDR    0x910
+#define PCIE_PL_IATU_REGION_LIMIT              0x914
+#define PCIE_PL_IATU_REGION_LOWER_TARGET_ADDR  0x918
+#define PCIE_PL_IATU_REGION_UPPER_TARGET_ADDR  0x91C
+
+/* Target & Base address definition for Inbound/Outbound */
+
+/* Inbound address translation for iATU0 */
+#define PCIE_EP_INBOUND_INTERNAL_BASE          0x1E000000
+#define PCIE_EP_OUTBOUND_INTERNAL_BASE         0x20000000
+#define PCIE_EP_OUTBOUND_MEMSIZE               0x80000000
+
+/* EMI control stuff */
+/* 36MHz clockout */
+#define PCIE_EP_IF_CLK                         0x00003024
+#define PCIE_EP_IF_CLK_NO_36MHZ_CLKOUT         0x00000400
+
+/* GPIO 1 Alternate1 Set/Clear */
+#define PCIE_EP_P0_ALTSEL1                     0x00102B20
+#define PCIE_EP_P0_ALTSEL1_PIN1_SET            0x00000002
+
+/* Structure used to extract attached EP detailed information for
+ * PPE/DSL_MEI driver/Bonding
+ */
+struct pcie_ep_dev_priv {
+	u32 card_idx; /*!< EP logical index, the first found one will be 0
+			regardless of RC physical index
+			*/
+	u32 irq_base; /*!< The first MSI interrupt number */
+	u32 irq_num; /*!< How many MSI interrupt supported */
+	u8 __iomem *membase;  /*!< The EP inbound memory base address
+				derived from BAR0, SoC virtual address
+				for PPE/DSL_MEI driver
+				*/
+	u32 phy_membase; /*!< The EP inbound memory base address
+				derived from BAR0, physical address for
+				PPE FW
+				*/
+	size_t memsize; /*!< The EP inbound memory window size */
+	u32 peer_num;  /*!< Bonding peer number available */
+	/*!< The bonding peer EP inbound memory base address derived from
+	 * its BAR0, SoC virtual address for PPE/DSL_MEI driver
+	 */
+
+	u8 __iomem *peer_membase[IFX_PCIE_EP_MAX_PEER];
+
+	/*!< The bonding peer EP inbound memory base address derived from
+	 * its BAR0, physical address for PPE FW
+	 */
+	u32 peer_phy_membase[IFX_PCIE_EP_MAX_PEER];
+
+	/*!< The bonding peer inbound memory window size */
+	size_t peer_memsize[IFX_PCIE_EP_MAX_PEER];
+	atomic_t refcnt; /*!< The EP mapping driver referenced times
+				by other modules
+				*/
+};
+
+struct pcie_ep_info {
+	int dev_num;
+	struct pcie_ep_dev_priv pcie_ep[IFX_PCIE_EP_MAX_NUM];
+};
+
+/* Card specific private data structure */
+struct pcie_ep_adapter {
+	/* OS defined structs */
+	struct pci_dev *pdev;
+	unsigned long phy_mem; /* Physical address */
+	u8 __iomem *mem;       /* Virtual address */
+	size_t memsize;
+	u32 card_num;          /* EP card index */
+	u32 rc_phy_idx;        /* Attached which RC */
+
+	/* PCI config space info */
+	u16 device_id;
+	u16 irq_base;          /* irq base for multiple MSI */
+	u32 msi_nvec;          /* MSI vector number supported */
+	struct platform_device *mei_dev; /* the mei driver */
+};
+
+#endif /* LTQ_VRX320_H */
+
+
diff --git a/drivers/net/ethernet/lantiq/ltq_wrapper.h b/drivers/net/ethernet/lantiq/ltq_wrapper.h
new file mode 100644
index 0000000..3d13ad5
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/ltq_wrapper.h
@@ -0,0 +1,28 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2010 John Crispin <blogic@openwrt.org>
+ *  Copyright (C) 2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+#ifndef _LTQ_WRAPPER_H__
+#define _LTQ_WRAPPER_H__
+
+#include <linux/irq.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+
+/* generic reg access functions */
+#define ltq_r32(reg)            __raw_readl(reg)
+#define ltq_w32(val, reg)       __raw_writel(val, reg)
+
+#define ltq_r16(reg)            __raw_readw(reg)
+#define ltq_w16(val, reg)       __raw_writew(val, reg)
+
+#define ltq_w32_mask(clear, set, reg)   \
+        ltq_w32((ltq_r32(reg) & ~(clear)) | (set), reg)
+#define ltq_r8(reg)             __raw_readb(reg)
+#define ltq_w8(val, reg)        __raw_writeb(val, reg)
+
+#endif
diff --git a/drivers/net/ethernet/lantiq/pcie-lantiq.h b/drivers/net/ethernet/lantiq/pcie-lantiq.h
new file mode 100644
index 0000000..43638b6
--- /dev/null
+++ b/drivers/net/ethernet/lantiq/pcie-lantiq.h
@@ -0,0 +1,1378 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ *
+ *  Copyright (C) 2009~2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
+ */
+#ifndef PCIE_LANTIQ_H
+#define PCIE_LANTIQ_H
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+
+//#include <lantiq.h>
+#include <linux/gpio.h>
+//#include <lantiq_soc.h>
+
+
+/*!
+ \defgroup PCIE  PCI Express bus driver module
+ \brief  PCI Express IP module support VRX200/ARX300/HN
+*/
+
+/*!
+ \defgroup PCIE_OS OS APIs
+ \ingroup PCIE
+ \brief PCIe bus driver OS interface functions
+*/
+
+/*!
+ \file pcie-lantiq.h
+ \ingroup PCIE
+ \brief header file for PCIe module common header file
+*/
+
+#define MS(_v, _f)  (((_v) & (_f)) >> _f##_S)
+#define SM(_v, _f)  (((_v) << _f##_S) & (_f))
+
+
+#define PCIE_MSG_MSI		0x00000001
+#define PCIE_MSG_ISR		0x00000002
+#define PCIE_MSG_FIXUP		0x00000004
+#define PCIE_MSG_READ_CFG	0x00000008
+#define PCIE_MSG_WRITE_CFG	0x00000010
+#define PCIE_MSG_CFG		(PCIE_MSG_READ_CFG | PCIE_MSG_WRITE_CFG)
+#define PCIE_MSG_REG		0x00000020
+#define PCIE_MSG_INIT		0x00000040
+#define PCIE_MSG_ERR		0x00000080
+#define PCIE_MSG_PHY		0x00000100
+#define PCIE_MSG_ANY		0x000001ff
+
+/* Debug option, more will be coming */
+
+/* #define LTQ_PCIE_DBG */
+
+/* Reuse kernel stuff, but we need to differentiate baseline
+ * error reporting and AEE */
+#ifdef CONFIG_PCIEAER
+#define LTQ_PCIE_BASIC_ERROR_INT
+#endif /* CONFIG_PCIEAER */
+
+/* XXX, should be only enabled after LTQ_PCIE_BASIC_ERROR_INT */
+#define LTQ_PCIE_AER_REPORT
+
+/* Always report fatal error */
+#define PCIE_KASSERT(exp, msg) do {	\
+	if (unlikely(!(exp))) {	\
+		printk msg;		\
+		BUG();			\
+	}				\
+} while (0)
+
+/* Port number definition */
+enum {
+	LTQ_PCIE_PORT0 = 0,
+	LTQ_PCIE_PORT1,
+	LTQ_PCIE_PORT2,
+};
+
+#if defined(LTQ_PCIE_DBG)
+#define pcie_dbg(_m, _fmt, args...) do {	\
+	if (g_pcie_debug_flag & (_m))		\
+		pcie_debug((_fmt), ##args);	\
+} while (0)
+
+#else
+#define pcie_dbg(_m, _fmt, args...)	do {} while (0)
+#endif
+
+#define MSI_IRQ_NUM    16
+
+enum {
+	PCIE_MSI_IDX0 = 0,
+	PCIE_MSI_IDX1,
+	PCIE_MSI_IDX2,
+	PCIE_MSI_IDX3,
+};
+
+/* Interrupt related stuff */
+#define PCIE_LEGACY_DISABLE		0
+#define PCIE_LEGACY_INTA		1
+#define PCIE_LEGACY_INTB		2
+#define PCIE_LEGACY_INTC		3
+#define PCIE_LEGACY_INTD		4
+#define PCIE_LEGACY_INT_MAX		PCIE_LEGACY_INTD
+
+#if 0
+/** Structure used to extract physical Root Complex index number,
+ * it is shared between RC and EP */
+struct ltq_pcie_controller {
+	/*!< PCI controller information used as system specific information */
+	struct pci_controller pcic;
+	spinlock_t lock; /*!< Per controller lock */
+	 /*!< RC specific, per host bus information,
+	  * port 0 -- RC 0, port 1 -- RC1 */
+	const u32 port;
+};
+#endif
+
+/* The structure will store mapping address to support multiple RC */
+struct pcie_addr_map {
+	const u32 cfg_base;
+	const u32 mem_base;
+	const u32 io_base;
+	const u32 mem_phy_base;
+	const u32 mem_phy_end;
+	const u32 io_phy_base;
+	const u32 io_phy_end;
+	const u32 app_logic_base;
+	const u32 rc_addr_base;
+	const u32 phy_base;
+};
+
+struct msi_irq_idx {
+	const int irq;
+	const int idx;
+};
+
+struct ltq_msi_pic {
+	volatile u32 pic_table[MSI_IRQ_NUM];
+	volatile u32 pic_endian; /* 0x40  */
+};
+
+struct msi_irq {
+	struct ltq_msi_pic * const msi_pic_p;
+	const u32 msi_phy_base;
+	const struct msi_irq_idx msi_irq_idx[MSI_IRQ_NUM];
+	spinlock_t msi_lock;
+	/*
+	 * Each bit in msi_free_irq_bitmask represents a MSI interrupt that is
+	 * in use.
+	 */
+	u16 msi_free_irq_bitmask;
+
+	/*
+	 * Each bit in msi_multiple_irq_bitmask tells that the device using
+	 * this bit in msi_free_irq_bitmask is also using the next bit. This
+	 * is used so we can disable all of the MSI interrupts when a device
+	 * uses multiple.
+	 */
+	u16 msi_multiple_irq_bitmask;
+};
+
+struct pcie_ir_irq {
+	const unsigned int irq;
+	const char name[16];
+};
+
+struct pcie_legacy_irq {
+	const u32 irq_bit;
+	const int irq;
+};
+
+struct pcie_irq {
+	struct pcie_ir_irq ir_irq;
+	struct pcie_legacy_irq legacy_irq[PCIE_LEGACY_INT_MAX];
+};
+
+#if 0
+struct ltq_pcie_port {
+	struct pcie_addr_map port_to_addr;
+	struct ltq_pcie_controller controller;
+	struct pcie_irq legacy_irqs;
+	struct msi_irq msi_irqs;
+	int rc_physical_port;
+};
+#endif
+
+
+/* Port number defined in platform specific file */
+
+#define PCIE_CFG_PORT_TO_BASE(X) (g_pcie_port_defs[(X)].port_to_addr.cfg_base)
+
+#define PCIE_MEM_PORT_TO_BASE(X) (g_pcie_port_defs[(X)].port_to_addr.mem_base)
+
+#define PCIE_IO_PORT_TO_BASE(X)  (g_pcie_port_defs[(X)].port_to_addr.io_base)
+
+#define PCIE_MEM_PHY_PORT_TO_BASE(X)	\
+	(g_pcie_port_defs[(X)].port_to_addr.mem_phy_base)
+
+#define PCIE_MEM_PHY_PORT_TO_END(X)	\
+	(g_pcie_port_defs[(X)].port_to_addr.mem_phy_end)
+
+#define PCIE_IO_PHY_PORT_TO_BASE(X)	\
+	(g_pcie_port_defs[(X)].port_to_addr.io_phy_base)
+
+#define PCIE_IO_PHY_PORT_TO_END(X)	\
+	(g_pcie_port_defs[(X)].port_to_addr.io_phy_end)
+
+#define PCIE_APP_PORT_TO_BASE(X)	\
+	(g_pcie_port_defs[(X)].port_to_addr.app_logic_base)
+
+#define PCIE_RC_PORT_TO_BASE(X)		\
+	(g_pcie_port_defs[(X)].port_to_addr.rc_addr_base)
+
+#define PCIE_PHY_PORT_TO_BASE(X)	\
+	(g_pcie_port_defs[(X)].port_to_addr.phy_base)
+
+/* PCIe Application Logic Register */
+/* RC Core Control Register */
+#define PCIE_RC_CCR(X)		(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x10)
+
+/* This should be enabled after initializing configuratin registers
+ * Also should check link status retraining bit
+ */
+/* Enable LTSSM to continue link establishment */
+#define PCIE_RC_CCR_LTSSM_ENABLE		0x00000001
+/* RC Core Debug Register */
+#define PCIE_RC_DR(X)		(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x14)
+
+#define PCIE_RC_DR_DLL_UP			0x00000001
+#define PCIE_RC_DR_CURRENT_POWER_STATE		0x0000000E
+#define PCIE_RC_DR_CURRENT_POWER_STATE_S	1
+#define PCIE_RC_DR_CURRENT_LTSSM_STATE		0x000001F0
+#define PCIE_RC_DR_CURRENT_LTSSM_STATE_S	4
+
+#define PCIE_RC_DR_PM_DEV_STATE			0x00000E00
+#define PCIE_RC_DR_PM_DEV_STATE_S		9
+
+#define PCIE_RC_DR_PM_ENABLED			0x00001000
+#define PCIE_RC_DR_PME_EVENT_ENABLED		0x00002000
+#define PCIE_RC_DR_AUX_POWER_ENABLED		0x00004000
+
+/* Current Power State Definition */
+enum {
+	PCIE_RC_DR_D0 = 0,
+	PCIE_RC_DR_D1, /* Not supported */
+	PCIE_RC_DR_D2, /* Not supported */
+	PCIE_RC_DR_D3,
+	PCIE_RC_DR_UN,
+};
+
+/* PHY Link Status Register */
+#define PCIE_PHY_SR(X)		(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x18)
+
+#define PCIE_PHY_SR_PHY_LINK_UP		0x00000001
+
+/* Electromechanical Control Register */
+#define PCIE_EM_CR(X)		(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x1C)
+
+#define PCIE_EM_CR_CARD_IS_PRESENT		0x00000001
+#define PCIE_EM_CR_MRL_OPEN			0x00000002
+#define PCIE_EM_CR_POWER_FAULT_SET		0x00000004
+#define PCIE_EM_CR_MRL_SENSOR_SET		0x00000008
+#define PCIE_EM_CR_PRESENT_DETECT_SET		0x00000010
+#define PCIE_EM_CR_CMD_CPL_INT_SET		0x00000020
+#define PCIE_EM_CR_SYS_INTERLOCK_SET		0x00000040
+#define PCIE_EM_CR_ATTENTION_BUTTON_SET		0x00000080
+
+/* Interrupt Status Register */
+#define PCIE_IR_SR(X)		(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x20)
+
+#define PCIE_IR_SR_PME_CAUSE_MSI		0x00000002
+#define PCIE_IR_SR_HP_PME_WAKE_GEN		0x00000004
+#define PCIE_IR_SR_HP_MSI			0x00000008
+#define PCIE_IR_SR_AHB_LU_ERR			0x00000030
+#define PCIE_IR_SR_AHB_LU_ERR_S			4
+#define PCIE_IR_SR_INT_MSG_NUM			0x00003E00
+#define PCIE_IR_SR_INT_MSG_NUM_S		9
+#define PCIE_IR_SR_AER_INT_MSG_NUM		0xF8000000
+#define PCIE_IR_SR_AER_INT_MSG_NUM_S		27
+
+/* Message Control Register */
+#define PCIE_MSG_CR(X)		(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x30)
+
+#define PCIE_MSG_CR_GEN_PME_TURN_OFF_MSG	0x00000001
+#define PCIE_MSG_CR_GEN_UNLOCK_MSG		0x00000002
+
+#define PCIE_VDM_DR(X)		(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x34)
+
+/* Vendor-Defined Message Requester ID Register */
+#define PCIE_VDM_RID(X)		(PCIE_APP_PORT_TO_BASE(X) + 0x38)
+
+#define PCIE_VDM_RID_VENROR_MSG_REQ_ID		0x0000FFFF
+#define PCIE_VDM_RID_VDMRID_S			0
+
+/* ASPM Control Register */
+#define PCIE_ASPM_CR(X)		(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x40)
+
+#define PCIE_ASPM_CR_HOT_RST			0x00000001
+#define PCIE_ASPM_CR_REQ_EXIT_L1		0x00000002
+#define PCIE_ASPM_CR_REQ_ENTER_L1		0x00000004
+
+/* Vendor Message DW0 Register */
+#define PCIE_VM_MSG_DW0(X)	(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x50)
+
+#define PCIE_VM_MSG_DW0_TYPE		0x0000001F /* Message type */
+#define PCIE_VM_MSG_DW0_TYPE_S		0
+#define PCIE_VM_MSG_DW0_FORMAT		0x00000060 /* Format */
+#define PCIE_VM_MSG_DW0_FORMAT_S	5
+#define PCIE_VM_MSG_DW0_TC		0x00007000 /* Traffic Class */
+#define PCIE_VM_MSG_DW0_TC_S		12
+#define PCIE_VM_MSG_DW0_ATTR		0x000C0000 /* Atrributes */
+#define PCIE_VM_MSG_DW0_ATTR_S		18
+#define PCIE_VM_MSG_DW0_EP_TLP		0x00100000 /* Poisoned TLP */
+#define PCIE_VM_MSG_DW0_TD		0x00200000 /* TLP Digest */
+#define PCIE_VM_MSG_DW0_LEN		0xFFC00000 /* Length */
+#define PCIE_VM_MSG_DW0_LEN_S		22
+
+/* Format Definition */
+enum {
+	PCIE_VM_MSG_FORMAT_00 = 0, /* 3DW Hdr, no data */
+	PCIE_VM_MSG_FORMAT_01, /* 4DW Hdr, no data */
+	PCIE_VM_MSG_FORMAT_10, /* 3DW Hdr, with data */
+	PCIE_VM_MSG_FORMAT_11, /* 4DW Hdr, with data */
+};
+
+/* Traffic Class Definition */
+enum {
+	PCIE_VM_MSG_TC0 = 0,
+	PCIE_VM_MSG_TC1,
+	PCIE_VM_MSG_TC2,
+	PCIE_VM_MSG_TC3,
+	PCIE_VM_MSG_TC4,
+	PCIE_VM_MSG_TC5,
+	PCIE_VM_MSG_TC6,
+	PCIE_VM_MSG_TC7,
+};
+
+/* Attributes Definition */
+enum {
+	PCIE_VM_MSG_ATTR_00 = 0, /* RO and No Snoop cleared */
+	PCIE_VM_MSG_ATTR_01, /* RO cleared , No Snoop set */
+	PCIE_VM_MSG_ATTR_10, /* RO set, No Snoop cleared */
+	PCIE_VM_MSG_ATTR_11, /* RO and No Snoop set */
+};
+
+/* Payload Size Definition */
+#define PCIE_VM_MSG_LEN_MIN		0
+#define PCIE_VM_MSG_LEN_MAX		1024
+
+/* Vendor Message DW1 Register */
+#define PCIE_VM_MSG_DW1(X)	(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x54)
+
+#define PCIE_VM_MSG_DW1_FUNC_NUM	0x00000070 /* Function Number */
+#define PCIE_VM_MSG_DW1_FUNC_NUM_S	8
+#define PCIE_VM_MSG_DW1_CODE		0x00FF0000 /* Message Code */
+#define PCIE_VM_MSG_DW1_CODE_S		16
+#define PCIE_VM_MSG_DW1_TAG		0xFF000000 /* Tag */
+#define PCIE_VM_MSG_DW1_TAG_S		24
+
+#define PCIE_VM_MSG_DW2(X)	(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x58)
+
+#define PCIE_VM_MSG_DW3(X)	(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x5C)
+
+/* Vendor Message Request Register */
+#define PCIE_VM_MSG_REQR(X)	(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x60)
+
+#define PCIE_VM_MSG_REQR_REQ		0x00000001
+
+
+/* AHB Slave Side Band Control Register */
+#define PCIE_AHB_SSB(X)		(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x70)
+
+#define PCIE_AHB_SSB_REQ_BCM		0x00000001
+#define PCIE_AHB_SSB_REQ_EP		0x00000002
+#define PCIE_AHB_SSB_REQ_TD		0x00000004
+#define PCIE_AHB_SSB_REQ_ATTR		0x00000018
+#define PCIE_AHB_SSB_REQ_ATTR_S		3
+#define PCIE_AHB_SSB_REQ_TC		0x000000E0
+#define PCIE_AHB_SSB_REQ_TC_S		5
+
+/* AHB Master SideBand Ctrl Register */
+#define PCIE_AHB_MSB(X)		(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x74)
+
+#define PCIE_AHB_MSB_RESP_ATTR		0x00000003
+#define PCIE_AHB_MSB_RESP_ATTR_S	0
+#define PCIE_AHB_MSB_RESP_BAD_EOT	0x00000004
+#define PCIE_AHB_MSB_RESP_BCM		0x00000008
+#define PCIE_AHB_MSB_RESP_EP		0x00000010
+#define PCIE_AHB_MSB_RESP_TD		0x00000020
+#define PCIE_AHB_MSB_RESP_FUN_NUM	0x000003C0
+#define PCIE_AHB_MSB_RESP_FUN_NUM_S	6
+
+/* AHB Control Register, fixed bus enumeration exception */
+#define PCIE_AHB_CTRL(X)	(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0x78)
+
+#define PCIE_AHB_CTRL_BUS_ERROR_SUPPRESS	0x00000001
+
+/* Interrupt Enalbe Register */
+#define PCIE_IRNEN(X)		(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0xF4)
+
+#define PCIE_IRNCR(X)		(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0xF8)
+
+#define PCIE_IRNICR(X)		(u32 *)(PCIE_APP_PORT_TO_BASE(X) + 0xFC)
+
+/* PCIe interrupt enable/control/capture register definition */
+#define PCIE_IRN_AER_REPORT		0x00000001
+#define PCIE_IRN_AER_MSIX		0x00000002
+#define PCIE_IRN_PME			0x00000004
+#define PCIE_IRN_HOTPLUG		0x00000008
+#define PCIE_IRN_RX_VDM_MSG		0x00000010
+#define PCIE_IRN_RX_CORRECTABLE_ERR_MSG	0x00000020
+#define PCIE_IRN_RX_NON_FATAL_ERR_MSG	0x00000040
+#define PCIE_IRN_RX_FATAL_ERR_MSG	0x00000080
+#define PCIE_IRN_RX_PME_MSG		0x00000100
+#define PCIE_IRN_RX_PME_TURNOFF_ACK	0x00000200
+#define PCIE_IRN_AHB_BR_FATAL_ERR	0x00000400
+#define PCIE_IRN_LINK_AUTO_BW_STATUS	0x00000800
+#define PCIE_IRN_BW_MGT			0x00001000
+#define PCIE_IRN_INTA			0x00002000 /* INTA */
+#define PCIE_IRN_INTB			0x00004000 /* INTB */
+#define PCIE_IRN_INTC			0x00008000 /* INTC */
+#define PCIE_IRN_INTD			0x00010000 /* INTD */
+#define PCIE_IRN_WAKEUP			0x00020000 /* Wake up Interrupt */
+
+#define PCIE_RC_CORE_COMBINED_INT  (PCIE_IRN_AER_REPORT | PCIE_IRN_AER_MSIX \
+		| PCIE_IRN_PME | PCIE_IRN_HOTPLUG | PCIE_IRN_RX_VDM_MSG \
+		| PCIE_IRN_RX_CORRECTABLE_ERR_MSG \
+		| PCIE_IRN_RX_NON_FATAL_ERR_MSG | PCIE_IRN_RX_FATAL_ERR_MSG \
+		| PCIE_IRN_RX_PME_MSG | PCIE_IRN_RX_PME_TURNOFF_ACK \
+		| PCIE_IRN_AHB_BR_FATAL_ERR | PCIE_IRN_LINK_AUTO_BW_STATUS\
+		| PCIE_IRN_BW_MGT)
+
+/* PCIe RC Configuration Register */
+#define PCIE_VDID(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x00)
+
+/* Bit definition from pci_reg.h */
+#define PCIE_PCICMDSTS(X)	(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x04)
+#define PCIE_CCRID(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x08)
+
+#define PCIE_CLSLTHTBR(X)	(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x0C)
+
+/* BAR0, BAR1,Only necessary if the bridges implements a device-specific
+   register set or memory buffer */
+#define PCIE_BAR0(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x10)
+
+#define PCIE_BAR1(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x14)
+
+#define PCIE_BNR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x18)
+/* Bus Number Register bits */
+#define PCIE_BNR_PRIMARY_BUS_NUM	0x000000FF
+#define PCIE_BNR_PRIMARY_BUS_NUM_S	0
+#define PCIE_PNR_SECONDARY_BUS_NUM	0x0000FF00
+#define PCIE_PNR_SECONDARY_BUS_NUM_S	8
+#define PCIE_PNR_SUB_BUS_NUM	0x00FF0000
+#define PCIE_PNR_SUB_BUS_NUM_S	16
+
+/* IO Base/Limit Register bits */
+#define PCIE_IOBLSECS(X)	(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x1C)
+
+#define PCIE_IOBLSECS_32BIT_IO_ADDR	0x00000001
+#define PCIE_IOBLSECS_IO_BASE_ADDR	0x000000F0
+#define PCIE_IOBLSECS_IO_BASE_ADDR_S	4
+#define PCIE_IOBLSECS_32BIT_IOLIMT	0x00000100
+#define PCIE_IOBLSECS_IO_LIMIT_ADDR	0x0000F000
+#define PCIE_IOBLSECS_IO_LIMIT_ADDR_S	12
+
+/* Non-prefetchable Memory Base/Limit Register bit */
+#define PCIE_MBML(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x20)
+
+#define PCIE_MBML_MEM_BASE_ADDR		0x0000FFF0
+#define PCIE_MBML_MEM_BASE_ADDR_S	4
+#define PCIE_MBML_MEM_LIMIT_ADDR	0xFFF00000
+#define PCIE_MBML_MEM_LIMIT_ADDR_S	20
+
+/* Prefetchable Memory Base/Limit Register bit */
+#define PCIE_PMBL(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x24)
+#define PCIE_PMBL_64BIT_ADDR		0x00000001
+#define PCIE_PMBL_UPPER_12BIT		0x0000FFF0
+#define PCIE_PMBL_UPPER_12BIT_S		4
+#define PCIE_PMBL_E64MA			0x00010000
+#define PCIE_PMBL_END_ADDR		0xFFF00000
+#define PCIE_PMBL_END_ADDR_S		20
+
+#define PCIE_PMBU32(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x28)
+
+#define PCIE_PMLU32(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x2C)
+
+/* I/O Base/Limit Upper 16 bits register */
+#define PCIE_IO_BANDL(X)	(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x30)
+
+#define PCIE_IO_BANDL_UPPER_16BIT_IO_BASE	0x0000FFFF
+#define PCIE_IO_BANDL_UPPER_16BIT_IO_BASE_S	0
+#define PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT	0xFFFF0000
+#define PCIE_IO_BANDL_UPPER_16BIT_IO_LIMIT_S	16
+
+#define PCIE_CPR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x34)
+
+#define PCIE_EBBAR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x38)
+
+/* Interrupt and Secondary Bridge Control Register */
+#define PCIE_INTRBCTRL(X)	(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x3C)
+
+#define PCIE_INTRBCTRL_INT_LINE			0x000000FF
+#define PCIE_INTRBCTRL_INT_LINE_S		0
+#define PCIE_INTRBCTRL_INT_PIN			0x0000FF00
+#define PCIE_INTRBCTRL_INT_PIN_S		8
+#define PCIE_INTRBCTRL_PARITY_ERR_RESP_ENABLE	0x00010000
+#define PCIE_INTRBCTRL_SERR_ENABLE		0x00020000
+#define PCIE_INTRBCTRL_ISA_ENABLE		0x00040000
+#define PCIE_INTRBCTRL_VGA_ENABLE		0x00080000
+#define PCIE_INTRBCTRL_VGA_16BIT_DECODE		0x00100000
+#define PCIE_INTRBCTRL_RST_SECONDARY_BUS	0x00400000
+/* Others are read only */
+enum {
+	PCIE_INTRBCTRL_INT_NON = 0,
+	PCIE_INTRBCTRL_INTA,
+	PCIE_INTRBCTRL_INTB,
+	PCIE_INTRBCTRL_INTC,
+	PCIE_INTRBCTRL_INTD,
+};
+
+#define PCIE_PM_CAPR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x40)
+
+/* Power Management Control and Status Register */
+#define PCIE_PM_CSR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x44)
+
+#define PCIE_PM_CSR_POWER_STATE		0x00000003 /* Power State */
+#define PCIE_PM_CSR_POWER_STATE_S	0
+#define PCIE_PM_CSR_SW_RST		0x00000008 /* Soft Reset Enabled */
+#define PCIE_PM_CSR_PME_ENABLE		0x00000100 /* PME Enable */
+#define PCIE_PM_CSR_PME_STATUS		0x00008000 /* PME status */
+
+/* MSI Capability Register for EP */
+#define PCIE_MCAPR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x50)
+
+#define PCIE_MCAPR_MSI_CAP_ID		0x000000FF
+#define PCIE_MCAPR_MSI_CAP_ID_S		0
+#define PCIE_MCAPR_MSI_NEXT_CAP_PTR	0x0000FF00
+#define PCIE_MCAPR_MSI_NEXT_CAP_PTR_S	8
+#define PCIE_MCAPR_MSI_ENABLE		0x00010000
+#define PCIE_MCAPR_MULTI_MSG_CAP	0x000E0000
+#define PCIE_MCAPR_MULTI_MSG_CAP_S	17
+#define PCIE_MCAPR_MULTI_MSG_ENABLE	0x00700000
+#define PCIE_MCAPR_MULTI_MSG_ENABLE_S	20
+#define PCIE_MCAPR_ADDR64_CAP		0X00800000
+
+/* MSI Message Address Register */
+#define PCIE_MA(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x54)
+
+#define PCIE_MA_ADDR_MASK		0xFFFFFFFC /* Message Address */
+
+/* MSI Message Upper Address Register */
+#define PCIE_MUA(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x58)
+
+/* MSI Message Data Register */
+#define PCIE_MD(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x5C)
+
+#define PCIE_MD_DATA			0x0000FFFF /* Message Data */
+#define PCIE_MD_DATA_S			0
+
+/* PCI Express Capability Register */
+#define PCIE_XCAP(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x70)
+
+#define PCIE_XCAP_ID			0x000000FF
+#define PCIE_XCAP_ID_S			0
+#define PCIE_XCAP_NEXT_CAP		0x0000FF00
+#define PCIE_XCAP_NEXT_CAP_S		8
+#define PCIE_XCAP_VER			0x000F0000
+#define PCIE_XCAP_VER_S			16
+#define PCIE_XCAP_DEV_PORT_TYPE		0x00F00000
+#define PCIE_XCAP_DEV_PORT_TYPE_S	20
+#define PCIE_XCAP_SLOT_IMPLEMENTED	0x01000000
+#define PCIE_XCAP_MSG_INT_NUM		0x3E000000
+#define PCIE_XCAP_MSG_INT_NUM_S		25
+
+/* Device Capability Register */
+#define PCIE_DCAP(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x74)
+
+#define PCIE_DCAP_MAX_PAYLOAD_SIZE	0x00000007
+#define PCIE_DCAP_MAX_PAYLOAD_SIZE_S	0
+#define PCIE_DCAP_PHANTOM_FUNC		0x00000018
+#define PCIE_DCAP_PHANTOM_FUNC_S	3
+#define PCIE_DCAP_EXT_TAG		0x00000020
+#define PCIE_DCAP_EP_L0S_LATENCY	0x000001C0
+#define PCIE_DCAP_EP_L0S_LATENCY_S	6
+#define PCIE_DCAP_EP_L1_LATENCY		0x00000E00
+#define PCIE_DCAP_EP_L1_LATENCY_S	9
+#define PCIE_DCAP_ROLE_BASE_ERR_REPORT	0x00008000
+
+/* Maximum payload size supported */
+enum {
+	PCIE_MAX_PAYLOAD_128 = 0,
+	PCIE_MAX_PAYLOAD_256,
+	PCIE_MAX_PAYLOAD_512,
+	PCIE_MAX_PAYLOAD_1024,
+	PCIE_MAX_PAYLOAD_2048,
+	PCIE_MAX_PAYLOAD_4096,
+};
+
+/* Device Control and Status Register */
+#define PCIE_DCTLSTS(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x78)
+
+#define PCIE_DCTLSTS_CORRECTABLE_ERR_EN		0x00000001
+#define PCIE_DCTLSTS_NONFATAL_ERR_EN		0x00000002
+#define PCIE_DCTLSTS_FATAL_ERR_EN		0x00000004
+#define PCIE_DCTLSYS_UR_REQ_EN			0x00000008
+#define PCIE_DCTLSTS_RELAXED_ORDERING_EN	0x00000010
+#define PCIE_DCTLSTS_MAX_PAYLOAD_SIZE		0x000000E0
+#define PCIE_DCTLSTS_MAX_PAYLOAD_SIZE_S		5
+#define PCIE_DCTLSTS_EXT_TAG_EN			0x00000100
+#define PCIE_DCTLSTS_PHANTOM_FUNC_EN		0x00000200
+#define PCIE_DCTLSTS_AUX_PM_EN			0x00000400
+#define PCIE_DCTLSTS_NO_SNOOP_EN		0x00000800
+#define PCIE_DCTLSTS_MAX_READ_SIZE		0x00007000
+#define PCIE_DCTLSTS_MAX_READ_SIZE_S		12
+#define PCIE_DCTLSTS_CORRECTABLE_ERR		0x00010000
+#define PCIE_DCTLSTS_NONFATAL_ERR		0x00020000
+#define PCIE_DCTLSTS_FATAL_ER			0x00040000
+#define PCIE_DCTLSTS_UNSUPPORTED_REQ		0x00080000
+#define PCIE_DCTLSTS_AUX_POWER			0x00100000
+#define PCIE_DCTLSTS_TRANSACT_PENDING	0x00200000
+
+#define PCIE_DCTLSTS_ERR_EN	(PCIE_DCTLSTS_CORRECTABLE_ERR_EN | \
+		PCIE_DCTLSTS_NONFATAL_ERR_EN | PCIE_DCTLSTS_FATAL_ERR_EN \
+		| PCIE_DCTLSYS_UR_REQ_EN)
+
+/* Link Capability Register */
+#define PCIE_LCAP(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x7C)
+#define PCIE_LCAP_MAX_LINK_SPEED		0x0000000F
+#define PCIE_LCAP_MAX_LINK_SPEED_S		0
+#define PCIE_LCAP_MAX_LENGTH_WIDTH		0x000003F0
+#define PCIE_LCAP_MAX_LENGTH_WIDTH_S		4
+#define PCIE_LCAP_ASPM_LEVEL			0x00000C00
+#define PCIE_LCAP_ASPM_LEVEL_S			10
+#define PCIE_LCAP_L0S_EIXT_LATENCY		0x00007000
+#define PCIE_LCAP_L0S_EIXT_LATENCY_S		12
+#define PCIE_LCAP_L1_EXIT_LATENCY		0x00038000
+#define PCIE_LCAP_L1_EXIT_LATENCY_S		15
+#define PCIE_LCAP_CLK_PM			0x00040000
+#define PCIE_LCAP_SDER				0x00080000
+#define PCIE_LCAP_DLL_ACTIVE_REPROT		0x00100000
+#define PCIE_LCAP_PORT_NUM			0xFF000000
+#define PCIE_LCAP_PORT_NUM_S			24
+
+/* Maximum Length width definition */
+#define PCIE_MAX_LENGTH_WIDTH_RES		0x00
+#define PCIE_MAX_LENGTH_WIDTH_X1		0x01 /* Default */
+#define PCIE_MAX_LENGTH_WIDTH_X2		0x02
+#define PCIE_MAX_LENGTH_WIDTH_X4		0x04
+#define PCIE_MAX_LENGTH_WIDTH_X8		0x08
+#define PCIE_MAX_LENGTH_WIDTH_X12		0x0C
+#define PCIE_MAX_LENGTH_WIDTH_X16		0x10
+#define PCIE_MAX_LENGTH_WIDTH_X32		0x20
+
+/* Active State Link PM definition */
+enum {
+	PCIE_ASPM_RES0 = 0,
+	PCIE_ASPM_L0S_ENTRY_SUPPORT, /* L0s */
+	PCIE_ASPM_RES1,
+	PCIE_ASPM_L0S_L1_ENTRY_SUPPORT, /* L0s and L1, default */
+};
+
+/* L0s Exit Latency definition */
+enum {
+	PCIE_L0S_EIXT_LATENCY_L64NS = 0, /* < 64 ns */
+	PCIE_L0S_EIXT_LATENCY_B64A128,  /* > 64 ns < 128 ns */
+	PCIE_L0S_EIXT_LATENCY_B128A256, /* > 128 ns < 256 ns */
+	PCIE_L0S_EIXT_LATENCY_B256A512, /* > 256 ns < 512 ns */
+	PCIE_L0S_EIXT_LATENCY_B512TO1U, /* > 512 ns < 1 us */
+	PCIE_L0S_EIXT_LATENCY_B1A2U, /* > 1 us < 2 us */
+	PCIE_L0S_EIXT_LATENCY_B2A4U, /* > 2 us < 4 us */
+	PCIE_L0S_EIXT_LATENCY_M4US, /* > 4 us  */
+};
+
+/* L1 Exit Latency definition */
+enum {
+	PCIE_L1_EXIT_LATENCY_L1US = 0, /* < 1 us */
+	PCIE_L1_EXIT_LATENCY_B1A2,     /* > 1 us < 2 us */
+	PCIE_L1_EXIT_LATENCY_B2A4,     /* > 2 us < 4 us */
+	PCIE_L1_EXIT_LATENCY_B4A8,     /* > 4 us < 8 us */
+	PCIE_L1_EXIT_LATENCY_B8A16,    /* > 8 us < 16 us */
+	PCIE_L1_EXIT_LATENCY_B16A32,   /* > 16 us < 32 us */
+	PCIE_L1_EXIT_LATENCY_B32A64,   /* > 32 us < 64 us */
+	PCIE_L1_EXIT_LATENCY_M64US,    /* > 64 us */
+};
+
+/* Link Control and Status Register */
+#define PCIE_LCTLSTS(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x80)
+#define PCIE_LCTLSTS_ASPM_ENABLE		0x00000003
+#define PCIE_LCTLSTS_ASPM_ENABLE_S		0
+#define PCIE_LCTLSTS_RCB128			0x00000008
+#define PCIE_LCTLSTS_LINK_DISABLE		0x00000010
+#define PCIE_LCTLSTS_RETRIAN_LINK		0x00000020
+#define PCIE_LCTLSTS_COM_CLK_CFG		0x00000040
+#define PCIE_LCTLSTS_EXT_SYNC			0x00000080
+#define PCIE_LCTLSTS_CLK_PM_EN			0x00000100
+#define PCIE_LCTLSTS_LINK_SPEED			0x000F0000
+#define PCIE_LCTLSTS_LINK_SPEED_S		16
+#define PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH	0x03F00000
+#define PCIE_LCTLSTS_NEGOTIATED_LINK_WIDTH_S	20
+#define PCIE_LCTLSTS_RETRAIN_PENDING		0x08000000
+#define PCIE_LCTLSTS_SLOT_CLK_CFG		0x10000000
+#define PCIE_LCTLSTS_DLL_ACTIVE			0x20000000
+
+/* Slot Capabilities Register */
+#define PCIE_SLCAP(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x84)
+
+/* Slot Capabilities */
+#define PCIE_SLCTLSTS(X)	(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x88)
+
+/* Root Control and Capability Register */
+#define PCIE_RCTLCAP(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x8C)
+
+#define PCIE_RCTLCAP_SERR_ON_CORRECTABLE_ERR	0x00000001
+#define PCIE_RCTLCAP_SERR_ON_NONFATAL_ERR	0x00000002
+#define PCIE_RCTLCAP_SERR_ON_FATAL_ERR		0x00000004
+#define PCIE_RCTLCAP_PME_INT_EN	0x00000008
+#define PCIE_RCTLCAP_SERR_ENABLE	(PCIE_RCTLCAP_SERR_ON_CORRECTABLE_ERR \
+		| PCIE_RCTLCAP_SERR_ON_NONFATAL_ERR \
+		| PCIE_RCTLCAP_SERR_ON_FATAL_ERR)
+/* Root Status Register */
+#define PCIE_RSTS(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x90)
+
+#define PCIE_RSTS_PME_REQ_ID		0x0000FFFF
+#define PCIE_RSTS_PME_REQ_ID_S		0
+#define PCIE_RSTS_PME_STATUS		0x00010000
+#define PCIE_RSTS_PME_PENDING		0x00020000
+
+/* PCI Express Enhanced Capability Header */
+#define PCIE_ENHANCED_CAP(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x100)
+
+#define PCIE_ENHANCED_CAP_ID			0x0000FFFF
+#define PCIE_ENHANCED_CAP_ID_S			0
+#define PCIE_ENHANCED_CAP_VER			0x000F0000
+#define PCIE_ENHANCED_CAP_VER_S			16
+#define PCIE_ENHANCED_CAP_NEXT_OFFSET		0xFFF00000
+#define PCIE_ENHANCED_CAP_NEXT_OFFSET_S		20
+
+/* Uncorrectable Error Status Register */
+#define PCIE_UES_R(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x104)
+
+#define PCIE_DATA_LINK_PROTOCOL_ERR		0x00000010
+#define PCIE_SURPRISE_DOWN_ERROR		0x00000020
+#define PCIE_POISONED_TLP			0x00001000
+#define PCIE_FC_PROTOCOL_ERR			0x00002000
+#define PCIE_COMPLETION_TIMEOUT			0x00004000
+#define PCIE_COMPLETOR_ABORT			0x00008000
+#define PCIE_UNEXPECTED_COMPLETION		0x00010000
+#define PCIE_RECEIVER_OVERFLOW			0x00020000
+#define PCIE_MALFORNED_TLP			0x00040000
+#define PCIE_ECRC_ERR				0x00080000
+#define PCIE_UR_REQ				0x00100000
+#define PCIE_ALL_UNCORRECTABLE_ERR	(PCIE_DATA_LINK_PROTOCOL_ERR |\
+		PCIE_SURPRISE_DOWN_ERROR | PCIE_POISONED_TLP |\
+		PCIE_FC_PROTOCOL_ERR | PCIE_COMPLETION_TIMEOUT | \
+		PCIE_COMPLETOR_ABORT | PCIE_UNEXPECTED_COMPLETION |\
+		PCIE_RECEIVER_OVERFLOW | PCIE_MALFORNED_TLP | \
+		PCIE_ECRC_ERR | PCIE_UR_REQ)
+
+/* Uncorrectable Error Mask Register, Mask means no report */
+#define PCIE_UEMR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x108)
+
+/* Uncorrectable Error Severity Register */
+#define PCIE_UESR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x10C)
+
+/* Correctable Error Status Register */
+#define PCIE_CESR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x110)
+#define PCIE_RX_ERR			0x00000001
+#define PCIE_BAD_TLP			0x00000040
+#define PCIE_BAD_DLLP			0x00000080
+#define PCIE_REPLAY_NUM_ROLLOVER	0x00000100
+#define PCIE_REPLAY_TIMER_TIMEOUT_ERR	0x00001000
+#define PCIE_ADVISORY_NONFTAL_ERR	0x00002000
+#define PCIE_CORRECTABLE_ERR	(PCIE_RX_ERR | PCIE_BAD_TLP | PCIE_BAD_DLLP \
+		| PCIE_REPLAY_NUM_ROLLOVER | PCIE_REPLAY_TIMER_TIMEOUT_ERR\
+		| PCIE_ADVISORY_NONFTAL_ERR)
+
+/* Correctable Error Mask Register */
+#define PCIE_CEMR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x114)
+
+/* Advanced Error Capabilities and Control Register */
+#define PCIE_AECCR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x118)
+
+#define PCIE_AECCR_FIRST_ERR_PTR		0x0000001F
+#define PCIE_AECCR_FIRST_ERR_PTR_S		0
+#define PCIE_AECCR_ECRC_GEN_CAP			0x00000020
+#define PCIE_AECCR_ECRC_GEN_EN			0x00000040
+#define PCIE_AECCR_ECRC_CHECK_CAP		0x00000080
+#define PCIE_AECCR_ECRC_CHECK_EN		0x00000100
+
+/* Header Log Register 1 */
+#define PCIE_HLR1(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x11C)
+
+/* Header Log Register 2 */
+#define PCIE_HLR2(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x120)
+
+/* Header Log Register 3 */
+#define PCIE_HLR3(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x124)
+
+/* Header Log Register 4 */
+#define PCIE_HLR4(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x128)
+
+/* Root Error Command Register */
+#define PCIE_RECR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x12C)
+
+#define PCIE_RECR_CORRECTABLE_ERR_REPORT_EN	0x00000001 /* COR-ERR */
+#define PCIE_RECR_NONFATAL_ERR_REPORT_EN	0x00000002 /* Non-Fatal ERR */
+#define PCIE_RECR_FATAL_ERR_REPORT_EN		0x00000004 /* Fatal ERR */
+#define PCIE_RECR_ERR_REPORT_EN	(PCIE_RECR_CORRECTABLE_ERR_REPORT_EN\
+		| PCIE_RECR_NONFATAL_ERR_REPORT_EN |\
+		PCIE_RECR_FATAL_ERR_REPORT_EN)
+
+/* Root Error Status Register */
+#define PCIE_RESR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x130)
+
+#define PCIE_RESR_CORRECTABLE_ERR		0x00000001
+#define PCIE_RESR_MULTI_CORRECTABLE_ERR		0x00000002
+#define PCIE_RESR_FATAL_NOFATAL_ERR		0x00000004
+#define PCIE_RESR_MULTI_FATAL_NOFATAL_ERR	0x00000008
+#define PCIE_RESR_FIRST_UNCORRECTABLE_FATAL_ERR	0x00000010
+#define PCIR_RESR_NON_FATAL_ERR			0x00000020
+#define PCIE_RESR_FATAL_ERR			0x00000040
+#define PCIE_RESR_AER_INT_MSG_NUM		0xF8000000
+#define PCIE_RESR_AER_INT_MSG_NUM_S		27
+
+/* Error Source Indentification Register */
+#define PCIE_ESIR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x134)
+
+#define PCIE_ESIR_CORRECTABLE_ERR_SRC_ID	0x0000FFFF
+#define PCIE_ESIR_CORRECTABLE_ERR_SRC_ID_S	0
+#define PCIE_ESIR_FATAL_NON_FATAL_SRC_ID	0xFFFF0000
+#define PCIE_ESIR_FATAL_NON_FATAL_SRC_ID_S	16
+
+/* VC Enhanced Capability Header */
+#define PCIE_VC_ECH(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x140)
+
+/* Port VC Capability Register */
+#define PCIE_PVC1(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x144)
+
+#define PCIE_PVC1_EXT_VC_CNT			0x00000007
+#define PCIE_PVC1_EXT_VC_CNT_S			0
+#define PCIE_PVC1_LOW_PRI_EXT_VC_CNT		0x00000070
+#define PCIE_PVC1_LOW_PRI_EXT_VC_CNT_S		4
+#define PCIE_PVC1_REF_CLK			0x00000300
+#define PCIE_PVC1_REF_CLK_S			8
+#define PCIE_PVC1_PORT_ARB_TAB_ENTRY_SIZE	0x00000C00
+#define PCIE_PVC1_PORT_ARB_TAB_ENTRY_SIZE_S	10
+
+/* Extended Virtual Channel Count Defintion */
+#define PCIE_EXT_VC_CNT_MIN		0
+#define PCIE_EXT_VC_CNT_MAX		7
+
+/* Port Arbitration Table Entry Size Definition */
+enum {
+	PCIE_PORT_ARB_TAB_ENTRY_SIZE_S1BIT = 0,
+	PCIE_PORT_ARB_TAB_ENTRY_SIZE_S2BIT,
+	PCIE_PORT_ARB_TAB_ENTRY_SIZE_S4BIT,
+	PCIE_PORT_ARB_TAB_ENTRY_SIZE_S8BIT,
+};
+
+/* Port VC Capability Register 2 */
+#define PCIE_PVC2(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x148)
+
+#define PCIE_PVC2_VC_ARB_16P_FIXED_WRR		0x00000001
+#define PCIE_PVC2_VC_ARB_32P_WRR		0x00000002
+#define PCIE_PVC2_VC_ARB_64P_WRR		0x00000004
+#define PCIE_PVC2_VC_ARB_128P_WRR		0x00000008
+#define PCIE_PVC2_VC_ARB_WRR			0x0000000F
+#define PCIE_PVC2_VC_ARB_TAB_OFFSET		0xFF000000
+#define PCIE_PVC2_VC_ARB_TAB_OFFSET_S		24
+
+/* Port VC Control and Status Register */
+#define PCIE_PVCCRSR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x14C)
+
+#define PCIE_PVCCRSR_LOAD_VC_ARB_TAB		0x00000001
+#define PCIE_PVCCRSR_VC_ARB_SEL			0x0000000E
+#define PCIE_PVCCRSR_VC_ARB_SEL_S		1
+#define PCIE_PVCCRSR_VC_ARB_TAB_STATUS		0x00010000
+
+/* VC0 Resource Capability Register */
+#define PCIE_VC0_RC(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x150)
+
+#define PCIE_VC0_RC_PORT_ARB_HW_FIXED		0x00000001
+#define PCIE_VC0_RC_PORT_ARB_32P_WRR		0x00000002
+#define PCIE_VC0_RC_PORT_ARB_64P_WRR		0x00000004
+#define PCIE_VC0_RC_PORT_ARB_128P_WRR		0x00000008
+#define PCIE_VC0_RC_PORT_ARB_TM_128P_WRR	0x00000010
+#define PCIE_VC0_RC_PORT_ARB_TM_256P_WRR	0x00000020
+#define PCIE_VC0_RC_PORT_ARB	(PCIE_VC0_RC_PORT_ARB_HW_FIXED |\
+		PCIE_VC0_RC_PORT_ARB_32P_WRR | PCIE_VC0_RC_PORT_ARB_64P_WRR |\
+		PCIE_VC0_RC_PORT_ARB_128P_WRR |\
+		PCIE_VC0_RC_PORT_ARB_TM_128P_WRR |\
+		PCIE_VC0_RC_PORT_ARB_TM_256P_WRR)
+
+#define PCIE_VC0_RC_REJECT_SNOOP		0x00008000
+#define PCIE_VC0_RC_MAX_TIMESLOTS		0x007F0000
+#define PCIE_VC0_RC_MAX_TIMESLOTS_S		16
+#define PCIE_VC0_RC_PORT_ARB_TAB_OFFSET		0xFF000000
+#define PCIE_VC0_RC_PORT_ARB_TAB_OFFSET_S	24
+
+/* VC0 Resource Control Register */
+#define PCIE_VC0_RC0(X)			(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x154)
+
+#define PCIE_VC0_RC0_TVM0			0x00000001
+#define PCIE_VC0_RC0_TVM1			0x00000002
+#define PCIE_VC0_RC0_TVM2			0x00000004
+#define PCIE_VC0_RC0_TVM3			0x00000008
+#define PCIE_VC0_RC0_TVM4			0x00000010
+#define PCIE_VC0_RC0_TVM5			0x00000020
+#define PCIE_VC0_RC0_TVM6			0x00000040
+#define PCIE_VC0_RC0_TVM7			0x00000080
+#define PCIE_VC0_RC0_TC_VC			0x000000FF
+
+#define PCIE_VC0_RC0_LOAD_PORT_ARB_TAB		0x00010000
+#define PCIE_VC0_RC0_PORT_ARB_SEL		0x000E0000
+#define PCIE_VC0_RC0_PORT_ARB_SEL_S		17
+#define PCIE_VC0_RC0_VC_ID			0x07000000
+#define PCIE_VC0_RC0_VC_ID_S			24
+#define PCIE_VC0_RC0_VC_EN			0x80000000
+
+/* VC0 Resource Status Register */
+#define PCIE_VC0_RSR0(X)	(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x158)
+
+#define PCIE_VC0_RSR0_PORT_ARB_TAB_STATUS	0x00010000
+#define PCIE_VC0_RSR0_VC_NEG_PENDING		0x00020000
+
+/* Ack Latency Timer and Replay Timer Register */
+#define PCIE_ALTRT(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x700)
+
+#define PCIE_ALTRT_ROUND_TRIP_LATENCY_LIMIT	0x0000FFFF
+#define PCIE_ALTRT_ROUND_TRIP_LATENCY_LIMIT_S	0
+#define PCIE_ALTRT_REPLAY_TIME_LIMIT		0xFFFF0000
+#define PCIE_ALTRT_REPLAY_TIME_LIMIT_S		16
+
+/* Other Message Register */
+#define PCIE_OMR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x704)
+
+/* Port Force Link Register */
+#define PCIE_PFLR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x708)
+
+#define PCIE_PFLR_LINK_NUM			0x000000FF
+#define PCIE_PFLR_LINK_NUM_S			0
+#define PCIE_PFLR_FORCE_LINK			0x00008000
+#define PCIE_PFLR_LINK_STATE			0x003F0000
+#define PCIE_PFLR_LINK_STATE_S			16
+#define PCIE_PFLR_LOW_POWER_ENTRY_CNT		0xFF000000
+#define PCIE_PFLR_LOW_POWER_ENTRY_CNT_S		24
+
+/* Ack Frequency Register */
+#define PCIE_AFR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x70C)
+
+#define PCIE_AFR_AF			0x000000FF
+#define PCIE_AFR_AF_S			0
+#define PCIE_AFR_FTS_NUM		0x0000FF00
+#define PCIE_AFR_FTS_NUM_S		8
+#define PCIE_AFR_COM_FTS_NUM		0x00FF0000
+#define PCIE_AFR_COM_FTS_NUM_S		16
+#define PCIE_AFR_L0S_ENTRY_LATENCY	0x07000000
+#define PCIE_AFR_L0S_ENTRY_LATENCY_S	24
+#define PCIE_AFR_L1_ENTRY_LATENCY	0x38000000
+#define PCIE_AFR_L1_ENTRY_LATENCY_S	27
+#define PCIE_AFR_FTS_NUM_DEFAULT	32
+#define PCIE_AFR_L0S_ENTRY_LATENCY_DEFAULT	7
+#define PCIE_AFR_L1_ENTRY_LATENCY_DEFAULT	5
+
+/* Port Link Control Register */
+#define PCIE_PLCR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x710)
+
+#define PCIE_PLCR_OTHER_MSG_REQ		0x00000001
+#define PCIE_PLCR_SCRAMBLE_DISABLE	0x00000002
+#define PCIE_PLCR_LOOPBACK_EN		0x00000004
+#define PCIE_PLCR_LTSSM_HOT_RST		0x00000008
+#define PCIE_PLCR_DLL_LINK_EN		0x00000020
+#define PCIE_PLCR_FAST_LINK_SIM_EN	0x00000080
+#define PCIE_PLCR_LINK_MODE		0x003F0000
+#define PCIE_PLCR_LINK_MODE_S		16
+#define PCIE_PLCR_CORRUPTED_CRC_EN	0x02000000
+
+/* Lane Skew Register */
+#define PCIE_LSR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x714)
+
+#define PCIE_LSR_LANE_SKEW_NUM		0x00FFFFFF
+#define PCIE_LSR_LANE_SKEW_NUM_S	0
+#define PCIE_LSR_FC_DISABLE		0x01000000
+#define PCIE_LSR_ACKNAK_DISABLE		0x02000000
+#define PCIE_LSR_LANE_DESKEW_DISABLE	0x80000000
+
+/* Symbol Number Register */
+#define PCIE_SNR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x718)
+
+#define PCIE_SNR_TS			0x0000000F
+#define PCIE_SNR_TS_S			0
+#define PCIE_SNR_SKP			0x00000700
+#define PCIE_SNR_SKP_S			8
+#define PCIE_SNR_REPLAY_TIMER		0x0007C000
+#define PCIE_SNR_REPLAY_TIMER_S		14
+#define PCIE_SNR_ACKNAK_LATENCY_TIMER	0x00F80000
+#define PCIE_SNR_ACKNAK_LATENCY_TIMER_S	19
+#define PCIE_SNR_FC_TIMER		0x1F000000
+#define PCIE_SNR_FC_TIMER_S		28
+
+/* Symbol Timer Register and Filter Mask Register 1 */
+#define PCIE_STRFMR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x71C)
+
+#define PCIE_STRFMR_SKP_INTERVAL		0x000007FF
+#define PCIE_STRFMR_SKP_INTERVAL_S		0
+#define PCIE_STRFMR_FC_WDT_DISABLE		0x00008000
+#define PCIE_STRFMR_TLP_FUNC_MISMATCH_OK	0x00010000
+#define PCIE_STRFMR_POISONED_TLP_OK		0x00020000
+#define PCIE_STRFMR_BAR_MATCH_OK		0x00040000
+#define PCIE_STRFMR_TYPE1_CFG_REQ_OK		0x00080000
+#define PCIE_STRFMR_LOCKED_REQ_OK		0x00100000
+#define PCIE_STRFMR_CPL_TAG_ERR_RULES_OK	0x00200000
+#define PCIE_STRFMR_CPL_REQUESTOR_ID_MISMATCH_OK	0x00400000
+#define PCIE_STRFMR_CPL_FUNC_MISMATCH_OK	0x00800000
+#define PCIE_STRFMR_CPL_TC_MISMATCH_OK		0x01000000
+#define PCIE_STRFMR_CPL_ATTR_MISMATCH_OK	0x02000000
+#define PCIE_STRFMR_CPL_LENGTH_MISMATCH_OK	0x04000000
+#define PCIE_STRFMR_TLP_ECRC_ERR_OK		0x08000000
+#define PCIE_STRFMR_CPL_TLP_ECRC_OK		0x10000000
+#define PCIE_STRFMR_RX_TLP_MSG_NO_DROP		0x20000000
+#define PCIE_STRFMR_RX_IO_TRANS_ENABLE		0x40000000
+#define PCIE_STRFMR_RX_CFG_TRANS_ENABLE		0x80000000
+
+#define PCIE_DEF_SKP_INTERVAL	700 /* 1180 ~1538 , 125MHz * 2, 250MHz * 1 */
+
+/* Filter Masker Register 2 */
+#define PCIE_FMR2(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x720)
+
+#define PCIE_FMR2_VENDOR_MSG0_PASSED_TO_TRGT1	0x00000001
+#define PCIE_FMR2_VENDOR_MSG1_PASSED_TO_TRGT1	0x00000002
+
+/* Debug Register 0 */
+#define PCIE_DBR0(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x728)
+
+/* Debug Register 1 */
+#define PCIE_DBR1(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x72C)
+
+/* Transmit Posted FC Credit Status Register */
+#define PCIE_TPFCS(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x730)
+
+#define PCIE_TPFCS_TX_P_DATA_FC_CREDITS		0x00000FFF
+#define PCIE_TPFCS_TX_P_DATA_FC_CREDITS_S	0
+#define PCIE_TPFCS_TX_P_HDR_FC_CREDITS		0x000FF000
+#define PCIE_TPFCS_TX_P_HDR_FC_CREDITS_S	12
+
+/* Transmit Non-Posted FC Credit Status */
+#define PCIE_TNPFCS(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x734)
+
+#define PCIE_TNPFCS_TX_NP_DATA_FC_CREDITS	0x00000FFF
+#define PCIE_TNPFCS_TX_NP_DATA_FC_CREDITS_S	0
+#define PCIE_TNPFCS_TX_NP_HDR_FC_CREDITS	0x000FF000
+#define PCIE_TNPFCS_TX_NP_HDR_FC_CREDITS_S	12
+
+/* Transmit Complete FC Credit Status Register */
+#define PCIE_TCFCS(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x738)
+
+#define PCIE_TCFCS_TX_CPL_DATA_FC_CREDITS	0x00000FFF
+#define PCIE_TCFCS_TX_CPL_DATA_FC_CREDITS_S	0
+#define PCIE_TCFCS_TX_CPL_HDR_FC_CREDITS	0x000FF000
+#define PCIE_TCFCS_TX_CPL_HDR_FC_CREDITS_S	12
+
+/* Queue Status Register */
+#define PCIE_QSR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x73C)
+
+#define PCIE_QSR_WAIT_UPDATE_FC_DLL		0x00000001
+#define PCIE_QSR_TX_RETRY_BUF_NOT_EMPTY		0x00000002
+#define PCIE_QSR_RX_QUEUE_NOT_EMPTY		0x00000004
+
+/* VC Transmit Arbitration Register 1 */
+#define PCIE_VCTAR1(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x740)
+
+#define PCIE_VCTAR1_WRR_WEIGHT_VC0		0x000000FF
+#define PCIE_VCTAR1_WRR_WEIGHT_VC1		0x0000FF00
+#define PCIE_VCTAR1_WRR_WEIGHT_VC2		0x00FF0000
+#define PCIE_VCTAR1_WRR_WEIGHT_VC3		0xFF000000
+
+/* VC Transmit Arbitration Register 2 */
+#define PCIE_VCTAR2(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x744)
+
+#define PCIE_VCTAR2_WRR_WEIGHT_VC4		0x000000FF
+#define PCIE_VCTAR2_WRR_WEIGHT_VC5		0x0000FF00
+#define PCIE_VCTAR2_WRR_WEIGHT_VC6		0x00FF0000
+#define PCIE_VCTAR2_WRR_WEIGHT_VC7		0xFF000000
+
+/* VC0 Posted Receive Queue Control Register */
+#define PCIE_VC0_PRQCR(X)	(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x748)
+
+#define PCIE_VC0_PRQCR_P_DATA_CREDITS		0x00000FFF
+#define PCIE_VC0_PRQCR_P_DATA_CREDITS_S		0
+#define PCIE_VC0_PRQCR_P_HDR_CREDITS		0x000FF000
+#define PCIE_VC0_PRQCR_P_HDR_CREDITS_S		12
+#define PCIE_VC0_PRQCR_P_TLP_QUEUE_MODE		0x00E00000
+#define PCIE_VC0_PRQCR_P_TLP_QUEUE_MODE_S	20
+#define PCIE_VC0_PRQCR_TLP_RELAX_ORDER		0x40000000
+#define PCIE_VC0_PRQCR_VC_STRICT_ORDER		0x80000000
+
+/* VC0 Non-Posted Receive Queue Control */
+#define PCIE_VC0_NPRQCR(X)	(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x74C)
+
+#define PCIE_VC0_NPRQCR_NP_DATA_CREDITS		0x00000FFF
+#define PCIE_VC0_NPRQCR_NP_DATA_CREDITS_S	0
+#define PCIE_VC0_NPRQCR_NP_HDR_CREDITS		0x000FF000
+#define PCIE_VC0_NPRQCR_NP_HDR_CREDITS_S	12
+#define PCIE_VC0_NPRQCR_NP_TLP_QUEUE_MODE	0x00E00000
+#define PCIE_VC0_NPRQCR_NP_TLP_QUEUE_MODE_S	20
+
+/* VC0 Completion Receive Queue Control */
+#define PCIE_VC0_CRQCR(X)	(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x750)
+
+#define PCIE_VC0_CRQCR_CPL_DATA_CREDITS		0x00000FFF
+#define PCIE_VC0_CRQCR_CPL_DATA_CREDITS_S	0
+#define PCIE_VC0_CRQCR_CPL_HDR_CREDITS		0x000FF000
+#define PCIE_VC0_CRQCR_CPL_HDR_CREDITS_S	12
+#define PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE	0x00E00000
+#define PCIE_VC0_CRQCR_CPL_TLP_QUEUE_MODE_S	21
+
+/* Applicable to the above three registers */
+enum {
+	PCIE_VC0_TLP_QUEUE_MODE_STORE_FORWARD = 1,
+	PCIE_VC0_TLP_QUEUE_MODE_CUT_THROUGH = 2,
+	PCIE_VC0_TLP_QUEUE_MODE_BYPASS = 4,
+};
+
+/* VC0 Posted Buffer Depth Register */
+#define PCIE_VC0_PBD(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x7A8)
+
+#define PCIE_VC0_PBD_P_DATA_QUEUE_ENTRIES	0x00003FFF
+#define PCIE_VC0_PBD_P_DATA_QUEUE_ENTRIES_S	0
+#define PCIE_VC0_PBD_P_HDR_QUEUE_ENTRIES	0x03FF0000
+#define PCIE_VC0_PBD_P_HDR_QUEUE_ENTRIES_S	16
+
+/* VC0 Non-Posted Buffer Depth Register */
+#define PCIE_VC0_NPBD(X)	(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x7AC)
+
+#define PCIE_VC0_NPBD_NP_DATA_QUEUE_ENTRIES	0x00003FFF
+#define PCIE_VC0_NPBD_NP_DATA_QUEUE_ENTRIES_S	0
+#define PCIE_VC0_NPBD_NP_HDR_QUEUE_ENTRIES	0x03FF0000
+#define PCIE_VC0_NPBD_NP_HDR_QUEUE_ENTRIES_S	16
+
+/* VC0 Completion Buffer Depth Register */
+#define PCIE_VC0_CBD(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x7B0)
+
+#define PCIE_VC0_CBD_CPL_DATA_QUEUE_ENTRIES	0x00003FFF
+#define PCIE_VC0_CBD_CPL_DATA_QUEUE_ENTRIES_S	0
+#define PCIE_VC0_CBD_CPL_HDR_QUEUE_ENTRIES	0x03FF0000
+#define PCIE_VC0_CBD_CPL_HDR_QUEUE_ENTRIES_S	16
+
+/* PHY Status Register,*/
+#define PCIE_PHYSR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x810)
+
+/* PHY Control Register */
+#define PCIE_PHYCR(X)		(u32 *)(PCIE_RC_PORT_TO_BASE(X) + 0x814)
+
+/*
+ * PCIe PDI PHY register definition, suppose all the following
+ * stuff is confidential.
+ * XXX, detailed bit definition
+ */
+#define	PCIE_PHY_PLL_CTRL1(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x22 << 1))
+#define	PCIE_PHY_PLL_CTRL2(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x23 << 1))
+#define	PCIE_PHY_PLL_CTRL3(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x24 << 1))
+#define	PCIE_PHY_PLL_CTRL4(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x25 << 1))
+#define	PCIE_PHY_PLL_CTRL5(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x26 << 1))
+#define	PCIE_PHY_PLL_CTRL6(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x27 << 1))
+#define	PCIE_PHY_PLL_CTRL7(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x28 << 1))
+#define	PCIE_PHY_PLL_A_CTRL1(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x29 << 1))
+#define	PCIE_PHY_PLL_A_CTRL2(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x2A << 1))
+#define	PCIE_PHY_PLL_A_CTRL3(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x2B << 1))
+#define	PCIE_PHY_PLL_STATUS(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x2C << 1))
+
+#define PCIE_PHY_TX1_CTRL1(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x30 << 1))
+#define PCIE_PHY_TX1_CTRL2(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x31 << 1))
+#define PCIE_PHY_TX1_CTRL3(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x32 << 1))
+#define PCIE_PHY_TX1_A_CTRL1(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x33 << 1))
+#define PCIE_PHY_TX1_A_CTRL2(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x34 << 1))
+#define PCIE_PHY_TX1_MOD1(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x35 << 1))
+#define PCIE_PHY_TX1_MOD2(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x36 << 1))
+#define PCIE_PHY_TX1_MOD3(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x37 << 1))
+
+#define PCIE_PHY_TX2_CTRL1(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x38 << 1))
+#define PCIE_PHY_TX2_CTRL2(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x39 << 1))
+#define PCIE_PHY_TX2_A_CTRL1(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x3B << 1))
+#define PCIE_PHY_TX2_A_CTRL2(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x3C << 1))
+#define PCIE_PHY_TX2_MOD1(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x3D << 1))
+#define PCIE_PHY_TX2_MOD2(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x3E << 1))
+#define PCIE_PHY_TX2_MOD3(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x3F << 1))
+
+#define PCIE_PHY_RX1_CTRL1(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x50 << 1))
+#define PCIE_PHY_RX1_CTRL2(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x51 << 1))
+#define PCIE_PHY_RX1_CDR(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x52 << 1))
+#define PCIE_PHY_RX1_EI(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x53 << 1))
+#define PCIE_PHY_RX1_A_CTRL(X)	(u32 *)(PCIE_PHY_PORT_TO_BASE(X) + (0x55 << 1))
+
+/* MSI PIC */
+#define MSI_PIC_REG_BASE		(KSEG1 | 0x1F700000)
+#define MSI1_PIC_REG_BASE		(KSEG1 | 0x1F500000)
+#define MSI2_PIC_REG_BASE		(KSEG1 | 0x1F700600)
+
+#define MSI_PIC_BIG_ENDIAN		1
+#define MSI_PIC_LITTLE_ENDIAN		0
+
+#define MSI_PCI_INT_DISABLE		0x80000000
+#define MSI_PIC_INT_LINE		0x30000000
+#define MSI_PIC_INT_LINE_S		28
+#define MSI_PIC_MSG_ADDR		0x0FFF0000
+#define MSI_PIC_MSG_ADDR_S		16
+#define MSI_PIC_MSG_DATA		0x0000FFFF
+#define MSI_PIC_MSG_DATA_S		0x0
+
+#define PCIE_INTA			(INT_NUM_IM4_IRL0 + 8)
+#define PCIE_INTB			(INT_NUM_IM4_IRL0 + 9)
+#define PCIE_INTC			(INT_NUM_IM4_IRL0 + 10)
+#define PCIE_INTD			(INT_NUM_IM4_IRL0 + 11)
+#define PCIE_IR				(INT_NUM_IM4_IRL0 + 25)
+#define PCIE_WAKE			(INT_NUM_IM4_IRL0 + 26)
+#define PCIE_MSI_IR0			(INT_NUM_IM4_IRL0 + 27)
+#define PCIE_MSI_IR1			(INT_NUM_IM4_IRL0 + 28)
+#define PCIE_MSI_IR2			(INT_NUM_IM4_IRL0 + 29)
+#define PCIE_MSI_IR3			(INT_NUM_IM0_IRL0 + 30)
+#define PCIE_L3_INT			(INT_NUM_IM3_IRL0 + 16)
+
+#define PCIE1_INTA			(INT_NUM_IM0_IRL0 + 9)
+#define PCIE1_INTB			(INT_NUM_IM0_IRL0 + 10)
+#define PCIE1_INTC			(INT_NUM_IM0_IRL0 + 11)
+#define PCIE1_INTD			(INT_NUM_IM0_IRL0 + 12)
+#define PCIE1_IR			(INT_NUM_IM1_IRL0 + 17)
+#define PCIE1_WAKE			(INT_NUM_IM1_IRL0 + 18)
+#define PCIE1_MSI_IR0			(INT_NUM_IM1_IRL0 + 9)
+#define PCIE1_MSI_IR1			(INT_NUM_IM1_IRL0 + 10)
+#define PCIE1_MSI_IR2			(INT_NUM_IM1_IRL0 + 11)
+#define PCIE1_MSI_IR3			(INT_NUM_IM1_IRL0 + 12)
+#define PCIE1_L3_INT			(INT_NUM_IM1_IRL0 + 13)
+
+#define PCIE2_INTA			(INT_NUM_IM0_IRL0 + 19)
+#define PCIE2_INTB			(INT_NUM_IM1_IRL0 + 31)
+#define PCIE2_INTC			(INT_NUM_IM2_IRL0 + 17)
+#define PCIE2_INTD			(INT_NUM_IM2_IRL0 + 18)
+#define PCIE2_IR			(INT_NUM_IM1_IRL0 + 21)
+#define PCIE2_WAKE			(INT_NUM_IM1_IRL0 + 23)
+#define PCIE2_MSI_IR0			(INT_NUM_IM2_IRL0 + 12)
+#define PCIE2_MSI_IR1			(INT_NUM_IM2_IRL0 + 13)
+#define PCIE2_MSI_IR2			(INT_NUM_IM2_IRL0 + 14)
+#define PCIE2_MSI_IR3			(INT_NUM_IM2_IRL0 + 15)
+#define PCIE2_L3_INT			(INT_NUM_IM2_IRL0 + 30)
+
+#define INT_NUM_IM4_IRL31		(INT_NUM_IM4_IRL0 + 31)
+
+#define RCU_AHB_ENDIAN			0x004C
+#define RCU_RST_REQ			0x0010
+#define RCU_AHB_BE_PCIE_PDI		0x00000080
+#define RCU_RST_STAT2			0x0024
+#define RCU_RST_REQ2			0x0048
+
+#define RCU_PCIE_ARBITER_MASK		0x00000C00
+#define RCU_PCIE_ARBITER_RC0		0x00000000
+#define RCU_PCIE_ARBITER_RC0_RC1	0x00000800
+#define RCU_PCIE_ARBITER_RC0_RC1_RC2	0x00000400
+
+#define RCU_BE_AHB4S			0x00000001
+#define RCU_BE_AHB3M			0x00000002
+#define RCU_BE_USIF			0x00000004
+#define RCU_BE_AHB2S			0x00000008
+#define RCU_BE_PCIE0S			0x00000010
+#define RCU_BE_PCIE0_DBI		0x00000020
+#define RCU_BE_DCDC_PDI			0x00000040
+#define RCU_BE_PCIE0_PDI		0x00000080
+#define RCU_BE_PCIE1S			0x00000100
+#define RCU_BE_PCIE1_DBI		0x00000200
+#define RCU_BE_PCIE1_PDI		0x00000400
+#define RCU_BE_AHB1S			0x00000800
+#define RCU_BE_PCIE0M			0x00001000
+#define RCU_BE_PCIE1M			0x00002000
+
+#define RCU_BE_PCIE2M			0x00004000
+#define RCU_BE_PCIE2_DBI		0x00008000
+#define RCU_BE_PCIE2_PDI		0x00010000
+#define RCU_BE_PCIE2S			0x00020000
+
+#define RCU_VR9_BE_PCIE0M		0x00000001
+#define RCU_VR9_BE_AHB1S		0x00000008
+#define RCU_VR9_BE_PCIE0S		0x00000010
+#define RCU_VR9_BE_AHB2M		0x00000002
+
+/* PCIe Address Mapping Base */
+#if defined(CONFIG_LANTIQ_PCIE_1ST_CORE)
+#define PCIE_CFG_PHY_BASE	0x1D000000UL
+#define PCIE_CFG_BASE		(KSEG1 + PCIE_CFG_PHY_BASE)
+#define PCIE_CFG_SIZE		(8 * 1024 * 1024)
+
+#define PCIE_MEM_PHY_BASE	0x1C000000UL
+#define PCIE_MEM_BASE		(KSEG1 + PCIE_MEM_PHY_BASE)
+#define PCIE_MEM_SIZE		(16 * 1024 * 1024)
+#define PCIE_MEM_PHY_END	(PCIE_MEM_PHY_BASE + PCIE_MEM_SIZE - 1)
+
+#define PCIE_IO_PHY_BASE	0x1D800000UL
+#define PCIE_IO_BASE		(KSEG1 + PCIE_IO_PHY_BASE)
+#define PCIE_IO_SIZE		(1 * 1024 * 1024)
+#define PCIE_IO_PHY_END		(PCIE_IO_PHY_BASE + PCIE_IO_SIZE - 1)
+
+#define PCIE_RC_CFG_BASE	(KSEG1 + 0x1D900000)
+#define PCIE_APP_LOGIC_REG	(KSEG1 + 0x1E100900)
+#define PCIE_MSI_PHY_BASE	0x1F600000UL
+
+#define PCIE_PDI_PHY_BASE	0x1F106800UL
+#define PCIE_PDI_BASE		(KSEG1 + PCIE_PDI_PHY_BASE)
+#define PCIE_PDI_SIZE		0x200
+#endif /* CONFIG_LANTIQ_PCIE_1ST_CORE */
+
+#if defined(CONFIG_LANTIQ_PCIE_2ND_CORE)
+#define PCIE1_CFG_PHY_BASE	0x19000000UL
+#define PCIE1_CFG_BASE		(KSEG1 + PCIE1_CFG_PHY_BASE)
+#define PCIE1_CFG_SIZE		(8 * 1024 * 1024)
+
+#define PCIE1_MEM_PHY_BASE	0x18000000UL
+#define PCIE1_MEM_BASE		(KSEG1 + PCIE1_MEM_PHY_BASE)
+#define PCIE1_MEM_SIZE		(16 * 1024 * 1024)
+#define PCIE1_MEM_PHY_END	(PCIE1_MEM_PHY_BASE + PCIE1_MEM_SIZE - 1)
+
+#define PCIE1_IO_PHY_BASE	0x19800000UL
+#define PCIE1_IO_BASE		(KSEG1 + PCIE1_IO_PHY_BASE)
+#define PCIE1_IO_SIZE		(1 * 1024 * 1024)
+#define PCIE1_IO_PHY_END	(PCIE1_IO_PHY_BASE + PCIE1_IO_SIZE - 1)
+
+#define PCIE1_RC_CFG_BASE	(KSEG1 + 0x19900000)
+#define PCIE1_APP_LOGIC_REG	(KSEG1 + 0x1E100700)
+#define PCIE1_MSI_PHY_BASE	0x1F400000UL
+
+#define PCIE1_PDI_PHY_BASE	0x1F700400UL
+#define PCIE1_PDI_BASE		(KSEG1 + PCIE1_PDI_PHY_BASE)
+#define PCIE1_PDI_SIZE		0x200
+#endif /* CONFIG_LANTIQ_PCIE_2ND_CORE */
+
+#if defined(CONFIG_LANTIQ_PCIE_3RD_CORE)
+#define PCIE2_CFG_PHY_BASE	0x1A800000UL
+#define PCIE2_CFG_BASE		(KSEG1 + PCIE2_CFG_PHY_BASE)
+#define PCIE2_CFG_SIZE		(8 * 1024 * 1024)
+
+#define PCIE2_MEM_PHY_BASE	0x1B000000UL
+#define PCIE2_MEM_BASE		(KSEG1 + PCIE2_MEM_PHY_BASE)
+#define PCIE2_MEM_SIZE		(16 * 1024 * 1024)
+#define PCIE2_MEM_PHY_END	(PCIE2_MEM_PHY_BASE + PCIE2_MEM_SIZE - 1)
+
+#define PCIE2_IO_PHY_BASE	0x19A00000UL
+#define PCIE2_IO_BASE		(KSEG1 + PCIE2_IO_PHY_BASE)
+#define PCIE2_IO_SIZE		(1 * 1024 * 1024)
+#define PCIE2_IO_PHY_END	(PCIE2_IO_PHY_BASE + PCIE2_IO_SIZE - 1)
+
+#define PCIE2_RC_CFG_BASE	(KSEG1 + 0x19B00000)
+#define PCIE2_APP_LOGIC_REG	(KSEG1 + 0x1E100400)
+#define PCIE2_MSI_PHY_BASE	0x1F700A00UL
+
+#define PCIE2_PDI_PHY_BASE	0x1F106A00UL
+#define PCIE2_PDI_BASE		(KSEG1 + PCIE2_PDI_PHY_BASE)
+#define PCIE2_PDI_SIZE		0x200
+#endif /* CONFIG_LANTIQ_PCIE_3RD_CORE */
+
+/* Subject to change, DT is preferred */
+#define PCIE_GPIO_RESET		238 /* VR9 */
+#define PCIE_RC0_LED_RST	181
+#define PCIE_RC1_LED_RST	182
+
+#define PCIE_RC2_LED_RST	171
+
+static int pcie_port_to_rst_pin[] = {
+	PCIE_RC0_LED_RST,
+	PCIE_RC1_LED_RST,
+	PCIE_RC2_LED_RST,
+};
+
+
+#endif /* PCIE_LANTIQ_H */
diff --git a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_desc.c b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_desc.c
index 6654097..ae5f685 100644
--- a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_desc.c
+++ b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_desc.c
@@ -369,8 +369,8 @@ static void DWC_ETH_QOS_wrapper_rx_descriptor_init_single_q(
 	desc_data->skb_realloc_idx = 0;
 	desc_data->skb_realloc_threshold = MIN_RX_DESC_CNT;
 	desc_data->pkt_received = 0;
-	hw_if->rx_desc_init(pdata, qInx);
 	desc_data->cur_rx = 0;
+	hw_if->rx_desc_init(pdata, qInx);
 
 	DBGPR("<--DWC_ETH_QOS_wrapper_rx_descriptor_init_single_q\n");
 }
diff --git a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_mdio.c b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_mdio.c
index 84bdca7..0015ace 100644
--- a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_mdio.c
+++ b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_mdio.c
@@ -34,6 +34,31 @@
  */
 #include "DWC_ETH_QOS_yheader.h"
 
+extern struct DWC_ETH_QOS_prv_data *pdata_p;
+
+#define MDIO_ADDR_LANTIQ 31
+
+int DWC_ETH_QOS_mdio_read_ext(int regaddr, int *phydata)
+{
+	if (!pdata_p){
+		printk(KERN_ALERT "%s:%d: pdata is null\n", __func__, __LINE__);
+		return 0;
+	}
+	return DWC_ETH_QOS_mdio_read_direct(pdata_p, MDIO_ADDR_LANTIQ,
+					   (regaddr & 0x1F), phydata);
+}
+EXPORT_SYMBOL(DWC_ETH_QOS_mdio_read_ext);
+
+int DWC_ETH_QOS_mdio_write_ext(int regaddr, int phydata)
+{
+	if (!pdata_p) {
+		printk(KERN_ALERT "%s:%d: pdata is null\n", __func__, __LINE__);
+		return 0;
+	}
+	return DWC_ETH_QOS_mdio_write_direct(pdata_p, MDIO_ADDR_LANTIQ,
+					    (regaddr & 0x1F), phydata);
+}
+EXPORT_SYMBOL(DWC_ETH_QOS_mdio_write_ext);
 /*!
 * \brief read MII PHY register, function called by the driver alone
 *
@@ -134,7 +159,7 @@ static int DWC_ETH_QOS_mdio_read(struct mii_bus *bus, int phyaddr, int phyreg)
 	struct net_device *dev = bus->priv;
 	struct DWC_ETH_QOS_prv_data *pdata = netdev_priv(dev);
 	hw_interface_t *hw_if = &(pdata->hw_if);
-	int phydata = 0;
+	int phydata;
 
 	DBGPR_MDIO("--> DWC_ETH_QOS_mdio_read: phyaddr = %d, phyreg = %d\n",
 	      phyaddr, phyreg);
diff --git a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_pci.c b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_pci.c
index adf7422..19dcc16 100644
--- a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_pci.c
+++ b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_pci.c
@@ -368,6 +368,7 @@ void DWC_ETH_QOS_init_all_fptrs(struct DWC_ETH_QOS_prv_data *pdata)
    DWC_ETH_QOS_init_function_ptrs_desc(&pdata->desc_if);
 }
 
+struct DWC_ETH_QOS_prv_data *pdata_p;
 /*!
 * \brief API to initialize the device.
 *
@@ -476,6 +477,7 @@ int DWC_ETH_QOS_probe(struct pci_dev *pdev,
    dev->base_addr = dwc_eth_qos_pci_base_addr;
    SET_NETDEV_DEV(dev, &pdev->dev);
    pdata = netdev_priv(dev);
+   pdata_p = pdata;
    DWC_ETH_QOS_init_all_fptrs(pdata);
    hw_if = &(pdata->hw_if);
    desc_if = &(pdata->desc_if);
diff --git a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_yheader.h b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_yheader.h
index 5bdbdae..9061b74 100644
--- a/drivers/net/ethernet/synopsys/DWC_ETH_QOS_yheader.h
+++ b/drivers/net/ethernet/synopsys/DWC_ETH_QOS_yheader.h
@@ -1243,6 +1243,8 @@ int DWC_ETH_QOS_mdio_read_direct(struct DWC_ETH_QOS_prv_data *pdata,
 				 int phyaddr, int phyreg, int *phydata);
 int DWC_ETH_QOS_mdio_write_direct(struct DWC_ETH_QOS_prv_data *pdata,
 				  int phyaddr, int phyreg, int phydata);
+int DWC_ETH_QOS_mdio_read_ext(int regaddr, int *phydata);
+int DWC_ETH_QOS_mdio_write_ext(int regaddr, int phydata);
 void dbgpr_regs(void);
 void dump_phy_registers(struct DWC_ETH_QOS_prv_data *);
 void dump_tx_desc(struct DWC_ETH_QOS_prv_data *pdata, int first_desc_idx,
diff --git a/drivers/net/lpal_api/lpal_directpath.c b/drivers/net/lpal_api/lpal_directpath.c
index faa9201..926700c 100644
--- a/drivers/net/lpal_api/lpal_directpath.c
+++ b/drivers/net/lpal_api/lpal_directpath.c
@@ -142,7 +142,7 @@ int32_t ppa_directpath_register_dev_ex(PPA_SUBIF *subif, PPA_NETIF *netif,
 			    (ppa_drv_g_ppe_directpath_data[if_id].netif ==
 			     netif)) {
 				if (subif) {
-#if defined(CONFIG_PPA_PUMA7) && CONFIG_PPA_PUMA7
+#if defined(CONFIG_PPA_PUMA7) && CONFIG_PPA_PUMA7
 					subif->port_id = DP_PORT_ID(if_id);
 					subif->subif = DP_SUBIF(if_id);
 #endif
@@ -299,7 +299,7 @@ PPA_BUF *ppa_directpath_alloc_skb(PPA_SUBIF *subif, int32_t len,
 {
 	PPA_BUF *ret = (void *)PPA_INVALID;
 
-#if defined(CONFIG_PPA_PUMA7) && CONFIG_PPA_PUMA7
+#if defined(CONFIG_PPA_PUMA7) && CONFIG_PPA_PUMA7
 	spin_lock_bh(&g_lpal_dp_lock);
 
 	/* TODO: subif validation */
diff --git a/include/linux/avalanche/generic/_tistdtypes.h b/include/linux/avalanche/generic/_tistdtypes.h
index 779347b..c52079f 100755
--- a/include/linux/avalanche/generic/_tistdtypes.h
+++ b/include/linux/avalanche/generic/_tistdtypes.h
@@ -4,9 +4,12 @@
  * Description:
  * TI Standard defines for primitive "C" types only
  *
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
   GPL LICENSE SUMMARY
 
-  Copyright(c) 2009-2016 Intel Corporation.
+  Copyright(c) 2009-2015 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of version 2 of the GNU General Public License as
@@ -29,8 +32,43 @@
   2200 Mission College Blvd.
   Santa Clara, CA  97052
 
+  BSD LICENSE 
+
+  Copyright(c) 2009-2015 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
+#ifndef CONFIG_ARM_AVALANCHE_SOC /*AP-CPU*/
+#include <linux/types.h>
+#endif
+
 /** \file   _tistdtypes.h
     \brief  TI Standard defines for primitive "C" types only
 
@@ -58,10 +96,12 @@
  * \enum Bool - Boolean Type
  */
 
-typedef bool            Bool;
+typedef enum 
+{
+    False = 0,
+    True = 1
+} Bool;
 
-#define True true
-#define False false
 
 typedef int             Int;    /**< Signed base integer quanity */
 typedef unsigned int    Uns;    /**< This is depricated support only */
@@ -73,17 +113,19 @@ typedef void*           Ptr;    /**< Arbitrary (void) pointer (works for pointin
 
 /* Signed integer definitions (64bit, 32bit, 16bit, 8bit) follow... */ 
 typedef long long       Int64; 
-typedef int32_t         Int32;
+typedef int             Int32;
 typedef short           Int16;
 typedef signed char     Int8; 
 
 /* Unsigned integer definitions (64bit, 32bit, 16bit, 8bit) follow... */ 
-typedef unsigned long long  Uint64;
-typedef uint32_t            Uint32;
-typedef uint8_t             Uint8;
+typedef unsigned long long  Uint64; 
+
+typedef unsigned int        Uint32;
 typedef unsigned short      Uint16;
+typedef unsigned char       Uint8;
 
 
 /*@}*/
 #endif /* _TI_STD_TYPES */
 
+
diff --git a/include/linux/avalanche/generic/avalanche_intd.h b/include/linux/avalanche/generic/avalanche_intd.h
new file mode 100644
index 0000000..39121e0
--- /dev/null
+++ b/include/linux/avalanche/generic/avalanche_intd.h
@@ -0,0 +1,165 @@
+/*
+ *
+ * avalanche_intd.h
+ * Description:
+ * interrupt distributor header file
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2015 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2015 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _AVALANCHE_INTD_H
+#define _AVALANCHE_INTD_H
+
+#define AVALANCHE_MAX_HOSTS_PER_SOC         (10)
+#define ALALANCHE_INTD_MAX_INTS_SUPPORTED   (1024)
+
+#define AVALANCHE_IDIST_IP_INT_NUM          (32)
+#define AVALANCHE_IDIST1_IP_INT_NUM         (16)
+#define AVALANCHE_IDIST_SYS_INT_NUM         (16)
+#define AVALANCHE_IDIST1_SYS_INT_NUM        (12)
+#ifndef NUM_INTS_PER_REG
+#define NUM_INTS_PER_REG                    (32)
+#endif
+
+/*
+ * Interrupt Distributor relies on the below structure for SoC related
+ * information
+ */
+
+/* NOTE:
+ *      Do name the structure instances for the following structures as
+ *      as SOC_HOST_INFO as "host_info" and AVALANCHE_SOC_INFO as "soc_info"
+ *      as these are been reffered by interrupt distributor code.
+ */
+typedef struct avalanche_intd_host_info
+{
+    unsigned int host_num;
+    unsigned int max_ip_ints_mapped;
+}SOC_HOST_INFO;
+
+
+/* NOTE: Read INTD as Interrupt Distributor */
+typedef struct avalanche_idist_pcer_regs
+{
+  volatile unsigned int idpparamr;      /* INTD Pacer Parameter Register */
+  volatile unsigned int idpdecr;        /* INTD Pacer decerement Register */
+}IDIST_PACER_REGS;
+
+typedef struct avalanche_idist_regs    /* Avalanche Interrupt Distributor registers */
+{
+    volatile unsigned int idrevr;           /* INTD Revision Reg                */
+    volatile unsigned int idcntrlr;         /* INTD Control Reg                 */
+    volatile unsigned int unused1[2];       /* 0x08                             */
+    volatile unsigned int ideoir;           /* INTD End Of Interrupt (EOI) Reg  */
+    volatile unsigned int ideoiintvr;       /* INTD EOI Interrupt Vector Reg    */
+    volatile unsigned int unused2[2];       /* 0x18  to 0x1C                    */
+    volatile unsigned int idpprer;          /* INTD Pacer Prescale  Reg         */
+    volatile unsigned int unused4[3];       /* 0x24  to 0x2C                    */
+    IDIST_PACER_REGS  idpacer[26];          /* INTD pacer Reg                   */
+    volatile unsigned int idenbsr[32];      /* INTD Enabler  set Reg            */
+    volatile unsigned int idenbcr[32];      /* INTD Enabler Clear Reg           */
+    volatile unsigned int idstasr[32];      /* INTD Status  Set  Reg            */
+    volatile unsigned int idstacr[32];      /* INTD Status Clear  Reg           */
+    volatile unsigned int idcounterr[32];   /* INTD Counter  Reg                */
+    volatile unsigned int idpolr[32];       /* INTD polarity Reg                */
+    volatile unsigned int idtypr[32];       /* INTD type Reg                    */
+    volatile unsigned int idintvr[32];      /* INTD Interrupt Vector Reg        */
+}avalanche_idist_regs_t;
+
+/**
+ * Write to end of interrupt register
+ *
+ * @param vect_val the system interrupt number
+ *
+ * @return int 0 on success
+ */
+int avalanche_intd_write_eoi(unsigned int vect_val);
+
+/**
+ * Get interrupts count for specified ip interrupt.
+ *
+ * @param host_num should be 0 always.
+ * @param ip_int_num ip interrupt number.
+ *
+ * @return int interrupt count on success, -1 to indicate
+ *         failure.
+ */
+int avalanche_intd_get_interrupt_count(unsigned int host_num, unsigned int ip_int_num);
+
+/**
+ * Set interrupt count for specified ip interrupt, writing to
+ * interrupt count register will decerement the count value by
+ * the value written.
+ *
+ * @param host_num should always be 0.
+ * @param ip_int_num ip interrupt number.
+ * @param count_val count value to write to interrupt count
+ *                  register.
+ *
+ * @return int 0 on success.
+ */
+int avalanche_intd_set_interrupt_count(unsigned int host_num, unsigned int ip_int_num, unsigned int count_val);
+
+
+#endif /* _AVALANCHE_INTD_H */
+
diff --git a/include/linux/avalanche/generic/avalanche_pdsp_api.h b/include/linux/avalanche/generic/avalanche_pdsp_api.h
new file mode 100755
index 0000000..293b3c9
--- /dev/null
+++ b/include/linux/avalanche/generic/avalanche_pdsp_api.h
@@ -0,0 +1,437 @@
+/*
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2015 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _AVALANCHE_PDSP_H
+#define _AVALANCHE_PDSP_H
+
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+#include <asm-arm/arch-avalanche/generic/_tistdtypes.h>
+#ifndef __KERNEL__
+#include <puma_autoconf.h>
+#endif
+#else /* NP- CPU */
+#ifdef __KERNEL__
+#include <linux/avalanche/puma7/puma7_defs.h>
+#include <linux/avalanche/generic/_tistdtypes.h>
+#else
+#include "_tistdtypes.h"
+#endif
+#endif
+#include <linux/ioctl.h>
+
+
+#if PUMA7_OR_NEWER_SOC_TYPE
+    #define AVALANCHE_PDSP_H_PUMA7
+
+#define PRECMD_INDEX_SHIFT        16
+#define PRECMD_OPTION_SHIFT       8
+#define PRECMD_COMMAND_SHIFT      0
+#define PRECMD_INDEX_MASK         (0xFFFFu << PRECMD_INDEX_SHIFT)
+
+#define PRECMD_COMMAND_MASK       (0xFFu << PRECMD_COMMAND_SHIFT)
+#define PRECMD_COMMAND(x)         (((x) << PRECMD_COMMAND_SHIFT) & PRECMD_COMMAND_MASK)
+#define PRECMD_INDEX(x)           (((x) << PRECMD_INDEX_SHIFT)   & PRECMD_INDEX_MASK)
+#define PRECMD_OPTION_MASK        (0xFFu << PRECMD_OPTION_SHIFT)
+#define PRECMD_OPTION(x)          (((x) << PRECMD_OPTION_SHIFT)  & PRECMD_OPTION_MASK)
+
+#define MIN_PKTS_FOR_QDA_ACTIVATION_STEP_A0 (0xffffffff)
+#define MIN_PKTS_FOR_QDA_ACTIVATION_STEP_B0 (10)
+#define MIN_PKTS_FOR_QDA_ACTIVATION_ADDR    (0xF3E13200)
+
+#if defined(CONFIG_MACH_PUMA7_FPGA_PP) || defined (CONFIG_MACH_PUMA7_BOARD)
+    //#define FPGA_SANITY_UNITEST     0
+#endif
+#elif defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
+    #define AVALANCHE_PDSP_H_PUMA6
+#else
+    #undef  AVALANCHE_PDSP_H_PUMA6
+    #undef  AVALANCHE_PDSP_H_PUMA7
+#endif
+
+#ifdef CONFIG_WIFI_MESH_TUNNEL
+#define WIFI_MESH_MODE                      (1<<0)
+#endif
+
+/* PP PDSP commands */
+typedef enum
+{
+#if defined (AVALANCHE_PDSP_H_PUMA7)
+
+    // Global PDSP  commands
+    PDSP_ENABLE                     = 0x80,
+    PDSP_GET_STATUS                 = 0x81,
+    PDSP_DISABLE                    = 0x82,
+    PDSP_SANITY_CHECK_EXECUTE       = 0x90,
+
+    // Sequencer    commands
+    PDSP_SEQUENCER_SET_TDQ          = 0x83,
+    PDSP_SEQUENCER_PID_COMMAND      = 0x84,
+
+    // Classifier1  commands
+    PDSP_CLASSIFIER1_VPID_COMMAND   = 0x83,
+
+    // Classifier2  commands
+    PDSP_CLASSIFIER2_PID_COMMAND    = 0x83,
+    PDSP_CLASSIFIER2_CLASSIFICATION_MODE_COMMAND = 0x84,
+    PDSP_CLASSIFIER2_MOCA_IRREG_SESS_OPEN = 0x85,
+
+    // PDSP ReSequencer commands
+    PDSP_RESEQUENCER_SET_SYNC_Q_THRSHOLD = 0x83,
+
+    // QoS          commands
+    PDSP_QOS_CMD_CONFIG_CLUSTER     = 0x83,
+
+    // Accumulator  commands
+    PDSP_ACCUMULATOR_ENABLE_CH      = 0x83,
+    PDSP_ACCUMULATOR_DISABLE_CH     = 0x84,
+
+    // Session Cache Commands
+    PDSP_SESSION_CACHE_SESSION_CMD  = 0x83,
+    PDSP_SESSION_CACHE_FLUSH_ALL    = 0x84,
+    PDSP_SESSION_CACHE_SESSION_TIMEOUT  = 0x85,
+
+#ifdef CONFIG_WIFI_PROXY
+    //Wifi TX commands
+    PDSP_CMD_WIFI_TX_INIT                = 0x83,
+    PDSP_CMD_WIFI_TX_ADD_CHANNEL         = 0x84,
+    PDSP_CMD_WIFI_TX_REMOVE_CHANNEL      = 0x85,
+    PDSP_CMD_WIFI_TX_START_CHANNEL       = 0x86,
+    PDSP_CMD_WIFI_TX_STOP_CHANNEL        = 0x87,
+    PDSP_CMD_WIFI_TX_INIT_DBG            = 0x88,
+    PDSP_CMD_WIFI_TX_SET_MAX_BURST       = 0x89,
+
+    //Wifi RX commands
+    PDSP_CMD_WIFI_RX_INIT                = 0x83,
+    PDSP_CMD_WIFI_RX_ADD_CHANNEL         = 0x84,
+    PDSP_CMD_WIFI_RX_REMOVE_CHANNEL      = 0x85,
+    PDSP_CMD_WIFI_RX_START_CHANNEL       = 0x86,
+    PDSP_CMD_WIFI_RX_STOP_CHANNEL        = 0x87,
+    PDSP_CMD_WIFI_RX_INIT_DBG            = 0x88,
+    PDSP_CMD_WIFI_RX_SET_MAX_BURST       = 0x89,
+#endif
+
+#else
+    PP_HAL_PDSP_CMD_OPEN    =   0x80,
+    PP_HAL_PDSP_CMD_FLUSH_ALL,
+    PP_HAL_PDSP_CMD_FLUSH_MANY,
+    PP_HAL_PDSP_CMD_reserved_x83,
+    PP_HAL_PDSP_CMD_PID,
+    PP_HAL_PDSP_CMD_VPID,
+    PP_HAL_PDSP_CMD_SESSION,
+    PP_HAL_PDSP_CMD_STATUS,
+    PP_HAL_PDSP_CMD_PSM,
+    PP_HAL_PDSP_CMD_VERSION,
+    PP_HAL_PDSP_CMD_reserved_x8A,
+    PP_HAL_PDSP_CMD_reserved_x8B,
+    PP_HAL_PDSP_CMD_ACK_SUPPRESS,
+    PP_HAL_PDSP_CMD_QOS_CLUSTER = 0xA0,
+
+    PDSP_PREFETCHER_CONFIG_TDQ = 0x87,
+    PDSP_PREFETCHER_ENABLE  = 0x83
+#endif
+}PP_HAL_PDSP_CMD_e;
+
+#if defined (AVALANCHE_PDSP_H_PUMA7)
+
+typedef enum
+{
+    PDSP_ID_START,
+    PDSP_ID_Sequencer = PDSP_ID_START,          //  Sequencer
+
+    PDSP_ID_Prefetcher_0,                       //  Prefetcher   group - PDSP 0
+    PDSP_ID_Prefetcher_1,                       //  Prefetcher   group - PDSP 1
+    PDSP_ID_Prefetcher_2,                       //  Prefetcher   group - PDSP 2
+    PDSP_ID_Prefetcher_3,                       //  Prefetcher   group - PDSP 3
+
+    PDSP_ID_Classifier1_0,                      //  Classifier1  group - PDSP 0
+    PDSP_ID_Classifier1_1,                      //  Classifier1  group - PDSP 1
+    PDSP_ID_Classifier1_2,                      //  Classifier1  group - PDSP 2
+    PDSP_ID_Classifier1_3,                      //  Classifier1  group - PDSP 3
+
+    PDSP_ID_Classifier2_0,                      //  Classifier2  group - PDSP 0
+    PDSP_ID_Classifier2_1,                      //  Classifier2  group - PDSP 1
+    PDSP_ID_Classifier2_2,                      //  Classifier2  group - PDSP 2
+    PDSP_ID_Classifier2_3,                      //  Classifier2  group - PDSP 3
+
+    PDSP_ID_Modifier_0,                         //  Modifier     group - PDSP 0
+    PDSP_ID_Modifier_1,                         //  Modifier     group - PDSP 1
+    PDSP_ID_Modifier_2,                         //  Modifier     group - PDSP 2
+    PDSP_ID_Modifier_3,                         //  Modifier     group - PDSP 3
+
+    PDSP_ID_ReSequencer,                        //  ReSequencer
+
+    PDSP_ID_QoS_0,                              //  QoS          group - PDSP 0
+    PDSP_ID_QoS_1,                              //  QoS          group - PDSP 1
+
+    PDSP_ID_Recycler,                           //  Recycler PDSP
+    PDSP_ID_Accumulator,                        //  Accumulator PDSP
+    PDSP_ID_Wifi_TX,                            //  Wifi proxy - TX PDSP (Wifi_0)
+    PDSP_ID_Wifi_RX,                            //  Wifi proxy - RX PDSP (Wifi_1)
+    PDSP_ID_Moca,                               //  Moca PDSP
+
+    PDSP_ID_Encrypt,                            // Encrypt (formerly FCC_0)
+    PDSP_ID_Decrypt,                            // Decrypt (formerly FCC_1)
+    PDSP_ID_DPI,                                // DPI PDSP
+    PDSP_ID_Crypto,                             // Crypto ("Security")
+    PDSP_ID_RCE,                                // RCE PDSP
+
+    PDSP_ID_Session_Cache,                      //  Session Cache PDSP
+    PDSP_ID_AQM,                                //  AQM PDSP
+    PDSP_ID_MC,                                 //  MC PDSP
+    PDSP_ID_TurboDOX,                           //  TurboDOX PDSP
+
+    PDSP_ID_DS_RESEQ,
+    PDSP_ID_US_START,                           //  US PDSP first index
+    PDSP_ID_US_Preprocessor = PDSP_ID_US_START, //  US Preprocessing PDSP
+    PDSP_ID_US_Request_Builder,                 //  US REQuest Builder PDSP
+    PDSP_ID_US_Frag_Divert,                     //  US Frag& Divert PDSP
+    PDSP_ID_US_END = PDSP_ID_US_Frag_Divert,    //  US PDSP last index
+    PDSP_ID_MAX
+}pdsp_id_t;
+
+/* PDSP Timers definitions */
+#define AVALANCHE_PDSP_TIMER_CTRL_OFF                       0x00
+#define AVALANCHE_PDSP_TIMER_LOAD_OFF                       0x04
+#define AVALANCHE_PDSP_TIMER_CTRL_PRESCALER_ENABLE_SHIFT    15
+#define AVALANCHE_PDSP_TIMER_CTRL_PRESCALER_VALUE_SHIFT     2
+#define AVALANCHE_PDSP_TIMER_CTRL_AUTO_LOAD_SHIFT           1
+#define AVALANCHE_PDSP_TIMER_CTRL_START_SHIFT               0
+
+#elif defined (AVALANCHE_PDSP_H_PUMA6)
+typedef enum
+{
+    PDSP_ID_START,
+    PDSP_ID_Prefetcher_0 = PDSP_ID_START,   //  Prefetcher   group - PDSP 0
+    PDSP_ID_Classifier1_0,                  //  Classifier1  group - PDSP 0
+    PDSP_ID_Classifier2_0,                  //  Classifier2  group - PDSP 0
+    PDSP_ID_Modifier_0,                     //  Modifier     group - PDSP 0
+    PDSP_ID_QoS_0,                          //  QoS          group - PDSP 0
+    PDSP_ID_LAN_Proxy,                      //  _PrxPDSP only in P6
+    PDSP_ID_CoE,                            //  _CoePDSP only in P6
+    PDSP_ID_MAX
+}pdsp_id_t;
+
+#else // PUMA5
+typedef enum
+{
+    PDSP_ID_START,
+    PDSP_ID_Prefetcher_0 = PDSP_ID_START,   //  Prefetcher
+    PDSP_ID_Classifier1_0,                  //  Classifier
+    PDSP_ID_Modifier_0,                     //  Modifier
+    PDSP_ID_QoS_0,                          //  QoS
+    PDSP_ID_MAX
+}pdsp_id_t;
+#endif
+
+
+typedef Uint32 pdsp_cmd_t;
+
+typedef struct
+{
+    pdsp_id_t       pdsp_id;
+    pdsp_cmd_t      cmd;
+    Uint32          params_len;
+    Uint32          params[64];
+}
+pdsp_cmd_params_t;
+
+/********************************************************************************************************/
+/* IOCTL commands:
+
+   If you are adding new ioctl's to the kernel, you should use the _IO
+   macros defined in <linux/ioctl.h> _IO macros are used to create ioctl numbers:
+
+    _IO(type, nr)         - an ioctl with no parameter.
+   _IOW(type, nr, size)  - an ioctl with write parameters (copy_from_user), kernel would actually read data from user space
+   _IOR(type, nr, size)  - an ioctl with read parameters (copy_to_user), kernel would actually write data to user space
+   _IOWR(type, nr, size) - an ioctl with both write and read parameters
+
+   'Write' and 'read' are from the user's point of view, just like the
+    system calls 'write' and 'read'.  For example, a SET_FOO ioctl would
+    be _IOW, although the kernel would actually read data from user space;
+    a GET_FOO ioctl would be _IOR, although the kernel would actually write
+    data to user space.
+
+    The first argument to _IO, _IOW, _IOR, or _IOWR is an identifying letter
+    or number from the SoC_ModuleIds_e enum located in this file.
+
+    The second argument to _IO, _IOW, _IOR, or _IOWR is a sequence number
+    to distinguish ioctls from each other.
+
+   The third argument to _IOW, _IOR, or _IOWR is the type of the data going
+   into the kernel or coming out of the kernel (e.g.  'int' or 'struct foo').
+
+   NOTE!  Do NOT use sizeof(arg) as the third argument as this results in
+   your ioctl thinking it passes an argument of type size_t.
+
+*/
+#define PDSP_DRIVER_MODULE_ID                   (0xDE)
+
+#define PDSP_DRIVER_RESET_PDSP                      _IOW (PDSP_DRIVER_MODULE_ID,  1, pdsp_id_t)
+#define PDSP_DRIVER_START_PDSP                      _IOW (PDSP_DRIVER_MODULE_ID,  2, pdsp_id_t)
+#define PDSP_DRIVER_DOWNLOAD_START                  _IOW (PDSP_DRIVER_MODULE_ID,  3, pdsp_id_t)
+#define PDSP_DRIVER_DOWNLOAD_FINISH                 _IOW (PDSP_DRIVER_MODULE_ID,  4, pdsp_id_t)
+#define PDSP_DRIVER_TEST_IRAM                       _IOW (PDSP_DRIVER_MODULE_ID,  5, pdsp_id_t)
+#define PDSP_DRIVER_PUT_CMD                         _IOWR(PDSP_DRIVER_MODULE_ID,  6, pdsp_cmd_params_t)
+#define PDSP_DRIVER_SANITY_CHECK_START              _IOW (PDSP_DRIVER_MODULE_ID,  7, pdsp_id_t)
+#define PDSP_DRIVER_EXECUTE_SANITY_CHECK            _IOWR(PDSP_DRIVER_MODULE_ID,  8, pdsp_cmd_params_t)
+#define PDSP_DRIVER_SANITY_CHECK_END                _IOW (PDSP_DRIVER_MODULE_ID,  9, pdsp_id_t)
+#define PDSP_DRIVER_EXECUTE_TURBODOX_SANITY_CHECK   _IOWR(PDSP_DRIVER_MODULE_ID, 10, pdsp_cmd_params_t)
+#define PDSP_DRIVER_HALT_PDSP                       _IOWR(PDSP_DRIVER_MODULE_ID, 11, pdsp_cmd_params_t)
+#define PDSP_DRIVER_RESUME_PDSP                     _IOWR(PDSP_DRIVER_MODULE_ID, 12, pdsp_cmd_params_t)
+#define PDSP_DRIVER_PDSP_BREAKPOINT_ENABLE          _IOWR(PDSP_DRIVER_MODULE_ID, 13, pdsp_cmd_params_t)
+#define PDSP_DRIVER_PDSP_BREAKPOINT_DELETE_ALL      _IOWR(PDSP_DRIVER_MODULE_ID, 14, pdsp_cmd_params_t)
+#define PDSP_DRIVER_PDSP_BREAKPOINT_DISABLE         _IOWR(PDSP_DRIVER_MODULE_ID, 15, pdsp_cmd_params_t)
+#define PDSP_DRIVER_PDSP_BREAKPOINT_PRINT           _IOWR(PDSP_DRIVER_MODULE_ID, 16, pdsp_cmd_params_t)
+#define PDSP_DRIVER_PDSP_SINGLE_STEP_ENABLE         _IOWR(PDSP_DRIVER_MODULE_ID, 17, pdsp_cmd_params_t)
+#define PDSP_DRIVER_PDSP_SINGLE_STEP_DISABLE        _IOWR(PDSP_DRIVER_MODULE_ID, 18, pdsp_cmd_params_t)
+#define PDSP_DRIVER_PDSP_RUN_TO_OP_CODE             _IOWR(PDSP_DRIVER_MODULE_ID, 19, pdsp_cmd_params_t)
+#define PDSP_DRIVER_PDSP_MODIFY_DBG_REG             _IOWR(PDSP_DRIVER_MODULE_ID, 20, pdsp_cmd_params_t)
+#define PDSP_DRIVER_PDSP_SHOW_STATUS                _IOWR(PDSP_DRIVER_MODULE_ID, 21, pdsp_cmd_params_t)
+#define PDSP_DRIVER_PDSP_PRINT_CTRL_REGS            _IOWR(PDSP_DRIVER_MODULE_ID, 22, pdsp_cmd_params_t)
+
+
+#ifdef __KERNEL__
+
+/* Success Code */
+#define SR_RETCODE_SUCCESS          1
+
+/* PDSP error codes */
+#define SRPDSP_ENORES                   -1
+#define SRPDSP_EINVCMD                  -2
+#define SRPDSP_EINVOPT                  -3
+#define SRPDSP_EINVINDEX                -4
+#define SRPDSP_EALREADYOPEN             -5
+#define SRPDSP_ENOTOPEN                 -6
+#define SRPDSP_EMAPERROR                -7
+#define SRPDSP_EINVPORT                 -8
+#define SRPDSP_EINVPID                  -9
+#define SRPDSP_EPAUSELIMITEXCEED        -10
+#define SRPDSP_ESESSIONNOTPAUSED        -11
+#define SRPDSP_ESESSIONPAUSED           -12
+#define SRPDSP_EREOPENINVALID           -13
+#define SRPDSP_EINTERROR                -99
+
+
+
+
+Int32 pdsp_cmd_send    (pdsp_id_t               id,
+                        pdsp_cmd_t              cmd_word,
+                        void *wr_ptr,   Uint32  wr_word,
+                        void *rd_ptr,   Uint32  rd_word);
+
+typedef enum
+{
+    PDSPCTRL_HLT      ,
+    PDSPCTRL_STEP     ,
+    PDSPCTRL_FREERUN  ,
+    PDSPCTRL_RESUME   ,
+    PDSPCTRL_RST      ,
+    PDSPCTRL_START    ,
+}
+pdsp_ctrl_op_t;
+/*
+ * pdsp_control -
+ *
+ * Description: This API provides interface to control PDSPs. Following
+ * operations are supported :-
+ *  PDSPCTRL_HLT
+ *      HALT pdsp execution
+ *  PDSPCTRL_STEP
+ *      Set PDSP Single step mode. This option halts the PDSP and successive
+ *      RESUMEs are carried as single steps.
+ *  PDSPCTRL_FREERUN
+ *      Set free running mode, i.e., disable single step. PDSP execution is
+ *      implicitly RESUMEd as a result of this command.
+ *  PDSPCTRL_RESUME
+ *      RESUME pdsp execution
+ *  PDSPCTRL_RST
+ *      RESET PDSP and start execution from specified program counter. The
+ *      16-bit program counter shoule be passed by ctl_data pointer.
+ *  PDSPCTRL_PSM
+ *      Enable or Disable PSM mode. ctl_data should be passed as pointer to
+ *      boolean (32-bit integer) flag indicating desired enable (!0) or disable
+ *      (0) status of PSM. Note that pdsp_id value is ignored for this option.
+ *
+ * Note:
+ *   Setting option PDSPCTRL_STEP just sets the PDSP in single step
+ *  mode and halts its execution, actual single stepping should be performed by
+ *  calling this API with PDSPCTRL_RESUME option per step till free
+ *  running is enabled explicitly with option PDSPCTRL_FREERUN
+ *  single step or halting the pdsp
+ *
+ * Precondition:
+ *  -   ti_ppd_init
+ *
+ * Parameters:
+ *  id (IN)         - Id of PDSP to control: CPDSP(0), MPDSP(1), QPDSP(2).
+ *  ctl_op (IN)     - Eiter of the PDSP control options as explained above.
+ *  ctl_data (IN)   - Pointer to data corresponding the pdsp control option.
+ *
+ * Return:
+ *  0 on Success, <0 on error.
+ */
+Int32 pdsp_control (pdsp_id_t   pdsp_id, Uint32 ctl_op, Ptr ctl_data);
+
+#endif
+
+#endif
diff --git a/include/linux/avalanche/generic/avalanche_pp_api.h b/include/linux/avalanche/generic/avalanche_pp_api.h
index 2d87d47..8211bfd 100755
--- a/include/linux/avalanche/generic/avalanche_pp_api.h
+++ b/include/linux/avalanche/generic/avalanche_pp_api.h
@@ -1,4 +1,6 @@
 /*
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
 
   GPL LICENSE SUMMARY
 
@@ -25,51 +27,86 @@
   2200 Mission College Blvd.
   Santa Clara, CA  97052
 
+  BSD LICENSE
+
+  Copyright(c) 2014-2016 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
 */
 
 #ifndef     _AVALANCHE_PP_H
 #define     _AVALANCHE_PP_H
-
-#include <linux/avalanche/generic/_tistdtypes.h>
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+#include <asm-arm/arch-avalanche/generic/_tistdtypes.h>
 
 #ifdef __KERNEL__
 
-#ifdef  CONFIG_ARM_AVALANCHE_PDSP_PP
- #define PUMA7_SOC_TYPE 1
- #define PUMA7_OR_NEWER_SOC_TYPE 1
-#else
- #define PUMA7_SOC_TYPE 0
- #define PUMA7_OR_NEWER_SOC_TYPE 0
-#endif
-#define PUMA6_SOC_TYPE 0
-#if PUMA6_SOC_TYPE
+#if defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
 #include <asm-arm/arch-avalanche/puma6/puma6_cppi_prv.h>
 #endif
 
 #if PUMA7_SOC_TYPE
-#include <linux/avalanche/puma7/puma7_cppi.h>
+#include <asm-arm/arch-avalanche/puma7/puma7_cppi.h>
+#include <asm-arm/arch-avalanche/puma7/puma7_pp.h>
 #endif
 
 #else
-#if PUMA6_SOC_TYPE
 #include <puma_autoconf.h>
+#if defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
 #include <puma6_cppi_prv.h>
 #endif
-#if PUMA7_SOC_TYPE
+#ifdef PUMA7_SOC_TYPE
 #include <puma7_cppi_prv.h>
 #endif
+#endif
 
+#else /* AP-CPU */
+#ifdef __KERNEL__
+#include <linux/avalanche/generic/_tistdtypes.h>
+#include <linux/avalanche/puma7/puma7_defs.h>
+#include <linux/avalanche/puma7/puma7_cppi.h>
+#include <linux/avalanche/puma7/puma7_pp.h>
+#else
+#include "_tistdtypes.h"
+#endif
 #endif
 
 #include <linux/ioctl.h>
-
+#include <asm/byteorder.h>
 /**************************************************************************
  ****************************** Limit Definitions *************************
  **************************************************************************/
 
 
 /* These are the maximum number of PID,VPID & Sessions that are supported.*/
-#if PUMA6_SOC_TYPE
+#if defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
 #define AVALANCHE_PP_MAX_PID                            32
 #define AVALANCHE_PP_MAX_VPID                           32
 #define AVALANCHE_PP_MAX_ACCELERATED_SESSIONS           2048
@@ -78,7 +115,7 @@
 #define MAX_ALLOWED_QOS_CLUSTERS_PER_DEVICE             16
 #else
 #define AVALANCHE_PP_MAX_PID                            32
-#define AVALANCHE_PP_MAX_VPID                           32
+#define AVALANCHE_PP_MAX_VPID                           51
 #define AVALANCHE_PP_MAX_STATIC_ENTRIES                 (32 * 1024)
 #define AVALANCHE_PP_MAX_LUT_ENTRIES                    (3 * 1024)
 #define AVALANCHE_PP_MAX_ACCELERATED_SESSIONS           (AVALANCHE_PP_MAX_STATIC_ENTRIES + AVALANCHE_PP_MAX_LUT_ENTRIES)
@@ -136,6 +173,12 @@ typedef struct
     Uint32  WifiRxPDSPver;
     Uint32  MocaPPver;
     Uint32  MocaPDSPver;
+	Uint32  CryptoPPver;
+    Uint32  CryptoPDSPver;
+    Uint32  EncryptPPver;
+    Uint32  EncryptPDSPver;
+    Uint32  DecryptPPver;
+    Uint32  DecryptPDSPver;
     Uint32  IpsecPPver;
     Uint32  IpsecPDSPver;
 
@@ -276,7 +319,7 @@ AVALANCHE_PP_PID_RANGE_t;
 /*                                                                      */
 /*                                                                      */
 /* ******************************************************************** */
-#if PUMA6_SOC_TYPE
+#if defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
 #define AVALANCHE_PP_QOS_CLST_MAX_INDX          31
 #define AVALANCHE_PP_QOS_QUEUE_MAX_INDX         (PAL_CPPI41_SR_QPDSP_QOS_Q_LAST - PAL_CPPI41_SR_QPDSP_QOS_Q_BASE)
 #endif
@@ -435,7 +478,7 @@ typedef struct // former TI_PP_VPID
      * or AVALANCHE_PP_VLAN_PPPoE */
     Uint16                          vlan_identifier;
 
-#if PUMA6_SOC_TYPE
+#if defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
     /* These are the QoS related settings */
     AVALANCHE_PP_QOS_CLST_CFG_t *   qos_cluster[ MAX_ALLOWED_QOS_CLUSTERS_PER_DEVICE ];
     unsigned char                   qos_clusters_count;
@@ -501,7 +544,7 @@ typedef struct // former TI_PP_VPID_STATS
 /*                                                                      */
 /*                                                                      */
 /* ******************************************************************** */
-#if PUMA6_SOC_TYPE
+#if defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
 typedef enum
 {
     AVALANCHE_PP_LUT_ENTRY_L2_ETHERNET,
@@ -742,36 +785,46 @@ typedef enum
 typedef struct
 {
     Uint8       PID;                    /* Type: PP_PID_NUM_e                                    */
+#if defined(__BIG_ENDIAN_BITFIELD)
     Uint8       L2_type:4,              /* Type: PP_LOOKUP_FIELD_L2_TYPES_e                      */
                 L3_type:4;              /* Type: PP_LOOKUP_FIELD_L3_TYPES_e                      */
+#elif defined (__LITTLE_ENDIAN_BITFIELD)
+    Uint8       L3_type:4,              /* Type: PP_LOOKUP_FIELD_L2_TYPES_e                      */
+		L2_type:4;              /* Type: PP_LOOKUP_FIELD_L3_TYPES_e                      */
+#endif
+#if defined(__BIG_ENDIAN_BITFIELD)
     Uint8       L4_Protocol:4,          /* Type: PP_LOOKUP_FIELD_L4_TYPES_e                      */
                 Tunnel_type:4;          /* Type: PP_LOOKUP_FIELD_TUNNEL_TYPE_e                   */
+#elif defined (__LITTLE_ENDIAN_BITFIELD)
+    Uint8       Tunnel_type:4,          /* Type: PP_LOOKUP_FIELD_L4_TYPES_e                      */
+                L4_Protocol:4;          /* Type: PP_LOOKUP_FIELD_TUNNEL_TYPE_e                   */
+#endif
     Uint8       Flags;                	/* Type: PP_LOOKUP_FIELD_FLAGS_e                         */
     Uint8       dstmac[6];              /* Destination MAC address                               */
     Uint8       srcmac[6];              /* Source MAC address                                    */
-    Uint16      Vlan1;                  /* Packet's external VLAN if exists                      */
-    Uint16      Vlan2;                  /* Packet's internal VLAN if exists                      */
+    __be16      Vlan1;                  /* Packet's external VLAN if exists                      */
+    __be16      Vlan2;                  /* Packet's internal VLAN if exists                      */
 
     union
     {
-        Uint32  v4;
-        Uint32  v6[ 4 ];
+        __be32  v4;
+        __be32  v6[ 4 ];
     }
     SRC_IP;                             /* For IPv4 only the first 4 MSB are set, all other bytes must be 0          */
 
     union
     {
-        Uint32  v4;
-        Uint32  v6[ 4 ];
+        __be32  v4;
+        __be32  v6[ 4 ];
     }
     DST_IP;                             /* For IPv4 only the first 4 MSB are set, all other bytes must be 0          */
 
     Uint8       IPv6_Flow_Label[4];     /* IPv6 Flow Label (MSbits must be 0). For DS-Lite holds IPv4 destination IP */
     Uint8       ToS;                    /* IP TOS for IPv4, Traffic Class for IPv6               */
     Uint8       Reserved;               /* Must be 0                                             */
-    Uint16      PPPoE_session_id;       /* 0xFFFF if none                                        */
-    Uint16      L4_SRC_PORT;            /* UDP/TCP Source       Port. If not set, must be 0      */
-    Uint16      L4_DST_PORT;            /* UDP/TCP Destintation Port. If not set, must be 0      */
+    __be16      PPPoE_session_id;       /* 0xFFFF if none                                        */
+    __be16      L4_SRC_PORT;            /* UDP/TCP Source       Port. If not set, must be 0      */
+    __be16      L4_DST_PORT;            /* UDP/TCP Destintation Port. If not set, must be 0      */
 }
 __Avalanche_PP_LUTs_Data_t;
 
@@ -805,7 +858,7 @@ typedef struct // former TI_PP_SESSION_PROPERTY
 #endif
     Uint16                              reserved1;
 
-#if PUMA6_SOC_TYPE
+#if defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
     Bool                                isTunnel;
 #endif
     __Avalanche_PP_LUTs_Data_t          lookup;
@@ -859,6 +912,21 @@ typedef struct
 }
 AVALANCHE_PP_PSI_t;
 #endif
+
+#ifdef CONFIG_WIFI_PROXY
+/**
+ * @class wifi traffic class
+ * @vpid vpid of wifi device
+ * @wifi_session_info wifi specific session info
+ *
+ */
+struct wifi_proxy_psi_t {
+    Uint8  class;
+    Uint8  vpid;
+    Uint16 wifi_session_info;
+};
+#endif
+
 #ifndef CONFIG_WIFI_MESH_TUNNEL
 #define AVALANCHE_PP_EGRESS_DROP_SESS    0x01
 
@@ -883,6 +951,7 @@ typedef struct
                                 #define AVALANCHE_PP_EGRESS_FIELD_ENABLE_DOCSIS                 0x08
                                 #define AVALANCHE_PP_EGRESS_WH_IPv4                             0x10
                                 #define AVALANCHE_PP_EGRESS_WH_IPv6                             0x20
+                                #define AVALANCHE_PP_EGRESS_WIFI_PID                            0x40
     Uint16                      reserved;
 
     __Avalanche_PP_LUTs_Data_t  lookup;
@@ -891,6 +960,9 @@ typedef struct
 
     union
     {
+#ifdef CONFIG_WIFI_PROXY
+        struct wifi_proxy_psi_t wifi_psi;
+#endif
         AVALANCHE_PP_PSI_t      us_fields;
         Uint32                  psi_word;
     }
@@ -1026,7 +1098,7 @@ typedef struct // former TI_PP_SESSION
      * successful creation of the session. */
     Uint32                  session_handle;
 
-#if PUMA6_SOC_TYPE
+#if defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
     /* Session Timeout indicates the number of micro-seconds of inactivity
      * after which the PP generates an event to the host. The field if set
      * to 0 indicates that the session needs to be configured permanently
@@ -1129,6 +1201,70 @@ PP_HAL_SESSION_RECORD_NON_ACCELERATED_STATS_t;
  *  The structure describes the global statistics for the Packet Processor.
  **************************************************************************/
 #if PUMA7_OR_NEWER_SOC_TYPE
+
+typedef struct
+{
+    Uint32  cmp_recv      ;
+    Uint32  cmp_recv_valid;
+    Uint32  cmp_irq_cnt   ;
+    Uint32  req_sent      ;
+    Uint32  req_irq_cnt   ;
+    Uint32  dev_cnt5      ;
+
+} wifi_tx_dev_stats_t;
+
+typedef struct
+{
+    Uint32  req_recv      ;
+    Uint32  req_recv_valid;
+    Uint32  req_irq_cnt   ;
+    Uint32  cmp_sent      ;
+    Uint32  cmp_irq_cnt   ;
+    Uint32  dev_cnt5      ;
+} wifi_rx_dev_stats_t;
+
+typedef struct
+{
+    /* global */
+    Uint32  rx_pkts                ;
+    Uint32  tx_pkts                ;
+    Uint32  cmp_null_buffer        ;
+    Uint32  cmp_ring_full          ;
+    Uint32  cmp_ring_empty         ;
+    Uint32  cmp_pattern_buffer     ;
+    Uint32  req_int_desc_starvation;
+    Uint32  req_ring_full          ;
+    Uint32  req_ring_empty         ;
+    Uint32  req_ring_ooo           ;
+} avalanche_pp_wifi_tx_stats_t;
+
+typedef struct
+{
+    Uint32 rx_pkts            ;
+    Uint32 tx_pkts            ;
+    Uint32 req_desc_starvation;
+    Uint32 req_null_buffer    ;
+    Uint32 req_zero_date_len  ;
+    Uint32 req_ring_full      ;
+    Uint32 req_ring_empty     ;
+    Uint32 cmp_buff_starvation;
+    Uint32 cmp_ring_full      ;
+    Uint32 cmp_ring_empty     ;
+} avalanche_pp_wifi_rx_stats_t;
+
+typedef struct
+{
+    avalanche_pp_wifi_tx_stats_t tx_stats;
+    avalanche_pp_wifi_rx_stats_t rx_stats;
+#ifdef __KERNEL__
+    wifi_tx_dev_stats_t tx_dev_stats[WIFI_DEVS_CNT];
+    wifi_rx_dev_stats_t rx_dev_stats[WIFI_DEVS_CNT];
+#else
+    wifi_tx_dev_stats_t tx_dev_stats[4];
+    wifi_rx_dev_stats_t rx_dev_stats[4];
+#endif
+} avalanche_pp_wifi_stats_t;
+
 typedef struct
 {
     /* Classifier1 */
@@ -1257,10 +1393,10 @@ typedef struct
 
     Uint32      AQM_pkts_frwrd_to_QoS;
     Uint32      AQM_pkts_discarded;
-    Uint32      AQM_res3;
-    Uint32      AQM_res4;
-    Uint32      AQM_res5;
-    Uint32      AQM_res6;
+    Uint32      AQM_move_to_dls_interrupt;
+    Uint32      AQM_move_to_normal_mode_intrpt;
+    Uint32      AQM_sent_wakeup_upon_timer_expiry;
+    Uint32      AQM_sent_wakeup_upon_bytes_thrshold_crossed;
     Uint32      AQM_res7;
     Uint32      AQM_res8;
 
@@ -1290,55 +1426,7 @@ typedef struct
     Uint32      MC_res15;
     Uint32      MC_res16;
 
-    Uint32      WiFi_TX_res1;
-    Uint32      WiFi_TX_res2;
-    Uint32      WiFi_TX_res3;
-    Uint32      WiFi_TX_res4;
-    Uint32      WiFi_TX_res5;
-    Uint32      WiFi_TX_res6;
-    Uint32      WiFi_TX_res7;
-    Uint32      WiFi_TX_res8;
-    Uint32      WiFi_TX_res9;
-    Uint32      WiFi_TX_res10;
-    Uint32      WiFi_TX_res11;
-    Uint32      WiFi_TX_res12;
-    Uint32      WiFi_TX_res13;
-    Uint32      WiFi_TX_res14;
-    Uint32      WiFi_TX_res15;
-    Uint32      WiFi_TX_res16;
-    Uint32      WiFi_TX_res17;
-    Uint32      WiFi_TX_res18;
-    Uint32      WiFi_TX_res19;
-    Uint32      WiFi_TX_res20;
-    Uint32      WiFi_TX_res21;
-    Uint32      WiFi_TX_res22;
-    Uint32      WiFi_TX_res23;
-    Uint32      WiFi_TX_res24;
-
-    Uint32      WiFi_RX_res1;
-    Uint32      WiFi_RX_res2;
-    Uint32      WiFi_RX_res3;
-    Uint32      WiFi_RX_res4;
-    Uint32      WiFi_RX_res5;
-    Uint32      WiFi_RX_res6;
-    Uint32      WiFi_RX_res7;
-    Uint32      WiFi_RX_res8;
-    Uint32      WiFi_RX_res9;
-    Uint32      WiFi_RX_res10;
-    Uint32      WiFi_RX_res11;
-    Uint32      WiFi_RX_res12;
-    Uint32      WiFi_RX_res13;
-    Uint32      WiFi_RX_res14;
-    Uint32      WiFi_RX_res15;
-    Uint32      WiFi_RX_res16;
-    Uint32      WiFi_RX_res17;
-    Uint32      WiFi_RX_res18;
-    Uint32      WiFi_RX_res19;
-    Uint32      WiFi_RX_res20;
-    Uint32      WiFi_RX_res21;
-    Uint32      WiFi_RX_res22;
-    Uint32      WiFi_RX_res23;
-    Uint32      WiFi_RX_res24;
+    avalanche_pp_wifi_stats_t wifi_stats;
 
     Uint32      MoCA_rx_pkts;
     Uint32      MoCA_tx_pkts;
@@ -1352,8 +1440,14 @@ typedef struct
 
 typedef struct
 {
-    Uint64 ds_received_packets;
-} AVALANCHE_PP_DS_STATS_t;
+    Uint32      NoSessionCounter;
+    Uint32      NoSessionFragCounter;
+    Uint32      MinimumSessionCounter;
+    Uint32      UsDocsisTcpSessionCounter;
+    Uint32      TunnelEncapSessionCounter;
+    Uint32      TunnelDecapSessionCounter;
+    Uint32      TunnelEncapUsDocsisTcpSessionCounter;
+}AVALANCHE_HOP_LIST_STATS_t;
 
 #define AVALANCHE_PP_US_SERVICE_FLOW_COUNTERS 16
 typedef struct
@@ -1369,8 +1463,7 @@ typedef struct
     AVALANCHE_PP_STAGE1_STATS_t         stage1;
     AVALANCHE_PP_STAGE2_Part1_STATS_t   stage2_1;
     AVALANCHE_PP_STAGE2_Part2_STATS_t   stage2_2;
-    //AVALANCHE_PP_DS_STATS_t ds;
-    //AVALANCHE_PP_US_STATS_t us;
+    AVALANCHE_HOP_LIST_STATS_t          hopListCounters;                        /* Not PP counters */
 } AVALANCHE_PP_GLOBAL_STATS_t;
 
 #else
@@ -1471,13 +1564,18 @@ extern AVALANCHE_PP_RET_e    avalanche_pp_wifi_mesh_get_vpid_packet_header_size
 #endif
 /* Session Management API */
 extern AVALANCHE_PP_RET_e    avalanche_pp_session_create        ( AVALANCHE_PP_SESSION_INFO_t *  ptr_session, void * pkt_ptr );
+#if PUMA7_OR_NEWER_SOC_TYPE
+extern AVALANCHE_PP_RET_e    avalanche_pp_session_delete        ( Uint32    session_handle,     AVALANCHE_PP_SESSION_STATS_t *  ptr_session_stats, Bool deleteFromFW );
+#else
 extern AVALANCHE_PP_RET_e    avalanche_pp_session_delete        ( Uint32    session_handle,     AVALANCHE_PP_SESSION_STATS_t *  ptr_session_stats );
+#endif
 extern AVALANCHE_PP_RET_e    avalanche_pp_session_get_list      ( Uint8     vpid_handle,        PP_LIST_ID_e   list_id, Uint32 * num_entries, Uint32 * session_handle_list );
 extern AVALANCHE_PP_RET_e    avalanche_pp_session_get_info      ( Uint32    session_handle,     AVALANCHE_PP_SESSION_INFO_t**  ptr_session_info );
 extern AVALANCHE_PP_RET_e    avalanche_pp_session_set_timeout   (Uint8 timeoutSeconds);
 extern AVALANCHE_PP_RET_e    avalanche_pp_flush_sessions        ( Uint8     vpid_handle, PP_LIST_ID_e   list_id );
 
 extern AVALANCHE_PP_RET_e   avalanche_pp_session_list_execute      ( Uint8     vpid_handle, PP_LIST_ID_e   list_id,    AVALANCHE_EXEC_HOOK_FN_t   handler, Ptr  data );
+extern AVALANCHE_PP_RET_e   avalanche_pp_flush_sessions_per_mac    ( Uint8     mac[6]);
 extern AVALANCHE_PP_RET_e   avalanche_pp_session_pre_action_bind   ( Uint8     vpid_handle,                            AVALANCHE_EXEC_HOOK_FN_t   handler, Ptr  data );
 extern AVALANCHE_PP_RET_e   avalanche_pp_session_post_action_bind  ( Uint8     vpid_handle,                            AVALANCHE_EXEC_HOOK_FN_t   handler, Ptr  data );
 
@@ -1489,7 +1587,8 @@ extern AVALANCHE_PP_RET_e   avalanche_pp_modify_stats_counters      ( Uint32 ses
 extern AVALANCHE_PP_RET_e   avalanche_pp_get_stats_session          ( Uint32 session_handle, AVALANCHE_PP_SESSION_STATS_t* ptr_session_stats );
 extern AVALANCHE_PP_RET_e   avalanche_pp_get_stats_vpid             ( Uint8  vpid_handle, AVALANCHE_PP_VPID_STATS_t* ptr_vpid_stats );
 extern AVALANCHE_PP_RET_e   avalanche_pp_get_stats_global           ( AVALANCHE_PP_GLOBAL_STATS_t* ptr_stats );
-extern AVALANCHE_PP_RET_e   avalanche_pp_reset_stats_globa          ( void );
+extern AVALANCHE_PP_RET_e   avalanche_pp_reset_stats_global                 ( void );
+extern void                 avalanche_pp_substract_stats_global_counters(AVALANCHE_PP_GLOBAL_STATS_t* old_stats, AVALANCHE_PP_GLOBAL_STATS_t* new_stats);
 
 #ifdef CONFIG_WIFI_MESH_TUNNEL
 
@@ -1531,7 +1630,7 @@ extern AVALANCHE_PP_RET_e   avalanche_pp_event_handler_register     ( Uint32 *
 extern AVALANCHE_PP_RET_e   avalanche_pp_event_handler_unregister   ( Uint32    handle_event_handler );
 extern AVALANCHE_PP_RET_e   avalanche_pp_event_report( AVALANCHE_PP_EVENT_e  event, Uint32 param1, Uint32 param2 );
 
-#if PUMA6_SOC_TYPE
+#if defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
 /* QoS API. */
 extern AVALANCHE_PP_RET_e   avalanche_pp_qos_cluster_setup      ( Uint8     clst_indx,  AVALANCHE_PP_QOS_CLST_CFG_t*    clst_cfg );
 extern AVALANCHE_PP_RET_e   avalanche_pp_qos_cluster_enable     ( Uint8     clst_indx );
@@ -1569,7 +1668,7 @@ typedef struct
     Uint32                              lut2_starvation;
     Uint32                              tdox_starvation;
 
-#if PUMA6_SOC_TYPE
+#if defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
     Uint32                              lut1_histogram[AVALANCHE_PP_LUT_HISTOGRAM_SIZE];
     Uint32                              lut1_starvation;
     Uint32                              active_lut1_keys;
@@ -1598,6 +1697,397 @@ extern AVALANCHE_PP_RET_e    avalanche_pp_modify_stats_counters   ( Uint32 sessi
 extern Bool                  avalanche_pp_state_is_active( void );
 extern Bool                  avalanche_pp_state_is_psm( void );
 
+/*---------------------*/
+/*    WIFI Proxy       */
+/*---------------------*/
+#ifdef CONFIG_WIFI_PROXY
+
+/**
+ * Ring configuration structure for the sender entity
+ * @base_addr ring base address
+ * @elem_sz_order element size power of 2 order
+ * @sz_mask ring size mask, number of elements can be written to
+ *          the ring in a mask form, (4 elements) = 0b11, (8
+ *          elements) = 0b111 and so on
+ * @hw_cnt_addr HW counter address
+ * @rmt_head_ptr_addr remote head pointer address
+ * @note this struct is aligned to wifi fw pdsps mailbox
+ *       commands, DO NOT change it.
+ * @note this struct MUST be 4 bytes aligned
+ */
+struct send_ring_t {
+    Uint32  base_addr;
+    Uint16  elem_sz_order;
+    Uint16  sz_mask;
+    Uint32  hw_cnt_addr;
+    Uint32  rmt_head_ptr_addr;
+};
+
+/**
+ * Ring configuration structure for the receiver entity
+ * @base_addr ring base address
+ * @elem_sz_order element size power of 2 order
+ * @sz_mask ring size mask, number of elements can be written to
+ *          the ring in a mask form, (4 elements) = 0b11, (8
+ *          elements) = 0b111 and so on
+ * @hw_cnt_addr HW counter address
+ * @rmt_tail_ptr_addr remote tail pointer address
+ * @note this struct is aligned to wifi fw pdsps mailbox
+ *       commands, DO NOT change it.
+ * @note this struct MUST be 4 bytes aligned
+ */
+struct recv_ring_t {
+    Uint32  base_addr;
+    Uint16  elem_sz_order;
+    Uint16  sz_mask;
+    Uint32  hw_cnt_addr;
+    Uint32  rmt_tail_ptr_addr;
+};
+
+/**
+ * wifi tx channel rings configuration, FW to wifi SOC
+ * @req_ring used by the FW to send packets to wifi SOC
+ * @cmp_ring used by the wifi SOC to recycle buffers back to FW
+ * @note this struct MUST be 4 bytes aligned
+ */
+struct wifi_proxy_tx_ch_t {
+    struct send_ring_t req_ring;
+    struct recv_ring_t cmp_ring;
+};
+
+/**
+ * wifi rx channel rings configuration, wifi SOC to FW
+ * @req_ring used by FW to send wifi SOC empty buffers to use
+ * @cmp_ring used by wifi SOC to send packets to FW
+ * @note this struct MUST be 4 bytes aligned
+ */
+struct wifi_proxy_rx_ch_t {
+    struct send_ring_t cmp_ring;
+    struct recv_ring_t req_ring;
+};
+
+/**
+ * wifi device channel configuration.
+ * @wifi_dev_id device's index
+ * @tx_channel tx channel configuration
+ * @rx_channel rx channel configuration
+ */
+struct wifi_proxy_dev_ch_t {
+    wifi_dev_id_e       wifi_dev_id;
+    struct wifi_proxy_tx_ch_t tx_channel;
+    struct wifi_proxy_rx_ch_t rx_channel;
+};
+
+/**
+ * wifi_proxy_fw_init_info_t
+ * @bMgr tx & rx buffers's buffer manager
+ * @bPool tx & rx buffers's buffer pool
+ * @tx_int_qMgr tx pdsp internal descriptors free queue manager
+ * @tx_int_qNum tx pdsp internal descriptors free queue number
+ * @tx_int_cnt number of desriptors in tx_int free queue
+ * @rx_freeQNum rx pdsp free queue number
+ * @rx_freeQMgr rx pdsp free queue manager number
+ * @rx_destQNum rx pdsp destination queue number
+ * @rx_destQMgr rx pdsp destination queue manager number
+ */
+struct wifi_proxy_fw_init_info_t {
+    Uint32 bMgr;
+    Uint32 bPool;
+    Uint32 tx_int_qMgr;
+    Uint32 tx_int_qNum;
+    Uint32 tx_int_cnt;
+    Uint32 rx_freeQNum;
+    Uint32 rx_freeQMgr;
+    Uint32 rx_destQNum;
+    Uint32 rx_destQMgr;
+};
+
+#ifdef CONFIG_WIFI_PROXY_DEBUG
+/**
+ * wifi_proxy_debug_init_info_t
+ * @counter_index PP's debug IP counter index (0-3)
+ * @buff_start_addr FW's log messages buffer start address, this
+ *                  will be configured to the counter start
+ *                  address register
+ * @buff_end_addr FW's log messages buffer end address, this
+ *                will be configured to the counter roll over
+ *                register
+ */
+struct wifi_proxy_debug_init_info_t {
+    Uint32 counter_index;
+    Uint32 buff_start_addr;
+    Uint32 buff_end_addr;
+};
+#endif
+
+/**
+ * init info for initializing wifi proxy.
+ * @buffers_base_addr base address to use for buffer pool.
+ * @buffer_sz buffer size of each buffer.
+ * @buffer_cnt number of buffers.
+ */
+struct wifi_proxy_init_info_t {
+    Uint32 buffers_base_addr;
+    Uint32 buffer_sz;
+    Uint32 buffer_cnt;
+};
+
+/**
+ * wifi_proxy_init_ret_info_t
+ * info returned as reply to wifi_proxy_init_info_t
+ * @addresses addresses to map by atom
+ * @lengths addresses lengths
+ */
+struct wifi_proxy_init_ret_info_t {
+    Uint32 addresses[2];
+    Uint32 lengths[2];
+};
+
+/**
+ * wifi device indexes enumeration
+ */
+typedef enum {
+    WIFI_DEV_MODE_PARTIAL,
+    WIFI_DEV_MODE_FULL,
+    WIFI_DEV_MODES_CNT
+} wifi_dev_mode_e;
+
+/**
+ * wifi_proxy_add_ch_info_t
+ * @dev_id device id
+ * @tx_ch tx channel configuration, fw to wifi soc
+ * @rx_ch rx channel configuration, wifi soc to fw 
+ * @f_mode specify if the device is working in full offload mode
+ * @author iemergi (2/2/2016)
+ */
+struct wifi_proxy_add_ch_info_t {
+    wifi_dev_id_e               dev_id;
+    struct wifi_proxy_tx_ch_t   tx_ch;
+    struct wifi_proxy_rx_ch_t   rx_ch;
+    wifi_dev_mode_e             mode;
+};
+
+/**
+ * wifi proxy add channel return structure
+ * @fw_to_dev_req_tail_addr fw to dev request ring tail pointer
+ *                   address in PDSP's local memory (DMEM)
+ * @fw_to_dev_cmp_head_addr fw to dev complete ring head pointer
+ *                   address in PDSP's local memory (DMEM)
+ * @dev_to_fw_cmp_tail_addr dev to fw complete ring tail pointer
+ *                   address in PDSP's local memory (DMEM)
+ * @dev_to_fw_req_head_addr dev to fw request ring head pointer
+ *                   address in PDSP's local memory (DMEM)
+ */
+struct wifi_proxy_add_ch_ret_info_t {
+    Uint32 fw_to_dev_req_tail_addr;
+    Uint32 fw_to_dev_cmp_head_addr;
+    Uint32 dev_to_fw_cmp_tail_addr;
+    Uint32 dev_to_fw_req_head_addr;
+};
+
+/**
+ * wifi device statistics structure.
+ * @tx_req_sent_pkt_num number of packets sent on tx request
+ *                      ring
+ * @tx_cmp_recv_pkt_num number of packets receive on tx complete
+ *                      ring
+ * @rx_cmp_sent_pkt_num number of packets sent on rx complete
+ *                      ring
+ * @rx_req_recv_pkt_num number of packets received on rx request
+ *                      ring
+ */
+struct pp_hal_wifi_device_stats{
+    wifi_dev_state_e state;
+    Uint32 tx_req_sent_pkt_num;
+    Uint32 tx_cmp_recv_pkt_num;
+    Uint32 rx_cmp_sent_pkt_num;
+    Uint32 rx_req_recv_pkt_num;
+};
+
+#define WIFI_TX_PDSP_DMEM_CTRL_OFFSET               0x100
+#define WIFI_TX_PDSP_DMEM_CTRL_DESC_PER_DEVS        0x000 + WIFI_TX_PDSP_DMEM_CTRL_OFFSET
+#define WIFI_TX_PDSP_DMEM_CTRL_PDSP_COPY_CNT_HIST   0x010 + WIFI_TX_PDSP_DMEM_CTRL_OFFSET
+#define WIFI_TX_PDSP_DMEM_DEVICE_CTRL_OFFSET        0x080 + WIFI_TX_PDSP_DMEM_CTRL_OFFSET
+#define WIFI_TX_PDSP_DMEM_DEVICE_DB_OFFSET          0x200
+#define WIFI_RX_PDSP_DMEM_CTRL_OFFSET               0x100
+#define WIFI_RX_PDSP_DMEM_CTRL_PDSP_COPY_CNT_HIST   0x000 + WIFI_RX_PDSP_DMEM_CTRL_OFFSET
+#define WIFI_RX_PDSP_DMEM_DEVICE_CTRL_OFFSET        0x080 + WIFI_RX_PDSP_DMEM_CTRL_OFFSET
+#define WIFI_RX_PDSP_DMEM_DEVICE_DB_OFFSET          0x200
+
+/**
+ * proxy tx pdsp devices control register layout
+ *
+ * @suspend specify if the device is in suspend state
+ * @valid specify if the device's entry is valid
+ * @stat_counters_off offset to device's statistical counters
+ * @free_buffers number of buffers the device can use
+ * @max_buffers maximum number of buffers the device can use
+ *
+ * @note the struct contains reserve fields in order to be align to
+ * the actual memory layout
+ */
+struct __attribute__((packed)) fw_tx_pdsp_devs_ctrl_reg {
+#if defined(__BIG_ENDIAN_BITFIELD)
+    Uint8   reserve:1,
+            pdsp_res:2,
+            mode:1,
+            cmp_irq:1,
+            req_irq:1,
+            suspend:1,
+            valid:1;
+#elif defined (__LITTLE_ENDIAN_BITFIELD)
+    Uint8   valid:1,
+            suspend:1,
+            req_irq:1,
+            cmp_irq:1,
+            mode:1,
+            pdsp_res:2,
+            reserve:1;
+#endif
+    Uint8   Breserve0;
+
+    Uint16  stat_counters_off;
+    Uint16  free_buffers;
+    Uint16  max_buffers ;
+};
+
+/**
+ * proxy tx pdsp devices database entry structure
+ *
+ * @req_ring request ring structure
+ * @req_ring_head request ring head pointer
+ * @req_ring_tail request ring tail pointer
+ * @cmp_ring complete request structure
+ * @cmp_ring_head complete ring head pointer
+ * @cmp_ring_tail complete ring tail pointer
+ * @mcdma_page_offset the offset to the page the McDMA is using
+ * @mcdma_page_num_entries number of entries ceing copied to
+ *                         mcdma_page_offset
+ * @mcdma_done_page_offset the offset to the page the McDMA is
+ *                         done using
+ * @mcdma_done_num_entries number of entries copied to
+ *                         mcdma_done_page_offset
+ * @pdsp_page_offset offset to next free page the pdsp can use
+ * @mcdma_ch_regs_offset the offset to mcdma channel regs that
+ *                       the device is using
+ * @pagesBase mcdma pages base offset
+ *
+ */
+struct __attribute__((packed)) fw_tx_pdsp_devs_db_entry {
+    /* request ring */
+    struct send_ring_t req_ring;
+    Uint32             req_ring_head;
+    Uint32             req_ring_tail;
+    /* request ring control */
+    Uint16             internal_q_off;
+    Uint16             infra_dma_q;
+    Uint8              seq_num;
+    Uint8              next_exp_seq_num;
+    Uint8              internal_desc_use_cnt;
+    Uint8              num_elemments_pushed;
+    /* complete ring */
+    struct recv_ring_t cmp_ring;
+    Uint32             cmp_ring_head;
+    Uint32             cmp_ring_tail;
+    /* complete ring control */
+    Uint16  mcdma_page_offset;
+    Uint16  pdsp_page_offset;
+    Uint8   mcdma_page_num_entries;
+    Uint8   mcdma_ch_regs_offset;
+    Uint16  pagesBase;
+};
+
+/**
+ * proxy rx pdsp devices control register layout
+ *
+ * @suspend specify if the device is in suspend state
+ * @valid specify if the device's entry is valid
+ * @pid device's pid
+ * @stat_counters_off offset to device's statistical counters
+ * @free_buffers number of buffers the device can use
+ * @max_buffers maximum number of buffers the device can use
+ *
+ * @note the struct contains reserve fields in order to be align to
+ * the actual memory layout
+ */
+struct __attribute__((packed)) fw_rx_pdsp_devs_ctrl_reg {
+#if defined(__BIG_ENDIAN_BITFIELD)
+    Uint8   reserve:3,
+            mode:1,
+            cmp_irq:1,
+            req_irq:1,
+            suspend:1,
+            valid:1;
+#elif defined (__LITTLE_ENDIAN_BITFIELD)
+    Uint8   valid:1,
+            suspend:1,
+            req_irq:1,
+            cmp_irq:1,
+            mode:1,
+            reserve:3;
+#endif
+    Uint8   pid;
+    Uint16  stat_counters_off;
+    Uint16  free_buffers;
+    Uint16  max_buffers ;
+};
+/**
+ * proxy rx pdsp devices database entry structure
+ *
+ * @cmp_ring complete ring structure
+ * @cmp_ring_head complete ring head pointer
+ * @cmp_ring_tail complete ring tail pointer
+ * @devBuffersLack specify how much buffers needs to be send to
+ *                 the device on complete ring
+ * @req_ring request ring structure
+ * @req_ring_head request ring head pointer
+ * @req_ring_tail request ring tail pointer
+ * @mcdma_page_offset the offset to the page the McDMA is using
+ * @mcdma_page_num_entries number of entries ceing copied to
+ *                         mcdma_page_offset
+ * @mcdma_done_page_offset the offset to the page the McDMA is
+ *                         done using
+ * @mcdma_done_num_entries number of entries copied to
+ *                         mcdma_done_page_offset
+ * @mcdma_ch_regs_offset the offset to mcdma channel regs that
+ *                       the device is using
+ * @pdsp_page_offset offset to next free page the pdsp can use
+ * @pagesBase mcdma pages base offset
+ * @note the struct contains reserve fields in order to be
+ * align to the actual memory layout
+ */
+struct __attribute__((packed, aligned(64))) fw_rx_pdsp_devs_db_entry {
+    /* complete ring */
+    struct recv_ring_t cmp_ring;
+    Uint32             cmp_ring_head;
+    Uint32             cmp_ring_tail;
+    /* request ring control */
+    Uint16  devBuffersLack;
+    Uint16  Reserved16;
+    Uint32  Reserved32;
+    /* request ring */
+    struct send_ring_t req_ring;
+    Uint32             req_ring_head;
+    Uint32             req_ring_tail;
+    /* request ring control */
+    Uint16  mcdma_page_offset;
+    Uint16  next_free_page_offset;
+    Uint8   mcdma_page_num_entries;
+    Uint8   mcdma_ch_regs_offset;
+    Uint16  pagesBase;
+};
+
+AVALANCHE_PP_RET_e avalanche_pp_wifi_init(struct wifi_proxy_fw_init_info_t *init_info);
+AVALANCHE_PP_RET_e avalanche_pp_wifi_set_max_copy_burst(Uint8 max_burst);
+AVALANCHE_PP_RET_e avalanche_pp_add_wifi_dev_ch(struct wifi_proxy_add_ch_info_t *info,
+                                                struct wifi_proxy_add_ch_ret_info_t *ret_vals);
+AVALANCHE_PP_RET_e avalanche_pp_rem_wifi_dev_ch(wifi_dev_id_e wifi_dev_id);
+AVALANCHE_PP_RET_e avalanche_pp_start_wifi_dev_ch(wifi_dev_id_e wifi_dev_id);
+AVALANCHE_PP_RET_e avalanche_pp_stop_wifi_dev_ch(wifi_dev_id_e wifi_dev_id);
+AVALANCHE_PP_RET_e avalanche_pp_get_dev_ch_stats(wifi_dev_id_e dev_id,
+                                                 struct pp_hal_wifi_device_stats *dev_stats);
+
+#endif
 
 #if 0
 
@@ -1613,7 +2103,7 @@ typedef     Uint8     avalanche_pp_psm_ioctl_param_t;
 typedef     Uint32    avalanche_pp_frag_mode_ioctl_param_t;
 typedef     Uint8     avalanche_pp_mtaMacAddr_ioctl_param_t[6];
 
-#if PUMA6_SOC_TYPE
+#if defined(PUMA6_SOC_TYPE) && PUMA6_SOC_TYPE
 typedef     struct
 {
 
diff --git a/include/linux/avalanche/generic/modphy_mrpc_api.h b/include/linux/avalanche/generic/modphy_mrpc_api.h
new file mode 100644
index 0000000..8af6572
--- /dev/null
+++ b/include/linux/avalanche/generic/modphy_mrpc_api.h
@@ -0,0 +1,159 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+/*------------------------------------------------------------------------------
+* File Name: modphy_mrpc_api.h
+* Description:
+* modphy mrpc client driver api
+*------------------------------------------------------------------------------
+*/
+
+#ifndef  MODPHY_MRPC_API_H
+#define  MODPHY_MRPC_API_H
+/**************************************************************************/
+/*      INCLUDES:                                                         */
+/**************************************************************************/
+
+/**************************************************************************/
+/*      INTERFACE  DEFINES AND STRUCTS                                    */
+/**************************************************************************/
+
+#define MODPHY_OK   (0)
+#define MODPHY_FAIL (-1)
+
+typedef enum modphyController_e
+{
+    MODPHY_MOCA_CLIENT_ID,
+    MODPHY_DOCSIS_QAM_25MHZ_CLIENT_ID,
+	MODPHY_DOCSIS_OFDM_25MHZ_CLIENT_ID,
+    MODPHY_SGMII0_1G_CLIENT_ID,
+	MODPHY_SGMII1_1G_CLIENT_ID,
+    MODPHY_SGMII0_2_5G_CLIENT_ID,
+    MODPHY_SGMII1_2_5G_CLIENT_ID,
+    MODPHY_MOCA_50MHZ_CLIENT_ID,
+    MODPHY_DOCSIS_QAM_50MHZ_CLIENT_ID,
+	MODPHY_DOCSIS_OFDM_50MHZ_CLIENT_ID,
+    MODPHY_NUM_OF_CLIENTS
+}ModphyController_e;
+
+typedef enum modphyLanes_e
+{
+    MODPHY_LANE_0,
+    MODPHY_LANE_1,
+	MODPHY_LANE_2,
+    MODPHY_MAX_NUM_OF_LANES
+}ModphyLanes_e;
+
+typedef struct modphyClient_t
+{
+    ModphyController_e clientId;
+    ModphyLanes_e      laneId;
+}ModphyClient_t;
+
+/*********************************************************************************************************/
+/*! \fn int modphy_init(ModphyController_e modphyClientId)
+ *********************************************************************************************************
+ *  \brief  This function inits the modphy for a specific client.
+ *  \param[in] modphyClientId : Client ID
+ *  \return MODPHY_OK if writing succeed otherwise MODPHY_FAIL
+ ********************************************************************************************************/
+int modphy_init(ModphyController_e modphyClientId);
+
+/*********************************************************************************************************/
+/*! \fn int modphy_configure(ModphyController_e modphyClientId)
+ *********************************************************************************************************
+ *  \brief  This function configure the modphy for a specific client.
+ *  \param[in] modphyClientId : Client ID
+ *  \return MODPHY_OK if writing succeed otherwise MODPHY_FAIL
+ ********************************************************************************************************/
+int modphy_lane_configure(ModphyLanes_e lane, ModphyController_e modphyClientId);
+
+/*********************************************************************************************************/
+/*! \fn int modphy_tx_disable(ModphyLanes_e lane, ModphyController_e modphyClientId)
+ *********************************************************************************************************
+ *  \brief  This function disable TX lanes
+ *  \param[in] modphyClientId : Client ID
+ *  \return MODPHY_OK if writing succeed otherwise MODPHY_FAIL
+ ********************************************************************************************************/
+int modphy_tx_disable(ModphyLanes_e lane, ModphyController_e modphyClientId);
+
+/*********************************************************************************************************/
+/*! \fn int modphy_reset_k_align(ModphyController_e modphyClientId)
+ *********************************************************************************************************
+ *  \brief  This function reset K alignment in modphy
+ *  \param[in] modphyClientId : Client ID
+ *  \return MODPHY_OK if writing succeed otherwise MODPHY_FAIL
+ ********************************************************************************************************/
+int modphy_reset_k_align(ModphyController_e modphyClientId);
+
+/*********************************************************************************************************/
+/*! \fn void modphy_reset_client(ModphyController_e modphyClientId)
+ *********************************************************************************************************
+ *  \brief  This function resets ModPhy client. Used for ext.switches WA. Can be scheduled out.
+ *  \param[in] modphyClientId : Client ID
+ *  \return void
+ ********************************************************************************************************/
+void modphy_reset_client(ModphyController_e modphyClientId);
+
+#endif
diff --git a/include/linux/avalanche/generic/pal.h b/include/linux/avalanche/generic/pal.h
new file mode 100755
index 0000000..c4b523e
--- /dev/null
+++ b/include/linux/avalanche/generic/pal.h
@@ -0,0 +1,96 @@
+/*
+ *
+ * pal.h
+ * Description:
+ * see below
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2008-2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2008-2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+/** \file   pal.h
+    \brief  Platform Include file
+
+    This file includes all platform abstraction related headers.
+
+
+    \author     PSP Architecture Team
+    \version    1.0
+ */
+
+#ifndef _PAL_H_
+#define _PAL_H_
+
+#include "pal_defs.h"   /* Platform definitions - basic types - includes "_tistdtypes.h" */
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+#include "pformCfg.h"   /* Platform specific file - includes SOC specific header */
+#include "csl_defs.h"   /* CSL definitions - basic types and macros */
+#include "pal_os.h"     /* PAL OS interfaces file - includes selected OS abstraction headers */
+#include "pal_sys.h"    /* Platform System Interfaces file */
+#else /* AP-CPU*/
+#include <linux/avalanche/puma7/puma7.h>
+#include <linux/avalanche/generic/avalanche_intd.h>
+#include <linux/avalanche/generic/avalanche_intc.h>
+#include <linux/avalanche/generic/pal_sys.h>
+#endif
+#endif /* _PAL_H_ */
diff --git a/include/linux/avalanche/generic/pal_cppi41.h b/include/linux/avalanche/generic/pal_cppi41.h
new file mode 100644
index 0000000..0f87094
--- /dev/null
+++ b/include/linux/avalanche/generic/pal_cppi41.h
@@ -0,0 +1,742 @@
+/*
+ *
+ * pal_cppi41.h
+ * Description:
+ * see below
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2015 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2015 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** \file   pal_cppi41.h
+ *  \brief PAL CPPI4.1 header file
+ *  This file is minimized CPPI4.1 PAL header file to be
+ *  included the datapipe driver which use CPPI4.1.
+ *  This file is compliant to the PSP Framework 1.0 definitions
+ *  and prototypes.
+ *
+ *  \author Idan Emergi
+ */
+
+#ifndef __PAL_CPPI4_H__
+#define __PAL_CPPI4_H__
+
+#ifndef CONFIG_ARM_AVALANCHE_SOC
+#include <linux/avalanche/puma7/puma7_defs.h>
+#include <linux/avalanche/generic/avalanche_pdsp_api.h>
+#include <asm/cacheflush.h>
+#endif
+
+#include <linux/avalanche/generic/_tistdtypes.h>
+#include <linux/avalanche/generic/pal.h>
+#include <asm/io.h>
+
+/**
+ * General PAL defines
+ */
+#define PAL_CPPI_TESTS 0
+
+typedef enum cppi_domain
+{
+    CPPI41_DOMAIN_PP = 0,
+    CPPI41_DOMAIN_DSG,
+    CPPI41_DOMAIN_DOCSIS_US,
+    CPPI41_DOMAIN_NUM
+} CPPI41_DOMAIN;
+
+typedef volatile unsigned int CSL_Reg32;                    /* 32bit register */
+//#define PAL_CPPI_PP_QMGR_GLOBAL_DEFAULT_DESC_SIZE           (64)
+
+/* convert cppi descriptor size tp descriptor hint */
+#define PAL_CPPI4_DESCSIZE_2_QMGRSIZE(size)                 ((size - 24) / 4)
+
+/**
+ * Accumulator PDSP list entry types
+ */
+#define PAL_CPPI41_ACC_ENTRY_TYPE_D                         (0)
+#define PAL_CPPI41_ACC_ENTRY_TYPE_CD                        (1)
+#define PAL_CPPI41_ACC_ENTRY_TYPE_ABCD                      (2)
+
+
+/**
+ *  \defgroup CPPI4_PAL_Ioctl_Codes CPPI4 PAL Ioctl Codes
+ */
+/*@{*/
+#define PAL_CPPI41_IOCTL_GET_SWVER               0       /**< Get software version */
+#define PAL_CPPI41_IOCTL_GET_HWVER               1       /**< Get hardware version */
+#define PAL_CPPI41_IOCTL_GET_FDQ_STARVE_CNT      2       /**< Get free descriptor queue starvation count */
+#define PAL_CPPI41_IOCTL_GET_FDBQ_STARVE_CNT     3       /**< Get the free descriptor/buffer queue starvation count */
+#define PAL_CPPI41_IOCTL_GET_QUEUE_PEND_STATUS   4       /**< Get the queue pending status */
+#define PAL_CPPI41_IOCTL_GET_QUEUE_ENTRY_COUNT   5       /**< Get the queue entry count */
+#define PAL_CPPI41_IOCTL_GET_QUEUE_BYTE_COUNT    6       /**< Get the queue byte count */
+#define PAL_CPPI41_IOCTL_GET_QUEUE_HEAD_PKT_SIZE 7       /**< Get the head packet size */
+#define PAL_CPPI41_IOCTL_QUEUE_DIVERT            8       /**< Divert contents of one queue to another */
+#define PAL_CPPI41_IOCTL_BUFMGR_SOFT_RESET       9       /**< Soft reset the buffer manager */
+#define PAL_CPPI41_IOCTL_BUF_REFCNT_INCR        10       /**< Increment buffer reference count */
+
+/**
+ * PAL Handles
+ */
+/* The PAL layer handle */
+typedef void* PAL_Handle;
+/* Accumulator PDSP channel handle, return from open accumulator channel */
+typedef void* PAL_Cppi4AccChHnd;
+/* CPPI Queue handle, return from open queue, used for push/pop/close queue operations */
+typedef void* PAL_Cppi4QueueHnd;
+/* The PAL CPPI4 Buffer descriptor type */
+typedef unsigned int PAL_Cppi4BD;
+#define CPPI41_EM_DESCINFO_DTYPE_SHIFT     30
+#define CPPI41_EM_DESCINFO_DTYPE_MASK      (0x3u<<CPPI41_EM_DESCINFO_DTYPE_SHIFT)
+#define CPPI41_EM_DESCINFO_DTYPE_EMB       0
+#define CPPI41_EM_DESCINFO_SLOTCNT_SHIFT   27
+#define CPPI41_EM_DESCINFO_SLOTCNT_MASK    (0x7u<<CPPI41_EM_DESCINFO_SLOTCNT_SHIFT)
+#define CPPI41_EM_DESCINFO_PSWSIZE_SHIFT   22
+#define CPPI41_EM_DESCINFO_PSWSIZE_MASK    (0x1Fu<<CPPI41_EM_DESCINFO_PSWSIZE_SHIFT)
+#define CPPI41_EM_DESCINFO_PKTLEN_SHIFT    0
+#define CPPI41_EM_DESCINFO_PKTLEN_MASK     (0x003FFFFFu<<CPPI41_EM_DESCINFO_PKTLEN_SHIFT)
+
+#define CPPI41_EM_TAGINFO_SRCPORT_SHIFT    27
+#define CPPI41_EM_TAGINFO_SRCPORT_MASK     (0x1Fu<<CPPI41_EM_TAGINFO_SRCPORT_SHIFT)
+#define CPPI41_EM_TAGINFO_SRCCHN_SHIFT     21
+#define CPPI41_EM_TAGINFO_SRCCHN_MASK      (0x3Fu<<CPPI41_EM_TAGINFO_SRCCHN_SHIFT)
+#define CPPI41_EM_TAGINFO_SRCSUBCHN_SHIFT  16
+#define CPPI41_EM_TAGINFO_SRCSUBCHN_MASK   (0x1Fu<<CPPI41_EM_TAGINFO_SRCSUBCHN_SHIFT)
+#define CPPI41_EM_TAGINFO_DSTTAG_SHIFT     0
+#define CPPI41_EM_TAGINFO_DSTTAG_MASK      (0xFFFFu<<CPPI41_EM_TAGINFO_DSTTAG_SHIFT)
+
+#define CPPI41_EM_PKTINFO_PKTERROR_SHIFT    31
+#define CPPI41_EM_PKTINFO_PKTERROR_MASK    (1u<<CPPI41_EM_PKTINFO_PKTERROR_SHIFT)
+
+#define CPPI41_EM_PKTINFO_PKTTYPE_SHIFT     26
+#define CPPI41_EM_PKTINFO_PKTTYPE_MASK     (0x1Fu<<CPPI41_EM_PKTINFO_PKTTYPE_SHIFT)
+#define CPPI41_EM_PKTINFO_PKTTYPE_ATMAAL5           0
+#define CPPI41_EM_PKTINFO_PKTTYPE_ATMNULLAAL        1
+#define CPPI41_EM_PKTINFO_PKTTYPE_ATMOAM            2
+#define CPPI41_EM_PKTINFO_PKTTYPE_ATMTRANSPARENT    3
+#define CPPI41_EM_PKTINFO_PKTTYPE_EFM               4
+#define CPPI41_EM_PKTINFO_PKTTYPE_USB               5
+#define CPPI41_EM_PKTINFO_PKTTYPE_GENERIC           6
+#define CPPI41_EM_PKTINFO_PKTTYPE_ETH               7
+
+
+#define CPPI41_EM_PKTINFO_EOPIDX_SHIFT     20
+#define CPPI41_EM_PKTINFO_EOPIDX_MASK      (0x7u<<CPPI41_EM_PKTINFO_EOPIDX_SHIFT)
+#define CPPI41_EM_PKTINFO_PROTSPEC_SHIFT   16
+#define CPPI41_EM_PKTINFO_PROTSPEC_MASK    (0xFu<<CPPI41_EM_PKTINFO_PROTSPEC_SHIFT)
+#define CPPI41_EM_PKTINFO_RETPOLICY_SHIFT  15
+#define CPPI41_EM_PKTINFO_RETPOLICY_MASK   (1u<<CPPI41_EM_PKTINFO_RETPOLICY_SHIFT)
+#define CPPI41_EM_PKTINFO_ONCHIP_SHIFT     14
+#define CPPI41_EM_PKTINFO_ONCHIP_MASK      (1u<<CPPI41_EM_PKTINFO_ONCHIP_SHIFT)
+#define CPPI41_EM_PKTINFO_RETQMGR_SHIFT    12
+#define CPPI41_EM_PKTINFO_RETQMGR_MASK     (0x3u<<CPPI41_EM_PKTINFO_RETQMGR_SHIFT)
+#define CPPI41_EM_PKTINFO_RETQ_SHIFT       0
+#define CPPI41_EM_PKTINFO_RETQ_MASK        (0x7FFu<<CPPI41_EM_PKTINFO_RETQ_SHIFT)
+
+#define CPPI41_EM_BUF_VALID_SHIFT          31
+#define CPPI41_EM_BUF_VALID_MASK           (1u << CPPI41_EM_BUF_VALID_SHIFT)
+#define CPPI41_EM_BUF_MGR_SHIFT            29
+#define CPPI41_EM_BUF_MGR_MASK             (0x3u << CPPI41_EM_BUF_MGR_SHIFT)
+#define CPPI41_EM_BUF_POOL_SHIFT           24
+#define CPPI41_EM_BUF_POOL_MASK            (0x1Fu << CPPI41_EM_BUF_POOL_SHIFT)
+#define CPPI41_EM_BUF_BUFFLEN_MASK         (0x3FFFFFu)
+
+
+/* Commonly used values */
+#define CPPI41_EM_DESCINFO_SLOTCNT_MYCNT        ((EMSLOTCNT-1u)<<CPPI41_EM_DESCINFO_SLOTCNT_SHIFT)
+#define CPPI41_EM_DESCINFO_SLOTCNT_PP           ((EMSLOTCNT_PP-1u)<<CPPI41_EM_DESCINFO_SLOTCNT_SHIFT)
+#define CPPI41_EM_DESCINFO_SLOTCNT_MPEG         ((EMSLOTCNT-1u)<<CPPI41_EM_DESCINFO_SLOTCNT_SHIFT)
+#define CPPI41_EM_DESCINFO_SLOTCNT_MPEG_ENCAP   ((EMSLOTCNT_EXT-1u)<<CPPI41_EM_DESCINFO_SLOTCNT_SHIFT)
+#define CPPI41_EM_DESCINFO_DTYPE_EMBEDDED       (0u<<CPPI41_EM_DESCINFO_DTYPE_SHIFT)
+#define CPPI41_EM_PKTINFO_RETPOLICY_RETURN      (1u<<CPPI41_EM_PKTINFO_RETPOLICY_SHIFT)
+
+/**
+ * \brief CPPI4.1 Host descriptor structure.
+ *
+ * The CPPI4.1 Host descriptor structure is defined here to enable its
+ * reuse across various driver modules. The PAL CPPI (much like the
+ * underlying hardware) does not use the descriptor structre internally
+ * for any of its operations.
+ */
+typedef struct {
+	Uint32 descInfo;     /**< Desc type, proto specific word cnt, pkt len (valid only in Host PD)*/
+	Uint32 tagInfo;      /**< Source tag (31:16), Dest Tag (15:0) (valid only in Host PD)*/
+	Uint32 pktInfo;      /**< pkt err state, type, proto flags, return info, desc location */
+	Uint32 buffLen;      /**< Number of valid data bytes in the buffer */
+	Uint32 bufPtr;       /**< Pointer to the buffer associated with this descriptor */
+	Ptr nextBDPtr;       /**< Pointer to the next buffer descriptor */
+	Uint32 orgBuffLen;   /**< Original buffer size */
+	Uint32 orgBufPtr;    /**< Original buffer pointer */
+	Uint32 netInfoWord0; /**< Network stack private communications info (valid only in Host PD) */
+	Uint32 netInfoWord1; /**< Network stack private communications info (valid only in Host PD) */
+
+} Cppi4HostDesc;
+
+typedef struct
+{
+	Cppi4HostDesc       hw;         /* The Hardware Descriptor */
+	int                 psi[5];     /* protocol specific information for fw  */
+	struct sk_buff*     skb;        /* The data pointer virtual address */
+}Cppi4HostDescLinux;
+
+#define PAL_CPPI4_HOSTDESC_DESC_TYPE_SHIFT      27
+#define PAL_CPPI4_HOSTDESC_DESC_TYPE_MASK       (0x1F << PAL_CPPI4_HOSTDESC_DESC_TYPE_SHIFT)
+#define PAL_CPPI4_HOSTDESC_DESC_TYPE_HOST       16
+
+#define PAL_CPPI4_HOSTDESC_PROT_WORD_CNT_SHIFT  22
+#define PAL_CPPI4_HOSTDESC_PROT_WORD_CNT_MASK   (0x1F << PAL_CPPI4_HOSTDESC_PROT_WORD_CNT_SHIFT)
+
+#define PAL_CPPI4_HOSTDESC_PKT_LEN_SHIFT        0
+#define PAL_CPPI4_HOSTDESC_PKT_LEN_MASK         (0x1FFFFF << PAL_CPPI4_HOSTDESC_PKT_LEN_SHIFT)
+
+#define PAL_CPPI4_HOSTDESC_PKT_ERR_SHIFT        31
+#define PAL_CPPI4_HOSTDESC_PKT_ERR_MASK         (0x1 << PAL_CPPI4_HOSTDESC_PKT_ERR_SHIFT)
+#define PAL_CPPI4_HOSTDESC_PKT_ERR_NOERR        0
+#define PAL_CPPI4_HOSTDESC_PKT_ERR_ERR          1
+
+#define PAL_CPPI4_HOSTDESC_PKT_TYPE_SHIFT       26
+#define PAL_CPPI4_HOSTDESC_PKT_TYPE_MASK        (0x1F << PAL_CPPI4_HOSTDESC_PKT_TYPE_SHIFT)
+#define PAL_CPPI4_HOSTDESC_PKT_TYPE_ATMAAL5             0
+#define PAL_CPPI4_HOSTDESC_PKT_TYPE_ATMNULLAAL          1
+#define PAL_CPPI4_HOSTDESC_PKT_TYPE_ATMOAM              2
+#define PAL_CPPI4_HOSTDESC_PKT_TYPE_ATMTRANSPARENT      3
+#define PAL_CPPI4_HOSTDESC_PKT_TYPE_EFM                 4
+#define PAL_CPPI4_HOSTDESC_PKT_TYPE_USB                 5
+#define PAL_CPPI4_HOSTDESC_PKT_TYPE_GENERIC             6
+#define PAL_CPPI4_HOSTDESC_PKT_TYPE_ETH                 7
+#define PAL_CPPI4_HOSTDESC_PKT_TYPE_MPEG                8
+
+#define PAL_CPPI4_HOSTDESC_PKT_RETPLCY_SHIFT    15
+#define PAL_CPPI4_HOSTDESC_PKT_RETPLCY_MASK     (0x1 << PAL_CPPI4_HOSTDESC_PKT_RETPLCY_SHIFT)
+#define PAL_CPPI4_HOSTDESC_PKT_RETPLCY_LINKED   0
+#define PAL_CPPI4_HOSTDESC_PKT_RETPLCY_UNLINKED 1
+
+#define PAL_CPPI4_HOSTDESC_DESC_LOC_SHIFT       14
+#define PAL_CPPI4_HOSTDESC_DESC_LOC_MASK        (0x1 << PAL_CPPI4_HOSTDESC_DESCLOC_SHIFT)
+#define PAL_CPPI4_HOSTDESC_DESC_LOC_OFFCHIP     0
+#define PAL_CPPI4_HOSTDESC_DESC_LOC_ONCHIP      1
+
+#define PAL_CPPI4_HOSTDESC_PKT_RETQMGR_SHIFT    12
+#define PAL_CPPI4_HOSTDESC_PKT_RETQMGR_MASK     (0x3 << PAL_CPPI4_HOSTDESC_PKT_RETQMGR_SHIFT)
+#define PAL_CPPI4_HOSTDESC_PKT_RETQNUM_SHIFT    0
+#define PAL_CPPI4_HOSTDESC_PKT_RETQNUM_MASK     (0xFFF << PAL_CPPI4_HOSTDESC_PKT_RETQNUM_SHIFT)
+
+#define PAL_CPPI4_HOSTDESC_NETINFW0_DIVERT_FLAG_MASK    0x80
+#define PAL_CPPI4_HOSTDESC_NETINFW0_DO_NOT_DISCARD      0x80000000
+#if PUMA7_OR_NEWER_SOC_TYPE
+#define PAL_CPPI4_HOSTDESC_NETINFW0_SESSION_VALID       0x00000001
+#define PAL_CPPI4_HOSTDESC_NETINFW0_PTID_FLAG_MASK      0x40000000
+#endif
+
+
+
+/**
+ * The Queue Tuple
+ * The basic queue tuple in CPPI 4.1 used across alldata
+ * structures where a definition of a queue is required.
+ */
+typedef struct
+{
+    unsigned int qMgr;    /* The queue manager number */
+    unsigned int qNum;    /* The queue number */
+} Cppi4Queue;
+
+
+/**
+ * \brief The BufPool Tuple
+ * - The basic BufPool tuple in CPPI 4.1 used across all data
+ *   structures where a definition of a buffer pool is required.
+ */
+typedef struct
+{
+    Uint32 bMgr;        /**< The buffer manager number */
+    Uint32 bPool;       /**< The buffer pool number */
+} Cppi4BufPool;
+
+/**
+ * \brief Queue Manager queue management region
+ *
+ * The structure instance variable points to CPPI4 queue management
+ * register space in  SOC memory map directly.
+ * This is a template only, no memory is ever allocated for this!
+ *
+ */
+typedef volatile struct
+{
+    CSL_Reg32 Queue_Reg_A;
+    CSL_Reg32 Queue_Reg_B;
+    CSL_Reg32 Queue_Reg_C;
+    CSL_Reg32 Queue_Reg_D;
+
+} CSL_Queue_Mgmt_Regs;
+
+/**
+ * \brief Queue Manager queue status region
+ *
+ * The structure instance variable points to CPPI4 queue status
+ * register space in  SOC memory map directly.
+ * This is a template only, no memory is ever allocated for this!
+ *
+ */
+typedef volatile struct
+{
+    CSL_Reg32 Queue_Status_Reg_A;
+    CSL_Reg32 Queue_Status_Reg_B;
+    CSL_Reg32 Queue_Status_Reg_C;
+    CSL_Reg32 Reserved;
+
+} CSL_Queue_Status_Regs;
+
+
+/**
+ * \brief Queue Manager region
+ *
+ * The structure instance variable points to CPPI4 Queue manager region
+ * register space in  SOC memory map directly.
+ * This is a template only, no memory is ever allocated for this!
+ *
+ * Register naming comes directly from the spec names, with redundant words
+ * dropped and abbreviations made where appropriate.
+ */
+typedef volatile struct
+{
+    CSL_Reg32   Revision;                     /* Major and Minor verisions of the module */
+    CSL_Reg32   Reserved;                     /* Reserved */
+    CSL_Reg32   Queue_Diversion;              /* Queue Diversion register */
+    CSL_Reg32   Reserved0[5];                 /* Reserved */
+    CSL_Reg32   Free_Desc_Buf_Starvation[4];  /* Free Descriptor/Buffer starvation count */
+    CSL_Reg32   Free_Desc_Starvation[4];      /* Free Descriptor starvation count */
+    CSL_Reg32   Reserved1[16];                /* Reserved */
+    CSL_Reg32   Linking_RAM_Reg0_Base;        /* Linking RAM Region 0 Base Address */
+    CSL_Reg32   Linking_RAM_Reg0_Size;        /* Linking RAM Region 0 Size */
+    CSL_Reg32   Linking_RAM_Reg1_Base;        /* Linking RAM Region 1 Base  */
+    CSL_Reg32   Reserved2;                    /* Reserved */
+    CSL_Reg32   Queue_Pending[((/*PAL_CPPI_PP_QMGR_G0_TOTAL_Q_COUNT*/ 1 )/sizeof(CSL_Reg32)) + 1]; /* Pending status for all queues. */
+
+} CSL_Queue_Manager_Region_Regs;
+
+/**
+ * \brief CPPI4 Queue Manager region overlay pointer
+ *
+ * Can be used in PAL layer directly for performance considerations.
+ */
+typedef CSL_Queue_Manager_Region_Regs* CSL_Queue_Manager_Region_RegsOvly;
+
+#define QMGR_QUEUE_N_REG_C_PKTSZ_SHIFT                  (0)
+#define QMGR_QUEUE_N_REG_C_PKTSZ_MASK                   (0x3FFF << QMGR_QUEUE_N_REG_C_PKTSZ_SHIFT)
+
+#define QMGR_QUEUE_N_REG_D_DESCSZ_SHIFT                 (0)
+#define QMGR_QUEUE_N_REG_D_DESCSZ_MASK                  (0x1F << QMGR_QUEUE_N_REG_D_DESCSZ_SHIFT)
+#define QMGR_QUEUE_N_REG_D_DESC_ADDR_SHIFT              (5)
+#define QMGR_QUEUE_N_REG_D_DESC_ADDR_MASK               (0x7FFFFFF << QMGR_QUEUE_N_REG_D_DESC_ADDR_SHIFT)
+
+/**
+ * \brief Accumulator list mode configuration
+ *
+ * In the list mode accumulator pops a given queue and populates a list in memory
+ * with the queue elements. Once done it raises an interrupt based on the pacing criteria.
+ *
+ * This structure defines the accumulator channel configuration when it is used
+ * in the list mode. This structure is embedded as part of the ::Cppi4AccumulatorCfg
+ * structure.
+ */
+typedef struct
+{
+    void          *listBase;        /**< The descriptor list base. */
+    unsigned int  maxPageEntry;     /**< Maximum number of entries per page */
+    unsigned int  pacingMode;       /**< Interrupt pacing mode: <BR>
+                                         0 => None. Interrupt on entry threshold count. <BR>
+                                         1 => Time delay since last interrupt. <BR>
+                                         2 => delay since first new packet <BR>
+                                         3 => delay since last new packet */
+    unsigned int  stallAvoidance;   /**< 0 => Do not hold off interrupts to avoid a stall. <BR>
+                                         1 => Hold off passing the final list page to the host when the host is congested <BR>
+                                         and additional packet descriptors can be appended to the current list. */
+    unsigned int  listCountMode;    /**< 0 => NULL Terminate Mode - The last list entry is used to store a NULL pointer record <BR>
+                                         (NULL terminator) to mark the end of list. <BR>
+                                         1 => Entry Count Mode - The first list entry is used to store the total list entry count <BR>
+                                         (not including the length entry). */
+    unsigned int listEntrySize;     /**< Type of descriptor information required in the list. <BR>
+                                         0 => Reg D only (4 bytes), <BR>
+                                         1 => Reg C & D (8 bytes) <BR>
+                                         2 => Reg A, B, C, D */
+    unsigned int maxPageCnt;        /**< Number of ping/pong pages. Valid values 2 or 3 */
+
+} Cppi4AccListCfg;
+
+/**
+ * \brief Accumulator monitor mode configuration
+ *
+ * In the monitor mode accumulator only monitors a given queue to see if it has elements enqueued.
+ * If the queue has reached the given element count it raises an interrupt based on the pacing criteria.
+ *
+ * This structure defines the accumulator channel configuration when it is used
+ * in monitor mode. This structure is embedded as part of the ::Cppi4AccumulatorCfg
+ * structure.
+ */
+typedef struct
+{
+    unsigned int  pktCountThresh; /**< The packet count threshold */
+    unsigned int  pacingMode;     /**< Interrupt pacing mode: <BR>
+                                          0 => None. Interrupt on entry threshold count. <BR>
+                                          1 => Time delay since count threshold reached. <BR> */
+} Cppi4AccMonitorCfg;
+
+/**
+ * \brief Accumulator channel configuration
+ *
+ * This defines the accumulator channel properties for a given host mode Tx/Rx channel
+ * An instance of this structure will be part of the channel initial configuration
+ * structure. This structure makes sense only for host mode channels.
+ */
+typedef struct
+{
+    unsigned int  accChanNum;         /**< Accumulator channel number */
+    unsigned int  mode;               /**<    0 => list mode
+                                              1 => monitor mode */
+    Cppi4Queue    queue;              /**< The queue to monitor */
+
+    unsigned int  pacingTickCnt;      /**< Number of 25us timer ticks to delay interrupt */
+
+    Cppi4AccListCfg   list;           /**< Normal mode configuration */
+    Cppi4AccMonitorCfg  monitor;      /**< Monitor mode configuration */
+
+} Cppi4AccumulatorCfg;
+
+/**
+ *  \brief CPPI4 PAL Accumulator Channel object
+ *
+ *  CPPI4 PAL layer Object - encapsulates all bookeeping and data structures for
+ *  CPPI4 PAL
+ */
+typedef struct PAL_Cppi4AccChObj_t
+{
+    struct Cppi4PALObj_t *palCppi4Obj;  /**< Back reference to the CPPI 4.1 structure */
+    Uint32 curPage;                     /**< Current accumulator page. */
+    Cppi4AccumulatorCfg initCfg;         /**< The accumulator channel init configuration */
+
+} PAL_Cppi4AccChObj;
+
+typedef enum cppi_desc_type
+{
+    CPPI41_DESC_TYPE_EMBEDDED = 0,
+    CPPI41_DESC_TYPE_HOST,
+    CPPI41_DESC_TYPE_MONOLITHIC,
+    CPPI41_DESC_TYPE_TEARDOWN
+} CPPI41_DESC_TYPE;
+
+typedef enum desc_type
+{
+    DESC_EMBEDDED = 0,
+    DESC_HOST = 16,
+    DESC_MONOLITHIC = 18,
+    DESC_TEARDOWN = 19
+} DESC_TYPE;
+
+#ifdef __KERNEL__
+
+
+
+/* convert DDR physical address to DDR virtual address - use netip_mmio functions if pp is present */
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+#define PAL_CPPI4_PHYS_2_VIRT(addr)                        (netip_mmio_to_virtual(addr))  /* X86 implementation here */
+/* convert DDR virtual address to DDR physical address */
+#define PAL_CPPI4_VIRT_2_PHYS(addr)                        (netip_mmio_to_physical(addr))  /* X86 implementation here */
+#else
+/* convert DDR physical address to DDR virtual address */
+#define PAL_CPPI4_VIRT_2_PHYS(addr)     PAL_osMemVirt2Phy((Ptr)(addr))
+/* convert DDR virtual address to DDR physical address */
+#define PAL_CPPI4_PHYS_2_VIRT(addr)     PAL_osMemPhy2Virt((Uint32)(addr))
+#endif
+
+#ifdef CONFIG_NET_SUBSYSTEM_SNOOPED_MODE
+
+#define PAL_CPPI4_CACHE_WRITEBACK(addr, size)			do {} while(0);
+#define PAL_CPPI4_CACHE_WRITEBACK_INVALIDATE(addr, size)	do {} while(0);
+#define PAL_CPPI4_CACHE_INVALIDATE(addr, size)			do {} while(0);
+
+#else
+
+#define PAL_CPPI4_CACHE_WRITEBACK(addr, size)			clflush_cache_range(addr, size)
+#define PAL_CPPI4_CACHE_WRITEBACK_INVALIDATE(addr, size)	clflush_cache_range(addr, size)
+#define PAL_CPPI4_CACHE_INVALIDATE(addr, size)			clflush_cache_range(addr, size)
+
+#endif
+
+/**
+ *  \brief PAL CPPI4.1 Initialization.
+ *
+ *  This function initializes the CPPI4.1 PAL layer.  This is the first function to be
+ *  called by a module requiring CPPI4.1 support.  Multiple upper layers may call
+ *  this function, although only one actual instance will be created.  After the
+ *  first call, subsequent callers will simply be given the PAL Handle that was
+ *  allocated during the first call.
+ *
+ *  In the typical scenerio, this API will be called once during system boot-up
+ *  and other drivers/modules can call the API will NULL parameters to retrieve
+ *  the PAL handle
+ *
+ *  The PAL handle that is returned must be used to close the PAL interface.
+ *
+ *  This function will bring the networking subsystem, out of reset, and
+ *  initialize the queue manager/buffer manager and DMA hardware.
+ *
+ *  \note: The initCfg parameter values are only valid for the first caller - i.e.
+ *  the CPPI4 PAL is initialized only once, regardless of the number of calls to
+ *  this function.
+ *
+ *  @param  initCfg      [IN]      Pointer to CPPI4 config structure, to be
+ *                                 allocated and loaded with values by the caller.
+ *  @param  param        [IN]      Not used in this implementation. For future use.
+ *
+ *  @return a valid ::PAL_Handle on success, NULL otherwise.
+ */
+PAL_Handle PAL_cppi4Init (void * initCfg, Ptr param);
+
+/**
+ *  \brief PAL CPPI4.1 de-initialization.
+ *
+ *  @return 0 on success, non zero value otherwise.
+ */
+int PAL_cppi4Exit(PAL_Handle hnd, void *param);
+
+
+/**
+ *  \brief PAL CPPI4.1 Queue Open
+ *
+ *  This function configures and opens a specified Queue.
+ *
+ *  @param  hnd   [IN] - Handle to the PAL Layer.
+ *  @param  queue [IN] - The queue to open.
+ *
+ *  @return a valid ::PAL_Cppi4QueueHnd on success and NULL on
+ *          failure.
+ */
+PAL_Cppi4QueueHnd PAL_cppi4QueueOpen(PAL_Handle hnd, Cppi4Queue  queue);
+
+/**
+ * \brief CPPI4.1 Queue Close
+ *  closes a specified Queue when the last time it is called.
+ *  For every other call it decrements the reference to the queue object.
+ *  Actually it does nothing on APPCPU.
+ *
+ * @param hnd NULL
+ * @param qHnd queue handle returned from queue open
+ *
+ * @return 0 on success or non zero value otherwise .
+ */
+int PAL_cppi4QueueClose(PAL_Handle hnd, PAL_Cppi4QueueHnd qHnd);
+
+/**
+ *  \brief CPPI4.1 Queue Push
+ *
+ *  This function is called to queue a descriptor onto a queue.
+ *
+ *  @param  hnd Handle to the Queue (PAL_Cppi4QueueHnd).
+ *  @param  dAddr descriptor physical address.
+ *  @param  dSize descriptor size.
+ *  @param  pSize packet size.
+ *
+ *  \note pSize parameter is optional. Pass NULL in case not required.
+ *
+ *  @return a valid PAL_Cppi4QueueHnd on success and NULL on
+ *          failure.
+ */
+int PAL_cppi4QueuePush(PAL_Cppi4QueueHnd hnd, void *dAddr, unsigned int dSize, unsigned int pSize);
+
+/**
+ *  \brief CPPI4.1 Queue Pop
+ *
+ *  This function is called to pop descriptor from specific
+ *  queue.
+ *
+ *  @param  hnd Handle to the Queue (PAL_Cppi4QueueHnd).
+ *
+ *  @return Buffer descriptor physical address.
+ */
+PAL_Cppi4BD *PAL_cppi4QueuePop(PAL_Cppi4QueueHnd hnd);
+
+/**
+ *  \brief CPPI4.1 Queue Get Entries Count
+ *
+ *  This function is called to get the number of descriptors in
+ *  a queue.
+ *
+ *  @param  hnd PAL handle returned from a previous
+ *              PAL_cppi4Init() call
+ *  @param  queue Handle to the Queue (PAL_Cppi4QueueHnd).
+ *  @param  entryCount [out] Number of entries in queue.
+ *
+ *  @return 0 on succuss, non zero value otherwise.
+ */
+int PAL_cppi4QueueGetEntryCount(PAL_Handle hnd, Cppi4Queue queue, unsigned int *entryCount);
+
+/**
+ *  \brief PAL CPPI 4.1 pdsp_cmd_send registration.
+ *
+ * Sets up the pdsp_cmd_send function callback used by PAL CPPI
+ * driver.
+ *
+ *  @param  cb            [IN]      pdsp_cmd_send callback
+ *                                  function
+ *
+ *  @return PAL_SOK on success, else failure code.
+ */
+PAL_Result PAL_cppi4PdspCmdSendRegister(Int32 (*cb)(pdsp_id_t, pdsp_cmd_t, void *, Uint32, void *, Uint32));
+
+/**
+ *  \brief PAL CPPI 4.1 pdsp_cmd_send unregistration.
+ *
+ * Unregisters the pdsp_cmd_send function callback used by PAL
+ * CPPI driver.
+ *
+ *  @return PAL_SOK on success, else failure code.
+ */
+PAL_Result PAL_cppi4PdspCmdSendUnregister(void);
+
+/**
+ *  \brief PAL CPPI 4.1 accumulator channel setup.
+ *
+ * Sets up an accumulator channel to monitor a queue.
+ *
+ *  @param  hnd PAL handle
+ *  @param  accCfg Pointer to the accumulator configuration
+ *                  structure.
+ *
+ *  @return pointer to a valid handle (PAL_Cppi4AccChHnd) on
+ *          success, NULL otherwise.
+ */
+PAL_Cppi4AccChHnd PAL_cppi4AccChOpen(PAL_Handle hnd, Cppi4AccumulatorCfg* accCfg);
+
+/**
+ *  \brief PAL CPPI 4.1 accumulator channel teardown.
+ *
+ *  Stop an accumulator channel from monitoring a queue.
+ *
+ *  @param  hnd Accumulator handle (::PAL_Cppi4AccChHnd)
+ *  @param  closeArgs For future extension. Pass NULL for now.
+ *
+ *  @return 0 on success, non zero value otherwise.
+ */
+int PAL_cppi4AccChClose(PAL_Cppi4AccChHnd hnd, void *closeArgs);
+
+/**
+ *  \brief PAL CPPI 4.1 get transmit channel accumulator page.
+ *
+ *  This function returns pointer to the next page that the accumulator would have populated with
+ *  BD list.
+ *
+ *  \note This function does not have information on whether the page it is returning has <B> really </B>
+ *  been populated by accumulator. This information should be available to the driver using the
+ *  INTD count register. It is the responsibility of the driver to call this function when it is sure that
+ *  the accumulator is finished with updating a new page.
+ *
+ *  @param  hnd Accumulator channel handle (PAL_Cppi4AccChHnd).
+ *
+ *  @return Valid pointer (virtual address) to list page on success, NULL otherwise.
+ */
+void* PAL_cppi4AccChGetNextList(PAL_Cppi4AccChHnd hnd);
+
+/* Following API will use NPCPU-APPCPU Shared memory to provide Accumulator fuctionalities */
+/**
+ *  \brief PAL CPPI 4.1 accumulator channel setup using shared memory.
+ *
+ * Sets up an accumulator channel to monitor a queue.
+ *
+ *  @param  hnd PAL handle
+ *  @param  accCfg Pointer to the accumulator configuration
+ *                  structure.
+ *  @param SharedMemoryBase addres.
+ *  @param accListPageSize size of accumulator page.
+ *
+ *  @return pointer to a valid handle (PAL_Cppi4AccChHnd) on
+ *          success, NULL otherwise.
+ */
+PAL_Cppi4AccChHnd PAL_cppi4AccChOpenSharedMemory(PAL_Handle hnd, Cppi4AccumulatorCfg* accCfg, unsigned long SharedMemoryBase, unsigned long accListPageSize);
+
+/**
+ *  \brief PAL CPPI4.1 control API.
+ *
+ *  This function provides the capability for control operations to be performed
+ *  on the PAL CPPI4 module.
+ *
+ *  The command (cmd) is used to direct the function to perform one or more of
+ *  the supported operations.  The commands supported are:
+ *
+ *  - #PAL_CPPI41_IOCTL_QUEUE_DIVERT
+ *          - cmdArg defines the source and destination queue. Also defines if packets
+ *          should be added to head/tail of destination queue. This argument is a 32-bit integer
+ *          and an exact map of the diversion register in the hardware. param provides the queue manager
+ *          index to which the queue belongs.
+ *
+ *  @param  hnd           [IN]      Handle to the PAL Layer.
+ *  @param  cmd           [IN]      Operation to be performed.
+ *  @param  cmdArg    [IN/OUT]      Provides additional info for the operation.
+ *  @param  param     [IN/OUT]      Cmd specific argument.
+ *
+ *  @return PAL_SOK on success, else failure code.
+ */
+int PAL_cppi4Control (PAL_Handle hnd, Uint32 cmd, Ptr cmdArg, Ptr param);
+
+#endif /* __KERNEL__ */
+
+#endif /* __PAL_CPPI4_H__ */
+
diff --git a/include/linux/avalanche/generic/pal_defs.h b/include/linux/avalanche/generic/pal_defs.h
new file mode 100755
index 0000000..48c0db9
--- /dev/null
+++ b/include/linux/avalanche/generic/pal_defs.h
@@ -0,0 +1,270 @@
+/*
+ *
+ * pal_defs.h
+ * Description:
+ * see below
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2008-2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2008-2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+/** \file   pal_defs.h
+    \brief  Generic Platform Abstraction header file
+
+    This file defines macros and data types generic across PAL services.
+
+
+    \author     PSP Architecture Team
+    \version    1.0
+ */
+
+#ifndef __PAL_DEFS_H__
+#define __PAL_DEFS_H__
+
+/* Import the TI standard primitive "C" types defines */
+#include "_tistdtypes.h"
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+#ifdef __KERNEL__
+#include <linux/spinlock.h>
+#endif
+#endif
+
+/**
+ * \defgroup PALDefines PAL Defines
+ *
+ *  PAL Generic Defines - used by all modules using PAL services
+ *  (including Drivers)
+ */
+/*@{*/
+
+/* PAL Result - return value of a function  */
+typedef Int             PAL_Result;
+
+/* Type Macros */
+#define PAL_False       ((Bool)0)
+#define PAL_True        ((Bool)1)
+
+/* General Macros */
+#define PAL_MAX(a,b)    ((a) > (b) ? (a) : (b))
+#define PAL_MIN(a,b)    ((a) < (b) ? (a) : (b))
+
+/* Array Dimension */
+#define PAL_DIM(array)  (sizeof(array)/sizeof(array[0]))
+
+/* Endianness */
+
+#define PAL_MK_UINT16(high8,low8)                               \
+    ((Uint16)( ((Uint16)(high8) << 8) | (Uint16)(low8) ))
+
+#define PAL_UINT16_LOW8(a)                                      \
+    ((Uint8)((a) & 0x00FF))
+
+#define PAL_UINT16_HIGH8(a)                                     \
+    ((Uint8)(((a) >> 8) & 0x00FF))
+
+#define PAL_MK_UINT32(high16,low16)                             \
+    ((Uint32)( ((Uint32)(high16) << 16) | (Uint32)(low16) ))
+
+#define PAL_MK_UINT32_FROM8S(high8,med_high8,med_low8,low8)     \
+    PAL_MK_UINT32(PAL_MK_UINT16(high8,med_high8), PAL_MK_UINT16(med_low8, low8))
+
+#define PAL_UINT32_LOW16(u32)                                   \
+    ((Uint16)((u32) & 0xFFFF))
+
+#define PAL_UINT32_HIGH16(u32)                                  \
+    ((Uint16)(((u32) >> 16) & 0xFFFF))
+
+#define PAL_UINT32_LOW8(u32)                                    \
+    ((Uint8)((u32) & 0x00FF))
+
+#define PAL_UINT32_MED_LOW8(u32)                                \
+    ((Uint8)(((u32) >> 8) & 0xFF))
+
+#define PAL_UINT32_MED_HIGH8(u32)                               \
+    ((Uint8)(((u32) >> 16) & 0xFF))
+
+#define PAL_UINT32_HIGH8(u32)                                   \
+    ((Uint8)(((u32) >> 24) & 0xFF))
+
+#define PAL_SWAP_UINT16(w)      \
+    (PAL_MK_UINT16(PAL_UINT16_LOW8(w), PAL_UINT16_HIGH8(w)))
+
+#define PAL_SWAP_UINT32(u32)                \
+    (PAL_MK_UINT32_FROM8S(                  \
+        PAL_UINT32_LOW8(u32),               \
+        PAL_UINT32_MED_LOW8(u32),           \
+        PAL_UINT32_MED_HIGH8(u32),          \
+        PAL_UINT32_HIGH8(u32)))
+
+/** Endian Utility Macros
+ * PAL_UINT16_LE(w) converts a Little-Endian 16bit word to current endian word
+ * PAL_UINT16_BE(w) converts a Big-Endian 16bit word to current endian word
+ * PAL_UINT32_LE(d) converts a Little-Endian 32bit dword to current endian dword
+ * PAL_UINT32_BE(d) converts a Big-Endian 32bit dword to current endian dword
+ */
+
+#ifdef PAL_NATIVE_ENDIAN_BIG
+/* Native CPU accesses to memory locations are big-endian style */
+#define PAL_UINT16_LE(w)    PAL_SWAP_UINT16(w)
+#define PAL_UINT16_BE(w)    (w)
+#define PAL_UINT32_LE(d)    PAL_SWAP_UINT32(d)
+#define PAL_UINT32_BE(d)    (d)
+
+#else
+/* Native CPU accesses to memory locations are little-endian style */
+#define PAL_UINT16_LE(w)    (w)
+#define PAL_UINT16_BE(w)    PAL_SWAP_UINT16(w)
+#define PAL_UINT32_LE(d)    (d)
+#define PAL_UINT32_BE(d)    PAL_SWAP_UINT32(d)
+
+#endif /* Endian switch */
+
+/**
+ * \defgroup PALErrorCodes PAL Error Codes
+ *
+ * PAL Error code bit fields follow a standard format. This format is used by
+ * all PAL components, Services and Device Drivers.
+ *
+ * The following bitfield diagram depicts the PAL error code format:
+ * \n
+ * |<----------------32----------------->|
+ * \n
+ * |1(A)| 3(B) |  4(C) |    8(D)   |   8(E)  |   8(F)  |
+ * - A - MSB - Set if Error / 0 if Success
+ * - B - Error level - 0=Informational, 1=Warning, 2=Minor, 3=Major, 4=Critical
+ * - C - PSP Architecture Component - 0=Reserved, 1=CSL, 2=Driver, 3=PAL, 4=SRV etc
+ * - D - Device specific - eg Instance Id of DDC
+ * - E,F - Error number - based upon implementation.
+ */
+
+/*@{*/
+
+/** Error severity levels  */
+#define PAL_INFO                (0)
+#define PAL_WARNING             (1)
+#define PAL_MINOR_ERROR         (2)
+#define PAL_MAJOR_ERROR         (3)
+#define PAL_CRITICAL_ERROR      (4)
+
+/** PAL Error Sources (PSP Architectural Components) */
+#define PAL_ERROR_SRC_CSL       (0)
+#define PAL_ERROR_SRC_DRV       (1)
+#define PAL_ERROR_SRC_PAL       (2)
+#define PAL_ERROR_SRC_SRV       (3)
+
+#define PAL_ERROR_FLAG          (0x80000000)    /**< PAL Error occured sentinel flag */
+
+/** Successful Return Code for PAL_Result */
+
+#define PAL_SOK                 (0x0)
+
+/**
+ * \note PAL Error bit manipulation masks and shift values
+ */
+#define PAL_ERROR_SEVERITY_SHIFT    (28)
+#define PAL_ERROR_SEVERITY_MASK     (0x70000000)
+
+#define PAL_ERROR_SRC_SHIFT         (24)
+#define PAL_ERROR_SRC_MASK          (0x0F000000)
+
+#define PAL_ERROR_QUAL_SHIFT        16
+#define PAL_ERROR_QUAL_MASK         (0x00FF0000)
+
+#define PAL_ERROR_NUM_SHIFT         (0)
+#define PAL_ERROR_NUM_MASK          (0x0000FFFF)
+
+/**
+ * \brief PAL_ERROR() macro composes a final 32bit error code per the
+ * above described format. It inputs the severity, source of error,
+ * source qualifier and the specific error number of interest
+ *
+ * \sa PAL_ERROR_CSLSTATUS()
+ */
+#define PAL_ERROR(severity, src, qual, num) \
+    ( PAL_ERROR_FLAG | \
+      (PAL_ERROR_SEVERITY_MASK & (severity << PAL_ERROR_SEVERITY_SHIFT)) | \
+    (PAL_ERROR_SRC_MASK & (src << PAL_ERROR_SRC_SHIFT)) | \
+    (PAL_ERROR_QUAL_MASK & (qual << PAL_ERROR_QUAL_SHIFT)) | \
+    (PAL_ERROR_NUM_MASK & (num << PAL_ERROR_NUM_SHIFT)))
+
+/**
+ * \brief The following 4 macros allow to extract relevant portions of
+ * the 32bit PAL error code.
+ */
+#define PAL_ERROR_NUM(code)         ((code & PAL_ERROR_NUM_MASK) >> PAL_ERROR_NUM_SHIFT)
+#define PAL_ERROR_QUAL(code)        ((code & PAL_ERROR_QUAL_MASK) >> PAL_ERROR_QUAL_SHIFT)
+#define PAL_ERROR_SRC(code)         ((code & PAL_ERROR_SRC_MASK) >> PAL_ERROR_SRC_SHIFT)
+#define PAL_ERROR_SEVERITY(code)    ((code & PAL_ERROR_SEVERITY_MASK) >> PAL_ERROR_SEVERITY_SHIFT)
+
+/**
+ * \brief   PAL_ERROR_CSLSTATUS() macros constructs a fully embodied
+ *      32bit PAL error code, given a 16bit CSL_Status number
+ * \note    CSL Errors are always ascribed severity level MAJOR.
+ */
+#define PAL_ERROR_CSLSTATUS(cslerr) \
+    PAL_ERROR(PAL_MAJOR_ERROR, PAL_ERROR_SRC_CSL, 0, (cslerr & 0x7F))
+
+/*@}*/
+/*@}*/
+
+#endif /* __PAL_DEFS_H__ */
diff --git a/include/linux/avalanche/generic/pal_os.h b/include/linux/avalanche/generic/pal_os.h
new file mode 100755
index 0000000..e7815a0
--- /dev/null
+++ b/include/linux/avalanche/generic/pal_os.h
@@ -0,0 +1,217 @@
+/*
+ *
+ * pal_os.h
+ * Description:
+ * see below
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2008-2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2008-2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+/** \file   pal_os.h
+    \brief  OS Abstraction Header File
+
+    This file provides visibility to OS abstraction APIs by including
+    only the configured service modules interface files.
+
+
+    \author     PSP Architecture Team
+    \version    1.0
+ */
+
+#ifndef __PAL_OS_H__
+#define __PAL_OS_H__
+
+
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+#include "pal_osCfg.h"
+#else /*AP-CPU*/
+#include "linux/avalanche/generic/pal_osCfg.h"
+#endif
+
+
+/* Added:
+ * PAL OS module type to be placed in section D of the final "ERROR CODE"
+ * as described in pal_defs.h
+ */
+#define PAL_OS_COMMON_ERR   (0)
+#define PAL_OSMEM_ERR       (1)
+#define PAL_OSBUF_ERR       (2)
+#define PAL_OSSEM_ERR       (3)
+#define PAL_OSMUTEX_ERR     (4)
+#define PAL_OSWAIT_ERR      (5)
+#define PAL_OSLIST_ERR      (6)
+#define PAL_OSPROTECT_ERR   (7)
+#define PAL_OSTIMER_ERR     (8)
+
+/* Common error codes for ALL PAL OS modules */
+#define PAL_OS_COMMON_ERROR_CREATE(x)   (PAL_ERROR(PAL_CRITICAL_ERROR, PAL_OS_COMMON_ERR, 0, (x)))
+
+/* Invalid parameter passed to the function error */
+#define PAL_OS_ERROR_INVALID_PARAM      (PAL_OS_COMMON_ERROR_CREATE(1))
+
+/* Feature not supported error */
+#define PAL_OS_ERROR_NOT_SUPPORTED      (PAL_OS_COMMON_ERROR_CREATE(2))
+
+/* No resources available error */
+#define PAL_OS_ERROR_NO_RESOURCES       (PAL_OS_COMMON_ERROR_CREATE(3))
+
+/* OS specific error */
+#define PAL_OS_ERROR_OS_SPECIFIC        (PAL_OS_COMMON_ERROR_CREATE(4))
+
+
+/* Default (memory) segment Id - Many of the modules (like OSSEM, OSBUF),
+ * depend upon a segment id to be passed in the API's. The macro below
+ * defines a default segment Id that can be used in these API's
+ */
+#define PAL_OSMEM_DEFAULT_SEGID         0
+
+
+#ifdef INLINE
+#define PAL_INLINE static inline
+#else
+#define PAL_INLINE
+#endif
+
+#ifdef PAL_INCLUDE_OSMEM
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+#include "pal_osMem.h"          /* OsMEM Services */
+#else /*AP-CPU*/
+#include "linux/avalanche/generic/pal_osMem.h"          /* OsMEM Services */
+#endif
+#endif /* PAL_INCLUDE_OSMEM */
+
+#ifdef PAL_INCLUDE_OSBUF
+#include "pal_osBuf.h"          /* OsBUF Services */
+#endif /* PAL_INCLUDE_OSBUF */
+
+#ifdef PAL_INCLUDE_OSSEM
+#include "pal_osSem.h"          /* OsSEM Services */
+#endif /* PAL_INCLUDE_OSSEM */
+
+#ifdef PAL_INCLUDE_OSMUTEX
+#include "pal_osMutex.h"        /* OsMUTEX Services */
+#endif /* PAL_INCLUDE_OSMUTEX */
+
+#ifdef PAL_INCLUDE_OSWAIT
+#include "pal_osWait.h"        /* OsWAIT Services */
+#endif /* PAL_INCLUDE_OSWAIT */
+
+#ifdef PAL_INCLUDE_OSLIST
+#include "pal_osList.h"         /* OsLIST Services */
+#endif /* PAL_INCLUDE_OSLIST */
+
+#ifdef PAL_INCLUDE_OSPROTECT
+#include "pal_osProtect.h"      /* OsPROTECT Services */
+#endif /* PAL_INCLUDE_OSPROTECT */
+
+#ifdef PAL_INCLUDE_OSCACHE
+#include "pal_osCache.h"      /* OsCACHE Services */
+#endif /* PAL_INCLUDE_OSCACHE */
+
+#ifdef PAL_INCLUDE_OSTIMER
+#include "pal_osTimer.h"        /* OsSEM Services */
+#endif /* PAL_INCLUDE_OSTIMER */
+
+#ifdef INLINE
+
+#ifdef PAL_INCLUDE_OSBUF
+#include "pal_osBuf_inline.h"
+#endif /* PAL_INCLUDE_OSBUF */
+
+#ifdef PAL_INCLUDE_OSMEM
+#include "pal_osMem_inline.h"
+#endif /* PAL_INCLUDE_OSMEM */
+
+#ifdef PAL_INCLUDE_OSMUTEX
+#include "pal_osMutex_inline.h"
+#endif /* PAL_INCLUDE_OSMUTEX */
+
+#ifdef PAL_INCLUDE_OSSEM
+#include "pal_osSem_inline.h"
+#endif /* PAL_INCLUDE_OSSEM */
+
+#ifdef PAL_INCLUDE_OSWAIT
+#include "pal_osWait_inline.h"
+#endif /* PAL_INCLUDE_OSWAIT */
+
+#ifdef PAL_INCLUDE_OSPROTECT
+#include "pal_osProtect_inline.h"
+#endif /* PAL_INCLUDE_OSPROTECT */
+
+#ifdef PAL_INCLUDE_OSLIST
+#include "pal_osList_inline.h"
+#endif /* PAL_INCLUDE_OSLIST */
+
+#ifdef PAL_INCLUDE_OSCACHE
+#include "pal_osCache_inline.h"      /* OsCACHE Services */
+#endif /* PAL_INCLUDE_OSCACHE */
+
+#ifdef PAL_INCLUDE_OSTIMER
+#include "pal_osTimer_inline.h"
+#endif /* PAL_INCLUDE_OSTIMER */
+
+#endif /* INLINE */
+
+#endif /* _PAL_OS_H_ */
+
diff --git a/include/linux/avalanche/generic/pal_osCfg.h b/include/linux/avalanche/generic/pal_osCfg.h
new file mode 100755
index 0000000..674f009
--- /dev/null
+++ b/include/linux/avalanche/generic/pal_osCfg.h
@@ -0,0 +1,98 @@
+/*
+ *
+ * pal_osCfg.h
+ * Description:
+ * see below
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2008-2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2008-2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+/** \file   pal_osCfg.h
+    \brief  OS Configuration Header File
+
+    This file provides the OS configuration.
+
+
+    \author     Ajay Singh
+    \version    0.1
+ */
+
+#ifndef __PAL_OSCFG_H__
+#define __PAL_OSCFG_H__
+
+#define INLINE
+
+#define PAL_INCLUDE_OSMEM
+#define PAL_INCLUDE_OSPROTECT
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+#define PAL_INCLUDE_OSBUF
+#define PAL_INCLUDE_OSSEM
+#define PAL_INCLUDE_OSMUTEX
+#define PAL_INCLUDE_OSWAIT
+#define PAL_INCLUDE_OSLIST
+#define PAL_INCLUDE_OSCACHE
+#define PAL_INCLUDE_OSTIMER
+#endif
+
+#endif
diff --git a/include/linux/avalanche/generic/pal_osMem.h b/include/linux/avalanche/generic/pal_osMem.h
new file mode 100755
index 0000000..b6128cb
--- /dev/null
+++ b/include/linux/avalanche/generic/pal_osMem.h
@@ -0,0 +1,346 @@
+/*
+ *
+ * pal_osMem.h
+ * Description:
+ * see below
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2008-2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2008-2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** \file   pal_osMem.h
+    \brief  OsMEM Services Header File
+
+    This file declares OS abstraction services for variable length heap
+    memory management operations. The PAL module implementing these APIs
+    is called OsMEM
+
+
+    \author     PSP Architecture Team
+    \version    1.0
+ */
+
+#ifndef __PAL_OSMEM_H__
+#define __PAL_OSMEM_H__
+
+#include "pal_defs.h"
+#include "pal_os.h"
+
+/**
+ * \defgroup PALOSMem PAL OS Memory Interface
+ *
+ * PAL OS Memory Interface
+ * @{
+ */
+
+/** \name PAL OS Memory Interface
+ *  PAL OS Memory Interface
+ * @{
+ */
+
+/**
+ * \brief PAL OS MEM Init
+ *
+ * This is an idempotent function that must be called ahead of
+ * calling any other OsMEM services. It initializes OsMEM internal
+ * data structures (ex: segment tables) and does any book-keep
+ * necessary to implement the published services of OsMEM.
+ *
+ * \param   param [IN] is an arbitrary void* data type used to pass platform
+ * specific initialization information for OsMEM. This can be used
+ * to extend OsMEM configurability to decisions made at run-time.
+ * This is added for future extensions only.
+ * \return  PAL_SOK if successful else a suitable error code.
+ */
+PAL_INLINE PAL_Result PAL_osMemInit(Ptr param);
+
+/**
+ * \brief PAL OS Memory Address Space
+ *
+ * Specifies type of memory address space
+ */
+typedef enum
+{
+    PAL_OSMEM_ADDR_PRG      = 0,    /**< Program only address space */
+    PAL_OSMEM_ADDR_DAT      = 1,    /**< Data only address */
+    PAL_OSMEM_ADDR_IO       = 2,    /**< I/O only space address */
+    PAL_OSMEM_ADDR_PRGDAT   = 3,    /**< Unified prog-data */
+    PAL_OSMEM_ADDR_PRGIO    = 4,    /**< Unified prog-io */
+    PAL_OSMEM_ADDR_DATIO    = 5,    /**< Unified data-io */
+    PAL_OSMEM_ADDR_UNIFIED  = 6,    /**< Homogeneous, unified prog/data/io memory */
+    PAL_OSMEM_ADDR_SPECIAL  = 7     /**< Special or un-classified address range */
+} PAL_OsMemAddrSpace;
+
+/**
+ * \brief PAL OS Memory attributes
+ *
+ * Memory attributes
+ */
+typedef struct
+{
+  PAL_OsMemAddrSpace addrSpace;
+} PAL_OsMemAttrs;
+
+/**
+ * \brief PAL OS Memory Segment Define
+ *
+ * This function defines a segment of memory at specified
+ * start address with given attributes. Once defined, user can allocate
+ * variable length memory buffers at desired address alignments
+ * via the PAL_osMemAlloc() call.
+ *
+ * \param   name [IN]       Name of memory segment being defined
+ * \param   startAddr [IN]  The start address (byte granular) of memory segment
+ * \param   numBytes [IN]   The length in bytes of the memory segment
+ * \param   attrs [IN]      Optional memory attributes characterizing the
+ *                          region of memory being defined. Ex: Program or
+ *                          Data memory etc.,
+ * \param   segId [OUT]     Location to recieve the numeric identifier of the
+ *                          just defined memory segment.
+ * \return  PAL_SOK if successful, else a suitable error code
+ */
+PAL_INLINE PAL_Result PAL_osMemSegDefine(const char* name,
+                              Uint32 startAddr,
+                              Uint32 numBytes,
+                              PAL_OsMemAttrs *attrs,
+                              Uint32 *segId);
+
+/**
+ * \brief PAL OS Memory Segment Undefine
+ *
+ * This function undefines specified segment of memory. Once
+ * undefined, the region is no longer available for PAL_osMemAlloc().
+ *
+ * \param   segId [IN] Identifier of the memory segment being undefined.
+ * \return  PAL_SOK if successful, else a suitable error code
+ */
+PAL_INLINE PAL_Result PAL_osMemSegUndefine(Uint32 segId);
+
+/**
+ * \brief PAL OS Memory Alloc
+ *
+ * This function allocates specified length of memory from
+ * the given memory segment.
+ * \note The memory segment must already be defined before calling this API.
+ * \note Alignment = 0 or 1 results is NO special alignments being done. A
+ * value of 2 forces the buffer to start at even byte boundary
+ *
+ * \param   segId [IN]      Identifier of the hosting memory segment
+ * \param   numBytes [IN]   The length in bytes of buffer being allocated
+ * \param   alignment [IN]  A power-of-2 alignment constraint specifier.
+ *                          If non-zero, OsMEM will allocate specified length
+ *                          of memory ensuring that it is aligned to an
+ *                          address boundary as specified.
+ * \param   memAddr [OUT]   Address of just allocated memory buffer
+ * \return  PAL_SOK if successful, else a suitable error code
+ */
+PAL_INLINE PAL_Result PAL_osMemAlloc(Uint32 segId,
+                          Uint32 numBytes,
+                          Uint16 alignment,
+                          Ptr *memAddr);
+
+/**
+ * \brief PAL OS Memory Free
+ *
+ * This function counters the PAL_osMemAlloc() call in that it frees
+ * the specified memory buffer and returns it to the hosting memory
+ * segment for others to allocate.
+ * \note    The memory segment must already be defined before calling this API.
+ *
+ * \param   segId [IN]      Identifier of the hosting memory segment
+ * \param   memAddr [IN]    The start address of memory buffer being freed.
+ * \param   numBytes [IN]   The length in bytes of buffer being freed.
+ * \return  PAL_SOK if successful, else a suitable error code
+ */
+PAL_INLINE PAL_Result PAL_osMemFree(Uint32 segId, Ptr memAddr, Uint32 numBytes);
+
+/**
+ * \brief PAL OS Memory Copy
+ *
+ * This function copies specified number of bytes from give source
+ * address to given destination address
+ * \note The user is responsible of making sure that adequate free memory
+ * is indeed available at the specified destination address.
+ *
+ * \param   dest [IN/OUT]   Address of destination buffer
+ * \param   src [IN]        Address of buffer to copy data from
+ * \param   numBytes [IN]   The number of contigious bytes to copy
+ * \return  PAL_SOK if successful, else a suitable error code
+ */
+PAL_INLINE PAL_Result PAL_osMemCopy(Ptr dest, const Ptr src, Uint32 numBytes);
+
+/**
+ * \brief PAL OS Memory Set
+ *
+ * This function stamps the specified region of memory with
+ * the given bit pattern (fill character).
+ *
+ * \param   memAddr [IN/OUT]    Address of memory region to be stamped with
+ *                              fill character
+ * \param   fillVal [IN]        Address of buffer to copy data from
+ * \param   numBytes [IN]       The number of contigious bytes to fill
+ * \return  PAL_SOK if successful, else a suitable error code
+ */
+PAL_INLINE PAL_Result PAL_osMemSet(Ptr memAddr, Char fillVal, Uint32 numBytes);
+
+/**
+ * \brief PAL OS Memory Lock
+ *
+ * This function locks out the specified region of memory from
+ * any page-swap operations effected by OS virtual memory manager.
+ * Once locked, the region of memory will stay resident untill
+ * its unlocked via PAL_osMemUnlock().
+ *
+ * \param   memAddr [IN]    Address of memory region to be locked from VM opserations
+ * \param   byteLen [IN]    Length of memory region in bytes
+ * \param   cookie [OUT]    Space to recieve an arbitrary platform specific data
+ *                          associated with just performed locking. User is not
+ *                          expected to interpret it any way. It is intended to
+ *                          be passed as-is during matching unlocking operation
+ *                          via PAL_osMemUnlock().
+ * \return  PAL_SOK if successful, else a suitable error code
+ */
+PAL_INLINE PAL_Result PAL_osMemLock(Ptr memAddr,
+                         Uint32 byteLen,
+                         Uint32 *cookie);
+
+/**
+ * \brief PAL OS Memory Un-Lock
+ *
+ * This function counter to PAL_osMemLock() in that it unlocks the
+ * specified region of memory thereby exposing it to any swaps
+ * performed by OS virtual memory manager.
+ *
+ * \param   memAddr [IN]    Address of memory to be unlocked for VM operations
+ * \param   byteLen [IN]    Length of memory region in bytes
+ * \param   cookie [IN]     Platform specific data obtained when the specific
+ *                          memory region was locked by a corresponding
+ *                          PAL_osMemLock() function
+ * \return  PAL_SOK if successful, else a suitable error code
+ */
+PAL_INLINE PAL_Result PAL_osMemUnlock(Ptr memAddr,
+                           Uint32 byteLen,
+                           Uint32 *cookie);
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+/**
+ * \brief PAL OS Memory Virtual To Physical
+ *
+ * This function is relevant in platforms where OS is running
+ * a virtual memory manager. It inputs a logical or virtual
+ * memory address (as seen by application) and returns the
+ * corresponding physical memory address (as seen by the h/w
+ * devices).
+ * \note A macro equivalent of this API will also be available
+ *
+ * \param   virtAddress [IN] The virtual memory address
+ * \return  A 32bit unsigned physical memory address.
+ */
+PAL_INLINE Uint32 PAL_osMemVirt2Phy(Ptr virtAddress);
+
+/**
+ * \brief PAL OS Memory Physical To Virtual
+ *
+ * This function is relevant in platforms where OS is running
+ * a virtual memory manager. It inputs a physical memory
+ * address (as seen by the h/w devices) and returns the corresponding
+ * virtual memory address (as seen by the application).
+ * \note A macro equivalent of this API will also be available
+ *
+ * \param   phyAddress [IN] The physical memory address
+ * \return  Virtual memory address (unadorned void* type)
+ */
+PAL_INLINE Ptr PAL_osMemPhy2Virt(Uint32 phyAddress);
+
+#endif
+/**
+ * \brief PAL OS Memory Report Attributes
+ *
+ * PAL OS Memory Report attributes
+ */
+typedef struct
+{
+  Int segBytesSz;           /**< Segment size in bytes */
+  Int segBytesUsed;         /**< Number of bytes allocated */
+  Int numBufs;              /**< Number of buffers allocated */
+  Int maxLengthFree;        /**< Max contigious bytes free */
+  Int maxLengthAllocated;   /**< Max contigious bytes allocated */
+} PAL_OsMemReport;
+
+/**
+ * \brief PAL OS Memory Report
+ *
+ * This function reports assorted usage statistics information
+ * regarding the specified memory segment
+ *
+ * \param   segId [IN]      Identifier of memory segment to report statistics
+ * \param   report [IN/OUT] Location where information must be reported. If
+ *                          NULL, structure is not filled.
+ * \param   buf [IN/OUT]    String buffer where a text formatted report will
+ *                          be printed. If NULL, no text reporting is done
+ * \return  PAL_SOK if successful, else a suitable error code.
+ */
+PAL_INLINE PAL_Result PAL_osMemReport(Uint32 segId, PAL_OsMemReport *report, Char* buf);
+
+/*@}*/
+/*@}*/
+
+#endif /* _PAL_OSMEM_H_ */
diff --git a/include/linux/avalanche/generic/pal_osMem_inline.h b/include/linux/avalanche/generic/pal_osMem_inline.h
new file mode 100755
index 0000000..30efa4e
--- /dev/null
+++ b/include/linux/avalanche/generic/pal_osMem_inline.h
@@ -0,0 +1,305 @@
+/*
+ *
+ * pal_osMem_inline.h
+ * Description:
+ * see below
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2008-2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2008-2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+/** \file   pal_osMem_inline.h
+    \brief  OsMEM Services Source File
+
+    This file implements the OsMEM services for Linux.
+
+
+    \author     PSP Architecture Team
+    \version   0.1
+*/
+
+#ifndef __PAL_OSMEM_INLINE_H__
+#define __PAL_OSMEM_INLINE_H__
+
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+#include "pal_os.h"
+#include "pal_defs.h"
+#include <asm/page.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <asm/memory.h>
+#else /*AP-CPU*/
+#include "linux/avalanche/generic/pal_os.h"
+#include "linux/avalanche/generic/pal_defs.h"
+#include <asm/page.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <asm/io.h>
+#endif
+
+
+/**
+ * \brief PAL OS MEM Init
+ */
+PAL_INLINE PAL_Result PAL_osMemInit (Ptr param)
+{
+    return PAL_SOK;
+}
+
+/**
+ * \brief PAL OS Memory Segment Define
+ * For Linux, the whole available memory is considered into one segment.
+ * No further segments are made in the memory. This function designates that
+ * segment with id 0.
+ */
+PAL_INLINE PAL_Result PAL_osMemSegDefine (    const char * name,
+                                Uint32 startAddr,
+                                Uint32 numBytes,
+                                PAL_OsMemAttrs * attrs,
+                                Uint32 *segId)
+{
+    /* always return the segment id 0.
+     * Only one segment is defined and used
+     */
+    *segId = 0;
+    return PAL_SOK;
+}
+
+/**
+ * \brief PAL OS Memory Segment Undefine
+ * Only segment 0 is recognized.
+ */
+PAL_INLINE PAL_Result PAL_osMemSegUndefine (Uint32 segId)
+{
+    return PAL_SOK;
+}
+
+/**
+ * \brief PAL OS Memory Alloc
+ * Only segment 0 is recognized.
+ * This function allocates only contiguous memory.
+ * specify alignment as 0 if all you
+ */
+PAL_INLINE PAL_Result PAL_osMemAlloc (
+                Uint32 segId,
+                Uint32 numBytes,
+                Uint16 alignment,
+                Ptr* memAddr)
+{
+    *memAddr = kmalloc(numBytes, GFP_KERNEL);
+
+    if(*memAddr == NULL)
+    {
+        return PAL_OS_ERROR_NO_RESOURCES;
+    }
+
+     return PAL_SOK;
+}
+
+/**
+ * \brief PAL OS Memory Free
+ * Only segment 0 is recognized.
+ */
+PAL_INLINE PAL_Result PAL_osMemFree (Uint32 segId, Ptr memAddr, Uint32 numBytes)
+{
+    kfree(memAddr);
+    return PAL_SOK;
+}
+
+/**
+ * \brief PAL OS Memory Copy
+ * \note This will misbehave if presented with invalid arguments.
+ */
+PAL_INLINE PAL_Result PAL_osMemCopy (Ptr dest, const Ptr src, Uint32 numBytes)
+{
+    memcpy(dest, src, numBytes);
+    return PAL_SOK;
+}
+
+/**
+ * \brief PAL OS Memory Set
+ * This will crash if presented with invalid arguments.
+ */
+PAL_INLINE PAL_Result PAL_osMemSet (Ptr memAddr, Char fillVal, Uint32 numBytes)
+{
+    memset(memAddr, fillVal, numBytes);
+    return PAL_SOK;
+}
+
+/**
+ * \brief PAL OS Memory Lock
+ * In linux, memory locking/Unlocking is supported only at page granularity.
+ * This implementation, locks all the pages from memAddr to memAddr + byteLen
+ * pages containing both addresses inclusive.
+ */
+PAL_INLINE PAL_Result PAL_osMemLock (Ptr memAddr, Uint32 byteLen, Uint32 *cookie)
+{
+    Uint32 temp;
+
+    /*
+     * Get the page associated with the memory address
+     * and set the reserved bit for that page
+     */
+    for (temp = (Uint32)memAddr; temp < PAGE_ALIGN((Uint32)memAddr+byteLen); temp += PAGE_SIZE)
+	{
+        SetPageReserved(virt_to_page(temp));
+    }
+    return PAL_SOK;
+}
+
+/**
+ * \brief PAL OS Memory Un-Lock
+ * In linux, memory locking/Unlocking is supported only at page granularity.
+ * This implementation, locks all the pages from memAddr to memAddr + byteLen
+ * pages containing both addresses inclusive.
+ */
+PAL_INLINE PAL_Result PAL_osMemUnlock (Ptr memAddr, Uint32 byteLen, Uint32 *cookie)
+{
+    Uint32 temp;
+
+    /*
+     * Get the page associated with the memory address
+     * and unset the reserved bit for that page
+     */
+    for (temp = (Uint32)memAddr; temp < PAGE_ALIGN((Uint32)memAddr+byteLen); temp += PAGE_SIZE)
+	{
+        ClearPageReserved(virt_to_page(temp));
+    }
+    return PAL_SOK;
+}
+
+/**
+ * \brief PAL OS Memory Virtual To Physical
+ */
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+PAL_INLINE Uint32 PAL_osMemVirt2Phy (Ptr virtAddress)
+{
+    return (Uint32) __virt_to_phys((Uint32)virtAddress);
+}
+
+/**
+ * \brief PAL OS Memory Physical To Virtual
+ */
+PAL_INLINE Ptr PAL_osMemPhy2Virt (Uint32 phyAddress)
+{
+
+    return (Ptr) __phys_to_virt(phyAddress);
+}
+#endif
+
+/**
+ * \brief PAL OS Memory Report
+ * No reporting is supported inherently by the Linux kernel.
+ */
+PAL_INLINE PAL_Result PAL_osMemReport (Uint32 segId, PAL_OsMemReport * report, Char *buf)
+{
+    return PAL_OS_ERROR_NOT_SUPPORTED;
+}
+
+/**
+ *  \brief PAL os Memory Allocation API. Allocated memory
+ *  memory will be aligned to requested size. For smaller
+ *  memory chunks (less than page size) use PAL_osMemAlloc
+ */
+
+PAL_INLINE void* PAL_osMemAllocSizeAligned(Uint32 segId, Uint32 numBytes)
+{
+    Uint32 order;
+    Uint32 ret;
+
+    /* find number of pages */
+    numBytes = (numBytes/PAGE_SIZE) + ((numBytes % PAGE_SIZE)?1:0);
+
+    /* find allocation order */
+    for(order = 0; (1 << order) < numBytes; order++);
+
+    ret = __get_free_pages(GFP_KERNEL, order);
+
+    /* really defensive stuff: just to make sure we are good */
+    if((ret % (1 << order)) != 0) {
+        free_pages(ret, order);
+        ret = 0;
+    }
+
+    return (void*) ret;
+}
+
+/**
+ *  \brief PAL os Memory Free API. This API can only free memory
+ *  allocated using PAL_osMemAllocSizeAligned.
+ */
+PAL_INLINE void PAL_osMemFreeSizeAligned(Uint32 segId, void* addr, Uint32 numBytes)
+{
+    Uint32 order;
+
+    /* find number of pages */
+    numBytes = (numBytes/PAGE_SIZE) + ((numBytes % PAGE_SIZE)?1:0);
+
+    /* find allocation order */
+    for(order = 0; (1 << order) < numBytes; order++);
+
+    free_pages((unsigned long)addr, order);
+}
+
+#endif
+
diff --git a/include/linux/avalanche/generic/pal_osProtect.h b/include/linux/avalanche/generic/pal_osProtect.h
new file mode 100755
index 0000000..0041eee
--- /dev/null
+++ b/include/linux/avalanche/generic/pal_osProtect.h
@@ -0,0 +1,161 @@
+/*
+ *
+ * pal_osProtect.h
+ * Description:
+ * see below
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2008-2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2008-2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+/** \file   pal_osProtect.h
+    \brief  OsPROTECT Services Header File
+    ===================================================================
+    The OsPROTECT models various levels of reentrancy protection
+    for use while writing critical sections in user code. critical
+    sections are those parts of user code that needs to run atomically
+    in some sense. Meaning, single threading is called for. However,
+    the degree of protection sought by user varies based on nature
+    of code he is writing.
+
+    It is possible that for some regions of code, user needs ultimate
+    degree of protection where all external interrupts are blocked,
+    essentially locking out the CPU exclusively for the critical
+    section of code. On the other hand user may wish to merely avoid
+    thread or task switch from occuring inside said region of code,
+    but he may wish to entertain ISRs to run if so required.
+
+    Depending on the underlying OS, the number of levels of protection
+    offered may vary. At the least, two basic levels of protection are
+    supported --
+
+    - PAL_OSPROTECT_INTERRUPTS - Mask interrupts globally. This has
+      real-time implications and must be used with descretion.
+      If blocking/unblocking of specific interrupt lines is desired,
+      one is reffered to APIs listed in pal_sys.h file.
+
+    - PAL_OSPROTECT_SCHEDULER - Only turns off Kernel scheduler
+      completely, but still allows h/w interrupts from being serviced.
+
+    Protection levels 0 to N (max positive Int) are platform specific
+    ===================================================================
+
+
+    \author     PSP Architecture Team
+    \version    1.0
+ */
+
+#ifndef __PAL_OSPROTECT_H__
+#define __PAL_OSPROTECT_H__
+
+#include "pal_defs.h"
+#include "pal_os.h"
+
+/**
+ * \defgroup PalOSProtect PAL OS Protect Interface
+ *
+ * PAL OS Protect Interface
+ * \{
+ */
+
+/** \name PAL OS Protect Interface
+ *  PAL OS Protect Interface
+ * \{
+ */
+
+#define PAL_OSPROTECT_INTERRUPT (-1)
+#define PAL_OSPROTECT_SCHEDULER (-2)
+
+/**
+ * \brief   PAL OS Protect Entry
+ *
+ *      This function saves the current state of protection in cookie
+ *      variable passed by caller. It then applies the requested level
+ *      of protection
+ * \param   level is numeric identifier of the desired degree of protection.
+ * \param   cookie is memory location where current state of protection is
+ *      saved for future use while restoring it via PAL_osProtectExit()
+ * \note    user is not expected to interpret the cookie in any manner. It
+ *      is intended for use in terminating the presently enforced
+ *      protection via a matching PAL_osProtectExit() call discssed
+ *      later in this file.
+ * \return  None
+ */
+PAL_INLINE void PAL_osProtectEntry(Int level, Uint32* cookie);
+
+/**
+ * \brief   PAL OS Protect Exit
+ *
+ *      This function undoes the protection enforced to original state
+ *      as is specified by the cookie passed.
+ * \param   level is numeric identifier of the desired degree of protection.
+ * \param   cookie is original state of protection at time when the
+ *      corresponding PAL_osProtectEnter() was called.
+ * \return  None
+ */
+PAL_INLINE void PAL_osProtectExit(Int level, Uint32 cookie);
+
+/*\}*/
+/*\}*/
+
+#endif /* _PAL_OSPROTECT_H_ */
diff --git a/include/linux/avalanche/generic/pal_osProtect_inline.h b/include/linux/avalanche/generic/pal_osProtect_inline.h
new file mode 100755
index 0000000..95e9b65
--- /dev/null
+++ b/include/linux/avalanche/generic/pal_osProtect_inline.h
@@ -0,0 +1,127 @@
+/*
+ *
+ * pal_osProtect_inline.h
+ * Description:
+ * see below
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2008-2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2008-2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** \file   pal_osProtect_inline.h
+    \brief  OsPROTECT Services Source File
+
+
+    \author     PSP Architecture Team
+    \version    1.0
+ */
+
+#ifndef __PAL_OSPROTECT_INLINE_H__
+#define __PAL_OSPROTECT_INLINE_H__
+
+#include "pal_os.h"
+#include "pal_defs.h"
+#include "pal_osCfg.h"
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+
+/**
+ * \defgroup PalOSProtect PAL OS Protect Interface
+ *
+ * PAL OS Protect Interface
+ * \{
+ */
+
+/** \name PAL OS Protect Interface
+ *  PAL OS Protect Interface
+ * \{
+ */
+
+
+/**
+ * \brief   PAL OS Protect Entry
+ */
+PAL_INLINE void PAL_osProtectEntry(Int level, Uint32* cookie)
+{
+	Ulong flags;
+    if(level == PAL_OSPROTECT_INTERRUPT)
+	{
+        local_irq_save(flags);
+		*cookie = flags;
+	}
+}
+/**
+ * \brief   PAL OS Protect Exit
+ */
+PAL_INLINE void PAL_osProtectExit(Int level, Uint32 cookie)
+{
+    if(level == PAL_OSPROTECT_INTERRUPT)
+	{
+        local_irq_restore((Ulong)cookie);
+	}
+}
+
+/*\}*/
+/*\}*/
+
+#endif
+
diff --git a/include/linux/avalanche/generic/pal_sys.h b/include/linux/avalanche/generic/pal_sys.h
new file mode 100755
index 0000000..aa3e86d
--- /dev/null
+++ b/include/linux/avalanche/generic/pal_sys.h
@@ -0,0 +1,278 @@
+/*
+ *
+ * pal_sys.h
+ * Description:
+ * see below
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2008-2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2008-2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+/** \file   pal_sys.h
+    \brief  PAL SoC level API header file
+
+    This file defines data types and services (macros as well as functions)
+    that are applicable to the abstracted h/w system (SoC/Board).
+
+
+    \author     PSP Architecture Team
+    \version    1.0
+ */
+
+#ifndef __PAL_SYS_H__
+#define __PAL_SYS_H__
+
+#define BOARD_TYPE_UNKNOWN 0xFF
+/*****************************************************************************
+ * Reset Control Module
+ *****************************************************************************/
+
+typedef enum PAL_SYS_RESET_CTRL_tag
+{
+    IN_RESET        = 0,
+    OUT_OF_RESET,
+    CLK_DISABLE,
+    CLK_ENABLE
+} PAL_SYS_RESET_CTRL_T;
+
+typedef enum PAL_SYS_SYSTEM_RST_MODE_tag
+{
+    RESET_SOC_WITH_MEMCTRL      = 1,    /* SW0 bit in SWRCR register */
+    RESET_SOC_WITHOUT_MEMCTRL   = 2     /* SW1 bit in SWRCR register */
+} PAL_SYS_SYSTEM_RST_MODE_T;
+
+typedef enum PAL_SYS_SYSTEM_RESET_STATUS_tag
+{
+    HARDWARE_RESET = 0,		/**< Power On Reset */
+    SOFTWARE_RESET0,   		/**< External Warm Reset*/
+    WATCHDOG_RESET,			/**< Maximum Reset - this could be from watchdog or emulation */
+	SOFTWARE_RESET1,		/**< System/Chip Reset */
+	RST_STAT_END
+} PAL_SYS_SYSTEM_RESET_STATUS_T;
+
+void PAL_sysResetCtrl(unsigned int reset_module,PAL_SYS_RESET_CTRL_T reset_ctrl);
+PAL_SYS_RESET_CTRL_T PAL_sysGetResetStatus(unsigned int reset_module);
+void PAL_sysSystemReset(PAL_SYS_SYSTEM_RST_MODE_T mode);
+
+typedef void (*REMOTE_VLYNQ_DEV_RESET_CTRL_FN)(unsigned int reset_module,
+                                               PAL_SYS_RESET_CTRL_T reset_ctrl);
+
+
+/*****************************************************************************
+ * Power Control Module
+ *****************************************************************************/
+/** \enum PAL_SYS_POWER_CTRL_tag
+	\brief Enum for power control states
+	\TODO Move this to pal_sys.h
+*/
+typedef enum PAL_SYS_POWER_CTRL_tag
+{
+	/* these enums below are used for modules alone */
+	PSC_SW_RST_DISABLE=0,	/**< Completely OFF (IN RESET) state - reset asserted and clock gated */
+	PSC_SYNC_RESET,			/**< Sync reset - reset asserted and clock running */
+	PSC_DISABLE, 			/**< Low power mode - Reset deasserted and clock gated */
+	PSC_ENABLE,				/**< Completely ON (OUT OF RESET) state - reset deasserted and clock running */
+
+	/* These enums should be used only for domains or from pal_sysPowerCtrl.c */
+    POWER_CTRL_POWER_UP,		/**< Power On */
+    POWER_CTRL_POWER_DOWN,			/**< Power Off */
+} PAL_SYS_POWER_CTRL_T;
+
+
+typedef enum PAL_SYS_SYSTEM_POWER_MODE_tag
+{
+    GLOBAL_POWER_MODE_RUN       = 0,    /* All system is up */
+    GLOBAL_POWER_MODE_IDLE,             /* MIPS is power down, all peripherals working */
+    GLOBAL_POWER_MODE_STANDBY,          /* Chip in power down, but clock to ADSKL subsystem is running */
+    GLOBAL_POWER_MODE_POWER_DOWN        /* Total chip is powered down */
+} PAL_SYS_SYSTEM_POWER_MODE_T;
+
+void PAL_sysPowerCtrl(unsigned int power_module,  PAL_SYS_POWER_CTRL_T power_ctrl);
+
+/*****************************************************************************
+ * Wakeup Control
+ *****************************************************************************/
+
+typedef enum PAL_SYS_WAKEUP_INTERRUPT_tag
+{
+    WAKEUP_INT0 = 1,
+    WAKEUP_INT1 = 2,
+    WAKEUP_INT2 = 4,
+    WAKEUP_INT3 = 8
+} PAL_SYS_WAKEUP_INTERRUPT_T;
+
+typedef enum PAL_SYS_WAKEUP_CTRL_tag
+{
+    WAKEUP_DISABLED = 0,
+    WAKEUP_ENABLED
+} PAL_SYS_WAKEUP_CTRL_T;
+
+typedef enum PAL_SYS_WAKEUP_POLARITY_tag
+{
+    WAKEUP_ACTIVE_HIGH = 0,
+    WAKEUP_ACTIVE_LOW
+} PAL_SYS_WAKEUP_POLARITY_T;
+
+
+/*****************************************************************************
+ * GPIO Control
+ *****************************************************************************/
+
+typedef enum PAL_SYS_GPIO_PIN_MODE_tag
+{
+    FUNCTIONAL_PIN = 0,
+    GPIO_PIN = 1
+} PAL_SYS_GPIO_PIN_MODE_T;
+
+typedef enum PAL_SYS_GPIO_PIN_DIRECTION_tag
+{
+    GPIO_OUTPUT_PIN = 0,
+    GPIO_INPUT_PIN = 1
+
+} PAL_SYS_GPIO_PIN_DIRECTION_T;
+
+typedef enum { GPIO_FALSE, GPIO_TRUE } PAL_SYS_GPIO_BOOL_T;
+
+typedef enum
+{
+    GPIO_PIN_DISABLE = 0,
+    GPIO_PIN_ENABLE
+}PAL_SYS_GPIO_PIN_STATUS_T;
+
+typedef enum
+{
+    GPIO_PIN_LOW = 0,
+    GPIO_PIN_HIGH
+}PAL_SYS_GPIO_PIN_POLARITY_T;
+
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+INT32 PAL_sysGpioInBit(UINT32 gpio_pin);
+INT32 PAL_sysGpioOutBit(UINT32 gpio_pin, INT32 value);
+#if (PUMA7_OR_NEWER_SOC_TYPE)
+INT32 PAL_sysGpioSetStatus(UINT32 gpio_pin, PAL_SYS_GPIO_PIN_STATUS_T status);
+INT32 PAL_sysGpioGetStatus(UINT32 gpio_pin);
+INT32 PAL_sysGpioSetPolarity(UINT32 gpio_pin, PAL_SYS_GPIO_PIN_POLARITY_T polarity);
+INT32 PAL_sysGpioResetAVB(void);
+INT32 PAL_sysGpioAVBconfig(UINT32 gpio_pin);
+INT32 PAL_sysGpioGetAVBcounterValue(void);
+#endif
+#if  defined (CONFIG_MACH_PUMA5)
+INT32 PAL_sysGpioCtrl(UINT32 gpio_pin, PAL_SYS_GPIO_PIN_MODE_T pin_mode, PAL_SYS_GPIO_PIN_DIRECTION_T pin_direction);
+INT32 PAL_sysGpioOutValue(UINT32 out_val, UINT32 out_mask,UINT32 reg_index);
+#else
+PAL_SYS_GPIO_PIN_DIRECTION_T PAL_sysGpioCtrlGetDir(UINT32 gpio_pin);
+INT32 PAL_sysGpioCtrlSetDir(UINT32 gpio_pin, PAL_SYS_GPIO_PIN_DIRECTION_T pin_direction);
+#endif
+/*****************************************************************************
+ * CLKC Control
+ *****************************************************************************/
+
+void PAL_sysClkcInit(void* param);
+int PAL_sysClkcSetFreq(PAL_SYS_CLKC_ID_T clk_id, unsigned int output_freq);
+int PAL_sysClkcGetFreq(PAL_SYS_CLKC_ID_T clk_id);
+#endif
+/*****************************************************************************
+ * MISC
+ *****************************************************************************/
+
+unsigned int PAL_sysGetChipVersionInfo(void);
+
+typedef struct module_info {
+        Uint32 version;
+        Uint32 base_addr;
+} MOD_INFO_T;
+
+#if defined (CONFIG_MACH_PUMA5)
+typedef struct board_info {
+        MOD_INFO_T modules[MAX_MODULES];
+}BOARD_INFO_T;
+
+extern BOARD_INFO_T soc[];
+
+PAL_Result PAL_sysProbeAndPrep(Uint32 version, Uint32 base_addr, void *param);
+PAL_Result avalanche_device_prepare(Uint32 module_id, Uint32 base_addr, BOARD_ID board_variant, void *param);
+#endif
+
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+/*****************************************************************************
+ * CACHE
+ *****************************************************************************/
+
+int PAL_sysCacheInvalidate(PAL_OsMemAddrSpace addrSpace,
+                             void *mem_start_ptr,
+                             unsigned int num_bytes);
+
+int PAL_sysCacheFlush(PAL_OsMemAddrSpace addrSpace,
+                        	void *mem_start_ptr,
+                        	unsigned int num_bytes);
+
+int PAL_sysCacheFlushAndInvalidate(PAL_OsMemAddrSpace addrSpace,
+                             void *mem_start_ptr,
+                             unsigned int num_bytes);
+#if defined (CONFIG_MACH_PUMA5)
+#include <asm-arm/arch-avalanche/generic/pal_sysPsc.h>
+#endif
+#include "pal_sysWdtimer.h"
+#include "pal_sysTimer16.h"
+#endif
+#endif
diff --git a/include/linux/avalanche/generic/pp_qos_p7.h b/include/linux/avalanche/generic/pp_qos_p7.h
new file mode 100755
index 0000000..b6ff712
--- /dev/null
+++ b/include/linux/avalanche/generic/pp_qos_p7.h
@@ -0,0 +1,572 @@
+/* 
+ * pp_qos_p7.h
+ * Description:
+ * QoS Manager driver APIs
+ 
+ 
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2016 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#ifndef PP_QOS_P7_H
+#define PP_QOS_P7_H
+/************************************************/
+/*                    Includes                  */
+/************************************************/
+
+/************************************************/
+/*                    Defines                   */
+/************************************************/
+
+#define PP_QOS_MAX_CLUSTERS          (64)
+#define PP_QOS_MAX_QUEUES            (192)
+#define PP_QOS_MAX_QUEUES_IN_CLUSTER AVALANCHE_PP_QOS_CLST_MAX_QCNT
+
+#define PP_QOS_MAX_QUEUE_INDEX       (PP_QOS_MAX_QUEUES - 1)
+#define PP_QOS_MAX_CLUSTER_INDEX     (PP_QOS_MAX_CLUSTERS - 1)
+
+#define PP_QOS_Q_REALTIME_FLAG       (1<<0)
+#define PP_QOS_Q_NO_QOS_FLAG         (1<<1)
+
+
+#define PP_QOS_ITERATION_TICK_USEC   (25)
+#define PP_QOS_ITERATION_PER_SECOND  (1000000 / PP_QOS_ITERATION_TICK_USEC)
+
+#define INVALID_QDA_THREAD_ID        (32)
+#define INVALID_QDA_QUEUE            (255)
+#define PP_QOS_INVALID_CLUSTER       (255)
+#define PP_QOS_DEFAULT_PRIORITY      (0)
+
+#define PP_QOS_FW_QCFG_BLK_BASE_PHY  (0xF3E10200)
+#define PP_QOS_FW_CLST_BLK_BASE_PHY  (0xF3E12200)
+
+/* Rate(in Mbps) * 1M) / iteration per second / 8(bits in byte) */
+#define PP_QOS_MEGA_BIT_PER_SEC_TO_IT_CREDIT_BYTES(x)    ((Uint32)(((Uint64)(x * 1000 * 1000)) / PP_QOS_ITERATION_PER_SECOND / 8 ))
+#define PP_QOS_PPS_TO_IT_CREDIT_PACKETS(x)               ((Uint16)(x / PP_QOS_ITERATION_PER_SECOND))
+
+/************************************************/
+/*                 Structures                   */
+/************************************************/
+/* QoS manager return code */
+typedef enum
+{
+    PP_QOS_RC_SUCCESS,
+    PP_QOS_RC_FAILURE,
+    PP_QOS_RC_INVALID_PARAM,
+    PP_QOS_RC_OUT_OF_MEMORY,
+    PP_QOS_RC_OBJECTS_STARVATION
+}
+PP_QOS_MGR_RET_e;
+
+/* QoS manager scheduling mode */
+typedef enum
+{
+    PP_QOS_SCH_STRICT,
+    PP_QOS_SCH_WFQ
+}
+PP_QOS_SCH_MODE_e;
+
+/* QoS manager Qos-profile */
+typedef struct
+{
+    PP_QOS_SCH_MODE_e sch_mode;                   /* Strict/WFQ */
+    Uint8             num_of_priorities;          /* Number of priorities */
+    Uint8             vpid_id;                    /* VPID ID */
+    Uint16            profile_private_identifier;
+    Uint32            egress_port_queue;          /* Egress queue number */
+    Uint32            egress_queue_depth_packets; /* Egress queue depth (packets) */
+    Uint32            egress_queue_depth_bytes;   /* Egress queue depth (bytes) */
+    Uint32            ingress_queue_depth_packets;/* Ingress queue depth (packets) */
+    Uint32            ingress_queue_depth_bytes;  /* Ingress queue depth (bytes) */
+    Uint32            port_rate_limit_Mbps;       /* Rate limit (in Mbps)*/
+    Uint32            port_pps_limit;             /* PPS limit */
+}
+PP_QOS_PROFILE_t;
+
+/* QoS manager statistics */
+typedef struct
+{
+    Uint8    active_shared_clusters;
+    Uint8    active_private_clusters[AVALANCHE_PP_MAX_PID];
+    Uint8    private_clusters_free_pool_cnt[AVALANCHE_PP_MAX_PID];
+    Uint8    active_shared_queues;
+    Uint8    active_private_queues[AVALANCHE_PP_MAX_PID];
+    Uint8    private_queues_free_pool_cnt[AVALANCHE_PP_MAX_PID];
+    Uint32   clusters_starvation_shared;
+    Uint32   queues_starvation_shared;
+}
+PP_QOS_DB_Counters_t;
+
+typedef struct
+{
+    Uint64      frwd_pkts;            /* Number of packets forwarded to the Egress Queue */
+    Uint64      drp_pkts;             /* Number of packets dropped due to congestion */
+}
+PP_QOS_MIB_STATS_t;
+
+typedef struct
+{
+
+    Uint32                      global_credit_bytes;        /* The amount of global credit bytes available to the next Qos queue in the cluster */
+
+    Uint16                      global_credit_pkts;         /* The amount of global credit packet available to the next Qos queue in the cluster */
+    Uint16                      max_global_credit_pkts;     /* The max amount of global credit pkts allowed carring over to the next queue. */
+
+    Uint32                      max_global_credit_bytes;    /* The max amount of global credit bytes allowed carring over to the next queue. */
+
+    Uint16                      qda_queue;                  /* The queue which we activated QDA on. INVALID_QDA_QUEUE indicates that QDA wasn't activated on any on the cluster queues */
+    Uint8                       egr_q_cnt;                  /* The total number of egress queues sampled to obtain the egress queue congestion estimation */
+    Uint8                       qos_q_cnt;                  /* The number of QOS queues in the cluster (1 to 9) */
+
+    Uint8                       qos_q3;                     /* The queue index (0 to 127) of each QOS queue in the cluster listed in priority order */
+    Uint8                       qos_q2;
+    Uint8                       qos_q1;
+    Uint8                       qos_q0;
+
+    Uint8                       qos_q7;
+    Uint8                       qos_q6;
+    Uint8                       qos_q5;
+    Uint8                       qos_q4;
+
+    Uint16                      egr_q1;                     /* The Queue index of every egress queue enumerated in Egress Queue Count */
+    Uint16                      egr_q0;
+
+    Uint16                      egr_q3;
+    Uint16                      egr_q2;
+
+    Uint32                      egr_congst_thrsh_bytes1;	/* Egress Congestion Threshold bytes point 1  */
+    Uint32                      egr_congst_thrsh_bytes2;	/* Egress Congestion Threshold bytes point 2  */
+    Uint32                      egr_congst_thrsh_bytes3;    /* Egress Congestion Threshold bytes point 3  */
+    Uint32                      egr_congst_thrsh_bytes4;	/* Egress Congestion Threshold bytes point 4  */
+
+    Uint16                      egr_congst_thrsh_pkts1;     /* Egress Congestion Threshold Packets point 4  */
+    Uint16                      egr_congst_thrsh_pkts2;     /* Egress Congestion Threshold Packets point 3  */
+    Uint16                      egr_congst_thrsh_pkts3;     /* Egress Congestion Threshold Packets point 2  */
+    Uint16                      egr_congst_thrsh_pkts4;     /* Egress Congestion Threshold Packets point 1  */
+
+    Uint32                      w14;                        /* Reserved */
+    Uint32                      w15;                        /* Reserved */
+
+}
+PP_QOS_FW_CLST_CFG_t;
+
+typedef struct
+{
+    Uint16 egr_q;                    /* The Queue index of the forwarding queue */
+    Uint8  flags;                    /* Specifies how the frames in the QOS queue should be handled */
+    Uint8  QDAThreadId;              /* Indicates which QDA thread id is working on that queue. INVALID_QDA_THREAD_ID means that no thread is bound to that queue */
+
+    Uint32 iteration_credit_bytes;   /* The amount of byte credit that the queue receives every 25us. */
+    Uint32 total_credit_bytes;       /* The total amount of forwarding byte credit that the queue is currently holding */
+    Uint32 max_credit_bytes;         /* The max amount of forwarding byte crerdit that the queue is allowed to hold at the end of the 25US iteration */
+
+    Uint16 iteration_credit_pkts;    /* The amount of packet credit that the queue receives every 25us. */
+    Uint16 total_credit_pkts;        /* The total amount of forwarding pkt credit that the queue is currently holding */
+
+    Uint16 max_credit_pkts;          /* The max amount of forwarding packet crerdit that the queue is allowed to hold at the end of the 25US iteration */
+    Uint16 congst_thrsh_pkts;        /* The size in packets at which point the Qos queue is considered to be congested */
+
+    Uint32 congst_thrsh_bytes;       /* The size in bytes at which point the Qos queue is considered to be congested */
+    Uint32 w7;                       /* Reserved */
+
+}
+PP_QOS_FW_QUEUE_t;
+
+#ifdef __KERNEL__
+/* **************************************************************************************** */
+/*                                                                                          */
+/*                                                                                          */
+/*                                                                                          */
+/*                      KERNEL only Stuff                                                   */
+/*                                                                                          */
+/*                                                                                          */
+/*                                                                                          */
+/* **************************************************************************************** */
+
+
+/************************************************/
+/* QoS manager APIs                             */
+/************************************************/
+/**************/
+/* Common     */
+/**************/
+/**
+ *  pp_qos_mngr_init - Initialized the QoS manager DB
+ *  
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_mngr_init(void);
+/**
+ *  pp_qos_set_basic_profile - This API should be called while
+ *  QoS profile is created for NI
+ *  basic profile is 1 cluster with 1 egress queue.
+ *  @qos_profile: Pointer to qos profile to set
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_set_basic_profile(PP_QOS_PROFILE_t *qos_profile);
+/**
+ *  pp_qos_is_profile_registered - This API return if the QoS
+ *  profile is alreadu exist int the QoS manager
+ *  @vpid_id: Pointer to qos profile to set
+ *  @profile_private_identifier: identifier for profile
+ *  @isSupported: pointer to return id profile is registered
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_is_profile_registered(Uint8 vpid_id, Uint16 profile_private_identifier, Bool *isRegistered);
+/**
+ *  pp_qos_delete_profile - This API should be called when NI
+ *  need to delete QoS profile
+ *  @vpid_id: Profile's VPID
+ *  @profile_private_identifier: Profile's private identifier
+ *  @profile_stats: To return the profile statistics before the
+ *                profile will deleted.
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_delete_profile(Uint8 vpid_id, Uint16 profile_private_identifier, PP_QOS_MIB_STATS_t *profile_stats);
+/**
+ *  pp_qos_delete_all_profiles - This API should be called while
+ *  NI is going down
+ *  @vpid_id: VPID ID
+ *  @vpid_stats: To return the vpid statistics before the
+ *             profiles will deleted.
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_delete_all_profiles(Uint8 vpid_id, PP_QOS_MIB_STATS_t * vpid_stats);
+/**
+ *  pp_qos_db_get_counters - Get the QoS DB statistics
+ *  @qos_db_stats: Pointer to QoS DB statistics to set
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_db_get_counters(PP_QOS_DB_Counters_t *qos_db_stats);
+/**
+ *  pp_qos_enable_psm - Enter to psm mode
+ *  
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_enable_psm(void);
+/**
+ *  pp_qos_disable_psm - Exit from psm mode
+ *  
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_disable_psm(void);
+
+
+/**************/
+/* Cluster    */
+/**************/
+/**
+ *  pp_qos_cluster_is_active - Check if cluster is active
+ *  @phy_cluster_id: Cluster ID
+ *  @is_active: Pointer to return if active or not
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_cluster_is_active(Uint8 phy_cluster_id, Bool *is_active);
+/**
+ *  pp_qos_set_cluster_config - Config QoS cluster
+ *  @phy_cluster_id: Cluster ID
+ *  @vpid_id: VPID ID
+ *  @clst_cfg: Pointer to requested cluster
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_set_cluster_config(Uint8 phy_cluster_id, Uint8 vpid_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg);
+/**
+ *  pp_qos_alloc_cluster - Alloc/Create QoS cluster
+ *  @vpid_id: VPID ID
+ *  @phy_cluster_id: Pointer to return the cluster ID
+ *  @profile_private_identifier: unique identifier for profile
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_alloc_cluster(Uint8 vpid_id, Uint16 profile_private_identifier, Uint8 *phy_cluster_id);
+/**
+ *  pp_qos_free_cluster - Free/Delete QoS cluster
+ *  @phy_cluster_id: Cluster ID
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_free_cluster(Uint8 phy_cluster_id);
+/**
+ *  pp_qos_get_cluster_config - Get the cluster configuration
+ *  @phy_cluster_id: Cluster ID
+ *  @clst_cfg: Pointer to return the cluster configuration
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_cluster_config(Uint8 phy_cluster_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg);
+/**
+ *  pp_qos_get_queue_and_cluster_id_by_priority - Get the
+ *  cluster and queue ID for given vpid identifier and Q
+ *  priority.
+ *  @vpid_id: VPID ID
+ *  @profile_private_identifier: Private identifier for profile
+ *  @priority: queue priority - This Uint8 field represent the
+ *           priority of the qos Q, 0 is the lowest priority,
+ *           the max priority is the number of qos queues in the
+ *           cluster.
+ *  @phy_cluster_id: Pointer to return the cluster ID
+ *  @phy_queue_id: Pointer to return the queue ID
+ *  
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_queue_and_cluster_id_by_priority(Uint8 vpid_id, Uint16 profile_private_identifier, Uint8 priority, Uint8 *phy_cluster_id, Uint8 *phy_queue_id);
+/**
+ *  pp_qos_get_queue_id_by_cluster_and_priority - Get the queue
+ *  ID by given cluster and priority.
+ *  @phy_cluster_id: Cluster ID
+ *  @priority: queue priority - This Uint8 field represent the
+ *           priority of the qos Q, 0 is the lowest priority,
+ *           the max priority is the number of qos queues in the
+ *           cluster.
+ *  @phy_queue_id: Pointer to return the queue ID
+ *  
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_queue_id_by_cluster_and_priority(Uint8 phy_cluster_id, Uint8 priority, Uint8 *phy_queue_id);
+/**
+ *  pp_qos_get_cluster_by_identifier - Get the cluster
+ *  configuration by given VPID and identifier.
+ *  @profile_private_identifier: Private identifier
+ *  @vpid_id: VPID ID
+ *  @phy_cluster_id: Pointer to return the cluster ID
+ *  @clst_cfg: Pointer to return the cluster configuration
+ *  
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_cluster_by_identifier(Uint16 profile_private_identifier, Uint8 vpid_id,  Uint8 *phy_cluster_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg);
+/**
+ *  pp_qos_get_cluster_stats - Get QoS statistics for cluster
+ *  @phy_cluster_id: Cluster ID
+ *  @cluster_stats: Pointer to return the cluster
+ *                statistics
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_cluster_stats(Uint8 phy_cluster_id, PP_QOS_MIB_STATS_t *cluster_stats);
+/**
+ *  pp_qos_get_cluster_by_queue_id - Get the cluster
+ *  configuration by a given queue id
+ *  @phy_queue_id: Queue ID
+ *  @phy_cluster_id: Pointer to return the cluster id
+ *  @clst_cfg: Pointer to return the cluster
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_cluster_by_queue_id(Uint8 phy_queue_id, Uint8 *phy_cluster_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg);
+/**************/
+/* Queue      */
+/**************/
+/**
+ *  pp_qos_add_queue_to_cluster - Adds queue to cluster
+ *  @phy_cluster_id: Cluster ID
+ *  @user_priority: User priority of the queue
+ *  @queue_cfg: Pointer to AVALANCHE_PP_QOS_QUEUE_t
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_add_queue_to_cluster(Uint8 phy_cluster_id, AVALANCHE_PP_QOS_QUEUE_t *queue_cfg, Uint8 user_priority);
+/**
+ *  pp_qos_del_queue_by_cluster_and_user_prio - Deletes queue
+ *  from cluster
+ *  @phy_cluster_id: Cluster ID
+ *  @user_priority: User priority of the queue
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_del_queue_by_cluster_and_user_prio(Uint8 phy_cluster_id, Uint8 user_priority);
+
+PP_QOS_MGR_RET_e pp_qos_get_queue_and_cluster_id_by_user_priority(Uint8 vpid_id, Uint16 profile_private_identifier, Uint8 user_priority,
+																	      Uint8 *phy_cluster_id, Uint8 *phy_queue_id, Uint8 *pp_priority);
+
+/**
+ *  pp_qos_queue_is_active - Check if queue is active
+ *  @phy_queue_id: Queue ID
+ *  @is_active: Pointer to return if active or not
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_queue_is_active(Uint8 phy_queue_id, Bool *is_active);
+/**
+ *  pp_qos_alloc_queue - Alloc/Create QoS queue
+ *  @phy_cluster_id: Cluster ID
+ *  @phy_queue_id: Pointer to return the queue ID
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_alloc_queue(Uint8 phy_cluster_id, Uint8 *phy_queue_id);
+/**
+ *  pp_qos_free_queue - Free/Delete QoS queue
+ *  @phy_queue_id: Queue ID
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_free_queue(Uint8 phy_queue_id);
+/**
+ *  pp_qos_get_queue_config - Get the queue configuration
+ *  @phy_queue_id: Queue ID
+ *  @queue_cfg: Pointer to return the queue configuration
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_queue_config(Uint8 phy_queue_id, AVALANCHE_PP_QOS_QUEUE_t *queue_cfg);
+/**
+ *  pp_qos_modify_active_queue - Modify properties for an active
+ *  queue
+ *  @q_cfg: Pointer to queue new configuration
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_modify_active_queue(AVALANCHE_PP_QOS_QUEUE_t *modified_q_cfg); /* Modify properties for an active queue. */
+/**
+ *  pp_qos_get_queue_stats - Get QoS queue statistics
+ *  @qos_qnum: Queue ID
+ *  @stats: Pointer to return the queue statistics
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_queue_stats(Uint32 qos_qnum, PP_QOS_MIB_STATS_t *q_stats);
+/**
+ *  pp_qos_inc_session_cnt_for_queue - Increment sessions
+ *  counter for QoS queue
+ *  @phy_queue_id: Queue ID
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_inc_session_cnt_for_queue(Uint8 phy_queue_id);
+/**
+ *  pp_qos_dec_session_cnt_for_queue - Decrement sessions
+ *  counter for QoS queue
+ *  @phy_queue_id: Queue ID
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_dec_session_cnt_for_queue(Uint8 phy_queue_id);
+
+/**************/
+/* VPID       */
+/**************/
+/**
+ *  pp_qos_vpid_is_active - Check if VPID is active (active in the QoS)
+ *  @vpid_id: VPID ID
+ *  @is_active: Pointer to return if active or not
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */ 
+PP_QOS_MGR_RET_e pp_qos_vpid_is_active(Uint8 vpid_id, Bool *is_active);
+/**
+ *  pp_qos_is_vpid_registered - Return True if the given VPID is
+ *  currently supported by the QoS
+ *  @vpid_id: VPID ID
+ *  @isRegistered: Pointer to return if the VPID is active
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_is_vpid_registered(Uint8 vpid_id, Bool *isRegistered);
+/**
+ *  pp_qos_vpid_set_qos_mode - Set the QOS clusters of a VPID to
+ *  do Qos or not
+ *  @vpid_id: VPID ID
+ *  @vpidQosMode: If the requsted mode is QoS/no-QoS
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_vpid_set_qos_mode(Uint8 vpid_id, Bool vpidQosMode);
+/**
+ *  pp_qos_get_vpid_config - Get the vpid clusters configuration
+ *  @phy_cluster_id: Cluster ID
+ *  @clst_cfg_arr: Pointer to array of clusters (in size of
+ *           PP_QOS_MAX_CLUSTERS)
+ *  @clusters_cnt: in -> Pointer to MAX size of clst_cfg array.
+ *                 out -> Pointer to return the number of
+ *               clusters thet filled by the function.
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_vpid_config(Uint8 vpid_id, AVALANCHE_PP_QOS_CLST_CFG_t *clst_cfg_arr, Uint8 *clusters_cnt);
+/**
+ *  pp_qos_get_vpid_stats - Get QoS statistics for VPID
+ *  @vpid_id: VPID ID
+ *  @vpid_stats: Pointer to return the vpid statistics
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_vpid_stats(Uint8 vpid_id, PP_QOS_MIB_STATS_t *vpid_stats);
+/**
+ *  pp_qos_get_profile_stats - Get QoS statistics for
+ *  Profile
+ *  @vpid_id: VPID ID
+ *  @profile_private_identifier: Private identifier
+ *  @profile_stats: Pointer to return the profile statistics
+ *
+ *  Returns PP_QOS_RC_SUCCESS if pass.
+ */
+PP_QOS_MGR_RET_e pp_qos_get_profile_stats(Uint8 vpid_id, Uint16 profile_private_identifier, PP_QOS_MIB_STATS_t *profile_stats);
+
+#endif /* __KERNEL__ */
+
+#endif /* PP_QOS_P7_H */
diff --git a/include/linux/avalanche/generic/ramtest.h b/include/linux/avalanche/generic/ramtest.h
new file mode 100755
index 0000000..5929bb8
--- /dev/null
+++ b/include/linux/avalanche/generic/ramtest.h
@@ -0,0 +1,84 @@
+/*
+ *
+ * ramtest.h
+ * Description:
+ * see below
+ *
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2008-2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE 
+
+  Copyright(c) 2008-2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+/*
+ * Generic RAM testing code 
+ *
+ */
+
+#define AVALANCHE_RAMTEST_BASIC_DATA_FAIL   -1
+#define AVALANCHE_RAMTEST_ADDRESS_FAIL      -2
+#define AVALANCHE_RAMTEST_DATA_FAIL         -3
+
+int avalanche_ram_basic_data_test(volatile unsigned int* base);
+int avalanche_ram_address_test(volatile unsigned int* base, unsigned int size);
+int avalanche_ram_data_test(volatile unsigned int* base, unsigned int size);
+int avalanche_do_ram_test(volatile unsigned int* base, unsigned int size);
+
diff --git a/include/linux/avalanche/puma7/puma7.h b/include/linux/avalanche/puma7/puma7.h
new file mode 100644
index 0000000..eb5b027
--- /dev/null
+++ b/include/linux/avalanche/puma7/puma7.h
@@ -0,0 +1,266 @@
+/*
+ *
+ * puma7.h
+ * Description:
+ * puma7 parent header file, has all macros related to H/W
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014-2015 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#ifndef _PUMA7_H
+#define _PUMA7_H
+#define AVALANCHE_SOC_NAME         "PUMA7"
+#include <linux/avalanche/puma7/puma7_interrupts.h>
+
+#define IO_ADDRESS(addr) ((unsigned long)netip_mmio_to_virtual(addr))
+#define IO_PHY2VIRT(addr)              (netip_mmio_to_virtual((unsigned long)addr))   /* X86 implementation here */
+/* convert hardware virtual address to hardware physical address */
+#define IO_VIRT2PHY(addr)             (netip_mmio_to_physical((unsigned long)addr))   /* X86 implementation here */
+
+#define AVALANCHE_GBE0_ADDR                         ((0xF0300000))
+#define AVALANCHE_GBE1_ADDR                         ((0xF0304000))
+#define AVALANCHE_GBE2_ADDR                         ((0xF0308000))
+#define AVALANCHE_GBE3_ADDR                         ((0xF030C000))
+#define AVALANCHE_GBE4_ADDR                         ((0xF0310000))
+#define AVALANCHE_GBE5_ADDR                         ((0xF0314000))
+
+#define AVALANCHE_PFI_REGS                          (IO_ADDRESS(0xF0210000))
+#define AVALANCHE_PFI_WIN_REGS                      (IO_ADDRESS(0xF0210400))
+#define AVALANCHE_GBE0                              (IO_ADDRESS(AVALANCHE_GBE0_ADDR))
+#define AVALANCHE_GBE1                              (IO_ADDRESS(AVALANCHE_GBE1_ADDR))
+#define AVALANCHE_GBE2                              (IO_ADDRESS(AVALANCHE_GBE2_ADDR))
+#define AVALANCHE_GBE3                              (IO_ADDRESS(AVALANCHE_GBE3_ADDR))
+#define AVALANCHE_GBE4                              (IO_ADDRESS(AVALANCHE_GBE4_ADDR))
+#define AVALANCHE_GBE5                              (IO_ADDRESS(AVALANCHE_GBE5_ADDR))
+#define AVALANCHE_GBE_GENERAL                       (IO_ADDRESS(0xF0318000))
+#define AVALANCHE_GBE_INT_CTRL_0                    (IO_ADDRESS(0xF031A000))
+#define AVALANCHE_GBE_INT_CTRL_1                    (IO_ADDRESS(0xF031A400))
+#define AVALANCHE_PHY_SLAVE                         (IO_ADDRESS(0xF0500000))
+
+#define AVALANCHE_CRU_BASE                          (IO_ADDRESS(0xF00D0000))
+/**
+ * Interrupts Distributor 0 (INTD0) base address, has 32 ip
+ * interrupts to 16 system interrupts.
+ */
+/******************************************************************************************/
+/* follopwing Macros are moved into .c file and global varable */
+/******************************************************************************************/
+
+#define AVALANCHE_INTD_BASE_INT                 24 // SRTR_INTD16, srtr_intr_16
+/**
+  INTD1 interrupt0's line in the system interrupt controller (INTC).
+  */
+#define AVALANCHE_INTD1_BASE_INT                40 // SRTR_INTD16, srtr_intr_16
+
+/**
+ * Convert INTD0 interrupt to INTC interrupt line.
+ */
+#define MAP_INTD_TO_INTC(intv)                  ((intv) + AVALANCHE_INTD_BASE_INT)
+/**
+ * Convert INTD1 interrupt to INTC interrupt line.
+ */
+#define MAP_INTD1_TO_INTC(intv)                 ((intv) + AVALANCHE_INTD1_BASE_INT)
+typedef enum
+{
+    e_Interrupt_Disable = 0,
+    e_Interrupt_Enable
+} AVALANCHE_INTRPT_MODE_T;
+
+typedef volatile struct interrupt_bundle_struct
+{
+    volatile unsigned int      interrupt_enable;                //  Read/Write.
+    volatile unsigned int      sw_interrupt;                    //  Write Only.
+    volatile unsigned int      edge_or_level;                   //  Read/Write. Edge=0, Level=1
+    volatile unsigned int      mask;                            //  Read/Write.
+    volatile unsigned int      interrupt_status_pre_masked;     //  Read Only.
+    volatile unsigned int      interrupt_status_post_masked;    //  Read Only.  Note: Reading cause to status bit clear !
+} interrupt_bundle_struct_t;
+
+#if 0
+/**
+ * Packet Processor Queue Managers
+ */
+typedef enum PAL_CPPI_PP_QMGRs
+{
+    PAL_CPPI_PP_QMGR_G0,
+    PAL_CPPI_PP_QMGR_G1,
+    PAL_CPPI_PP_QMGR_G2,
+    PAL_CPPI_PP_QMGR_LOCAL,
+    PAL_CPPI41_NUM_QUEUE_MGR
+}PAL_CPPI_PP_QMGRs_e;
+
+/**
+ * Accumulator PDSP channels
+ */
+/*
++-+-+-+-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
+|A|c|c|u|m|u|l|a|t|o|r| |C|h|a|n|n|e|l|s|
++-+-+-+-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
+*/
+/* following varabled are refered from  arm SDK include\asm-arm\arch-avalanche\puma7\puma7_cppi_prv.h file */
+
+typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD0_CHANNELS
+{
+    PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_CH_BASE,
+        PAL_CPPI_PP_HOST2PP_TX_COMPLETE_LOW_INTD0_ACC_CH_NUM = PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_CH_BASE,   // 0
+        PAL_CPPI_PP_HOST2PP_TX_COMPLETE_HIGH_INTD0_ACC_CH_NUM,                                                      // 1
+    PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_CH_LAST = PAL_CPPI_PP_HOST2PP_TX_COMPLETE_HIGH_INTD0_ACC_CH_NUM,
+
+    PAL_CPPI_PP_MoCA_RX_INTD0_ACC_CH_NUM,                                                                           // 2
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_3,                                                                        // 3
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_4,                                                                        // 4
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_5,                                                                        // 5
+    PAL_CPPI_PP_SGMII0_RX_LOW_INTD0_ACC_CH_NUM,                                                                     // 6
+    PAL_CPPI_PP_SGMII0_RX_HIGH_INTD0_ACC_CH_NUM,                                                                    // 7
+    PAL_CPPI_PP_SGMII1_RX_LOW_INTD0_ACC_CH_NUM,                                                                     // 8
+    PAL_CPPI_PP_SGMII1_RX_HIGH_INTD0_ACC_CH_NUM,                                                                    // 9
+    PAL_CPPI_PP_RGMII0_RX_LOW_INTD0_ACC_CH_NUM,                                                                     // 10
+    PAL_CPPI_PP_RGMII0_RX_HIGH_INTD0_ACC_CH_NUM,                                                                    // 11
+    PAL_CPPI_PP_RGMII1_RX_LOW_INTD0_ACC_CH_NUM,                                                                     // 12
+    PAL_CPPI_PP_RGMII1_RX_HIGH_INTD0_ACC_CH_NUM,                                                                    // 13
+    PAL_CPPI_PP_ATOM_RX_LOW_INTD0_ACC_CH_NUM,                                                                       // 14
+    PAL_CPPI_PP_ATOM_RX_HIGH_INTD0_ACC_CH_NUM,                                                                      // 15
+    PAL_CPPI_PP_DOCSIS_RX_MGMT_INTD0_ACC_CH_NUM,                                                                    // 16
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_17,                                                                       // 17
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_18,                                                                       // 18
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_19,                                                                       // 19
+    PAL_CPPI_PP_DOCSIS_RX_LOW_INTD0_ACC_CH_NUM,                                                                     // 20
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_21,                                                                       // 21
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_22,                                                                       // 22
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_23,                                                                       // 23
+    PAL_CPPI_PP_DOCSIS_RX_HIGH_INTD0_ACC_CH_NUM,                                                                    // 24
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_25,                                                                       // 25
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_26,                                                                       // 26
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_27,                                                                       // 27
+    PAL_CPPI_PP_VOICE_RX_INTD0_ACC_CH_NUM,                                                                         // 28
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_29,                                                                       // 29
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_30,                                                                       // 30
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_31,                                                                       // 31
+    PAL_CPPI_PP_INTD0_ACCUMULATOR_MAX_CHANNELS
+}PAL_CPPI_PP_ACCUMULATOR_INTD0_CHANNELS_e;
+
+typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD1_CHANNELS
+{
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_0,                                                                        // 0
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_1,                                                                        // 1
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_2,                                                                        // 2
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_3,                                                                        // 3
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_4,                                                                        // 4
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_5,                                                                        // 5
+    PAL_CPPI_PP_WiFi_RX_LOW_INTD1_ACC_CH_NUM,                                                                       // 6
+    PAL_CPPI_PP_WiFi_RX_HIGH_INTD1_ACC_CH_NUM,                                                                      // 7
+    PAL_CPPI_PP_NP2APP_RX_INTD1_ACC_CH_NUM,                                                                         // 8
+    PAL_CPPI_PP_NP2APP_TX_COMPLETE_INTD1_ACC_CH_NUM,                                                                // 9
+    PAL_CPPI_PP_APP2NP_RX_INTD1_ACC_CH_NUM,                                                                         // 10
+    PAL_CPPI_PP_APP2NP_TX_COMPLETE_INTD1_ACC_CH_NUM,                                                                // 11
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_12,                                                                       // 12
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_13,                                                                       // 13
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_14,                                                                       // 14
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_15,                                                                       // 15
+    PAL_CPPI_PP_INTD1_ACCUMULATOR_MAX_CHANNELS
+}PAL_CPPI_PP_ACCUMULATOR_INTD1_CHANNELS_e;
+
+/**
+ * Accumulator PDSP interrupts vectors, these interrupt are the
+ * outputs of the INTDs
+ */
+typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD0_INTERRUPT_VECTORS
+{
+    PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_INTV_NUM,                                                             // 0
+    PAL_CPPI_PP_MoCA_RX_INTD0_ACC_INTV_NUM,                                                                         // 1
+    PAL_CPPI_PP_SGMII0_LOW_RX_INTD0_ACC_INTV_NUM,                                                                   // 2
+    PAL_CPPI_PP_SGMII0_HIGH_RX_INTD0_ACC_INTV_NUM,                                                                  // 3
+    PAL_CPPI_PP_SGMII1_LOW_RX_INTD0_ACC_INTV_NUM,                                                                   // 4
+    PAL_CPPI_PP_SGMII1_HIGH_RX_INTD0_ACC_INTV_NUM,                                                                  // 5
+    PAL_CPPI_PP_RGMII0_LOW_RX_INTD0_ACC_INTV_NUM,                                                                   // 6
+    PAL_CPPI_PP_RGMII0_HIGH_RX_INTD0_ACC_INTV_NUM,                                                                  // 7
+    PAL_CPPI_PP_RGMII1_LOW_RX_INTD0_ACC_INTV_NUM,                                                                   // 8
+    PAL_CPPI_PP_RGMII1_HIGH_RX_INTD0_ACC_INTV_NUM,                                                                  // 9
+    PAL_CPPI_PP_ATOM_LOW_RX_INTD0_ACC_INTV_NUM,                                                                     // 10
+    PAL_CPPI_PP_ATOM_HIGH_RX_INTD0_ACC_INTV_NUM,                                                                    // 11
+    PAL_CPPI_PP_DOCSIS_RX_MGMT_INTD0_ACC_INTV_NUM,                                                                  // 12
+    PAL_CPPI_PP_DOCSIS_RX_LOW_INTD0_ACC_INTV_NUM,                                                                   // 13
+    PAL_CPPI_PP_DOCSIS_RX_HIGH_INTD0_ACC_INTV_NUM,                                                                  // 14
+    PAL_CPPI_PP_VOICE_RX_INTD0_INTV_NUM,                                                                            // 15
+    PAL_CPPI_PP_ACCUMULATOR_INTD0_MAX_INTERRUPT_VECTORS
+}PAL_CPPI_PP_ACCUMULATOR_INTERRUPT_VECTORS_e;
+
+typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD1_INTERRUPT_VECTORS
+{
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_INTV_NUM_0,                                                                      // 0
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_INTV_NUM_1,                                                                      // 1
+    PAL_CPPI_PP_WiFi_RX_LOW_INTD1_ACC_INTV_NUM,                                                                     // 2
+    PAL_CPPI_PP_WiFi_RX_HIGH_INTD1_ACC_INTV_NUM,                                                                    // 3
+    PAL_CPPI_PP_NP2APP_RX_INTD1_ACC_INTV_NUM,                                                                       // 4
+    PAL_CPPI_PP_NP2APP_TX_COMPLETE_INTD1_ACC_INTV_NUM,                                                              // 5
+    PAL_CPPI_PP_APP2NP_RX_INTD1_ACC_INTV_NUM,                                                                       // 6
+    PAL_CPPI_PP_APP2NP_TX_COMPLETE_INTD1_ACC_INTV_NUM,                                                              // 7
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_INTV_NUM_8,                                                                      // 8
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_INTV_NUM_9,                                                                      // 9
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_INTV_NUM_10,                                                                     // 10
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_INTV_NUM_11,                                                                     // 11
+    PAL_CPPI_PP_ACCUMULATOR_INTD1_MAX_INTERRUPT_VECTORS
+}PAL_CPPI_PP_ACCUMULATOR_INTD1_INTERRUPT_VECTORS_e;
+#endif
+#endif /*_PUMA7_H */
+
diff --git a/include/linux/avalanche/puma7/puma7_cppi.h b/include/linux/avalanche/puma7/puma7_cppi.h
index 13c16f8..3938fe4 100755
--- a/include/linux/avalanche/puma7/puma7_cppi.h
+++ b/include/linux/avalanche/puma7/puma7_cppi.h
@@ -5,25 +5,27 @@
  * File containing CPPI configurations for each driver.
  * Put into a single file to (hopefully) avoid configuration
  * clashes.
- 
+
+   This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
 
   GPL LICENSE SUMMARY
 
-  Copyright(c) 2014-2016 Intel Corporation.
+  Copyright(c) 2014 Intel Corporation.
 
-  This program is free software; you can redistribute it and/or modify 
+  This program is free software; you can redistribute it and/or modify
   it under the terms of version 2 of the GNU General Public License as
   published by the Free Software Foundation.
 
-  This program is distributed in the hope that it will be useful, but 
-  WITHOUT ANY WARRANTY; without even the implied warranty of 
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.
 
-  You should have received a copy of the GNU General Public License 
-  along with this program; if not, write to the Free Software 
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
-  The full GNU General Public License is included in this distribution 
+  The full GNU General Public License is included in this distribution
   in the file called LICENSE.GPL.
 
 
@@ -32,12 +34,96 @@
   2200 Mission College Blvd.
   Santa Clara, CA  97052
 
+  BSD LICENSE
+
+  Copyright(c) 2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
 
 #ifndef __PUMA7_CPPI_H__
 #define __PUMA7_CPPI_H__
 
-//This empty file is here just to track histrory.
+#include "puma7_cppi_prv.h"
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+#define PAL_CPPI4_CACHE_INVALIDATE(addr, size)              dma_cache_inv ((unsigned long)(addr), (size))
+#define PAL_CPPI4_CACHE_WRITEBACK(addr, size)               dma_cache_wback ((unsigned long)(addr), (size))
+#define PAL_CPPI4_CACHE_WRITEBACK_INVALIDATE(addr, size)    dma_cache_wback_inv ((unsigned long)(addr), (size))
+#endif
+extern int Puma_DOCSIS_CPPI_Init(void);
+extern int Puma_FCC_CPPI_Init(void);
+
+extern Uint8 *PalCppiPpLqmgrNames[PAL_CPPI_PP_QMGR_LOCAL_TOTAL_Q_COUNT];
+extern Uint8 *PalCppiPpGqmgr0Names[PAL_CPPI_PP_QMGR_G0_TOTAL_Q_COUNT];
+extern Uint8 *PalCppiPpGqmgr1Names[PAL_CPPI_PP_QMGR_G1_TOTAL_Q_COUNT];
+extern Uint8 *PalCppiPpGqmgr2Names[PAL_CPPI_PP_QMGR_G2_TOTAL_Q_COUNT];
+extern Uint8 *PalCppiDsg0qmgrNames[PAL_CPPI_DSG_QMGR_TOTAL_Q_COUNT];
+extern Uint8 *PalCppiDsg1qmgrNames[PAL_CPPI_DSG_QMGR_TOTAL_Q_COUNT];
+extern Uint8 *PalCppiDsg2qmgrNames[PAL_CPPI_DSG_QMGR_TOTAL_Q_COUNT];
+
+#define PAL_CPPI_QMGR_SHIFT      12
+#define PAL_CPPI_QMGR_MASK       0x3
+#define PAL_CPPI_QNUM_MASK       0xFFF
+
+#define PAL_CPPI_PP_QMGR_GET_Q_NAME(qMgr, qNum)                         \
+    ((qMgr) == PAL_CPPI_PP_QMGR_G0 ? PalCppiPpGqmgr0Names[(qNum)] :     \
+    ((qMgr) == PAL_CPPI_PP_QMGR_G1 ? PalCppiPpGqmgr1Names[(qNum)] :     \
+    ((qMgr) == PAL_CPPI_PP_QMGR_G2 ? PalCppiPpGqmgr2Names[(qNum)] : PalCppiPpLqmgrNames[(qNum)])))
+
+#define PAL_CPPI_PP_GET_QMGR(qMgrNum)       (((qMgrNum) >> PAL_CPPI_QMGR_SHIFT) & PAL_CPPI_QMGR_MASK)
+#define PAL_CPPI_PP_GET_QNUM(qMgrNum)       ((qMgrNum) & PAL_CPPI_QNUM_MASK)
+#define PAL_CPPI_PP_GET_QNAME(qMgrNum)      PAL_CPPI_PP_QMGR_GET_Q_NAME(PAL_CPPI_PP_GET_QMGR(qMgrNum), PAL_CPPI_PP_GET_QNUM(qMgrNum))
+
+
+#define PAL_CPPI_DSG_QMGR_GET_Q_NAME(qMgr, qNum)                            \
+    ((qMgr) == PAL_CPPI_OFDM0_QUEUE_MGR ? PalCppiDsg0qmgrNames[(qNum)] :     \
+    ((qMgr) == PAL_CPPI_OFDM1_QUEUE_MGR ? PalCppiDsg1qmgrNames[(qNum)] : PalCppiDsg2qmgrNames[(qNum)]))
+
+#define PAL_CPPI_DSG_GET_QNAME(qMgrNum)     PAL_CPPI_DSG_QMGR_GET_Q_NAME((((qMgrNum) >> PAL_CPPI_QMGR_SHIFT) & PAL_CPPI_QMGR_MASK), ((qMgrNum) & PAL_CPPI_QNUM_MASK))
+
+
+/***********************************/
+/* Backward compatible definitions */
+/***********************************/
+// The following defines are to prevent many #ifdef in the code due to name convention change in P7
+#define PAL_CPPI41_SR_QMGR_TOTAL_Q_COUNT                    PAL_CPPI_PP_QMGR_G0_TOTAL_Q_COUNT   /* This is the Qmgr with the maximum number of queues */
+#define PAL_CPPI41_SR_QPDSP_QOS_Q_LAST                      PAL_CPPI_PP_QMGR_G1_QOS_Q_LAST
+#define PAL_CPPI41_SR_QPDSP_QOS_Q_BASE                      PAL_CPPI_PP_QMGR_G1_QOS_Q_BASE
+#define PAL_CPPI41_SR_DOCSIS_TX_QPDSP_QOS_Q_BASE            PAL_CPPI_PP_QMGR_G1_QOS_US_Q_BASE
+#define PAL_CPPI41_SR_DOCSIS_TX_QPDSP_QOS_Q_LAST            PAL_CPPI_PP_QMGR_G1_QOS_US_Q_LAST
+
+#define IS_QOS_Q(q) ((q >= PAL_CPPI_NETDEV_BUILD_Q_INFO(PAL_CPPI_PP_QMGR_G1, PAL_CPPI_PP_QMGR_G1_QOS_Q_BASE))           && (q <= PAL_CPPI_NETDEV_BUILD_Q_INFO(PAL_CPPI_PP_QMGR_G1, PAL_CPPI_PP_QMGR_G1_QOS_Q_LAST)) )
+#define IS_AQM_Q(q) ((q >= PAL_CPPI_NETDEV_BUILD_Q_INFO(PAL_CPPI_PP_QMGR_G2, PAL_CPPI_PP_QMGR_G2_AQM_US_BE0_LOW_Q_NUM)) && (q <= PAL_CPPI_NETDEV_BUILD_Q_INFO(PAL_CPPI_PP_QMGR_G2, PAL_CPPI_PP_QMGR_G2_AQM_US_BE15_HI_Q_NUM)) )
+
+#define PAL_CPPI41_SR_DOCSIS_MGMT_RX_FD_HOST_DESC_SIZE      PAL_CPPI_PP_QMGR_GLOBAL_DEFAULT_DESC_SIZE
+#define PAL_CPPI41_SR_DOCSIS_MGMT_TX_FD_HOST_DESC_SIZE      PAL_CPPI_PP_QMGR_GLOBAL_DEFAULT_DESC_SIZE
+#define PAL_CPPI41_SR_DOCSIS_MGMT_TX_FD_HOST_BUFF_SIZE      PAL_CPPI_PP_QMGR_GLOBAL_DEFAULT_BUFF_SIZE
 
 #endif /* __PUMA7_CPPI_H__ */
diff --git a/include/linux/avalanche/puma7/puma7_cppi_dsgqmgr_q.h b/include/linux/avalanche/puma7/puma7_cppi_dsgqmgr_q.h
new file mode 100755
index 0000000..651cb06
--- /dev/null
+++ b/include/linux/avalanche/puma7/puma7_cppi_dsgqmgr_q.h
@@ -0,0 +1,126 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+    Intel Corporation
+    2200 Mission College Blvd.
+    Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#define PAL_CPPI_DSG_QMGR_Q_LIST                                                                           \
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_0)                                      /* PAL_CPPI_DSG_QMGR_Q_0 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_1)                                      /* PAL_CPPI_DSG_QMGR_Q_1 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_2)                                      /* PAL_CPPI_DSG_QMGR_Q_2 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_3)                                      /* PAL_CPPI_DSG_QMGR_Q_3 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_4)                                      /* PAL_CPPI_DSG_QMGR_Q_4 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_5)                                      /* PAL_CPPI_DSG_QMGR_Q_5 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_6)                                      /* PAL_CPPI_DSG_QMGR_Q_6 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_7)                                      /* PAL_CPPI_DSG_QMGR_Q_7 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_8)                                      /* PAL_CPPI_DSG_QMGR_Q_8 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_9)                                      /* PAL_CPPI_DSG_QMGR_Q_9 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_10)                                     /* PAL_CPPI_DSG_QMGR_Q_10 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_11)                                     /* PAL_CPPI_DSG_QMGR_Q_11 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_12)                                     /* PAL_CPPI_DSG_QMGR_Q_12 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_13)                                     /* PAL_CPPI_DSG_QMGR_Q_13 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_14)                                     /* PAL_CPPI_DSG_QMGR_Q_14 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_15)                                     /* PAL_CPPI_DSG_QMGR_Q_15 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_CoP_Q_NUM)                                /* PAL_CPPI_DSG_QMGR_Q_16 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_17)                                     /* PAL_CPPI_DSG_QMGR_Q_17 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_18)                                     /* PAL_CPPI_DSG_QMGR_Q_18 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_19)                                     /* PAL_CPPI_DSG_QMGR_Q_19 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_20)                                     /* PAL_CPPI_DSG_QMGR_Q_20 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_21)                                     /* PAL_CPPI_DSG_QMGR_Q_21 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_22)                                     /* PAL_CPPI_DSG_QMGR_Q_22 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_23)                                     /* PAL_CPPI_DSG_QMGR_Q_23 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_24)                                     /* PAL_CPPI_DSG_QMGR_Q_24 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_25)                                     /* PAL_CPPI_DSG_QMGR_Q_25 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_26)                                     /* PAL_CPPI_DSG_QMGR_Q_26 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_27)                                     /* PAL_CPPI_DSG_QMGR_Q_27 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_28)                                     /* PAL_CPPI_DSG_QMGR_Q_28 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_29)                                     /* PAL_CPPI_DSG_QMGR_Q_29 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_30)                                     /* PAL_CPPI_DSG_QMGR_Q_30 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_31)                                     /* PAL_CPPI_DSG_QMGR_Q_31 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_32)                                     /* PAL_CPPI_DSG_QMGR_Q_32 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_33)                                     /* PAL_CPPI_DSG_QMGR_Q_33 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_34)                                     /* PAL_CPPI_DSG_QMGR_Q_34 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_35)                                     /* PAL_CPPI_DSG_QMGR_Q_35 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_36)                                     /* PAL_CPPI_DSG_QMGR_Q_36 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_37)                                     /* PAL_CPPI_DSG_QMGR_Q_37 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_38)                                     /* PAL_CPPI_DSG_QMGR_Q_38 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_39)                                     /* PAL_CPPI_DSG_QMGR_Q_39 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_40)                                     /* PAL_CPPI_DSG_QMGR_Q_40 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_41)                                     /* PAL_CPPI_DSG_QMGR_Q_41 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_42)                                     /* PAL_CPPI_DSG_QMGR_Q_42 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_43)                                     /* PAL_CPPI_DSG_QMGR_Q_43 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_44)                                     /* PAL_CPPI_DSG_QMGR_Q_44 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_45)                                     /* PAL_CPPI_DSG_QMGR_Q_45 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_46)                                     /* PAL_CPPI_DSG_QMGR_Q_46 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_47)                                     /* PAL_CPPI_DSG_QMGR_Q_47 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_48)                                     /* PAL_CPPI_DSG_QMGR_Q_48 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_49)                                     /* PAL_CPPI_DSG_QMGR_Q_49 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_50)                                     /* PAL_CPPI_DSG_QMGR_Q_50 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_51)                                     /* PAL_CPPI_DSG_QMGR_Q_51 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_52)                                     /* PAL_CPPI_DSG_QMGR_Q_52 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_53)                                     /* PAL_CPPI_DSG_QMGR_Q_53 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_54)                                     /* PAL_CPPI_DSG_QMGR_Q_54 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_55)                                     /* PAL_CPPI_DSG_QMGR_Q_55 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_56)                                     /* PAL_CPPI_DSG_QMGR_Q_56 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_57)                                     /* PAL_CPPI_DSG_QMGR_Q_57 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_FD_EMB_Q_NUM)                             /* PAL_CPPI_DSG_QMGR_Q_58 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_TEARDOWN_Q_NUM)                           /* PAL_CPPI_DSG_QMGR_Q_59 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_60)                                     /* PAL_CPPI_DSG_QMGR_Q_60 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_61)                                     /* PAL_CPPI_DSG_QMGR_Q_61 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_62)                                     /* PAL_CPPI_DSG_QMGR_Q_62 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_DSG_QMGR_Q_63)                                     /* PAL_CPPI_DSG_QMGR_Q_63 */
diff --git a/include/linux/avalanche/puma7/puma7_cppi_gqmgr0_q.h b/include/linux/avalanche/puma7/puma7_cppi_gqmgr0_q.h
new file mode 100755
index 0000000..3c5eed4
--- /dev/null
+++ b/include/linux/avalanche/puma7/puma7_cppi_gqmgr0_q.h
@@ -0,0 +1,1842 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+    Intel Corporation
+    2200 Mission College Blvd.
+    Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#define PAL_CPPI_PP_QMGR_G0_Q_LIST                                                                                        \
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS0)                                   /* PAL_CPPI_PP_QMGR_G0_Q0 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS1)                                   /* PAL_CPPI_PP_QMGR_G0_Q1 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS2)                                   /* PAL_CPPI_PP_QMGR_G0_Q2 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS3)                                   /* PAL_CPPI_PP_QMGR_G0_Q3 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS4)                                   /* PAL_CPPI_PP_QMGR_G0_Q4 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS5)                                   /* PAL_CPPI_PP_QMGR_G0_Q5 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS6)                                   /* PAL_CPPI_PP_QMGR_G0_Q6 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS7)                                   /* PAL_CPPI_PP_QMGR_G0_Q7 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS8)                                   /* PAL_CPPI_PP_QMGR_G0_Q8 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS9)                                   /* PAL_CPPI_PP_QMGR_G0_Q9 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS10)                                  /* PAL_CPPI_PP_QMGR_G0_Q10 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS11)                                  /* PAL_CPPI_PP_QMGR_G0_Q11 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS12)                                  /* PAL_CPPI_PP_QMGR_G0_Q12 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS13)                                  /* PAL_CPPI_PP_QMGR_G0_Q13 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS14)                                  /* PAL_CPPI_PP_QMGR_G0_Q14 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS15)                                  /* PAL_CPPI_PP_QMGR_G0_Q15 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS16)                                  /* PAL_CPPI_PP_QMGR_G0_Q16 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS17)                                  /* PAL_CPPI_PP_QMGR_G0_Q17 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS18)                                  /* PAL_CPPI_PP_QMGR_G0_Q18 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS19)                                  /* PAL_CPPI_PP_QMGR_G0_Q19 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS20)                                  /* PAL_CPPI_PP_QMGR_G0_Q20 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS21)                                  /* PAL_CPPI_PP_QMGR_G0_Q21 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS22)                                  /* PAL_CPPI_PP_QMGR_G0_Q22 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS23)                                  /* PAL_CPPI_PP_QMGR_G0_Q23 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS24)                                  /* PAL_CPPI_PP_QMGR_G0_Q24 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS25)                                  /* PAL_CPPI_PP_QMGR_G0_Q25 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS26)                                  /* PAL_CPPI_PP_QMGR_G0_Q26 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS27)                                  /* PAL_CPPI_PP_QMGR_G0_Q27 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS28)                                  /* PAL_CPPI_PP_QMGR_G0_Q28 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS29)                                  /* PAL_CPPI_PP_QMGR_G0_Q29 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS30)                                  /* PAL_CPPI_PP_QMGR_G0_Q30 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_DS31)                                  /* PAL_CPPI_PP_QMGR_G0_Q31 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_OFDM0)                                 /* PAL_CPPI_PP_QMGR_G0_Q32 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_OFDM1)                                 /* PAL_CPPI_PP_QMGR_G0_Q33 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_Q34)                                   /* PAL_CPPI_PP_QMGR_G0_Q34 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID0_Q35)                                   /* PAL_CPPI_PP_QMGR_G0_Q35 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS0)                                   /* PAL_CPPI_PP_QMGR_G0_Q36 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS1)                                   /* PAL_CPPI_PP_QMGR_G0_Q37 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS2)                                   /* PAL_CPPI_PP_QMGR_G0_Q38 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS3)                                   /* PAL_CPPI_PP_QMGR_G0_Q39 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS4)                                   /* PAL_CPPI_PP_QMGR_G0_Q40 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS5)                                   /* PAL_CPPI_PP_QMGR_G0_Q41 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS6)                                   /* PAL_CPPI_PP_QMGR_G0_Q42 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS7)                                   /* PAL_CPPI_PP_QMGR_G0_Q43 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS8)                                   /* PAL_CPPI_PP_QMGR_G0_Q44 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS9)                                   /* PAL_CPPI_PP_QMGR_G0_Q45 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS10)                                  /* PAL_CPPI_PP_QMGR_G0_Q46 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS11)                                  /* PAL_CPPI_PP_QMGR_G0_Q47 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS12)                                  /* PAL_CPPI_PP_QMGR_G0_Q48 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS13)                                  /* PAL_CPPI_PP_QMGR_G0_Q49 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS14)                                  /* PAL_CPPI_PP_QMGR_G0_Q50 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS15)                                  /* PAL_CPPI_PP_QMGR_G0_Q51 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS16)                                  /* PAL_CPPI_PP_QMGR_G0_Q52 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS17)                                  /* PAL_CPPI_PP_QMGR_G0_Q53 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS18)                                  /* PAL_CPPI_PP_QMGR_G0_Q54 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS19)                                  /* PAL_CPPI_PP_QMGR_G0_Q55 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS20)                                  /* PAL_CPPI_PP_QMGR_G0_Q56 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS21)                                  /* PAL_CPPI_PP_QMGR_G0_Q57 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS22)                                  /* PAL_CPPI_PP_QMGR_G0_Q58 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS23)                                  /* PAL_CPPI_PP_QMGR_G0_Q59 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS24)                                  /* PAL_CPPI_PP_QMGR_G0_Q60 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS25)                                  /* PAL_CPPI_PP_QMGR_G0_Q61 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS26)                                  /* PAL_CPPI_PP_QMGR_G0_Q62 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS27)                                  /* PAL_CPPI_PP_QMGR_G0_Q63 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS28)                                  /* PAL_CPPI_PP_QMGR_G0_Q64 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS29)                                  /* PAL_CPPI_PP_QMGR_G0_Q65 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS30)                                  /* PAL_CPPI_PP_QMGR_G0_Q66 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_DS31)                                  /* PAL_CPPI_PP_QMGR_G0_Q67 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_OFDM0)                                 /* PAL_CPPI_PP_QMGR_G0_Q68 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_OFDM1)                                 /* PAL_CPPI_PP_QMGR_G0_Q69 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_Q34)                                   /* PAL_CPPI_PP_QMGR_G0_Q70 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID1_Q35)                                   /* PAL_CPPI_PP_QMGR_G0_Q71 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS0)                                   /* PAL_CPPI_PP_QMGR_G0_Q72 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS1)                                   /* PAL_CPPI_PP_QMGR_G0_Q73 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS2)                                   /* PAL_CPPI_PP_QMGR_G0_Q74 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS3)                                   /* PAL_CPPI_PP_QMGR_G0_Q75 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS4)                                   /* PAL_CPPI_PP_QMGR_G0_Q76 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS5)                                   /* PAL_CPPI_PP_QMGR_G0_Q77 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS6)                                   /* PAL_CPPI_PP_QMGR_G0_Q78 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS7)                                   /* PAL_CPPI_PP_QMGR_G0_Q79 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS8)                                   /* PAL_CPPI_PP_QMGR_G0_Q80 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS9)                                   /* PAL_CPPI_PP_QMGR_G0_Q81 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS10)                                  /* PAL_CPPI_PP_QMGR_G0_Q82 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS11)                                  /* PAL_CPPI_PP_QMGR_G0_Q83 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS12)                                  /* PAL_CPPI_PP_QMGR_G0_Q84 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS13)                                  /* PAL_CPPI_PP_QMGR_G0_Q85 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS14)                                  /* PAL_CPPI_PP_QMGR_G0_Q86 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS15)                                  /* PAL_CPPI_PP_QMGR_G0_Q87 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS16)                                  /* PAL_CPPI_PP_QMGR_G0_Q88 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS17)                                  /* PAL_CPPI_PP_QMGR_G0_Q89 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS18)                                  /* PAL_CPPI_PP_QMGR_G0_Q90 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS19)                                  /* PAL_CPPI_PP_QMGR_G0_Q91 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS20)                                  /* PAL_CPPI_PP_QMGR_G0_Q92 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS21)                                  /* PAL_CPPI_PP_QMGR_G0_Q93 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS22)                                  /* PAL_CPPI_PP_QMGR_G0_Q94 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS23)                                  /* PAL_CPPI_PP_QMGR_G0_Q95 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS24)                                  /* PAL_CPPI_PP_QMGR_G0_Q96 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS25)                                  /* PAL_CPPI_PP_QMGR_G0_Q97 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS26)                                  /* PAL_CPPI_PP_QMGR_G0_Q98 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS27)                                  /* PAL_CPPI_PP_QMGR_G0_Q99 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS28)                                  /* PAL_CPPI_PP_QMGR_G0_Q100 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS29)                                  /* PAL_CPPI_PP_QMGR_G0_Q101 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS30)                                  /* PAL_CPPI_PP_QMGR_G0_Q102 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_DS31)                                  /* PAL_CPPI_PP_QMGR_G0_Q103 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_OFDM0)                                 /* PAL_CPPI_PP_QMGR_G0_Q104 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_OFDM1)                                 /* PAL_CPPI_PP_QMGR_G0_Q105 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_Q34)                                   /* PAL_CPPI_PP_QMGR_G0_Q106 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID2_Q35)                                   /* PAL_CPPI_PP_QMGR_G0_Q107 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS0)                                   /* PAL_CPPI_PP_QMGR_G0_Q108 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS1)                                   /* PAL_CPPI_PP_QMGR_G0_Q109 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS2)                                   /* PAL_CPPI_PP_QMGR_G0_Q110 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS3)                                   /* PAL_CPPI_PP_QMGR_G0_Q111 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS4)                                   /* PAL_CPPI_PP_QMGR_G0_Q112 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS5)                                   /* PAL_CPPI_PP_QMGR_G0_Q113 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS6)                                   /* PAL_CPPI_PP_QMGR_G0_Q114 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS7)                                   /* PAL_CPPI_PP_QMGR_G0_Q115 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS8)                                   /* PAL_CPPI_PP_QMGR_G0_Q116 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS9)                                   /* PAL_CPPI_PP_QMGR_G0_Q117 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS10)                                  /* PAL_CPPI_PP_QMGR_G0_Q118 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS11)                                  /* PAL_CPPI_PP_QMGR_G0_Q119 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS12)                                  /* PAL_CPPI_PP_QMGR_G0_Q120 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS13)                                  /* PAL_CPPI_PP_QMGR_G0_Q121 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS14)                                  /* PAL_CPPI_PP_QMGR_G0_Q122 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS15)                                  /* PAL_CPPI_PP_QMGR_G0_Q123 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS16)                                  /* PAL_CPPI_PP_QMGR_G0_Q124 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS17)                                  /* PAL_CPPI_PP_QMGR_G0_Q125 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS18)                                  /* PAL_CPPI_PP_QMGR_G0_Q126 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS19)                                  /* PAL_CPPI_PP_QMGR_G0_Q127 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS20)                                  /* PAL_CPPI_PP_QMGR_G0_Q128 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS21)                                  /* PAL_CPPI_PP_QMGR_G0_Q129 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS22)                                  /* PAL_CPPI_PP_QMGR_G0_Q130 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS23)                                  /* PAL_CPPI_PP_QMGR_G0_Q131 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS24)                                  /* PAL_CPPI_PP_QMGR_G0_Q132 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS25)                                  /* PAL_CPPI_PP_QMGR_G0_Q133 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS26)                                  /* PAL_CPPI_PP_QMGR_G0_Q134 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS27)                                  /* PAL_CPPI_PP_QMGR_G0_Q135 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS28)                                  /* PAL_CPPI_PP_QMGR_G0_Q136 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS29)                                  /* PAL_CPPI_PP_QMGR_G0_Q137 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS30)                                  /* PAL_CPPI_PP_QMGR_G0_Q138 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_DS31)                                  /* PAL_CPPI_PP_QMGR_G0_Q139 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_OFDM0)                                 /* PAL_CPPI_PP_QMGR_G0_Q140 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_OFDM1)                                 /* PAL_CPPI_PP_QMGR_G0_Q141 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_Q34)                                   /* PAL_CPPI_PP_QMGR_G0_Q142 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID3_Q35)                                   /* PAL_CPPI_PP_QMGR_G0_Q143 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS0)                                   /* PAL_CPPI_PP_QMGR_G0_Q144 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS1)                                   /* PAL_CPPI_PP_QMGR_G0_Q145 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS2)                                   /* PAL_CPPI_PP_QMGR_G0_Q146 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS3)                                   /* PAL_CPPI_PP_QMGR_G0_Q147 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS4)                                   /* PAL_CPPI_PP_QMGR_G0_Q148 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS5)                                   /* PAL_CPPI_PP_QMGR_G0_Q149 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS6)                                   /* PAL_CPPI_PP_QMGR_G0_Q150 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS7)                                   /* PAL_CPPI_PP_QMGR_G0_Q151 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS8)                                   /* PAL_CPPI_PP_QMGR_G0_Q152 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS9)                                   /* PAL_CPPI_PP_QMGR_G0_Q153 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS10)                                  /* PAL_CPPI_PP_QMGR_G0_Q154 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS11)                                  /* PAL_CPPI_PP_QMGR_G0_Q155 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS12)                                  /* PAL_CPPI_PP_QMGR_G0_Q156 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS13)                                  /* PAL_CPPI_PP_QMGR_G0_Q157 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS14)                                  /* PAL_CPPI_PP_QMGR_G0_Q158 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS15)                                  /* PAL_CPPI_PP_QMGR_G0_Q159 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS16)                                  /* PAL_CPPI_PP_QMGR_G0_Q160 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS17)                                  /* PAL_CPPI_PP_QMGR_G0_Q161 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS18)                                  /* PAL_CPPI_PP_QMGR_G0_Q162 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS19)                                  /* PAL_CPPI_PP_QMGR_G0_Q163 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS20)                                  /* PAL_CPPI_PP_QMGR_G0_Q164 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS21)                                  /* PAL_CPPI_PP_QMGR_G0_Q165 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS22)                                  /* PAL_CPPI_PP_QMGR_G0_Q166 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS23)                                  /* PAL_CPPI_PP_QMGR_G0_Q167 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS24)                                  /* PAL_CPPI_PP_QMGR_G0_Q168 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS25)                                  /* PAL_CPPI_PP_QMGR_G0_Q169 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS26)                                  /* PAL_CPPI_PP_QMGR_G0_Q170 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS27)                                  /* PAL_CPPI_PP_QMGR_G0_Q171 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS28)                                  /* PAL_CPPI_PP_QMGR_G0_Q172 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS29)                                  /* PAL_CPPI_PP_QMGR_G0_Q173 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS30)                                  /* PAL_CPPI_PP_QMGR_G0_Q174 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_DS31)                                  /* PAL_CPPI_PP_QMGR_G0_Q175 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_OFDM0)                                 /* PAL_CPPI_PP_QMGR_G0_Q176 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_OFDM1)                                 /* PAL_CPPI_PP_QMGR_G0_Q177 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_Q34)                                   /* PAL_CPPI_PP_QMGR_G0_Q178 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID4_Q35)                                   /* PAL_CPPI_PP_QMGR_G0_Q179 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS0)                                   /* PAL_CPPI_PP_QMGR_G0_Q180 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS1)                                   /* PAL_CPPI_PP_QMGR_G0_Q181 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS2)                                   /* PAL_CPPI_PP_QMGR_G0_Q182 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS3)                                   /* PAL_CPPI_PP_QMGR_G0_Q183 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS4)                                   /* PAL_CPPI_PP_QMGR_G0_Q184 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS5)                                   /* PAL_CPPI_PP_QMGR_G0_Q185 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS6)                                   /* PAL_CPPI_PP_QMGR_G0_Q186 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS7)                                   /* PAL_CPPI_PP_QMGR_G0_Q187 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS8)                                   /* PAL_CPPI_PP_QMGR_G0_Q188 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS9)                                   /* PAL_CPPI_PP_QMGR_G0_Q189 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS10)                                  /* PAL_CPPI_PP_QMGR_G0_Q190 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS11)                                  /* PAL_CPPI_PP_QMGR_G0_Q191 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS12)                                  /* PAL_CPPI_PP_QMGR_G0_Q192 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS13)                                  /* PAL_CPPI_PP_QMGR_G0_Q193 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS14)                                  /* PAL_CPPI_PP_QMGR_G0_Q194 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS15)                                  /* PAL_CPPI_PP_QMGR_G0_Q195 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS16)                                  /* PAL_CPPI_PP_QMGR_G0_Q196 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS17)                                  /* PAL_CPPI_PP_QMGR_G0_Q197 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS18)                                  /* PAL_CPPI_PP_QMGR_G0_Q198 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS19)                                  /* PAL_CPPI_PP_QMGR_G0_Q199 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS20)                                  /* PAL_CPPI_PP_QMGR_G0_Q200 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS21)                                  /* PAL_CPPI_PP_QMGR_G0_Q201 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS22)                                  /* PAL_CPPI_PP_QMGR_G0_Q202 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS23)                                  /* PAL_CPPI_PP_QMGR_G0_Q203 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS24)                                  /* PAL_CPPI_PP_QMGR_G0_Q204 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS25)                                  /* PAL_CPPI_PP_QMGR_G0_Q205 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS26)                                  /* PAL_CPPI_PP_QMGR_G0_Q206 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS27)                                  /* PAL_CPPI_PP_QMGR_G0_Q207 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS28)                                  /* PAL_CPPI_PP_QMGR_G0_Q208 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS29)                                  /* PAL_CPPI_PP_QMGR_G0_Q209 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS30)                                  /* PAL_CPPI_PP_QMGR_G0_Q210 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_DS31)                                  /* PAL_CPPI_PP_QMGR_G0_Q211 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_OFDM0)                                 /* PAL_CPPI_PP_QMGR_G0_Q212 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_OFDM1)                                 /* PAL_CPPI_PP_QMGR_G0_Q213 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_Q34)                                   /* PAL_CPPI_PP_QMGR_G0_Q214 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID5_Q35)                                   /* PAL_CPPI_PP_QMGR_G0_Q215 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS0)                                   /* PAL_CPPI_PP_QMGR_G0_Q216 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS1)                                   /* PAL_CPPI_PP_QMGR_G0_Q217 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS2)                                   /* PAL_CPPI_PP_QMGR_G0_Q218 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS3)                                   /* PAL_CPPI_PP_QMGR_G0_Q219 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS4)                                   /* PAL_CPPI_PP_QMGR_G0_Q220 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS5)                                   /* PAL_CPPI_PP_QMGR_G0_Q221 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS6)                                   /* PAL_CPPI_PP_QMGR_G0_Q222 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS7)                                   /* PAL_CPPI_PP_QMGR_G0_Q223 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS8)                                   /* PAL_CPPI_PP_QMGR_G0_Q224 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS9)                                   /* PAL_CPPI_PP_QMGR_G0_Q225 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS10)                                  /* PAL_CPPI_PP_QMGR_G0_Q226 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS11)                                  /* PAL_CPPI_PP_QMGR_G0_Q227 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS12)                                  /* PAL_CPPI_PP_QMGR_G0_Q228 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS13)                                  /* PAL_CPPI_PP_QMGR_G0_Q229 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS14)                                  /* PAL_CPPI_PP_QMGR_G0_Q230 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS15)                                  /* PAL_CPPI_PP_QMGR_G0_Q231 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS16)                                  /* PAL_CPPI_PP_QMGR_G0_Q232 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS17)                                  /* PAL_CPPI_PP_QMGR_G0_Q233 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS18)                                  /* PAL_CPPI_PP_QMGR_G0_Q234 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS19)                                  /* PAL_CPPI_PP_QMGR_G0_Q235 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS20)                                  /* PAL_CPPI_PP_QMGR_G0_Q236 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS21)                                  /* PAL_CPPI_PP_QMGR_G0_Q237 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS22)                                  /* PAL_CPPI_PP_QMGR_G0_Q238 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS23)                                  /* PAL_CPPI_PP_QMGR_G0_Q239 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS24)                                  /* PAL_CPPI_PP_QMGR_G0_Q240 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS25)                                  /* PAL_CPPI_PP_QMGR_G0_Q241 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS26)                                  /* PAL_CPPI_PP_QMGR_G0_Q242 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS27)                                  /* PAL_CPPI_PP_QMGR_G0_Q243 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS28)                                  /* PAL_CPPI_PP_QMGR_G0_Q244 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS29)                                  /* PAL_CPPI_PP_QMGR_G0_Q245 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS30)                                  /* PAL_CPPI_PP_QMGR_G0_Q246 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_DS31)                                  /* PAL_CPPI_PP_QMGR_G0_Q247 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_OFDM0)                                 /* PAL_CPPI_PP_QMGR_G0_Q248 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_OFDM1)                                 /* PAL_CPPI_PP_QMGR_G0_Q249 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_Q34)                                   /* PAL_CPPI_PP_QMGR_G0_Q250 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID6_Q35)                                   /* PAL_CPPI_PP_QMGR_G0_Q251 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS0)                                   /* PAL_CPPI_PP_QMGR_G0_Q252 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS1)                                   /* PAL_CPPI_PP_QMGR_G0_Q253 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS2)                                   /* PAL_CPPI_PP_QMGR_G0_Q254 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS3)                                   /* PAL_CPPI_PP_QMGR_G0_Q255 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS4)                                   /* PAL_CPPI_PP_QMGR_G0_Q256 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS5)                                   /* PAL_CPPI_PP_QMGR_G0_Q257 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS6)                                   /* PAL_CPPI_PP_QMGR_G0_Q258 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS7)                                   /* PAL_CPPI_PP_QMGR_G0_Q259 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS8)                                   /* PAL_CPPI_PP_QMGR_G0_Q260 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS9)                                   /* PAL_CPPI_PP_QMGR_G0_Q261 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS10)                                  /* PAL_CPPI_PP_QMGR_G0_Q262 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS11)                                  /* PAL_CPPI_PP_QMGR_G0_Q263 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS12)                                  /* PAL_CPPI_PP_QMGR_G0_Q264 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS13)                                  /* PAL_CPPI_PP_QMGR_G0_Q265 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS14)                                  /* PAL_CPPI_PP_QMGR_G0_Q266 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS15)                                  /* PAL_CPPI_PP_QMGR_G0_Q267 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS16)                                  /* PAL_CPPI_PP_QMGR_G0_Q268 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS17)                                  /* PAL_CPPI_PP_QMGR_G0_Q269 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS18)                                  /* PAL_CPPI_PP_QMGR_G0_Q270 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS19)                                  /* PAL_CPPI_PP_QMGR_G0_Q271 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS20)                                  /* PAL_CPPI_PP_QMGR_G0_Q272 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS21)                                  /* PAL_CPPI_PP_QMGR_G0_Q273 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS22)                                  /* PAL_CPPI_PP_QMGR_G0_Q274 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS23)                                  /* PAL_CPPI_PP_QMGR_G0_Q275 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS24)                                  /* PAL_CPPI_PP_QMGR_G0_Q276 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS25)                                  /* PAL_CPPI_PP_QMGR_G0_Q277 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS26)                                  /* PAL_CPPI_PP_QMGR_G0_Q278 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS27)                                  /* PAL_CPPI_PP_QMGR_G0_Q279 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS28)                                  /* PAL_CPPI_PP_QMGR_G0_Q280 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS29)                                  /* PAL_CPPI_PP_QMGR_G0_Q281 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS30)                                  /* PAL_CPPI_PP_QMGR_G0_Q282 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_DS31)                                  /* PAL_CPPI_PP_QMGR_G0_Q283 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_OFDM0)                                 /* PAL_CPPI_PP_QMGR_G0_Q284 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_OFDM1)                                 /* PAL_CPPI_PP_QMGR_G0_Q285 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_Q34)                                   /* PAL_CPPI_PP_QMGR_G0_Q286 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID7_Q35)                                   /* PAL_CPPI_PP_QMGR_G0_Q287 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS0)                                   /* PAL_CPPI_PP_QMGR_G0_Q288 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS1)                                   /* PAL_CPPI_PP_QMGR_G0_Q289 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS2)                                   /* PAL_CPPI_PP_QMGR_G0_Q290 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS3)                                   /* PAL_CPPI_PP_QMGR_G0_Q291 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS4)                                   /* PAL_CPPI_PP_QMGR_G0_Q292 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS5)                                   /* PAL_CPPI_PP_QMGR_G0_Q293 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS6)                                   /* PAL_CPPI_PP_QMGR_G0_Q294 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS7)                                   /* PAL_CPPI_PP_QMGR_G0_Q295 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS8)                                   /* PAL_CPPI_PP_QMGR_G0_Q296 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS9)                                   /* PAL_CPPI_PP_QMGR_G0_Q297 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS10)                                  /* PAL_CPPI_PP_QMGR_G0_Q298 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS11)                                  /* PAL_CPPI_PP_QMGR_G0_Q299 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS12)                                  /* PAL_CPPI_PP_QMGR_G0_Q300 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS13)                                  /* PAL_CPPI_PP_QMGR_G0_Q301 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS14)                                  /* PAL_CPPI_PP_QMGR_G0_Q302 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS15)                                  /* PAL_CPPI_PP_QMGR_G0_Q303 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS16)                                  /* PAL_CPPI_PP_QMGR_G0_Q304 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS17)                                  /* PAL_CPPI_PP_QMGR_G0_Q305 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS18)                                  /* PAL_CPPI_PP_QMGR_G0_Q306 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS19)                                  /* PAL_CPPI_PP_QMGR_G0_Q307 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS20)                                  /* PAL_CPPI_PP_QMGR_G0_Q308 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS21)                                  /* PAL_CPPI_PP_QMGR_G0_Q309 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS22)                                  /* PAL_CPPI_PP_QMGR_G0_Q310 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS23)                                  /* PAL_CPPI_PP_QMGR_G0_Q311 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS24)                                  /* PAL_CPPI_PP_QMGR_G0_Q312 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS25)                                  /* PAL_CPPI_PP_QMGR_G0_Q313 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS26)                                  /* PAL_CPPI_PP_QMGR_G0_Q314 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS27)                                  /* PAL_CPPI_PP_QMGR_G0_Q315 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS28)                                  /* PAL_CPPI_PP_QMGR_G0_Q316 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS29)                                  /* PAL_CPPI_PP_QMGR_G0_Q317 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS30)                                  /* PAL_CPPI_PP_QMGR_G0_Q318 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_DS31)                                  /* PAL_CPPI_PP_QMGR_G0_Q319 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_OFDM0)                                 /* PAL_CPPI_PP_QMGR_G0_Q320 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_OFDM1)                                 /* PAL_CPPI_PP_QMGR_G0_Q321 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_Q34)                                   /* PAL_CPPI_PP_QMGR_G0_Q322 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID8_Q35)                                   /* PAL_CPPI_PP_QMGR_G0_Q323 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS0)                                   /* PAL_CPPI_PP_QMGR_G0_Q324 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS1)                                   /* PAL_CPPI_PP_QMGR_G0_Q325 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS2)                                   /* PAL_CPPI_PP_QMGR_G0_Q326 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS3)                                   /* PAL_CPPI_PP_QMGR_G0_Q327 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS4)                                   /* PAL_CPPI_PP_QMGR_G0_Q328 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS5)                                   /* PAL_CPPI_PP_QMGR_G0_Q329 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS6)                                   /* PAL_CPPI_PP_QMGR_G0_Q330 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS7)                                   /* PAL_CPPI_PP_QMGR_G0_Q331 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS8)                                   /* PAL_CPPI_PP_QMGR_G0_Q332 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS9)                                   /* PAL_CPPI_PP_QMGR_G0_Q333 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS10)                                  /* PAL_CPPI_PP_QMGR_G0_Q334 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS11)                                  /* PAL_CPPI_PP_QMGR_G0_Q335 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS12)                                  /* PAL_CPPI_PP_QMGR_G0_Q336 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS13)                                  /* PAL_CPPI_PP_QMGR_G0_Q337 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS14)                                  /* PAL_CPPI_PP_QMGR_G0_Q338 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS15)                                  /* PAL_CPPI_PP_QMGR_G0_Q339 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS16)                                  /* PAL_CPPI_PP_QMGR_G0_Q340 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS17)                                  /* PAL_CPPI_PP_QMGR_G0_Q341 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS18)                                  /* PAL_CPPI_PP_QMGR_G0_Q342 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS19)                                  /* PAL_CPPI_PP_QMGR_G0_Q343 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS20)                                  /* PAL_CPPI_PP_QMGR_G0_Q344 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS21)                                  /* PAL_CPPI_PP_QMGR_G0_Q345 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS22)                                  /* PAL_CPPI_PP_QMGR_G0_Q346 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS23)                                  /* PAL_CPPI_PP_QMGR_G0_Q347 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS24)                                  /* PAL_CPPI_PP_QMGR_G0_Q348 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS25)                                  /* PAL_CPPI_PP_QMGR_G0_Q349 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS26)                                  /* PAL_CPPI_PP_QMGR_G0_Q350 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS27)                                  /* PAL_CPPI_PP_QMGR_G0_Q351 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS28)                                  /* PAL_CPPI_PP_QMGR_G0_Q352 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS29)                                  /* PAL_CPPI_PP_QMGR_G0_Q353 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS30)                                  /* PAL_CPPI_PP_QMGR_G0_Q354 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_DS31)                                  /* PAL_CPPI_PP_QMGR_G0_Q355 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_OFDM0)                                 /* PAL_CPPI_PP_QMGR_G0_Q356 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_OFDM1)                                 /* PAL_CPPI_PP_QMGR_G0_Q357 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_Q34)                                   /* PAL_CPPI_PP_QMGR_G0_Q358 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID9_Q35)                                   /* PAL_CPPI_PP_QMGR_G0_Q359 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q360 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q361 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q362 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q363 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q364 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q365 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q366 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q367 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q368 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q369 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q370 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q371 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q372 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q373 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q374 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q375 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q376 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q377 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q378 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q379 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q380 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q381 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q382 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q383 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q384 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q385 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q386 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q387 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q388 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q389 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q390 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q391 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q392 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q393 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q394 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID10_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q395 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q396 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q397 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q398 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q399 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q400 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q401 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q402 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q403 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q404 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q405 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q406 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q407 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q408 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q409 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q410 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q411 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q412 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q413 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q414 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q415 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q416 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q417 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q418 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q419 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q420 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q421 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q422 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q423 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q424 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q425 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q426 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q427 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q428 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q429 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q430 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID11_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q431 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q432 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q433 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q434 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q435 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q436 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q437 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q438 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q439 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q440 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q441 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q442 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q443 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q444 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q445 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q446 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q447 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q448 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q449 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q450 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q451 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q452 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q453 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q454 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q455 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q456 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q457 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q458 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q459 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q460 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q461 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q462 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q463 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q464 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q465 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q466 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID12_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q467 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q468 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q469 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q470 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q471 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q472 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q473 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q474 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q475 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q476 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q477 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q478 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q479 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q480 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q481 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q482 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q483 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q484 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q485 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q486 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q487 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q488 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q489 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q490 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q491 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q492 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q493 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q494 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q495 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q496 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q497 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q498 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q499 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q500 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q501 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q502 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID13_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q503 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q504 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q505 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q506 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q507 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q508 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q509 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q510 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q511 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q512 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q513 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q514 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q515 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q516 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q517 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q518 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q519 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q520 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q521 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q522 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q523 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q524 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q525 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q526 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q527 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q528 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q529 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q530 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q531 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q532 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q533 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q534 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q535 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q536 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q537 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q538 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID14_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q539 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q540 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q541 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q542 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q543 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q544 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q545 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q546 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q547 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q548 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q549 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q550 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q551 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q552 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q553 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q554 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q555 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q556 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q557 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q558 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q559 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q560 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q561 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q562 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q563 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q564 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q565 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q566 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q567 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q568 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q569 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q570 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q571 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q572 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q573 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q574 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID15_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q575 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q576 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q577 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q578 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q579 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q580 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q581 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q582 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q583 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q584 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q585 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q586 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q587 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q588 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q589 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q590 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q591 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q592 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q593 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q594 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q595 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q596 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q597 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q598 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q599 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q600 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q601 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q602 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q603 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q604 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q605 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q606 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q607 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q608 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q609 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q610 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID16_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q611 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q612 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q613 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q614 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q615 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q616 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q617 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q618 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q619 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q620 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q621 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q622 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q623 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q624 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q625 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q626 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q627 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q628 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q629 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q630 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q631 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q632 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q633 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q634 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q635 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q636 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q637 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q638 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q639 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q640 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q641 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q642 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q643 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q644 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q645 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q646 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID17_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q647 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q648 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q649 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q650 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q651 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q652 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q653 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q654 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q655 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q656 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q657 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q658 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q659 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q660 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q661 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q662 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q663 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q664 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q665 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q666 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q667 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q668 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q669 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q670 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q671 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q672 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q673 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q674 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q675 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q676 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q677 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q678 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q679 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q680 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q681 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q682 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID18_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q683 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q684 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q685 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q686 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q687 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q688 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q689 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q690 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q691 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q692 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q693 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q694 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q695 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q696 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q697 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q698 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q699 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q700 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q701 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q702 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q703 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q704 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q705 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q706 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q707 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q708 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q709 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q710 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q711 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q712 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q713 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q714 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q715 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q716 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q717 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q718 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID19_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q719 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q720 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q721 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q722 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q723 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q724 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q725 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q726 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q727 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q728 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q729 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q730 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q731 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q732 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q733 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q734 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q735 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q736 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q737 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q738 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q739 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q740 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q741 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q742 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q743 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q744 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q745 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q746 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q747 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q748 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q749 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q750 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q751 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q752 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q753 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q754 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID20_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q755 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q756 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q757 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q758 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q759 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q760 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q761 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q762 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q763 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q764 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q765 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q766 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q767 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q768 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q769 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q770 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q771 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q772 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q773 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q774 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q775 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q776 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q777 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q778 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q779 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q780 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q781 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q782 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q783 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q784 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q785 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q786 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q787 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q788 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q789 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q790 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID21_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q791 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q792 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q793 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q794 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q795 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q796 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q797 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q798 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q799 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q800 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q801 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q802 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q803 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q804 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q805 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q806 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q807 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q808 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q809 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q810 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q811 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q812 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q813 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q814 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q815 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q816 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q817 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q818 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q819 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q820 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q821 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q822 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q823 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q824 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q825 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q826 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID22_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q827 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q828 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q829 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q830 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q831 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q832 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q833 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q834 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q835 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q836 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q837 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q838 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q839 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q840 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q841 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q842 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q843 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q844 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q845 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q846 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q847 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q848 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q849 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q850 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q851 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q852 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q853 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q854 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q855 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q856 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q857 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q858 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q859 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q860 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q861 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q862 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID23_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q863 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q864 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q865 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q866 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q867 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q868 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q869 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q870 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q871 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q872 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q873 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q874 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q875 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q876 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q877 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q878 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q879 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q880 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q881 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q882 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q883 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q884 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q885 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q886 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q887 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q888 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q889 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q890 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q891 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q892 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q893 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q894 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q895 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q896 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q897 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q898 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID24_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q899 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q900 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q901 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q902 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q903 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q904 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q905 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q906 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q907 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q908 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q909 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q910 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q911 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q912 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q913 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q914 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q915 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q916 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q917 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q918 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q919 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q920 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q921 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q922 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q923 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q924 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q925 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q926 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q927 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q928 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q929 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q930 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q931 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q932 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q933 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q934 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID25_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q935 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q936 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q937 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q938 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q939 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q940 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q941 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q942 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q943 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q944 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q945 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q946 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q947 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q948 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q949 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q950 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q951 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q952 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q953 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q954 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q955 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q956 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q957 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q958 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q959 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q960 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q961 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q962 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q963 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q964 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q965 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q966 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q967 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q968 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q969 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q970 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID26_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q971 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q972 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q973 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q974 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q975 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q976 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q977 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q978 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q979 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q980 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q981 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q982 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q983 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q984 */\ 
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q985 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q986 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q987 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q988 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q989 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q990 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q991 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q992 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q993 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q994 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q995 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q996 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q997 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q998 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q999 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1000 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1001 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1002 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1003 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1004 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1005 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1006 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID27_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1007 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1008 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1009 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1010 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1011 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1012 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1013 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1014 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1015 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1016 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1017 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1018 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1019 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1020 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1021 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1022 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1023 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1024 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1025 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1026 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1027 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1028 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1029 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1030 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1031 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1032 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1033 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1034 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1035 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1036 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1037 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1038 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1039 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1040 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1041 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1042 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID28_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1043 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1044 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1045 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1046 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1047 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1048 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1049 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1050 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1051 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1052 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1053 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1054 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1055 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1056 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1057 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1058 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1059 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1060 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1061 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1062 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1063 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1064 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1065 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1066 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1067 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1068 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1069 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1070 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1071 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1072 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1073 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1074 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1075 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1076 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1077 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1078 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID29_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1079 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1080 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1081 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1082 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1083 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1084 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1085 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1086 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1087 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1088 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1089 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1090 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1091 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1092 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1093 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1094 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1095 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1096 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1097 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1098 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1099 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1100 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1101 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1102 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1103 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1104 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1105 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1106 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1107 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1108 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1109 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1110 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1111 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1112 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1113 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1114 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID30_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1115 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1116 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1117 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1118 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1119 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1120 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1121 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1122 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1123 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1124 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1125 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1126 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1127 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1128 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1129 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1130 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1131 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1132 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1133 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1134 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1135 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1136 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1137 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1138 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1139 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1140 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1141 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1142 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1143 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1144 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1145 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1146 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1147 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1148 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1149 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1150 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID31_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1151 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1152 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1153 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1154 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1155 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1156 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1157 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1158 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1159 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1160 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1161 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1162 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1163 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1164 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1165 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1166 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1167 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1168 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1169 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1170 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1171 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1172 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1173 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1174 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1175 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1176 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1177 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1178 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1179 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1180 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1181 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1182 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1183 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1184 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1185 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1186 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID32_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1187 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1188 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1189 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1190 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1191 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1192 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1193 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1194 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1195 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1196 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1197 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1198 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1199 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1200 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1201 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1202 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1203 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1204 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1205 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1206 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1207 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1208 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1209 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1210 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1211 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1212 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1213 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1214 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1215 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1216 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1217 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1218 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1219 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1220 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1221 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1222 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID33_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1223 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1224 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1225 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1226 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1227 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1228 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1229 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1230 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1231 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1232 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1233 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1234 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1235 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1236 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1237 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1238 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1239 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1240 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1241 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1242 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1243 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1244 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1245 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1246 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1247 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1248 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1249 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1250 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1251 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1252 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1253 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1254 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1255 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1256 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1257 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1258 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID34_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1259 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1260 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1261 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1262 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1263 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1264 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1265 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1266 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1267 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1268 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1269 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1270 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1271 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1272 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1273 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1274 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1275 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1276 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1277 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1278 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1279 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1280 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1281 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1282 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1283 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1284 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1285 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1286 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1287 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1288 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1289 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1290 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1291 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1292 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1293 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1294 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID35_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1295 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1296 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1297 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1298 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1299 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1300 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1301 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1302 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1303 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1304 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1305 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1306 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1307 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1308 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1309 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1310 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1311 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1312 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1313 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1314 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1315 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1316 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1317 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1318 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1319 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1320 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1321 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1322 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1323 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1324 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1325 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1326 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1327 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1328 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1329 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1330 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID36_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1331 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1332 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1333 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1334 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1335 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1336 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1337 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1338 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1339 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1340 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1341 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1342 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1343 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1344 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1345 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1346 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1347 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1348 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1349 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1350 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1351 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1352 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1353 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1354 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1355 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1356 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1357 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1358 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1359 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1360 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1361 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1362 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1363 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1364 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1365 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1366 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID37_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1367 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1368 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1369 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1370 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1371 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1372 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1373 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1374 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1375 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1376 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1377 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1378 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1379 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1380 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1381 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1382 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1383 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1384 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1385 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1386 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1387 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1388 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1389 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1390 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1391 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1392 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1393 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1394 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1395 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1396 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1397 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1398 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1399 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1400 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1401 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1402 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID38_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1403 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1404 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1405 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1406 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1407 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1408 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1409 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1410 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1411 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1412 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1413 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1414 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1415 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1416 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1417 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1418 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1419 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1420 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1421 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1422 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1423 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1424 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1425 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1426 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1427 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1428 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1429 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1430 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1431 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1432 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1433 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1434 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1435 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1436 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1437 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1438 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID39_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1439 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1440 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1441 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1442 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1443 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1444 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1445 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1446 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1447 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1448 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1449 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1450 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1451 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1452 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1453 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1454 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1455 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1456 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1457 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1458 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1459 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1460 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1461 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1462 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1463 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1464 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1465 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1466 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1467 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1468 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1469 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1470 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1471 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1472 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1473 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1474 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID40_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1475 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1476 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1477 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1478 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1479 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1480 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1481 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1482 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1483 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1484 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1485 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1486 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1487 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1488 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1489 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1490 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1491 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1492 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1493 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1494 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1495 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1496 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1497 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1498 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1499 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1500 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1501 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1502 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1503 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1504 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1505 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1506 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1507 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1508 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1509 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1510 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID41_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1511 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1512 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1513 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1514 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1515 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1516 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1517 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1518 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1519 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1520 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1521 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1522 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1523 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1524 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1525 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1526 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1527 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1528 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1529 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1530 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1531 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1532 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1533 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1534 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1535 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1536 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1537 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1538 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1539 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1540 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1541 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1542 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1543 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1544 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1545 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1546 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID42_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1547 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1548 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1549 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1550 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1551 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1552 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1553 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1554 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1555 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1556 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1557 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1558 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1559 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1560 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1561 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1562 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1563 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1564 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1565 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1566 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1567 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1568 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1569 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1570 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1571 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1572 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1573 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1574 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1575 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1576 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1577 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1578 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1579 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1580 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1581 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1582 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID43_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1583 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1584 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1585 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1586 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1587 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1588 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1589 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1590 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1591 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1592 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1593 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1594 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1595 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1596 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1597 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1598 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1599 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1600 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1601 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1602 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1603 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1604 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1605 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1606 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1607 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1608 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1609 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1610 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1611 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1612 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1613 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1614 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1615 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1616 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1617 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1618 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID44_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1619 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1620 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1621 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1622 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1623 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1624 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1625 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1626 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1627 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1628 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1629 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1630 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1631 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1632 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1633 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1634 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1635 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1636 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1637 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1638 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1639 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1640 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1641 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1642 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1643 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1644 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1645 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1646 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1647 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1648 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1649 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1650 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1651 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1652 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1653 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1654 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID45_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1655 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1656 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1657 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1658 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1659 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1660 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1661 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1662 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1663 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1664 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1665 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1666 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1667 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1668 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1669 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1670 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1671 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1672 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1673 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1674 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1675 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1676 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1677 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1678 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1679 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1680 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1681 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1682 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1683 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1684 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1685 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1686 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1687 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1688 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1689 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1690 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID46_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1691 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS0)                                  /* PAL_CPPI_PP_QMGR_G0_Q1692 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS1)                                  /* PAL_CPPI_PP_QMGR_G0_Q1693 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS2)                                  /* PAL_CPPI_PP_QMGR_G0_Q1694 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS3)                                  /* PAL_CPPI_PP_QMGR_G0_Q1695 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS4)                                  /* PAL_CPPI_PP_QMGR_G0_Q1696 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS5)                                  /* PAL_CPPI_PP_QMGR_G0_Q1697 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS6)                                  /* PAL_CPPI_PP_QMGR_G0_Q1698 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS7)                                  /* PAL_CPPI_PP_QMGR_G0_Q1699 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS8)                                  /* PAL_CPPI_PP_QMGR_G0_Q1700 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS9)                                  /* PAL_CPPI_PP_QMGR_G0_Q1701 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS10)                                 /* PAL_CPPI_PP_QMGR_G0_Q1702 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS11)                                 /* PAL_CPPI_PP_QMGR_G0_Q1703 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS12)                                 /* PAL_CPPI_PP_QMGR_G0_Q1704 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS13)                                 /* PAL_CPPI_PP_QMGR_G0_Q1705 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS14)                                 /* PAL_CPPI_PP_QMGR_G0_Q1706 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS15)                                 /* PAL_CPPI_PP_QMGR_G0_Q1707 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS16)                                 /* PAL_CPPI_PP_QMGR_G0_Q1708 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS17)                                 /* PAL_CPPI_PP_QMGR_G0_Q1709 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS18)                                 /* PAL_CPPI_PP_QMGR_G0_Q1710 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS19)                                 /* PAL_CPPI_PP_QMGR_G0_Q1711 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS20)                                 /* PAL_CPPI_PP_QMGR_G0_Q1712 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS21)                                 /* PAL_CPPI_PP_QMGR_G0_Q1713 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS22)                                 /* PAL_CPPI_PP_QMGR_G0_Q1714 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS23)                                 /* PAL_CPPI_PP_QMGR_G0_Q1715 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS24)                                 /* PAL_CPPI_PP_QMGR_G0_Q1716 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS25)                                 /* PAL_CPPI_PP_QMGR_G0_Q1717 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS26)                                 /* PAL_CPPI_PP_QMGR_G0_Q1718 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS27)                                 /* PAL_CPPI_PP_QMGR_G0_Q1719 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS28)                                 /* PAL_CPPI_PP_QMGR_G0_Q1720 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS29)                                 /* PAL_CPPI_PP_QMGR_G0_Q1721 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS30)                                 /* PAL_CPPI_PP_QMGR_G0_Q1722 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_DS31)                                 /* PAL_CPPI_PP_QMGR_G0_Q1723 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_OFDM0)                                /* PAL_CPPI_PP_QMGR_G0_Q1724 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_OFDM1)                                /* PAL_CPPI_PP_QMGR_G0_Q1725 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_Q34)                                  /* PAL_CPPI_PP_QMGR_G0_Q1726 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_DS_RESEQ_DSID47_Q35)                                  /* PAL_CPPI_PP_QMGR_G0_Q1727 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_CLASSIFIER1_LOW_Q_NUM)                                /* PAL_CPPI_PP_QMGR_G0_Q1728 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_CLASSIFIER1_MED_LOW_Q_NUM)                            /* PAL_CPPI_PP_QMGR_G0_Q1729 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_CLASSIFIER1_MED_HI_Q_NUM)                             /* PAL_CPPI_PP_QMGR_G0_Q1730 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_CLASSIFIER1_HI_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G0_Q1731 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_CLASSIFIER2_LOW_Q_NUM)                                /* PAL_CPPI_PP_QMGR_G0_Q1732 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_CLASSIFIER2_MED_LOW_Q_NUM)                            /* PAL_CPPI_PP_QMGR_G0_Q1733 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_CLASSIFIER2_MED_HI_Q_NUM)                             /* PAL_CPPI_PP_QMGR_G0_Q1734 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_CLASSIFIER2_HI_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G0_Q1735 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_MODIFIER_LOW_Q_NUM)                                   /* PAL_CPPI_PP_QMGR_G0_Q1736 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_MODIFIER_MED_LOW_Q_NUM)                               /* PAL_CPPI_PP_QMGR_G0_Q1737 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_MODIFIER_MED_HI_Q_NUM)                                /* PAL_CPPI_PP_QMGR_G0_Q1738 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_MODIFIER_HI_Q_NUM)                                    /* PAL_CPPI_PP_QMGR_G0_Q1739 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_RECYCLER_LOW_Q_NUM)                                   /* PAL_CPPI_PP_QMGR_G0_Q1740 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_RECYCLER_HI_Q_NUM)                                    /* PAL_CPPI_PP_QMGR_G0_Q1741 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q0)                                               /* PAL_CPPI_PP_QMGR_G0_Q1742 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q1)                                               /* PAL_CPPI_PP_QMGR_G0_Q1743 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q2)                                               /* PAL_CPPI_PP_QMGR_G0_Q1744 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q3)                                               /* PAL_CPPI_PP_QMGR_G0_Q1745 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q4)                                               /* PAL_CPPI_PP_QMGR_G0_Q1746 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q5)                                               /* PAL_CPPI_PP_QMGR_G0_Q1747 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q6)                                               /* PAL_CPPI_PP_QMGR_G0_Q1748 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q7)                                               /* PAL_CPPI_PP_QMGR_G0_Q1749 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q8)                                               /* PAL_CPPI_PP_QMGR_G0_Q1750 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q9)                                               /* PAL_CPPI_PP_QMGR_G0_Q1751 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q10)                                              /* PAL_CPPI_PP_QMGR_G0_Q1752 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q11)                                              /* PAL_CPPI_PP_QMGR_G0_Q1753 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q12)                                              /* PAL_CPPI_PP_QMGR_G0_Q1754 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q13)                                              /* PAL_CPPI_PP_QMGR_G0_Q1755 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q14)                                              /* PAL_CPPI_PP_QMGR_G0_Q1756 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_COE_Q15)                                              /* PAL_CPPI_PP_QMGR_G0_Q1757 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_SESSION_CACHE_LOW_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G0_Q1758 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_SESSION_CACHE_MED_LOW_Q_NUM)                          /* PAL_CPPI_PP_QMGR_G0_Q1759 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_SESSION_CACHE_MED_HI_Q_NUM)                           /* PAL_CPPI_PP_QMGR_G0_Q1760 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G0_SESSION_CACHE_HI_Q_NUM)                               /* PAL_CPPI_PP_QMGR_G0_Q1761 */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/include/linux/avalanche/puma7/puma7_cppi_gqmgr1_q.h b/include/linux/avalanche/puma7/puma7_cppi_gqmgr1_q.h
new file mode 100755
index 0000000..5f220a9
--- /dev/null
+++ b/include/linux/avalanche/puma7/puma7_cppi_gqmgr1_q.h
@@ -0,0 +1,574 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 - 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+    Intel Corporation
+    2200 Mission College Blvd.
+    Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2014 - 2016 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#define PAL_CPPI_PP_QMGR_G1_Q_LIST                                                                                        \
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q0)                                                 /* PAL_CPPI_PP_QMGR_G1_Q0 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q1)                                                 /* PAL_CPPI_PP_QMGR_G1_Q1 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q2)                                                 /* PAL_CPPI_PP_QMGR_G1_Q2 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q3)                                                 /* PAL_CPPI_PP_QMGR_G1_Q3 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q4)                                                 /* PAL_CPPI_PP_QMGR_G1_Q4 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q5)                                                 /* PAL_CPPI_PP_QMGR_G1_Q5 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q6)                                                 /* PAL_CPPI_PP_QMGR_G1_Q6 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q7)                                                 /* PAL_CPPI_PP_QMGR_G1_Q7 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q8)                                                 /* PAL_CPPI_PP_QMGR_G1_Q8 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q9)                                                 /* PAL_CPPI_PP_QMGR_G1_Q9 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q10)                                                /* PAL_CPPI_PP_QMGR_G1_Q10 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q11)                                                /* PAL_CPPI_PP_QMGR_G1_Q11 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q12)                                                /* PAL_CPPI_PP_QMGR_G1_Q12 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q13)                                                /* PAL_CPPI_PP_QMGR_G1_Q13 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q14)                                                /* PAL_CPPI_PP_QMGR_G1_Q14 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q15)                                                /* PAL_CPPI_PP_QMGR_G1_Q15 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q16)                                                /* PAL_CPPI_PP_QMGR_G1_Q16 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q17)                                                /* PAL_CPPI_PP_QMGR_G1_Q17 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q18)                                                /* PAL_CPPI_PP_QMGR_G1_Q18 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q19)                                                /* PAL_CPPI_PP_QMGR_G1_Q19 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q20)                                                /* PAL_CPPI_PP_QMGR_G1_Q20 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q21)                                                /* PAL_CPPI_PP_QMGR_G1_Q21 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q22)                                                /* PAL_CPPI_PP_QMGR_G1_Q22 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q23)                                                /* PAL_CPPI_PP_QMGR_G1_Q23 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q24)                                                /* PAL_CPPI_PP_QMGR_G1_Q24 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q25)                                                /* PAL_CPPI_PP_QMGR_G1_Q25 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q26)                                                /* PAL_CPPI_PP_QMGR_G1_Q26 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q27)                                                /* PAL_CPPI_PP_QMGR_G1_Q27 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q28)                                                /* PAL_CPPI_PP_QMGR_G1_Q28 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q29)                                                /* PAL_CPPI_PP_QMGR_G1_Q29 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q30)                                                /* PAL_CPPI_PP_QMGR_G1_Q30 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q31)                                                /* PAL_CPPI_PP_QMGR_G1_Q31 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q32)                                                /* PAL_CPPI_PP_QMGR_G1_Q32 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q33)                                                /* PAL_CPPI_PP_QMGR_G1_Q33 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q34)                                                /* PAL_CPPI_PP_QMGR_G1_Q34 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q35)                                                /* PAL_CPPI_PP_QMGR_G1_Q35 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q36)                                                /* PAL_CPPI_PP_QMGR_G1_Q36 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q37)                                                /* PAL_CPPI_PP_QMGR_G1_Q37 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q38)                                                /* PAL_CPPI_PP_QMGR_G1_Q38 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q39)                                                /* PAL_CPPI_PP_QMGR_G1_Q39 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q40)                                                /* PAL_CPPI_PP_QMGR_G1_Q40 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q41)                                                /* PAL_CPPI_PP_QMGR_G1_Q41 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q42)                                                /* PAL_CPPI_PP_QMGR_G1_Q42 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q43)                                                /* PAL_CPPI_PP_QMGR_G1_Q43 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q44)                                                /* PAL_CPPI_PP_QMGR_G1_Q44 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q45)                                                /* PAL_CPPI_PP_QMGR_G1_Q45 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q46)                                                /* PAL_CPPI_PP_QMGR_G1_Q46 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q47)                                                /* PAL_CPPI_PP_QMGR_G1_Q47 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q48)                                                /* PAL_CPPI_PP_QMGR_G1_Q48 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q49)                                                /* PAL_CPPI_PP_QMGR_G1_Q49 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q50)                                                /* PAL_CPPI_PP_QMGR_G1_Q50 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q51)                                                /* PAL_CPPI_PP_QMGR_G1_Q51 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q52)                                                /* PAL_CPPI_PP_QMGR_G1_Q52 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q53)                                                /* PAL_CPPI_PP_QMGR_G1_Q53 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q54)                                                /* PAL_CPPI_PP_QMGR_G1_Q54 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q55)                                                /* PAL_CPPI_PP_QMGR_G1_Q55 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q56)                                                /* PAL_CPPI_PP_QMGR_G1_Q56 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q57)                                                /* PAL_CPPI_PP_QMGR_G1_Q57 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q58)                                                /* PAL_CPPI_PP_QMGR_G1_Q58 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q59)                                                /* PAL_CPPI_PP_QMGR_G1_Q59 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q60)                                                /* PAL_CPPI_PP_QMGR_G1_Q60 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q61)                                                /* PAL_CPPI_PP_QMGR_G1_Q61 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q62)                                                /* PAL_CPPI_PP_QMGR_G1_Q62 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q63)                                                /* PAL_CPPI_PP_QMGR_G1_Q63 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q64)                                                /* PAL_CPPI_PP_QMGR_G1_Q64 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q65)                                                /* PAL_CPPI_PP_QMGR_G1_Q65 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q66)                                                /* PAL_CPPI_PP_QMGR_G1_Q66 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q67)                                                /* PAL_CPPI_PP_QMGR_G1_Q67 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q68)                                                /* PAL_CPPI_PP_QMGR_G1_Q68 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q69)                                                /* PAL_CPPI_PP_QMGR_G1_Q69 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q70)                                                /* PAL_CPPI_PP_QMGR_G1_Q70 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q71)                                                /* PAL_CPPI_PP_QMGR_G1_Q71 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q72)                                                /* PAL_CPPI_PP_QMGR_G1_Q72 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q73)                                                /* PAL_CPPI_PP_QMGR_G1_Q73 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q74)                                                /* PAL_CPPI_PP_QMGR_G1_Q74 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q75)                                                /* PAL_CPPI_PP_QMGR_G1_Q75 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q76)                                                /* PAL_CPPI_PP_QMGR_G1_Q76 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q77)                                                /* PAL_CPPI_PP_QMGR_G1_Q77 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q78)                                                /* PAL_CPPI_PP_QMGR_G1_Q78 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q79)                                                /* PAL_CPPI_PP_QMGR_G1_Q79 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q80)                                                /* PAL_CPPI_PP_QMGR_G1_Q80 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q81)                                                /* PAL_CPPI_PP_QMGR_G1_Q81 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q82)                                                /* PAL_CPPI_PP_QMGR_G1_Q82 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q83)                                                /* PAL_CPPI_PP_QMGR_G1_Q83 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q84)                                                /* PAL_CPPI_PP_QMGR_G1_Q84 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q85)                                                /* PAL_CPPI_PP_QMGR_G1_Q85 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q86)                                                /* PAL_CPPI_PP_QMGR_G1_Q86 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q87)                                                /* PAL_CPPI_PP_QMGR_G1_Q87 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q88)                                                /* PAL_CPPI_PP_QMGR_G1_Q88 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q89)                                                /* PAL_CPPI_PP_QMGR_G1_Q89 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q90)                                                /* PAL_CPPI_PP_QMGR_G1_Q90 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q91)                                                /* PAL_CPPI_PP_QMGR_G1_Q91 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q92)                                                /* PAL_CPPI_PP_QMGR_G1_Q92 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q93)                                                /* PAL_CPPI_PP_QMGR_G1_Q93 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q94)                                                /* PAL_CPPI_PP_QMGR_G1_Q94 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q95)                                                /* PAL_CPPI_PP_QMGR_G1_Q95 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q96)                                                /* PAL_CPPI_PP_QMGR_G1_Q96 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q97)                                                /* PAL_CPPI_PP_QMGR_G1_Q97 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q98)                                                /* PAL_CPPI_PP_QMGR_G1_Q98 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q99)                                                /* PAL_CPPI_PP_QMGR_G1_Q99 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q100)                                               /* PAL_CPPI_PP_QMGR_G1_Q100 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q101)                                               /* PAL_CPPI_PP_QMGR_G1_Q101 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q102)                                               /* PAL_CPPI_PP_QMGR_G1_Q102 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q103)                                               /* PAL_CPPI_PP_QMGR_G1_Q103 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q104)                                               /* PAL_CPPI_PP_QMGR_G1_Q104 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q105)                                               /* PAL_CPPI_PP_QMGR_G1_Q105 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q106)                                               /* PAL_CPPI_PP_QMGR_G1_Q106 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q107)                                               /* PAL_CPPI_PP_QMGR_G1_Q107 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q108)                                               /* PAL_CPPI_PP_QMGR_G1_Q108 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q109)                                               /* PAL_CPPI_PP_QMGR_G1_Q109 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q110)                                               /* PAL_CPPI_PP_QMGR_G1_Q110 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q111)                                               /* PAL_CPPI_PP_QMGR_G1_Q111 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q112)                                               /* PAL_CPPI_PP_QMGR_G1_Q112 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q113)                                               /* PAL_CPPI_PP_QMGR_G1_Q113 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q114)                                               /* PAL_CPPI_PP_QMGR_G1_Q114 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q115)                                               /* PAL_CPPI_PP_QMGR_G1_Q115 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q116)                                               /* PAL_CPPI_PP_QMGR_G1_Q116 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q117)                                               /* PAL_CPPI_PP_QMGR_G1_Q117 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q118)                                               /* PAL_CPPI_PP_QMGR_G1_Q118 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q119)                                               /* PAL_CPPI_PP_QMGR_G1_Q119 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q120)                                               /* PAL_CPPI_PP_QMGR_G1_Q120 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q121)                                               /* PAL_CPPI_PP_QMGR_G1_Q121 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q122)                                               /* PAL_CPPI_PP_QMGR_G1_Q122 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q123)                                               /* PAL_CPPI_PP_QMGR_G1_Q123 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q124)                                               /* PAL_CPPI_PP_QMGR_G1_Q124 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q125)                                               /* PAL_CPPI_PP_QMGR_G1_Q125 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q126)                                               /* PAL_CPPI_PP_QMGR_G1_Q126 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q127)                                               /* PAL_CPPI_PP_QMGR_G1_Q127 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q128)                                               /* PAL_CPPI_PP_QMGR_G1_Q128 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q129)                                               /* PAL_CPPI_PP_QMGR_G1_Q129 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q130)                                               /* PAL_CPPI_PP_QMGR_G1_Q130 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q131)                                               /* PAL_CPPI_PP_QMGR_G1_Q131 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q132)                                               /* PAL_CPPI_PP_QMGR_G1_Q132 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q133)                                               /* PAL_CPPI_PP_QMGR_G1_Q133 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q134)                                               /* PAL_CPPI_PP_QMGR_G1_Q134 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q135)                                               /* PAL_CPPI_PP_QMGR_G1_Q135 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q136)                                               /* PAL_CPPI_PP_QMGR_G1_Q136 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q137)                                               /* PAL_CPPI_PP_QMGR_G1_Q137 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q138)                                               /* PAL_CPPI_PP_QMGR_G1_Q138 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q139)                                               /* PAL_CPPI_PP_QMGR_G1_Q139 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q140)                                               /* PAL_CPPI_PP_QMGR_G1_Q140 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q141)                                               /* PAL_CPPI_PP_QMGR_G1_Q141 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q142)                                               /* PAL_CPPI_PP_QMGR_G1_Q142 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q143)                                               /* PAL_CPPI_PP_QMGR_G1_Q143 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q144)                                               /* PAL_CPPI_PP_QMGR_G1_Q144 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q145)                                               /* PAL_CPPI_PP_QMGR_G1_Q145 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q146)                                               /* PAL_CPPI_PP_QMGR_G1_Q146 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q147)                                               /* PAL_CPPI_PP_QMGR_G1_Q147 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q148)                                               /* PAL_CPPI_PP_QMGR_G1_Q148 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q149)                                               /* PAL_CPPI_PP_QMGR_G1_Q149 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q150)                                               /* PAL_CPPI_PP_QMGR_G1_Q150 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q151)                                               /* PAL_CPPI_PP_QMGR_G1_Q151 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q152)                                               /* PAL_CPPI_PP_QMGR_G1_Q152 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q153)                                               /* PAL_CPPI_PP_QMGR_G1_Q153 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q154)                                               /* PAL_CPPI_PP_QMGR_G1_Q154 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q155)                                               /* PAL_CPPI_PP_QMGR_G1_Q155 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q156)                                               /* PAL_CPPI_PP_QMGR_G1_Q156 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q157)                                               /* PAL_CPPI_PP_QMGR_G1_Q157 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q158)                                               /* PAL_CPPI_PP_QMGR_G1_Q158 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q159)                                               /* PAL_CPPI_PP_QMGR_G1_Q159 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q160)                                               /* PAL_CPPI_PP_QMGR_G1_Q160 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q161)                                               /* PAL_CPPI_PP_QMGR_G1_Q161 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q162)                                               /* PAL_CPPI_PP_QMGR_G1_Q162 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q163)                                               /* PAL_CPPI_PP_QMGR_G1_Q163 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q164)                                               /* PAL_CPPI_PP_QMGR_G1_Q164 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q165)                                               /* PAL_CPPI_PP_QMGR_G1_Q165 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q166)                                               /* PAL_CPPI_PP_QMGR_G1_Q166 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q167)                                               /* PAL_CPPI_PP_QMGR_G1_Q167 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q168)                                               /* PAL_CPPI_PP_QMGR_G1_Q168 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q169)                                               /* PAL_CPPI_PP_QMGR_G1_Q169 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q170)                                               /* PAL_CPPI_PP_QMGR_G1_Q170 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q171)                                               /* PAL_CPPI_PP_QMGR_G1_Q171 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q172)                                               /* PAL_CPPI_PP_QMGR_G1_Q172 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q173)                                               /* PAL_CPPI_PP_QMGR_G1_Q173 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q174)                                               /* PAL_CPPI_PP_QMGR_G1_Q174 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q175)                                               /* PAL_CPPI_PP_QMGR_G1_Q175 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q176)                                               /* PAL_CPPI_PP_QMGR_G1_Q176 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q177)                                               /* PAL_CPPI_PP_QMGR_G1_Q177 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q178)                                               /* PAL_CPPI_PP_QMGR_G1_Q178 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q179)                                               /* PAL_CPPI_PP_QMGR_G1_Q179 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q180)                                               /* PAL_CPPI_PP_QMGR_G1_Q180 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q181)                                               /* PAL_CPPI_PP_QMGR_G1_Q181 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q182)                                               /* PAL_CPPI_PP_QMGR_G1_Q182 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q183)                                               /* PAL_CPPI_PP_QMGR_G1_Q183 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q184)                                               /* PAL_CPPI_PP_QMGR_G1_Q184 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q185)                                               /* PAL_CPPI_PP_QMGR_G1_Q185 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q186)                                               /* PAL_CPPI_PP_QMGR_G1_Q186 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q187)                                               /* PAL_CPPI_PP_QMGR_G1_Q187 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q188)                                               /* PAL_CPPI_PP_QMGR_G1_Q188 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q189)                                               /* PAL_CPPI_PP_QMGR_G1_Q189 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q190)                                               /* PAL_CPPI_PP_QMGR_G1_Q190 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q191)                                               /* PAL_CPPI_PP_QMGR_G1_Q191 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q192)                                               /* PAL_CPPI_PP_QMGR_G1_Q192 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q193)                                               /* PAL_CPPI_PP_QMGR_G1_Q193 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q194)                                               /* PAL_CPPI_PP_QMGR_G1_Q194 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q195)                                               /* PAL_CPPI_PP_QMGR_G1_Q195 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q196)                                               /* PAL_CPPI_PP_QMGR_G1_Q196 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q197)                                               /* PAL_CPPI_PP_QMGR_G1_Q197 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q198)                                               /* PAL_CPPI_PP_QMGR_G1_Q198 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q199)                                               /* PAL_CPPI_PP_QMGR_G1_Q199 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q200)                                               /* PAL_CPPI_PP_QMGR_G1_Q200 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q201)                                               /* PAL_CPPI_PP_QMGR_G1_Q201 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q202)                                               /* PAL_CPPI_PP_QMGR_G1_Q202 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q203)                                               /* PAL_CPPI_PP_QMGR_G1_Q203 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q204)                                               /* PAL_CPPI_PP_QMGR_G1_Q204 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q205)                                               /* PAL_CPPI_PP_QMGR_G1_Q205 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q206)                                               /* PAL_CPPI_PP_QMGR_G1_Q206 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q207)                                               /* PAL_CPPI_PP_QMGR_G1_Q207 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q208)                                               /* PAL_CPPI_PP_QMGR_G1_Q208 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q209)                                               /* PAL_CPPI_PP_QMGR_G1_Q209 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q210)                                               /* PAL_CPPI_PP_QMGR_G1_Q210 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q211)                                               /* PAL_CPPI_PP_QMGR_G1_Q211 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q212)                                               /* PAL_CPPI_PP_QMGR_G1_Q212 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q213)                                               /* PAL_CPPI_PP_QMGR_G1_Q213 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q214)                                               /* PAL_CPPI_PP_QMGR_G1_Q214 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q215)                                               /* PAL_CPPI_PP_QMGR_G1_Q215 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q216)                                               /* PAL_CPPI_PP_QMGR_G1_Q216 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q217)                                               /* PAL_CPPI_PP_QMGR_G1_Q217 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q218)                                               /* PAL_CPPI_PP_QMGR_G1_Q218 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q219)                                               /* PAL_CPPI_PP_QMGR_G1_Q219 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q220)                                               /* PAL_CPPI_PP_QMGR_G1_Q220 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q221)                                               /* PAL_CPPI_PP_QMGR_G1_Q221 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q222)                                               /* PAL_CPPI_PP_QMGR_G1_Q222 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q223)                                               /* PAL_CPPI_PP_QMGR_G1_Q223 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q224)                                               /* PAL_CPPI_PP_QMGR_G1_Q224 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q225)                                               /* PAL_CPPI_PP_QMGR_G1_Q225 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q226)                                               /* PAL_CPPI_PP_QMGR_G1_Q226 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q227)                                               /* PAL_CPPI_PP_QMGR_G1_Q227 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q228)                                               /* PAL_CPPI_PP_QMGR_G1_Q228 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q229)                                               /* PAL_CPPI_PP_QMGR_G1_Q229 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q230)                                               /* PAL_CPPI_PP_QMGR_G1_Q230 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q231)                                               /* PAL_CPPI_PP_QMGR_G1_Q231 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q232)                                               /* PAL_CPPI_PP_QMGR_G1_Q232 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q233)                                               /* PAL_CPPI_PP_QMGR_G1_Q233 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q234)                                               /* PAL_CPPI_PP_QMGR_G1_Q234 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q235)                                               /* PAL_CPPI_PP_QMGR_G1_Q235 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q236)                                               /* PAL_CPPI_PP_QMGR_G1_Q236 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q237)                                               /* PAL_CPPI_PP_QMGR_G1_Q237 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q238)                                               /* PAL_CPPI_PP_QMGR_G1_Q238 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q239)                                               /* PAL_CPPI_PP_QMGR_G1_Q239 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q240)                                               /* PAL_CPPI_PP_QMGR_G1_Q240 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q241)                                               /* PAL_CPPI_PP_QMGR_G1_Q241 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q242)                                               /* PAL_CPPI_PP_QMGR_G1_Q242 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q243)                                               /* PAL_CPPI_PP_QMGR_G1_Q243 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q244)                                               /* PAL_CPPI_PP_QMGR_G1_Q244 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q245)                                               /* PAL_CPPI_PP_QMGR_G1_Q245 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q246)                                               /* PAL_CPPI_PP_QMGR_G1_Q246 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q247)                                               /* PAL_CPPI_PP_QMGR_G1_Q247 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q248)                                               /* PAL_CPPI_PP_QMGR_G1_Q248 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q249)                                               /* PAL_CPPI_PP_QMGR_G1_Q249 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q250)                                               /* PAL_CPPI_PP_QMGR_G1_Q250 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q251)                                               /* PAL_CPPI_PP_QMGR_G1_Q251 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q252)                                               /* PAL_CPPI_PP_QMGR_G1_Q252 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q253)                                               /* PAL_CPPI_PP_QMGR_G1_Q253 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q254)                                               /* PAL_CPPI_PP_QMGR_G1_Q254 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_Q255)                                               /* PAL_CPPI_PP_QMGR_G1_Q255 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_RECYCLER_LOW_Q_NUM)                                     /* PAL_CPPI_PP_QMGR_G1_Q256 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_RECYCLER_HI_Q_NUM)                                      /* PAL_CPPI_PP_QMGR_G1_Q257 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_MoCA_TX_HI_Q_NUM)                                       /* PAL_CPPI_PP_QMGR_G1_Q258 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_MoCA_TX_LOW_Q_NUM)                                      /* PAL_CPPI_PP_QMGR_G1_Q259 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_ATOM_TX_HI_Q_NUM)                                       /* PAL_CPPI_PP_QMGR_G1_Q260 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_ATOM_TX_LOW_Q_NUM)                                      /* PAL_CPPI_PP_QMGR_G1_Q261 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_MGMT_Q_NUM)                            /* PAL_CPPI_PP_QMGR_G1_Q262 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_VOICE_Q_NUM)                           /* PAL_CPPI_PP_QMGR_G1_Q263 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE0_LOW_Q_NUM)                         /* PAL_CPPI_PP_QMGR_G1_Q264 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE1_LOW_Q_NUM)                         /* PAL_CPPI_PP_QMGR_G1_Q265 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE2_LOW_Q_NUM)                         /* PAL_CPPI_PP_QMGR_G1_Q266 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE3_LOW_Q_NUM)                         /* PAL_CPPI_PP_QMGR_G1_Q267 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE4_LOW_Q_NUM)                         /* PAL_CPPI_PP_QMGR_G1_Q268 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE5_LOW_Q_NUM)                         /* PAL_CPPI_PP_QMGR_G1_Q269 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE6_LOW_Q_NUM)                         /* PAL_CPPI_PP_QMGR_G1_Q270 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE7_LOW_Q_NUM)                         /* PAL_CPPI_PP_QMGR_G1_Q271 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE8_LOW_Q_NUM)                         /* PAL_CPPI_PP_QMGR_G1_Q272 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE9_LOW_Q_NUM)                         /* PAL_CPPI_PP_QMGR_G1_Q273 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE10_LOW_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q274 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE11_LOW_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q275 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE12_LOW_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q276 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE13_LOW_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q277 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE14_LOW_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q278 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE15_LOW_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q279 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE0_HIGH_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q280 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE1_HIGH_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q281 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE2_HIGH_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q282 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE3_HIGH_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q283 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE4_HIGH_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q284 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE5_HIGH_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q285 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE6_HIGH_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q286 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE7_HIGH_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q287 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE8_HIGH_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q288 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE9_HIGH_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G1_Q289 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE10_HIGH_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G1_Q290 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE11_HIGH_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G1_Q291 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE12_HIGH_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G1_Q292 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE13_HIGH_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G1_Q293 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE14_HIGH_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G1_Q294 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE15_HIGH_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G1_Q295 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_Q296)                                                   /* PAL_CPPI_PP_QMGR_G1_Q296 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_Q297)                                                   /* PAL_CPPI_PP_QMGR_G1_Q297 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_Q298)                                                   /* PAL_CPPI_PP_QMGR_G1_Q298 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_Q299)                                                   /* PAL_CPPI_PP_QMGR_G1_Q299 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_Q300)                                                   /* PAL_CPPI_PP_QMGR_G1_Q300 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_Q301)                                                   /* PAL_CPPI_PP_QMGR_G1_Q301 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_Q302)                                                   /* PAL_CPPI_PP_QMGR_G1_Q302 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_Q303)                                                   /* PAL_CPPI_PP_QMGR_G1_Q303 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_Q304)                                                   /* PAL_CPPI_PP_QMGR_G1_Q304 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_Q305)                                                   /* PAL_CPPI_PP_QMGR_G1_Q305 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_Q306)                                                   /* PAL_CPPI_PP_QMGR_G1_Q306 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_Q307)                                                   /* PAL_CPPI_PP_QMGR_G1_Q307 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_Q308)                                                   /* PAL_CPPI_PP_QMGR_G1_Q308 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_FW_MONO_FD_Q_NUM)                                    /* PAL_CPPI_PP_QMGR_G1_Q309 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_DOCSIS_LOW_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G1_Q310 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_DOCSIS_LOW_Q_NUM)                /* PAL_CPPI_PP_QMGR_G1_Q311 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_DOCSIS_HI_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q312 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_DOCSIS_HI_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G1_Q313 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_MoCA_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G1_Q314 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_MoCA_Q_NUM)                      /* PAL_CPPI_PP_QMGR_G1_Q315 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_ATOM_LOW_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q316 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_ATOM_LOW_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q317 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_ATOM_HI_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G1_Q318 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_ATOM_HI_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q319 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_RGMII0_LOW_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G1_Q320 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_RGMII0_LOW_Q_NUM)                /* PAL_CPPI_PP_QMGR_G1_Q321 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_RGMII0_HI_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q322 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_RGMII0_HI_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G1_Q323 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_RGMII1_LOW_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G1_Q324 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_RGMII1_LOW_Q_NUM)                /* PAL_CPPI_PP_QMGR_G1_Q325 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_RGMII1_HI_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q326 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_RGMII1_HI_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G1_Q327 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_SGMII0_LOW_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G1_Q328 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_SGMII0_LOW_Q_NUM)                /* PAL_CPPI_PP_QMGR_G1_Q329 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_SGMII0_HI_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q330 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_SGMII0_HI_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G1_Q331 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_SGMII1_LOW_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G1_Q332 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_SGMII1_LOW_Q_NUM)                /* PAL_CPPI_PP_QMGR_G1_Q333 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_SGMII1_HI_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q334 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_SGMII1_HI_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G1_Q335 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_WiFi_LOW_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q336 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_WiFi_LOW_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q337 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_WiFi_HI_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G1_Q338 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_WiFi_HI_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q339 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_TX_CH_15_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q340 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_TX_CH_15_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q341 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_TX_CH_16_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q342 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_TX_CH_16_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q343 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_VOICE_Q_NUM)                      /* PAL_CPPI_PP_QMGR_G1_Q344 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_VOICE_Q_NUM)                     /* PAL_CPPI_PP_QMGR_G1_Q345 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_NP2APP_Q_NUM)                     /* PAL_CPPI_PP_QMGR_G1_Q346 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_NP2APP_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G1_Q347 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_APP2NP_Q_NUM)                     /* PAL_CPPI_PP_QMGR_G1_Q348 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_APP2NP_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G1_Q349 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_TX_CH_20_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q350 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_TX_CH_20_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q351 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_TX_CH_21_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q352 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_TX_CH_21_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q353 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_TX_CH_22_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q354 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_TX_CH_22_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q355 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_HI_TX_CH_23_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q356 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_TX_CH_23_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q357 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_HOST2PP_LOW_Q_NUM)                /* PAL_CPPI_PP_QMGR_G1_Q358 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_HOST2PP_LOW_Q_NUM)               /* PAL_CPPI_PP_QMGR_G1_Q359 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_HOST2PP_HI_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G1_Q360 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_HOST2PP_HI_Q_NUM)                /* PAL_CPPI_PP_QMGR_G1_Q361 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_2_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G1_Q362 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_2_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q363 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_3_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G1_Q364 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_3_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q365 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_4_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G1_Q366 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_4_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q367 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_5_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G1_Q368 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_5_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q369 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_6_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G1_Q370 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_6_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q371 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_7_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G1_Q372 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_7_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q373 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_8_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G1_Q374 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_8_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q375 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_9_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G1_Q376 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_9_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q377 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_10_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q378 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_10_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q379 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_11_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q380 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_11_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q381 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_12_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q382 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_12_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q383 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_13_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q384 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_13_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q385 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_14_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q386 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_14_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q387 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_15_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q388 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_15_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q389 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_16_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q390 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_16_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q391 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_17_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q392 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_17_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q393 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_18_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q394 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_18_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q395 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_19_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q396 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_19_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q397 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_20_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q398 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_20_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q399 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_21_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q400 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_21_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q401 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_22_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q402 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_22_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q403 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_TX_CH_23_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G1_Q404 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_LOW_TX_CH_23_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G1_Q405 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SGMII0_TX_HI_Q_NUM)                                     /* PAL_CPPI_PP_QMGR_G1_Q406 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SGMII0_TX_LOW_Q_NUM)                                    /* PAL_CPPI_PP_QMGR_G1_Q407 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SGMII1_TX_HI_Q_NUM)                                     /* PAL_CPPI_PP_QMGR_G1_Q408 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SGMII1_TX_LOW_Q_NUM)                                    /* PAL_CPPI_PP_QMGR_G1_Q409 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_RGMII0_TX_HI_Q_NUM)                                     /* PAL_CPPI_PP_QMGR_G1_Q410 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_RGMII0_TX_LOW_Q_NUM)                                    /* PAL_CPPI_PP_QMGR_G1_Q411 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_RGMII1_TX_HI_Q_NUM)                                     /* PAL_CPPI_PP_QMGR_G1_Q412 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_RGMII1_TX_LOW_Q_NUM)                                    /* PAL_CPPI_PP_QMGR_G1_Q413 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_COP_TX_HI_Q_NUM)                                     /* PAL_CPPI_PP_QMGR_G1_Q414 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_US_COP_TX_LOW_Q_NUM)                                    /* PAL_CPPI_PP_QMGR_G1_Q415 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_UNUSED_INPUT_Q0)                                    /* PAL_CPPI_PP_QMGR_G1_Q416 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_UNUSED_INPUT_Q1)                                    /* PAL_CPPI_PP_QMGR_G1_Q417 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_UNUSED_INPUT_Q2)                                    /* PAL_CPPI_PP_QMGR_G1_Q418 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_UNUSED_INPUT_Q3)                                    /* PAL_CPPI_PP_QMGR_G1_Q419 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_UNUSED_INPUT_Q4)                                    /* PAL_CPPI_PP_QMGR_G1_Q420 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_UNUSED_INPUT_Q5)                                    /* PAL_CPPI_PP_QMGR_G1_Q421 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_UNUSED_INPUT_Q6)                                    /* PAL_CPPI_PP_QMGR_G1_Q422 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_QOS_UNUSED_INPUT_Q7)                                    /* PAL_CPPI_PP_QMGR_G1_Q423 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV0_INTERNAL_Q)                                /* PAL_CPPI_PP_QMGR_G1_Q424 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV1_INTERNAL_Q)                                /* PAL_CPPI_PP_QMGR_G1_Q425 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV2_INTERNAL_Q)                                /* PAL_CPPI_PP_QMGR_G1_Q426 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV3_INTERNAL_Q)                                /* PAL_CPPI_PP_QMGR_G1_Q427 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV4_INTERNAL_Q)                                /* PAL_CPPI_PP_QMGR_G1_Q428 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV5_INTERNAL_Q)                                /* PAL_CPPI_PP_QMGR_G1_Q429 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV6_INTERNAL_Q)                                /* PAL_CPPI_PP_QMGR_G1_Q430 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV7_INTERNAL_Q)                                /* PAL_CPPI_PP_QMGR_G1_Q431 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV0_INPUT_Q)                                   /* PAL_CPPI_PP_QMGR_G1_Q432 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV1_INPUT_Q)                                   /* PAL_CPPI_PP_QMGR_G1_Q433 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV2_INPUT_Q)                                   /* PAL_CPPI_PP_QMGR_G1_Q434 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV3_INPUT_Q)                                   /* PAL_CPPI_PP_QMGR_G1_Q435 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV4_INPUT_Q)                                   /* PAL_CPPI_PP_QMGR_G1_Q436 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV5_INPUT_Q)                                   /* PAL_CPPI_PP_QMGR_G1_Q437 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV6_INPUT_Q)                                   /* PAL_CPPI_PP_QMGR_G1_Q438 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV7_INPUT_Q)                                   /* PAL_CPPI_PP_QMGR_G1_Q439 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q0)                                               /* PAL_CPPI_PP_QMGR_G1_Q440 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q1)                                               /* PAL_CPPI_PP_QMGR_G1_Q441 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q2)                                               /* PAL_CPPI_PP_QMGR_G1_Q442 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q3)                                               /* PAL_CPPI_PP_QMGR_G1_Q443 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q4)                                               /* PAL_CPPI_PP_QMGR_G1_Q444 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q5)                                               /* PAL_CPPI_PP_QMGR_G1_Q445 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q6)                                               /* PAL_CPPI_PP_QMGR_G1_Q446 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q7)                                               /* PAL_CPPI_PP_QMGR_G1_Q447 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q8)                                               /* PAL_CPPI_PP_QMGR_G1_Q448 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q9)                                               /* PAL_CPPI_PP_QMGR_G1_Q449 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q10)                                              /* PAL_CPPI_PP_QMGR_G1_Q450 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q11)                                              /* PAL_CPPI_PP_QMGR_G1_Q451 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q12)                                              /* PAL_CPPI_PP_QMGR_G1_Q452 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q13)                                              /* PAL_CPPI_PP_QMGR_G1_Q453 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q14)                                              /* PAL_CPPI_PP_QMGR_G1_Q454 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q15)                                              /* PAL_CPPI_PP_QMGR_G1_Q455 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q16)                                              /* PAL_CPPI_PP_QMGR_G1_Q456 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q17)                                              /* PAL_CPPI_PP_QMGR_G1_Q457 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q18)                                              /* PAL_CPPI_PP_QMGR_G1_Q458 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q19)                                              /* PAL_CPPI_PP_QMGR_G1_Q459 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q20)                                              /* PAL_CPPI_PP_QMGR_G1_Q460 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q21)                                              /* PAL_CPPI_PP_QMGR_G1_Q461 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q22)                                              /* PAL_CPPI_PP_QMGR_G1_Q462 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q23)                                              /* PAL_CPPI_PP_QMGR_G1_Q463 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q24)                                              /* PAL_CPPI_PP_QMGR_G1_Q464 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q25)                                              /* PAL_CPPI_PP_QMGR_G1_Q465 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q26)                                              /* PAL_CPPI_PP_QMGR_G1_Q466 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q27)                                              /* PAL_CPPI_PP_QMGR_G1_Q467 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q28)                                              /* PAL_CPPI_PP_QMGR_G1_Q468 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q29)                                              /* PAL_CPPI_PP_QMGR_G1_Q469 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q30)                                              /* PAL_CPPI_PP_QMGR_G1_Q470 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q31)                                              /* PAL_CPPI_PP_QMGR_G1_Q471 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q32)                                              /* PAL_CPPI_PP_QMGR_G1_Q472 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q33)                                              /* PAL_CPPI_PP_QMGR_G1_Q473 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q34)                                              /* PAL_CPPI_PP_QMGR_G1_Q474 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q35)                                              /* PAL_CPPI_PP_QMGR_G1_Q475 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q36)                                              /* PAL_CPPI_PP_QMGR_G1_Q476 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q37)                                              /* PAL_CPPI_PP_QMGR_G1_Q477 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q38)                                              /* PAL_CPPI_PP_QMGR_G1_Q478 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q39)                                              /* PAL_CPPI_PP_QMGR_G1_Q479 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q40)                                              /* PAL_CPPI_PP_QMGR_G1_Q480 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q41)                                              /* PAL_CPPI_PP_QMGR_G1_Q481 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q42)                                              /* PAL_CPPI_PP_QMGR_G1_Q482 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q43)                                              /* PAL_CPPI_PP_QMGR_G1_Q483 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q44)                                              /* PAL_CPPI_PP_QMGR_G1_Q484 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q45)                                              /* PAL_CPPI_PP_QMGR_G1_Q485 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q46)                                              /* PAL_CPPI_PP_QMGR_G1_Q486 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q47)                                              /* PAL_CPPI_PP_QMGR_G1_Q487 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q48)                                              /* PAL_CPPI_PP_QMGR_G1_Q488 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q49)                                              /* PAL_CPPI_PP_QMGR_G1_Q489 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q50)                                              /* PAL_CPPI_PP_QMGR_G1_Q490 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q51)                                              /* PAL_CPPI_PP_QMGR_G1_Q491 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q52)                                              /* PAL_CPPI_PP_QMGR_G1_Q492 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q53)                                              /* PAL_CPPI_PP_QMGR_G1_Q493 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q54)                                              /* PAL_CPPI_PP_QMGR_G1_Q494 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q55)                                              /* PAL_CPPI_PP_QMGR_G1_Q495 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q56)                                              /* PAL_CPPI_PP_QMGR_G1_Q496 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q57)                                              /* PAL_CPPI_PP_QMGR_G1_Q497 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q58)                                              /* PAL_CPPI_PP_QMGR_G1_Q498 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q59)                                              /* PAL_CPPI_PP_QMGR_G1_Q499 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q60)                                              /* PAL_CPPI_PP_QMGR_G1_Q500 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q61)                                              /* PAL_CPPI_PP_QMGR_G1_Q501 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q62)                                              /* PAL_CPPI_PP_QMGR_G1_Q502 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_SYNCH_Q63)                                              /* PAL_CPPI_PP_QMGR_G1_Q503 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_MoCA_PDSP_Q0)                                           /* PAL_CPPI_PP_QMGR_G1_Q504 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_MoCA_PDSP_Q1)                                           /* PAL_CPPI_PP_QMGR_G1_Q505 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_MoCA_PDSP_Q2)                                           /* PAL_CPPI_PP_QMGR_G1_Q506 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_MoCA_PDSP_Q3)                                           /* PAL_CPPI_PP_QMGR_G1_Q507 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_MoCA_PDSP_Q4)                                           /* PAL_CPPI_PP_QMGR_G1_Q508 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_MoCA_PDSP_Q5)                                           /* PAL_CPPI_PP_QMGR_G1_Q509 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_MoCA_PDSP_Q6)                                           /* PAL_CPPI_PP_QMGR_G1_Q510 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G1_MoCA_PDSP_Q7)                                           /* PAL_CPPI_PP_QMGR_G1_Q511 */
diff --git a/include/linux/avalanche/puma7/puma7_cppi_gqmgr2_q.h b/include/linux/avalanche/puma7/puma7_cppi_gqmgr2_q.h
new file mode 100755
index 0000000..7847c4a
--- /dev/null
+++ b/include/linux/avalanche/puma7/puma7_cppi_gqmgr2_q.h
@@ -0,0 +1,574 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+    Intel Corporation
+    2200 Mission College Blvd.
+    Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#define PAL_CPPI_PP_QMGR_G2_Q_LIST                                                                                        \
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_PREFETCHER_LOW_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q0 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_PREFETCHER_MED_LOW_Q_NUM)                             /* PAL_CPPI_PP_QMGR_G2_Q1 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_PREFETCHER_MED_HI_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G2_Q2 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_PREFETCHER_HI_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q3 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_PREFETCHER_Q4)                                        /* PAL_CPPI_PP_QMGR_G2_Q4 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_PREFETCHER_Q5)                                        /* PAL_CPPI_PP_QMGR_G2_Q5 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_PREFETCHER_Q6)                                        /* PAL_CPPI_PP_QMGR_G2_Q6 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_PREFETCHER_Q7)                                        /* PAL_CPPI_PP_QMGR_G2_Q7 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST2PP_LOW_TX_COMPLETE_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G2_Q8 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST2PP_HI_TX_COMPLETE_Q_NUM)                         /* PAL_CPPI_PP_QMGR_G2_Q9 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_NP2APP_RX_COMPLETE_Q_NUM)                             /* PAL_CPPI_PP_QMGR_G2_Q10 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_APP2NP_RX_COMPLETE_Q_NUM)                             /* PAL_CPPI_PP_QMGR_G2_Q11 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_NP2APP_TX_COMPLETE_Q_NUM)                             /* PAL_CPPI_PP_QMGR_G2_Q12 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_APP2NP_TX_COMPLETE_Q_NUM)                             /* PAL_CPPI_PP_QMGR_G2_Q13 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_VOICE_Q_NUM)                         /* PAL_CPPI_PP_QMGR_G2_Q14 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_FCC_FORWARDING_Q_NUM)                /* PAL_CPPI_PP_QMGR_G2_Q15 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_DOCSIS_MGMT_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G2_Q16 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_DOCSIS_LOW_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G2_Q17 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_DOCSIS_HI_Q_NUM)                     /* PAL_CPPI_PP_QMGR_G2_Q18 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_MoCA_Q_NUM)                          /* PAL_CPPI_PP_QMGR_G2_Q19 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_ATOM_LOW_Q_NUM)                      /* PAL_CPPI_PP_QMGR_G2_Q20 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_ATOM_HI_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G2_Q21 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_RGMII0_LOW_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G2_Q22 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_RGMII0_HI_Q_NUM)                     /* PAL_CPPI_PP_QMGR_G2_Q23 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_RGMII1_LOW_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G2_Q24 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_RGMII1_HI_Q_NUM)                     /* PAL_CPPI_PP_QMGR_G2_Q25 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_SGMII0_LOW_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G2_Q26 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_SGMII0_HI_Q_NUM)                     /* PAL_CPPI_PP_QMGR_G2_Q27 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_SGMII1_LOW_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G2_Q28 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_SGMII1_HI_Q_NUM)                     /* PAL_CPPI_PP_QMGR_G2_Q29 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_WIFI_LOW_Q_NUM)                      /* PAL_CPPI_PP_QMGR_G2_Q30 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_WIFI_HI_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G2_Q31 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q0)                                          /* PAL_CPPI_PP_QMGR_G2_Q32 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q1)                                          /* PAL_CPPI_PP_QMGR_G2_Q33 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q2)                                          /* PAL_CPPI_PP_QMGR_G2_Q34 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q3)                                          /* PAL_CPPI_PP_QMGR_G2_Q35 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q4)                                          /* PAL_CPPI_PP_QMGR_G2_Q36 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q5)                                          /* PAL_CPPI_PP_QMGR_G2_Q37 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q6)                                          /* PAL_CPPI_PP_QMGR_G2_Q38 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q7)                                          /* PAL_CPPI_PP_QMGR_G2_Q39 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q8)                                          /* PAL_CPPI_PP_QMGR_G2_Q40 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q9)                                          /* PAL_CPPI_PP_QMGR_G2_Q41 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q10)                                         /* PAL_CPPI_PP_QMGR_G2_Q42 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q11)                                         /* PAL_CPPI_PP_QMGR_G2_Q43 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q12)                                         /* PAL_CPPI_PP_QMGR_G2_Q44 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q13)                                         /* PAL_CPPI_PP_QMGR_G2_Q45 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q14)                                         /* PAL_CPPI_PP_QMGR_G2_Q46 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DPI_PDSP_Q15)                                         /* PAL_CPPI_PP_QMGR_G2_Q47 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ENCRYPT_PP_IN_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q48 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ENCRYPT_HOST_IN_Q_NUM)                                /* PAL_CPPI_PP_QMGR_G2_Q49 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ENCRYPT_CRYPTO_IN_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G2_Q50 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ENCRYPT_HOST_OUT_Q_NUM)                               /* PAL_CPPI_PP_QMGR_G2_Q51 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DECRYPT_PP_IN_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q52 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DECRYPT_HOST_IN_Q_NUM)                                /* PAL_CPPI_PP_QMGR_G2_Q53 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DECRYPT_CRYPTO_IN_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G2_Q54 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DECRYPT_HOST_OUT_Q_NUM)                               /* PAL_CPPI_PP_QMGR_G2_Q55 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MC_PDSP_Q0)                                           /* PAL_CPPI_PP_QMGR_G2_Q56 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MC_PDSP_Q1)                                           /* PAL_CPPI_PP_QMGR_G2_Q57 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MC_PDSP_Q2)                                           /* PAL_CPPI_PP_QMGR_G2_Q58 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MC_PDSP_Q3)                                           /* PAL_CPPI_PP_QMGR_G2_Q59 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MC_PDSP_Q4)                                           /* PAL_CPPI_PP_QMGR_G2_Q60 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MC_PDSP_Q5)                                           /* PAL_CPPI_PP_QMGR_G2_Q61 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MC_PDSP_Q6)                                           /* PAL_CPPI_PP_QMGR_G2_Q62 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MC_PDSP_Q7)                                           /* PAL_CPPI_PP_QMGR_G2_Q63 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_PHY_Q_NUM)                                            /* PAL_CPPI_PP_QMGR_G2_Q64 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_WIFI_DEVICE0_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G2_Q65 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_WIFI_DEVICE1_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G2_Q65 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_WIFI_DEVICE2_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G2_Q65 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_WIFI_DEVICE3_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G2_Q65 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q69)                                                  /* PAL_CPPI_PP_QMGR_G2_Q69 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q70)                                                  /* PAL_CPPI_PP_QMGR_G2_Q70 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q71)                                                  /* PAL_CPPI_PP_QMGR_G2_Q71 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q72)                                                  /* PAL_CPPI_PP_QMGR_G2_Q72 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q73)                                                  /* PAL_CPPI_PP_QMGR_G2_Q73 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q74)                                                  /* PAL_CPPI_PP_QMGR_G2_Q74 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q75)                                                  /* PAL_CPPI_PP_QMGR_G2_Q75 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q76)                                                  /* PAL_CPPI_PP_QMGR_G2_Q76 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q77)                                                  /* PAL_CPPI_PP_QMGR_G2_Q77 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q78)                                                  /* PAL_CPPI_PP_QMGR_G2_Q78 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q79)                                                  /* PAL_CPPI_PP_QMGR_G2_Q79 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q80)                                                  /* PAL_CPPI_PP_QMGR_G2_Q80 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q81)                                                  /* PAL_CPPI_PP_QMGR_G2_Q81 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q82)                                                  /* PAL_CPPI_PP_QMGR_G2_Q82 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q83)                                                  /* PAL_CPPI_PP_QMGR_G2_Q83 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q84)                                                  /* PAL_CPPI_PP_QMGR_G2_Q84 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q85)                                                  /* PAL_CPPI_PP_QMGR_G2_Q85 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q86)                                                  /* PAL_CPPI_PP_QMGR_G2_Q86 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q87)                                                  /* PAL_CPPI_PP_QMGR_G2_Q87 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q88)                                                  /* PAL_CPPI_PP_QMGR_G2_Q88 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q89)                                                  /* PAL_CPPI_PP_QMGR_G2_Q89 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q90)                                                  /* PAL_CPPI_PP_QMGR_G2_Q90 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q91)                                                  /* PAL_CPPI_PP_QMGR_G2_Q91 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q92)                                                  /* PAL_CPPI_PP_QMGR_G2_Q92 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q93)                                                  /* PAL_CPPI_PP_QMGR_G2_Q93 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q94)                                                  /* PAL_CPPI_PP_QMGR_G2_Q94 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q95)                                                  /* PAL_CPPI_PP_QMGR_G2_Q95 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q96)                                                  /* PAL_CPPI_PP_QMGR_G2_Q96 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q97)                                                  /* PAL_CPPI_PP_QMGR_G2_Q97 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SEQUENCER_LOW_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q98 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SEQUENCER_MED_LOW_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G2_Q99 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SEQUENCER_MED_HI_Q_NUM)                               /* PAL_CPPI_PP_QMGR_G2_Q100 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SEQUENCER_HI_Q_NUM)                                   /* PAL_CPPI_PP_QMGR_G2_Q101 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SEQUENCER_CYCLE2_LOW_Q_NUM)                           /* PAL_CPPI_PP_QMGR_G2_Q102 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SEQUENCER_CYCLE2_MED_LOW_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G2_Q103 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SEQUENCER_CYCLE2_MED_HI_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G2_Q104 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SEQUENCER_CYCLE2_HI_Q_NUM)                            /* PAL_CPPI_PP_QMGR_G2_Q105 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_ENCRYPT_IN_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G2_Q106 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_DECRYPT_IN_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G2_Q107 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_AES_Q_NUM)                                     /* PAL_CPPI_PP_QMGR_G2_Q108 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_HCU_Q_NUM)                                     /* PAL_CPPI_PP_QMGR_G2_Q109 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_PDSP_Q4)                                       /* PAL_CPPI_PP_QMGR_G2_Q110 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_PDSP_Q5)                                       /* PAL_CPPI_PP_QMGR_G2_Q111 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_PDSP_Q6)                                       /* PAL_CPPI_PP_QMGR_G2_Q112 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CRYPTO_PDSP_Q7)                                       /* PAL_CPPI_PP_QMGR_G2_Q113 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_0_HI_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q114 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_0_LOW_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q115 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_1_HI_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q116 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_1_LOW_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q117 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_2_HI_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q118 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_2_LOW_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q119 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_3_HI_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q120 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_3_LOW_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q121 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_4_HI_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q122 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_4_LOW_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q123 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_5_HI_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q124 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_5_LOW_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q125 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_6_HI_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q126 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_6_LOW_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q127 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_7_HI_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q128 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_7_LOW_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q129 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_8_HI_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q130 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_8_LOW_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q131 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_9_HI_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q132 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_9_LOW_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q133 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_10_HI_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q134 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_10_LOW_Q_NUM)             /* PAL_CPPI_PP_QMGR_G2_Q135 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_11_HI_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q136 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_11_LOW_Q_NUM)             /* PAL_CPPI_PP_QMGR_G2_Q137 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_12_HI_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q138 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_12_LOW_Q_NUM)             /* PAL_CPPI_PP_QMGR_G2_Q139 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_13_HI_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q140 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_13_LOW_Q_NUM)             /* PAL_CPPI_PP_QMGR_G2_Q141 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_14_HI_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q142 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_14_LOW_Q_NUM)             /* PAL_CPPI_PP_QMGR_G2_Q143 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_15_HI_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q144 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_15_LOW_Q_NUM)             /* PAL_CPPI_PP_QMGR_G2_Q145 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_16_HI_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q146 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_16_LOW_Q_NUM)             /* PAL_CPPI_PP_QMGR_G2_Q147 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_17_HI_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q148 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_17_LOW_Q_NUM)             /* PAL_CPPI_PP_QMGR_G2_Q149 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_18_HI_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q150 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_18_LOW_Q_NUM)             /* PAL_CPPI_PP_QMGR_G2_Q151 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_19_HI_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q152 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_19_LOW_Q_NUM)             /* PAL_CPPI_PP_QMGR_G2_Q153 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_20_HI_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q154 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_20_LOW_Q_NUM)             /* PAL_CPPI_PP_QMGR_G2_Q155 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_21_HI_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q156 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_21_LOW_Q_NUM)             /* PAL_CPPI_PP_QMGR_G2_Q157 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_22_HI_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q158 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_22_LOW_Q_NUM)             /* PAL_CPPI_PP_QMGR_G2_Q159 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_23_HI_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q160 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA9_INFRA_INPUT_LOW_TX_CH_23_LOW_Q_NUM)             /* PAL_CPPI_PP_QMGR_G2_Q161 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_TurboDOX_LOW_Q_NUM)                                   /* PAL_CPPI_PP_QMGR_G2_Q162 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_TurboDOX_MED_LOW_Q_NUM)                               /* PAL_CPPI_PP_QMGR_G2_Q163 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_TurboDOX_MED_HI_Q_NUM)                                /* PAL_CPPI_PP_QMGR_G2_Q164 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_TurboDOX_HI_Q_NUM)                                    /* PAL_CPPI_PP_QMGR_G2_Q165 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST2PP_RESEQUENCER_INPUT_Q0)                         /* PAL_CPPI_PP_QMGR_G2_Q166 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST2PP_RESEQUENCER_INPUT_Q1)                         /* PAL_CPPI_PP_QMGR_G2_Q167 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST2PP_RESEQUENCER_INPUT_Q2)                         /* PAL_CPPI_PP_QMGR_G2_Q168 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST2PP_RESEQUENCER_INPUT_Q3)                         /* PAL_CPPI_PP_QMGR_G2_Q169 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST2PP_RESEQUENCER_INPUT_Q4)                         /* PAL_CPPI_PP_QMGR_G2_Q170 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST2PP_RESEQUENCER_INPUT_Q5)                         /* PAL_CPPI_PP_QMGR_G2_Q171 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST2PP_RESEQUENCER_INPUT_Q6)                         /* PAL_CPPI_PP_QMGR_G2_Q172 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST2PP_RESEQUENCER_INPUT_Q7)                         /* PAL_CPPI_PP_QMGR_G2_Q173 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q0)                                         /* PAL_CPPI_PP_QMGR_G2_Q174 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q1)                                         /* PAL_CPPI_PP_QMGR_G2_Q175 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q2)                                         /* PAL_CPPI_PP_QMGR_G2_Q176 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q3)                                         /* PAL_CPPI_PP_QMGR_G2_Q177 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q4)                                         /* PAL_CPPI_PP_QMGR_G2_Q178 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q5)                                         /* PAL_CPPI_PP_QMGR_G2_Q179 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q6)                                         /* PAL_CPPI_PP_QMGR_G2_Q180 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q7)                                         /* PAL_CPPI_PP_QMGR_G2_Q181 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q8)                                         /* PAL_CPPI_PP_QMGR_G2_Q182 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q9)                                         /* PAL_CPPI_PP_QMGR_G2_Q183 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q10)                                        /* PAL_CPPI_PP_QMGR_G2_Q184 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q11)                                        /* PAL_CPPI_PP_QMGR_G2_Q185 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q12)                                        /* PAL_CPPI_PP_QMGR_G2_Q186 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q13)                                        /* PAL_CPPI_PP_QMGR_G2_Q187 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q14)                                        /* PAL_CPPI_PP_QMGR_G2_Q188 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q15)                                        /* PAL_CPPI_PP_QMGR_G2_Q189 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q16)                                        /* PAL_CPPI_PP_QMGR_G2_Q190 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q17)                                        /* PAL_CPPI_PP_QMGR_G2_Q191 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q18)                                        /* PAL_CPPI_PP_QMGR_G2_Q192 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q19)                                        /* PAL_CPPI_PP_QMGR_G2_Q193 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q20)                                        /* PAL_CPPI_PP_QMGR_G2_Q194 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q21)                                        /* PAL_CPPI_PP_QMGR_G2_Q195 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q22)                                        /* PAL_CPPI_PP_QMGR_G2_Q196 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q23)                                        /* PAL_CPPI_PP_QMGR_G2_Q197 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q24)                                        /* PAL_CPPI_PP_QMGR_G2_Q198 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q25)                                        /* PAL_CPPI_PP_QMGR_G2_Q199 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q26)                                        /* PAL_CPPI_PP_QMGR_G2_Q200 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q27)                                        /* PAL_CPPI_PP_QMGR_G2_Q201 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q28)                                        /* PAL_CPPI_PP_QMGR_G2_Q202 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q29)                                        /* PAL_CPPI_PP_QMGR_G2_Q203 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q30)                                        /* PAL_CPPI_PP_QMGR_G2_Q204 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC0_PDSP_Q31)                                        /* PAL_CPPI_PP_QMGR_G2_Q205 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE0_LOW_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q206 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE0_HI_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q207 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE1_LOW_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q208 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE1_HI_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q209 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE2_LOW_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q210 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE2_HI_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q211 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE3_LOW_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q212 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE3_HI_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q213 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE4_LOW_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q214 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE4_HI_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q215 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE5_LOW_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q216 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE5_HI_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q217 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE6_LOW_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q218 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE6_HI_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q219 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE7_LOW_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q220 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE7_HI_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q221 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE8_LOW_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q222 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE8_HI_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q223 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE9_LOW_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q224 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE9_HI_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q225 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE10_LOW_Q_NUM)                                /* PAL_CPPI_PP_QMGR_G2_Q226 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE10_HI_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q227 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE11_LOW_Q_NUM)                                /* PAL_CPPI_PP_QMGR_G2_Q228 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE11_HI_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q229 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE12_LOW_Q_NUM)                                /* PAL_CPPI_PP_QMGR_G2_Q230 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE12_HI_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q231 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE13_LOW_Q_NUM)                                /* PAL_CPPI_PP_QMGR_G2_Q232 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE13_HI_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q233 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE14_LOW_Q_NUM)                                /* PAL_CPPI_PP_QMGR_G2_Q234 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE14_HI_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q235 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE15_LOW_Q_NUM)                                /* PAL_CPPI_PP_QMGR_G2_Q236 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_US_BE15_HI_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q237 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q32)                                         /* PAL_CPPI_PP_QMGR_G2_Q238 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q33)                                         /* PAL_CPPI_PP_QMGR_G2_Q239 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q34)                                         /* PAL_CPPI_PP_QMGR_G2_Q240 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q35)                                         /* PAL_CPPI_PP_QMGR_G2_Q241 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q36)                                         /* PAL_CPPI_PP_QMGR_G2_Q242 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q37)                                         /* PAL_CPPI_PP_QMGR_G2_Q243 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q38)                                         /* PAL_CPPI_PP_QMGR_G2_Q244 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q39)                                         /* PAL_CPPI_PP_QMGR_G2_Q245 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q40)                                         /* PAL_CPPI_PP_QMGR_G2_Q246 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q41)                                         /* PAL_CPPI_PP_QMGR_G2_Q247 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q42)                                         /* PAL_CPPI_PP_QMGR_G2_Q248 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q43)                                         /* PAL_CPPI_PP_QMGR_G2_Q249 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q44)                                         /* PAL_CPPI_PP_QMGR_G2_Q250 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q45)                                         /* PAL_CPPI_PP_QMGR_G2_Q251 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q46)                                         /* PAL_CPPI_PP_QMGR_G2_Q252 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q47)                                         /* PAL_CPPI_PP_QMGR_G2_Q253 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q48)                                         /* PAL_CPPI_PP_QMGR_G2_Q254 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q49)                                         /* PAL_CPPI_PP_QMGR_G2_Q255 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q50)                                         /* PAL_CPPI_PP_QMGR_G2_Q256 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q51)                                         /* PAL_CPPI_PP_QMGR_G2_Q257 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q52)                                         /* PAL_CPPI_PP_QMGR_G2_Q258 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q53)                                         /* PAL_CPPI_PP_QMGR_G2_Q259 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q54)                                         /* PAL_CPPI_PP_QMGR_G2_Q260 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q55)                                         /* PAL_CPPI_PP_QMGR_G2_Q261 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q56)                                         /* PAL_CPPI_PP_QMGR_G2_Q262 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q57)                                         /* PAL_CPPI_PP_QMGR_G2_Q263 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q58)                                         /* PAL_CPPI_PP_QMGR_G2_Q264 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q59)                                         /* PAL_CPPI_PP_QMGR_G2_Q265 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q60)                                         /* PAL_CPPI_PP_QMGR_G2_Q266 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q61)                                         /* PAL_CPPI_PP_QMGR_G2_Q267 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q62)                                         /* PAL_CPPI_PP_QMGR_G2_Q268 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_AQM_PDSP_Q63)                                         /* PAL_CPPI_PP_QMGR_G2_Q269 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_VOICE_DSP_TX_QNUM)                                    /* PAL_CPPI_PP_QMGR_G2_Q270 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_VOICE_DSP_Q1)                                         /* PAL_CPPI_PP_QMGR_G2_Q271 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_VOICE_DSP_Q2)                                         /* PAL_CPPI_PP_QMGR_G2_Q272 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_VOICE_DSP_Q3)                                         /* PAL_CPPI_PP_QMGR_G2_Q273 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q274)                                                 /* PAL_CPPI_PP_QMGR_G2_Q274 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q275)                                                 /* PAL_CPPI_PP_QMGR_G2_Q275 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q276)                                                 /* PAL_CPPI_PP_QMGR_G2_Q276 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q277)                                                 /* PAL_CPPI_PP_QMGR_G2_Q277 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q278)                                                 /* PAL_CPPI_PP_QMGR_G2_Q278 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q279)                                                 /* PAL_CPPI_PP_QMGR_G2_Q279 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q280)                                                 /* PAL_CPPI_PP_QMGR_G2_Q280 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q281)                                                 /* PAL_CPPI_PP_QMGR_G2_Q281 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q282)                                                 /* PAL_CPPI_PP_QMGR_G2_Q282 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q283)                                                 /* PAL_CPPI_PP_QMGR_G2_Q283 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q284)                                                 /* PAL_CPPI_PP_QMGR_G2_Q284 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q285)                                                 /* PAL_CPPI_PP_QMGR_G2_Q285 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q286)                                                 /* PAL_CPPI_PP_QMGR_G2_Q286 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q287)                                                 /* PAL_CPPI_PP_QMGR_G2_Q287 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q288)                                                 /* PAL_CPPI_PP_QMGR_G2_Q288 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q289)                                                 /* PAL_CPPI_PP_QMGR_G2_Q289 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q290)                                                 /* PAL_CPPI_PP_QMGR_G2_Q290 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q291)                                                 /* PAL_CPPI_PP_QMGR_G2_Q291 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q292)                                                 /* PAL_CPPI_PP_QMGR_G2_Q292 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_RECYCLER_LOW_Q_NUM)                                   /* PAL_CPPI_PP_QMGR_G2_Q293 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_RECYCLER_HI_Q_NUM)                                    /* PAL_CPPI_PP_QMGR_G2_Q294 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_TX_Q0)                                            /* PAL_CPPI_PP_QMGR_G2_Q295 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_UNUSED_Q0)                                        /* PAL_CPPI_PP_QMGR_G2_Q296 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_TX_Q1)                                            /* PAL_CPPI_PP_QMGR_G2_Q297 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_UNUSED_Q1)                                        /* PAL_CPPI_PP_QMGR_G2_Q298 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_TX_Q2)                                            /* PAL_CPPI_PP_QMGR_G2_Q299 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_UNUSED_Q2)                                        /* PAL_CPPI_PP_QMGR_G2_Q300 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_TX_Q3)                                            /* PAL_CPPI_PP_QMGR_G2_Q301 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_UNUSED_Q3)                                        /* PAL_CPPI_PP_QMGR_G2_Q302 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_TX_Q4)                                            /* PAL_CPPI_PP_QMGR_G2_Q303 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_UNUSED_Q4)                                        /* PAL_CPPI_PP_QMGR_G2_Q304 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_TX_Q5)                                            /* PAL_CPPI_PP_QMGR_G2_Q305 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_UNUSED_Q5)                                        /* PAL_CPPI_PP_QMGR_G2_Q306 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_TX_Q6)                                            /* PAL_CPPI_PP_QMGR_G2_Q307 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_UNUSED_Q6)                                        /* PAL_CPPI_PP_QMGR_G2_Q308 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_TX_Q7)                                            /* PAL_CPPI_PP_QMGR_G2_Q309 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_UNUSED_Q7)                                        /* PAL_CPPI_PP_QMGR_G2_Q310 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q311)                                                 /* PAL_CPPI_PP_QMGR_G2_Q311 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q312)                                                 /* PAL_CPPI_PP_QMGR_G2_Q312 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q313)                                                 /* PAL_CPPI_PP_QMGR_G2_Q313 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q314)                                                 /* PAL_CPPI_PP_QMGR_G2_Q314 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q315)                                                 /* PAL_CPPI_PP_QMGR_G2_Q315 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q316)                                                 /* PAL_CPPI_PP_QMGR_G2_Q316 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q317)                                                 /* PAL_CPPI_PP_QMGR_G2_Q317 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q318)                                                 /* PAL_CPPI_PP_QMGR_G2_Q318 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q319)                                                 /* PAL_CPPI_PP_QMGR_G2_Q319 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q320)                                                 /* PAL_CPPI_PP_QMGR_G2_Q320 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q321)                                                 /* PAL_CPPI_PP_QMGR_G2_Q321 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q322)                                                 /* PAL_CPPI_PP_QMGR_G2_Q322 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q323)                                                 /* PAL_CPPI_PP_QMGR_G2_Q323 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q324)                                                 /* PAL_CPPI_PP_QMGR_G2_Q324 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q325)                                                 /* PAL_CPPI_PP_QMGR_G2_Q325 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q326)                                                 /* PAL_CPPI_PP_QMGR_G2_Q326 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE0_HOST_RX_HI_Q_NUM)      /* PAL_CPPI_PP_QMGR_G2_Q327 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE0_HOST_RX_LOW_Q_NUM)     /* PAL_CPPI_PP_QMGR_G2_Q328 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE1_HOST_RX_HI_Q_NUM)      /* PAL_CPPI_PP_QMGR_G2_Q329 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE1_HOST_RX_LOW_Q_NUM)     /* PAL_CPPI_PP_QMGR_G2_Q330 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE2_HOST_RX_HI_Q_NUM)      /* PAL_CPPI_PP_QMGR_G2_Q331 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE2_HOST_RX_LOW_Q_NUM)     /* PAL_CPPI_PP_QMGR_G2_Q332 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE3_HOST_RX_Hi_Q_NUM)      /* PAL_CPPI_PP_QMGR_G2_Q333 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE3_HOST_RX_LOW_Q_NUM)     /* PAL_CPPI_PP_QMGR_G2_Q334 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE0_TX_FW_HI_Q_NUM)        /* PAL_CPPI_PP_QMGR_G2_Q335 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE0_TX_FW_LOW_Q_NUM)       /* PAL_CPPI_PP_QMGR_G2_Q336 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE1_TX_FW_HI_Q_NUM)        /* PAL_CPPI_PP_QMGR_G2_Q337 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE1_TX_FW_LOW_Q_NUM)       /* PAL_CPPI_PP_QMGR_G2_Q338 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE2_TX_FW_HI_Q_NUM)        /* PAL_CPPI_PP_QMGR_G2_Q339 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE2_TX_FW_LOWQ_NUM)        /* PAL_CPPI_PP_QMGR_G2_Q340 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE3_TX_FW_HI_Q_NUM)        /* PAL_CPPI_PP_QMGR_G2_Q341 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE3_TX_FW_LOWQ_NUM)        /* PAL_CPPI_PP_QMGR_G2_Q342 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q343)                                                 /* PAL_CPPI_PP_QMGR_G2_Q343 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_PP_EVENTS_Q0)                                         /* PAL_CPPI_PP_QMGR_G2_Q344 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_PP_EVENTS_Q1)                                         /* PAL_CPPI_PP_QMGR_G2_Q345 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_PP_EVENTS_Q2)                                         /* PAL_CPPI_PP_QMGR_G2_Q346 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_PP_EVENTS_Q3)                                         /* PAL_CPPI_PP_QMGR_G2_Q347 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q0)                                   /* PAL_CPPI_PP_QMGR_G2_Q348 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q1)                                   /* PAL_CPPI_PP_QMGR_G2_Q349 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q2)                                   /* PAL_CPPI_PP_QMGR_G2_Q350 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q3)                                   /* PAL_CPPI_PP_QMGR_G2_Q351 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q4)                                   /* PAL_CPPI_PP_QMGR_G2_Q352 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q5)                                   /* PAL_CPPI_PP_QMGR_G2_Q353 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q6)                                   /* PAL_CPPI_PP_QMGR_G2_Q354 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q7)                                   /* PAL_CPPI_PP_QMGR_G2_Q355 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q8)                                   /* PAL_CPPI_PP_QMGR_G2_Q356 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q9)                                   /* PAL_CPPI_PP_QMGR_G2_Q357 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q10)                                  /* PAL_CPPI_PP_QMGR_G2_Q358 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q11)                                  /* PAL_CPPI_PP_QMGR_G2_Q359 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q12)                                  /* PAL_CPPI_PP_QMGR_G2_Q360 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q13)                                  /* PAL_CPPI_PP_QMGR_G2_Q361 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q14)                                  /* PAL_CPPI_PP_QMGR_G2_Q362 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q15)                                  /* PAL_CPPI_PP_QMGR_G2_Q363 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q16)                                  /* PAL_CPPI_PP_QMGR_G2_Q364 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q17)                                  /* PAL_CPPI_PP_QMGR_G2_Q365 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q18)                                  /* PAL_CPPI_PP_QMGR_G2_Q366 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q19)                                  /* PAL_CPPI_PP_QMGR_G2_Q367 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q20)                                  /* PAL_CPPI_PP_QMGR_G2_Q368 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q21)                                  /* PAL_CPPI_PP_QMGR_G2_Q369 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q22)                                  /* PAL_CPPI_PP_QMGR_G2_Q370 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q23)                                  /* PAL_CPPI_PP_QMGR_G2_Q371 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q24)                                  /* PAL_CPPI_PP_QMGR_G2_Q372 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q25)                                  /* PAL_CPPI_PP_QMGR_G2_Q373 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q26)                                  /* PAL_CPPI_PP_QMGR_G2_Q374 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q27)                                  /* PAL_CPPI_PP_QMGR_G2_Q375 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q28)                                  /* PAL_CPPI_PP_QMGR_G2_Q376 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q29)                                  /* PAL_CPPI_PP_QMGR_G2_Q377 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q30)                                  /* PAL_CPPI_PP_QMGR_G2_Q378 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q31)                                  /* PAL_CPPI_PP_QMGR_G2_Q379 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q32)                                  /* PAL_CPPI_PP_QMGR_G2_Q380 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q33)                                  /* PAL_CPPI_PP_QMGR_G2_Q381 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q34)                                  /* PAL_CPPI_PP_QMGR_G2_Q382 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q35)                                  /* PAL_CPPI_PP_QMGR_G2_Q383 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q36)                                  /* PAL_CPPI_PP_QMGR_G2_Q384 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q37)                                  /* PAL_CPPI_PP_QMGR_G2_Q385 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q38)                                  /* PAL_CPPI_PP_QMGR_G2_Q386 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q39)                                  /* PAL_CPPI_PP_QMGR_G2_Q387 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q40)                                  /* PAL_CPPI_PP_QMGR_G2_Q388 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q41)                                  /* PAL_CPPI_PP_QMGR_G2_Q389 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q42)                                  /* PAL_CPPI_PP_QMGR_G2_Q390 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q43)                                  /* PAL_CPPI_PP_QMGR_G2_Q391 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q44)                                  /* PAL_CPPI_PP_QMGR_G2_Q392 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q45)                                  /* PAL_CPPI_PP_QMGR_G2_Q393 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q46)                                  /* PAL_CPPI_PP_QMGR_G2_Q394 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q47)                                  /* PAL_CPPI_PP_QMGR_G2_Q395 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q48)                                  /* PAL_CPPI_PP_QMGR_G2_Q396 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q49)                                  /* PAL_CPPI_PP_QMGR_G2_Q397 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q50)                                  /* PAL_CPPI_PP_QMGR_G2_Q398 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q51)                                  /* PAL_CPPI_PP_QMGR_G2_Q399 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q52)                                  /* PAL_CPPI_PP_QMGR_G2_Q400 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q53)                                  /* PAL_CPPI_PP_QMGR_G2_Q401 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q54)                                  /* PAL_CPPI_PP_QMGR_G2_Q402 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q55)                                  /* PAL_CPPI_PP_QMGR_G2_Q403 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q56)                                  /* PAL_CPPI_PP_QMGR_G2_Q404 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q57)                                  /* PAL_CPPI_PP_QMGR_G2_Q405 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q58)                                  /* PAL_CPPI_PP_QMGR_G2_Q406 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q59)                                  /* PAL_CPPI_PP_QMGR_G2_Q407 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q60)                                  /* PAL_CPPI_PP_QMGR_G2_Q408 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q61)                                  /* PAL_CPPI_PP_QMGR_G2_Q409 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q62)                                  /* PAL_CPPI_PP_QMGR_G2_Q410 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MULTICAST_CACHE_Q63)                                  /* PAL_CPPI_PP_QMGR_G2_Q411 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q412)                                                 /* PAL_CPPI_PP_QMGR_G2_Q412 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q413)                                                 /* PAL_CPPI_PP_QMGR_G2_Q413 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q414)                                                 /* PAL_CPPI_PP_QMGR_G2_Q414 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q415)                                                 /* PAL_CPPI_PP_QMGR_G2_Q415 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q416)                                                 /* PAL_CPPI_PP_QMGR_G2_Q416 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q417)                                                 /* PAL_CPPI_PP_QMGR_G2_Q417 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q418)                                                 /* PAL_CPPI_PP_QMGR_G2_Q418 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q419)                                                 /* PAL_CPPI_PP_QMGR_G2_Q419 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_IPSEC_MONOLITHIC_FD_Q_NUM)                            /* PAL_CPPI_PP_QMGR_G2_Q420 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_IPSEC_HOST_FD_Q_NUM)                                  /* PAL_CPPI_PP_QMGR_G2_Q421 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_FCC_STREAMING_FD_Q_NUM)                               /* PAL_CPPI_PP_QMGR_G2_Q422 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DOCSIS_LOW_INFRA_HOST_FD_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G2_Q423 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DOCSIS_HI_INFRA_HOST_FD_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G2_Q424 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SHARED_LOW_INFRA_HOST_FD_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G2_Q425 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ATOM_HI_INFRA_HOST_FD_Q_NUM)                          /* PAL_CPPI_PP_QMGR_G2_Q426 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_RGMII0_HI_INFRA_HOST_FD_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G2_Q427 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_RGMII1_HI_INFRA_HOST_FD_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G2_Q428 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SGMII0_HI_INFRA_HOST_FD_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G2_Q429 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SGMII1_HI_INFRA_HOST_FD_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G2_Q430 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_WIFI_INFRA_HOST_RX_FD_Q_NUM)                          /* PAL_CPPI_PP_QMGR_G2_Q431 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_NP2APP_HOST_FD_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q432 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_NP2APP_INFRA_PPINFO_HOST_FD_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G2_Q433 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_NP2APP_INFRA_DATA_HOST_FD_Q_NUM)                      /* PAL_CPPI_PP_QMGR_G2_Q434 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_APP2NP_HOST_FD_Q_NUM)                                 /* PAL_CPPI_PP_QMGR_G2_Q435 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_APP2NP_INFRA_PPINFO_HOST_FD_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G2_Q436 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_APP2NP_INFRA_DATA_HOST_FD_Q_NUM)                      /* PAL_CPPI_PP_QMGR_G2_Q437 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_FD_Q15)                                          /* PAL_CPPI_PP_QMGR_G2_Q438 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_FD_Q16)                                          /* PAL_CPPI_PP_QMGR_G2_Q439 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_FD_Q17)                                          /* PAL_CPPI_PP_QMGR_G2_Q440 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_FD_Q18)                                          /* PAL_CPPI_PP_QMGR_G2_Q441 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DOCSIS_TX_MGMT_HOST_FD_Q_NUM)                         /* PAL_CPPI_PP_QMGR_G2_Q442 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST2PP_LOW_HOST_FD_Q_NUM)                            /* PAL_CPPI_PP_QMGR_G2_Q443 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST2PP_HI_HOST_FD_Q_NUM)                             /* PAL_CPPI_PP_QMGR_G2_Q444 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_FD_Q22)                                          /* PAL_CPPI_PP_QMGR_G2_Q445 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST_FD_Q23)                                          /* PAL_CPPI_PP_QMGR_G2_Q446 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SHARED_PACKET_RAM_SHORT_RX_LOW_EMB_FD_Q_NUM)          /* PAL_CPPI_PP_QMGR_G2_Q447 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SHARED_PACKET_RAM_LONG_RX_LOW_EMB_FD_Q_NUM)           /* PAL_CPPI_PP_QMGR_G2_Q448 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SHARED_DDR_SHORT_RX_LOW)                              /* PAL_CPPI_PP_QMGR_G2_Q449 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SHARED_DDR_LONG_RX_LOW)                               /* PAL_CPPI_PP_QMGR_G2_Q450 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SHARED_DDR_XLONG_RX_LOW)                              /* PAL_CPPI_PP_QMGR_G2_Q451 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DOCSIS_DESC_PACKET_RAM_BUFF_DDR_RX_LOW_EMB_FD_Q_NUM)  /* PAL_CPPI_PP_QMGR_G2_Q452 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DOCSIS_PACKET_RAM_SHORT_RX_LOW_EMB_FD_Q_NUM)          /* PAL_CPPI_PP_QMGR_G2_Q453 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DOCSIS_PACKET_RAM_LONG_RX_LOW_EMB_FD_Q_NUM)           /* PAL_CPPI_PP_QMGR_G2_Q454 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DOCSIS_RX_HI_EMB_FD_Q_NUM)                            /* PAL_CPPI_PP_QMGR_G2_Q455 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_DOCSIS_RX_MGMT_HOST_FD_Q_NUM)                         /* PAL_CPPI_PP_QMGR_G2_Q456 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MoCA_PACKET_RAM_SHORT_RX_EMB_FD_Q_NUM)                /* PAL_CPPI_PP_QMGR_G2_Q457 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MoCA_PACKET_RAM_LONG_RX_EMB_FD_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G2_Q458 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MoCA_DDR_SHORT_RX_EMB_FD_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G2_Q459 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_MoCA_DDR_LONG_RX_EMB_FD_Q_NUM)                        /* PAL_CPPI_PP_QMGR_G2_Q460 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ATOM_PACKET_RAM_SHORT_RX_EMB_FD_Q_NUM)                /* PAL_CPPI_PP_QMGR_G2_Q461 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ATOM_PACKET_RAM_LONG_RX_EMB_FD_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G2_Q462 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ATOM_DDR_SHORT_RX_EMB_FD_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G2_Q463 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ATOM_DDR_LONG_RX_LOW_EMB_FD_Q_NUM)                    /* PAL_CPPI_PP_QMGR_G2_Q464 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_ATOM_DDR_LONG_RX_HIGH_EMB_FD_Q_NUM)                   /* PAL_CPPI_PP_QMGR_G2_Q465 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_RGMII0_PACKET_RAM_SHORT_RX_EMB_FD_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q466 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_RGMII0_PACKET_RAM_LONG_RX_EMB_FD_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q467 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_RGMII0_DDR_SHORT_RX_EMB_FD_Q_NUM)                     /* PAL_CPPI_PP_QMGR_G2_Q468 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_RGMII0_DDR_LONG_RX_LOW_EMB_FD_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G2_Q469 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_RGMII0_DDR_LONG_RX_HIGH_EMB_FD_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G2_Q470 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_RGMII1_PACKET_RAM_SHORT_RX_EMB_FD_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q471 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_RGMII1_PACKET_RAM_LONG_RX_EMB_FD_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q472 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_RGMII1_DDR_SHORT_RX_EMB_FD_Q_NUM)                     /* PAL_CPPI_PP_QMGR_G2_Q473 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_RGMII1_DDR_LONG_RX_LOW_EMB_FD_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G2_Q474 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_RGMII1_DDR_LONG_RX_HIGH_EMB_FD_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G2_Q475 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SGMII0_PACKET_RAM_SHORT_RX_EMB_FD_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q476 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SGMII0_PACKET_RAM_LONG_RX_EMB_FD_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q477 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SGMII0_DDR_SHORT_RX_EMB_FD_Q_NUM)                     /* PAL_CPPI_PP_QMGR_G2_Q478 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SGMII0_DDR_LONG_RX_LOW_EMB_FD_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G2_Q479 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SGMII0_DDR_LONG_RX_HIGH_EMB_FD_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G2_Q480 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SGMII1_PACKET_RAM_SHORT_RX_EMB_FD_Q_NUM)              /* PAL_CPPI_PP_QMGR_G2_Q481 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SGMII1_PACKET_RAM_LONG_RX_EMB_FD_Q_NUM)               /* PAL_CPPI_PP_QMGR_G2_Q482 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SGMII1_DDR_SHORT_RX_EMB_FD_Q_NUM)                     /* PAL_CPPI_PP_QMGR_G2_Q483 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SGMII1_DDR_LONG_RX_LOW_EMB_FD_Q_NUM)                  /* PAL_CPPI_PP_QMGR_G2_Q484 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_SGMII1_DDR_LONG_RX_HIGH_EMB_FD_Q_NUM)                 /* PAL_CPPI_PP_QMGR_G2_Q485 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST2PP_INFRA_LOW_EMB_FD_Q_NUM)                       /* PAL_CPPI_PP_QMGR_G2_Q486 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_HOST2PP_INFRA_HIGH_EMB_FD_Q_NUM)                      /* PAL_CPPI_PP_QMGR_G2_Q487 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_WIFI_FW_TX_INTERNAL_EMB_FD_Q_NUM)                     /* PAL_CPPI_PP_QMGR_G2_Q488 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_WIFI_FW_RX_EMB_FD_Q_NUM)                              /* PAL_CPPI_PP_QMGR_G2_Q489 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_VOICE_DSP_RX_EMB_FD_Q_NUM)                            /* PAL_CPPI_PP_QMGR_G2_Q490 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_VOICE_INFRA_RX_EMB_FD_Q_NUM)                          /* PAL_CPPI_PP_QMGR_G2_Q491 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q45)                                           /* PAL_CPPI_PP_QMGR_G2_Q492 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q46)                                           /* PAL_CPPI_PP_QMGR_G2_Q493 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q47)                                           /* PAL_CPPI_PP_QMGR_G2_Q494 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q48)                                           /* PAL_CPPI_PP_QMGR_G2_Q495 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q49)                                           /* PAL_CPPI_PP_QMGR_G2_Q496 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q50)                                           /* PAL_CPPI_PP_QMGR_G2_Q497 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q51)                                           /* PAL_CPPI_PP_QMGR_G2_Q498 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q52)                                           /* PAL_CPPI_PP_QMGR_G2_Q499 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q53)                                           /* PAL_CPPI_PP_QMGR_G2_Q500 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q54)                                           /* PAL_CPPI_PP_QMGR_G2_Q501 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q55)                                           /* PAL_CPPI_PP_QMGR_G2_Q502 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q56)                                           /* PAL_CPPI_PP_QMGR_G2_Q503 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q57)                                           /* PAL_CPPI_PP_QMGR_G2_Q504 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q58)                                           /* PAL_CPPI_PP_QMGR_G2_Q505 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q59)                                           /* PAL_CPPI_PP_QMGR_G2_Q506 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q60)                                           /* PAL_CPPI_PP_QMGR_G2_Q507 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q61)                                           /* PAL_CPPI_PP_QMGR_G2_Q508 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_EMB_FD_Q62)                                           /* PAL_CPPI_PP_QMGR_G2_Q509 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_TEARDOWN_FD_Q_NUM)                                    /* PAL_CPPI_PP_QMGR_G2_Q510 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_G2_Q511)                                                 /* PAL_CPPI_PP_QMGR_G2_Q511 */
diff --git a/include/linux/avalanche/puma7/puma7_cppi_lqmgr_q.h b/include/linux/avalanche/puma7/puma7_cppi_lqmgr_q.h
new file mode 100755
index 0000000..641cd05
--- /dev/null
+++ b/include/linux/avalanche/puma7/puma7_cppi_lqmgr_q.h
@@ -0,0 +1,95 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+    Intel Corporation
+    2200 Mission College Blvd.
+    Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#define PAL_CPPI_PP_QMGR_LOCAL_Q_LIST                                                                                     \
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_CLASSIFIER1_LOW_Q_NUM)                          /* PAL_CPPI_PP_QMGR_LOCAL_Q0 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_CLASSIFIER1_MED_LOW_Q_NUM)                      /* PAL_CPPI_PP_QMGR_LOCAL_Q1 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_CLASSIFIER1_MED_HI_Q_NUM)                       /* PAL_CPPI_PP_QMGR_LOCAL_Q2 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_CLASSIFIER1_HI_Q_NUM)                           /* PAL_CPPI_PP_QMGR_LOCAL_Q3 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_CLASSIFIER2_LOW_Q_NUM)                          /* PAL_CPPI_PP_QMGR_LOCAL_Q4 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_CLASSIFIER2_MED_LOW_Q_NUM)                      /* PAL_CPPI_PP_QMGR_LOCAL_Q5 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_CLASSIFIER2_MED_HI_Q_NUM)                       /* PAL_CPPI_PP_QMGR_LOCAL_Q6 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_CLASSIFIER2_HI_Q_NUM)                           /* PAL_CPPI_PP_QMGR_LOCAL_Q7 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_MODIFIER_LOW_Q_NUM)                             /* PAL_CPPI_PP_QMGR_LOCAL_Q8 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_MODIFIER_MED_LOW_Q_NUM)                         /* PAL_CPPI_PP_QMGR_LOCAL_Q9 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_MODIFIER_MED_HI_Q_NUM)                          /* PAL_CPPI_PP_QMGR_LOCAL_Q10 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_MODIFIER_HI_Q_NUM)                              /* PAL_CPPI_PP_QMGR_LOCAL_Q11 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_RECYCLER_LOW_Q_NUM)                             /* PAL_CPPI_PP_QMGR_LOCAL_Q12 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_RECYCLER_HI_Q_NUM)                              /* PAL_CPPI_PP_QMGR_LOCAL_Q13 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_SESSION_CACHE_LOW_Q_NUM)                        /* PAL_CPPI_PP_QMGR_LOCAL_Q14 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_SESSION_CACHE_MED_LOW_Q_NUM)                    /* PAL_CPPI_PP_QMGR_LOCAL_Q15 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_SESSION_CACHE_MED_HI_Q_NUM)                     /* PAL_CPPI_PP_QMGR_LOCAL_Q16 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_SESSION_CACHE_HI_Q_NUM)                         /* PAL_CPPI_PP_QMGR_LOCAL_Q17 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_TurboDOX_LOW_Q_NUM)                             /* PAL_CPPI_PP_QMGR_LOCAL_Q18 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_TurboDOX_MED_LOW_Q_NUM)                         /* PAL_CPPI_PP_QMGR_LOCAL_Q19 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_TurboDOX_MED_HI_Q_NUM)                          /* PAL_CPPI_PP_QMGR_LOCAL_Q20 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_TurboDOX_HI_Q_NUM)                              /* PAL_CPPI_PP_QMGR_LOCAL_Q21 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_RESEQUENCER_LOW_Q_NUM)                          /* PAL_CPPI_PP_QMGR_LOCAL_Q22 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_RESEQUENCER_MED_LOW_Q_NUM)                      /* PAL_CPPI_PP_QMGR_LOCAL_Q23 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_RESEQUENCER_MED_HI_Q_NUM)                       /* PAL_CPPI_PP_QMGR_LOCAL_Q24 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_RESEQUENCER_HI_Q_NUM)                           /* PAL_CPPI_PP_QMGR_LOCAL_Q25 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_RESEQUENCER_Q26)                                /* PAL_CPPI_PP_QMGR_LOCAL_Q26 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_RESEQUENCER_Q27)                                /* PAL_CPPI_PP_QMGR_LOCAL_Q27 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_RESEQUENCER_Q28)                                /* PAL_CPPI_PP_QMGR_LOCAL_Q28 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_RESEQUENCER_Q29)                                /* PAL_CPPI_PP_QMGR_LOCAL_Q29 */\
+PAL_CPPI_QMGR_Q_ADD(PAL_CPPI_PP_QMGR_LOCAL_PP_INTERNAL_EMB_FD_Q_NUM)                       /* PAL_CPPI_PP_QMGR_LOCAL_Q30 */
+
+
diff --git a/include/linux/avalanche/puma7/puma7_cppi_prv.h b/include/linux/avalanche/puma7/puma7_cppi_prv.h
index 53e1665..e3dfc15 100755
--- a/include/linux/avalanche/puma7/puma7_cppi_prv.h
+++ b/include/linux/avalanche/puma7/puma7_cppi_prv.h
@@ -1,9 +1,11 @@
 /*
 
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
 
   GPL LICENSE SUMMARY
 
-  Copyright(c) 2014-2016 Intel Corporation.
+  Copyright(c) 2014 - 2016 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of version 2 of the GNU General Public License as
@@ -25,11 +27,1967 @@
     2200 Mission College Blvd.
     Santa Clara, CA  97052
 
+  BSD LICENSE
+
+  Copyright(c) 2014 - 2016 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
 */
 
+#ifdef __KERNEL__
+#include <generated/autoconf.h>
+#endif
+#include "puma7_cppi_lqmgr_q.h"
+#include "puma7_cppi_gqmgr0_q.h"
+#include "puma7_cppi_gqmgr1_q.h"
+#include "puma7_cppi_gqmgr2_q.h"
+#include "puma7_cppi_dsgqmgr_q.h"
+#include "puma7_cppi_usqmgr_q.h"
+#ifndef CONFIG_ARM_AVALANCHE_SOC
+#include <linux/netip_mem_util.h>
+#endif
 #ifndef PUMA7_CPPI_PRV_H
 #define PUMA7_CPPI_PRV_H
-//Just for to track history.
+#ifndef CONFIG_ARM_AVALANCHE_SOC
+#define IO_ADDRESS(addr) ((unsigned long)netip_mmio_to_virtual(addr))
 #endif
+/**********************************************************************************************************************
+
+ #######  ##     ## ######## ##     ## ########    ##     ##    ###    ##    ##    ###     ######   ######## ########
+##     ## ##     ## ##       ##     ## ##          ###   ###   ## ##   ###   ##   ## ##   ##    ##  ##       ##     ##
+##     ## ##     ## ##       ##     ## ##          #### ####  ##   ##  ####  ##  ##   ##  ##        ##       ##     ##
+##     ## ##     ## ######   ##     ## ######      ## ### ## ##     ## ## ## ## ##     ## ##   #### ######   ########
+##  ## ## ##     ## ##       ##     ## ##          ##     ## ######### ##  #### ######### ##    ##  ##       ##   ##
+##    ##  ##     ## ##       ##     ## ##          ##     ## ##     ## ##   ### ##     ## ##    ##  ##       ##    ##
+ ##### ##  #######  ########  #######  ########    ##     ## ##     ## ##    ## ##     ##  ######   ######## ##     ##
+
+**********************************************************************************************************************/
+#undef PAL_CPPI_QMGR_Q_ADD
+#define PAL_CPPI_QMGR_Q_ADD(qNumber)       qNumber,
 
+/*
++-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+-+
+|P|P| |Q|u|e|u|e| |M|a|n|a|g|e|r|s|
++-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+-+
+*/
+typedef enum PAL_CPPI_PP_QMGRs
+{
+    PAL_CPPI_PP_QMGR_G0,
+    PAL_CPPI_PP_QMGR_G1,
+    PAL_CPPI_PP_QMGR_G2,
+    PAL_CPPI_PP_QMGR_LOCAL,
+    PAL_CPPI41_NUM_QUEUE_MGR                                                                        /* PP has the maximum number of queue managers */
+}PAL_CPPI_PP_QMGRs_e;
+
+/*
++-+-+ +-+-+-+-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+-+
+|P|P| |L|o|c|a|l| |Q|u|e|u|e| |M|a|n|a|g|e|r| |Q|u|e|u|e|s|
++-+-+ +-+-+-+-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+-+
+*/
+
+#define PAL_CPPI_PP_QMGR_LOCAL_REGS_BASE            (IO_ADDRESS(0xF3480000))
+#define PAL_CPPI_PP_QMGR_LOCAL_DESC_BASE            (IO_ADDRESS(0xF3490000))
+#define PAL_CPPI_PP_QMGR_LOCAL_QUEUES_BASE          (IO_ADDRESS(0xF34A0000))
+#define PAL_CPPI_PP_QMGR_LOCAL_Q_STATS_BASE         (IO_ADDRESS(0xF34B0000))
+#define PAL_CPPI_PP_QMGR_LOCAL_LINKING_RAM_BASE     (0xF34C0000)
+#define PAL_CPPI_PP_QMGR_LOCAL_LINKING_RAM_SIZE     512
+
+
+typedef enum PAL_CPPI_PP_QMGR_LOCAL_Qs
+{
+    PAL_CPPI_PP_QMGR_LOCAL_Q_LIST
+    PAL_CPPI_PP_QMGR_LOCAL_TOTAL_Q_COUNT
+}PAL_CPPI_PP_QMGR_LOCAL_Qs_e;
+
+
+/*
++-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+-+
+|P|P| |G|l|o|b|a|l|0| |Q|u|e|u|e| |M|a|n|a|g|e|r| |Q|u|e|u|e|s|
++-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+-+
+*/
+
+
+#define PAL_CPPI_PP_QMGR_G0_REGS_BASE                               (IO_ADDRESS(0xF9100000))
+#define PAL_CPPI_PP_QMGR_G0_DESC_BASE                               (IO_ADDRESS(0xF9110000))
+#define PAL_CPPI_PP_QMGR_G0_QUEUES_BASE                             (IO_ADDRESS(0xF9120000))
+#define PAL_CPPI_PP_QMGR_G0_Q_STATS_BASE                            (IO_ADDRESS(0xF9130000))
+#define PAL_CPPI_PP_QMGR_GLOBAL_LINKING_RAM_BASE                    (0xF9140000)
+#ifdef CONFIG_MACH_PUMA7_FPGA
+#ifdef CONFIG_MACH_PUMA7_FPGA_PP
+#define PAL_CPPI_PP_QMGR_GLOBAL_LINKING_RAM_SIZE                    16*1024
+#else
+#define PAL_CPPI_PP_QMGR_GLOBAL_LINKING_RAM_SIZE                    512
+#endif
+#else
+#define PAL_CPPI_PP_QMGR_GLOBAL_LINKING_RAM_SIZE                    ((64*1024)-1)
 #endif
+#define PAL_CPPI_PP_QMGR_GLOBAL_DEFAULT_BUFF_SIZE                   2048
+
+typedef enum PAL_CPPI_PP_QMGR_G0_Qs
+{
+    PAL_CPPI_PP_QMGR_G0_Q_LIST
+    PAL_CPPI_PP_QMGR_G0_TOTAL_Q_COUNT
+}PAL_CPPI_PP_QMGR_G0_Qs_e;
+
+
+/*
++-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+-+
+|P|P| |G|l|o|b|a|l|1| |Q|u|e|u|e| |M|a|n|a|g|e|r| |Q|u|e|u|e|s|
++-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+-+
+*/
+
+#define PAL_CPPI_PP_QMGR_G1_REGS_BASE               (IO_ADDRESS(0xF9300000))
+#define PAL_CPPI_PP_QMGR_G1_DESC_BASE               (IO_ADDRESS(0xF9310000))
+#define PAL_CPPI_PP_QMGR_G1_QUEUES_BASE             (IO_ADDRESS(0xF9320000))
+#define PAL_CPPI_PP_QMGR_G1_Q_STATS_BASE            (IO_ADDRESS(0xF9330000))
+#define PAL_CPPI_PP_QMGR_G1_Q_PROXY_BASE            (IO_ADDRESS(0xF9360000))
+
+typedef enum PAL_CPPI_PP_QMGR_G1_Qs
+{
+    PAL_CPPI_PP_QMGR_G1_Q_LIST
+    PAL_CPPI_PP_QMGR_G1_TOTAL_Q_COUNT
+}PAL_CPPI_PP_QMGR_G1_Qs_e;
+
+#define PAL_CPPI_PP_QMGR_G1_QOS_Q_BASE              PAL_CPPI_PP_QMGR_G1_QOS_Q0
+#define PAL_CPPI_PP_QMGR_G1_QOS_Q_LAST              PAL_CPPI_PP_QMGR_G1_QOS_Q255
+
+/*
++-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+-+
+|P|P| |G|l|o|b|a|l|2| |Q|u|e|u|e| |M|a|n|a|g|e|r| |Q|u|e|u|e|s|
++-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+ +-+-+-+-+-+-+
+*/
+
+#define PAL_CPPI_PP_QMGR_G2_REGS_BASE               (IO_ADDRESS(0xF9380000))
+#define PAL_CPPI_PP_QMGR_G2_DESC_BASE               (IO_ADDRESS(0xF9390000))
+#define PAL_CPPI_PP_QMGR_G2_QUEUES_BASE             (IO_ADDRESS(0xF93A0000))
+#define PAL_CPPI_PP_QMGR_G2_Q_STATS_BASE            (IO_ADDRESS(0xF93B0000))
+#define PAL_CPPI_PP_QMGR_G2_Q_PROXY_BASE            (IO_ADDRESS(0xF93E0000))
+
+typedef enum PAL_CPPI_PP_QMGR_G2_Qs
+{
+    PAL_CPPI_PP_QMGR_G2_Q_LIST
+    PAL_CPPI_PP_QMGR_G2_TOTAL_Q_COUNT
+}PAL_CPPI_PP_QMGR_G2_Qs_e;
+
+
+/*
++-+-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+-+
+|D|S|G| |Q|u|e|u|e| |M|a|n|a|g|e|r|s|
++-+-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+-+
+*/
+
+typedef enum PAL_CPPI_DSG_QUEUE_MNGRS
+{
+    PAL_CPPI_OFDM0_QUEUE_MGR,                        /* OFDM0  */
+    PAL_CPPI_OFDM1_QUEUE_MGR,                        /* OFDM1  */
+    PAL_CPPI_SC_QAM0_QUEUE_MGR,                      /* SC-QAM */
+    PAL_CPPI_DSG_NUM_QUEUE_MGR
+}PAL_CPPI_DSG_QUEUE_MNGRS_e;
+
+/* DSGs Common Queue Manager Info */
+#define PAL_CPPI_DS_DSG_FD_EMB_DESC_SIZE                        128     /* Descriptor Size in Bytes */
+#define PAL_CPPI_DSG_DESC_RAM_INTERNAL_ADDRESS                  0x40000
+#define PAL_CPPI_DSG_QUEUE_MGR_LINKING_RAM_INTERNAL_ADDRESS     0x45000
+
+/* OFDM0 DSG Queue Manager Info */
+#define PAL_CPPI_OFDM0_QUEUE_MGR_QUEUES_BASE            (IO_ADDRESS(0xF2160000))
+#define PAL_CPPI_OFDM0_QUEUE_MGR_REGS_BASE              (IO_ADDRESS(0xF2162000))
+#define PAL_CPPI_OFDM0_QUEUE_MGR_DESC_BASE              (IO_ADDRESS(0xF2163000))
+#define PAL_CPPI_OFDM0_QUEUE_MGR_Q_STATS_BASE           (IO_ADDRESS(0xF2164000))
+#define PAL_CPPI_OFDM0_DESC_RAM_BASE                    (IO_ADDRESS(0xF2100000 + PAL_CPPI_DSG_DESC_RAM_INTERNAL_ADDRESS))
+#define PAL_CPPI_OFDM0_QUEUE_MGR_LINKING_RAM_SIZE        128    /* Linkning RAM descriptors capacity */
+#define PAL_CPPI_OFDM0_FD_EMB_DESC_COUNT                 64     /* Descriptors RAM descriptors capacity */
+
+/* OFDM1 DSG Queue Manager Info */
+#define PAL_CPPI_OFDM1_QUEUE_MGR_QUEUES_BASE            (IO_ADDRESS(0xF21E0000))
+#define PAL_CPPI_OFDM1_QUEUE_MGR_REGS_BASE              (IO_ADDRESS(0xF21E2000))
+#define PAL_CPPI_OFDM1_QUEUE_MGR_DESC_BASE              (IO_ADDRESS(0xF21E3000))
+#define PAL_CPPI_OFDM1_QUEUE_MGR_Q_STATS_BASE           (IO_ADDRESS(0xF21E4000))
+#define PAL_CPPI_OFDM1_DESC_RAM_BASE                    (IO_ADDRESS(0xF2180000 + PAL_CPPI_DSG_DESC_RAM_INTERNAL_ADDRESS))
+#define PAL_CPPI_OFDM1_QUEUE_MGR_LINKING_RAM_SIZE        128    /* Linkning RAM descriptors capacity */
+#define PAL_CPPI_OFDM1_FD_EMB_DESC_COUNT                 64     /* Descriptors RAM descriptors capacity */
+
+/* SC-QAM0 DSG Queue Manager Info */
+#define PAL_CPPI_SC_QAM0_QUEUE_MGR_QUEUES_BASE          (IO_ADDRESS(0xF2060000))
+#define PAL_CPPI_SC_QAM0_QUEUE_MGR_REGS_BASE            (IO_ADDRESS(0xF2062000))
+#define PAL_CPPI_SC_QAM0_QUEUE_MGR_DESC_BASE            (IO_ADDRESS(0xF2063000))
+#define PAL_CPPI_SC_QAM0_QUEUE_MGR_Q_STATS_BASE         (IO_ADDRESS(0xF2064000))
+#define PAL_CPPI_SC_QAM0_DESC_RAM_BASE                  (IO_ADDRESS(0xF2000000 + PAL_CPPI_DSG_DESC_RAM_INTERNAL_ADDRESS))
+#define PAL_CPPI_SC_QAM0_QUEUE_MGR_LINKING_RAM_SIZE      256    /* Linkning RAM descriptors capacity */
+#define PAL_CPPI_SC_QAM0_FD_EMB_DESC_COUNT               128    /* Descriptors RAM descriptors capacity */
+
+
+typedef enum PAL_CPPI_DSG_QMGR_Qs
+{
+    PAL_CPPI_DSG_QMGR_Q_LIST
+    PAL_CPPI_DSG_QMGR_TOTAL_Q_COUNT
+}PAL_CPPI_DSG_QMGR_Qs_e;
+
+
+/*
++-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+
+|U|S| |Q|u|e|u|e| |M|a|n|a|g|e|r|
++-+-+ +-+-+-+-+-+ +-+-+-+-+-+-+-+
+*/
+
+typedef enum PAL_CPPI_MAC_US_QMGRs
+{
+    PAL_CPPI_MAC_US_QMGR_DOCSIS = 3
+}
+PAL_CPPI_MAC_US_QMGRs_e;
+
+#define PAL_CPPI_MAC_US_QMGR_REGS_BASE              (IO_ADDRESS(0xF2500000))
+#define PAL_CPPI_MAC_US_QMGR_DESC_BASE              (IO_ADDRESS(0xF2530000))
+#define PAL_CPPI_MAC_US_QMGR_QUEUES_BASE            (IO_ADDRESS(0xF2510000))
+#define PAL_CPPI_MAC_US_QMGR_Q_STATS_BASE           (IO_ADDRESS(0xF2520000))
+#define PAL_CPPI_MAC_US_QMGR_LINKING_RAM_BASE       (IO_ADDRESS(0xF2580000))
+#define PAL_CPPI_MAC_US_QMGR_LINKING_RAM_SIZE       (8*1024)
+
+typedef enum PAL_CPPI_MAC_US_QMGR_Qs
+{
+    PAL_CPPI_MAC_US_QMGR_DOCSIS_Q_LIST
+    PAL_CPPI_MAC_US_QMGR_TOTAL_Q_COUNT
+}
+PAL_CPPI_MAC_US_QMGR_Qs_e;
+
+#define PAL_CPPI_MAC_US_DESC_SIZE_MONO              128
+#define PAL_CPPI_MAC_US_DESC_SIZE_EMB               32
+
+#define PAL_CPPI_MAC_US_PRE_PROC_MONOLITIC_BASE     (IO_ADDRESS(0xF3FA0000))
+#define PAL_CPPI_MAC_US_PRE_PROC_MONOLITIC_COUNT    64
+#define PAL_CPPI_MAC_US_TX_MONOLITIC_BASE           (IO_ADDRESS(0xF2864000))
+#define PAL_CPPI_MAC_US_TX_MONOLITIC_COUNT          24
+#define PAL_CPPI_MAC_US_DLS_MONOLITIC_COUNT          8
+#define PAL_CPPI_MAC_US_TX_EMB_BASE                 (IO_ADDRESS(0xF2740000))
+#define PAL_CPPI_MAC_US_TX_EMB_COUNT                (3*1024)
+
+/**********************************************************************************************************************
+
+ #######   ######  ##     ##  #######  ##    ##
+##     ## ##    ## ###   ### ##     ## ###   ##
+##     ## ##       #### #### ##     ## ####  ##
+##     ##  ######  ## ### ## ##     ## ## ## ##
+##  ## ##       ## ##     ## ##     ## ##  ####
+##    ##  ##    ## ##     ## ##     ## ##   ###
+ ##### ##  ######  ##     ##  #######  ##    ##
+
+**********************************************************************************************************************/
+
+typedef enum PAL_CPPI_PP_QSMON_MGRs
+{
+    PAL_CPPI_PP_QSMON_MGR0,
+    PAL_CPPI_PP_QSMON_MGR1,
+    PAL_CPPI_PP_QSMON_MGR2,
+    PAL_CPPI_PP_QSMON_MGR3,
+    PAL_CPPI_PP_QSMON_MGR4,
+    PAL_CPPI_PP_BSMON_MGR,
+    PAL_CPPI_PP_NUM_QSMON_MGRs
+}PAL_CPPI_PP_QSMON_MGRs_e;
+
+#define PAL_CPPI_QSMON_MAX_THREADS                  32
+#define PAL_CPPI_QSMON_THREADS_PER_DMA              6
+#define PAL_CPPI_QSMON_SHARED_QUEUES_THRESHOLD      (9)  /* 3 for DSGs, 5 for GMIIs, 1 for MoCA */
+#define PAL_CPPI_QSMON_DOCSIS_ONLY_THRESHOLD        (3)  /* 3 for DSGs */
+#define PAL_CPPI_QSMON_PRIVATE_THRESHOLD            (1)
+#define PAL_CPPI_QSMON_DIRECTION_UP                 0
+#define PAL_CPPI_QSMON_DIRECTION_DOWN               1
+
+#define PAL_CPPI_QSMON_0_CTRL_REGS_BASE             (IO_ADDRESS(0xF9188300))
+#define PAL_CPPI_QSMON_0_CONFIG_REGS_BASE           (IO_ADDRESS(0xF9188400))
+#define PAL_CPPI_QSMON_0_STATUS_REGS_BASE           (IO_ADDRESS(0xF9188500))
+
+#define PAL_CPPI_QSMON_1_CTRL_REGS_BASE             (IO_ADDRESS(0xF9350000))
+#define PAL_CPPI_QSMON_1_CONFIG_REGS_BASE           (IO_ADDRESS(0xF9350100))
+#define PAL_CPPI_QSMON_1_STATUS_REGS_BASE           (IO_ADDRESS(0xF9350200))
+
+#define PAL_CPPI_QSMON_2_CTRL_REGS_BASE             (IO_ADDRESS(0xF93D0000))
+#define PAL_CPPI_QSMON_2_CONFIG_REGS_BASE           (IO_ADDRESS(0xF93D0100))
+#define PAL_CPPI_QSMON_2_STATUS_REGS_BASE           (IO_ADDRESS(0xF93D0200))
+
+#define PAL_CPPI_QSMON_3_CTRL_REGS_BASE             (IO_ADDRESS(0xF93D0400))
+#define PAL_CPPI_QSMON_3_CONFIG_REGS_BASE           (IO_ADDRESS(0xF93D0500))
+#define PAL_CPPI_QSMON_3_STATUS_REGS_BASE           (IO_ADDRESS(0xF93D0600))
+
+typedef enum PAL_CPPI_PP_QSMON_3_THREADs
+{
+    PAL_CPPI_PP_QSMON_3_THREAD_0_RGMII1_CH_0,
+    PAL_CPPI_PP_QSMON_3_THREAD_1_RGMII1_CH_1,
+    PAL_CPPI_PP_QSMON_3_THREAD_2_RGMII1_CH_2,
+    PAL_CPPI_PP_QSMON_3_THREAD_3_RGMII1_CH_4,
+    PAL_CPPI_PP_QSMON_3_THREAD_4_RGMII1_CH_5,
+    PAL_CPPI_PP_QSMON_3_THREAD_5_RGMII1_CH_6,
+
+    PAL_CPPI_PP_QSMON_3_THREAD_6_ATOM_CH_0,
+    PAL_CPPI_PP_QSMON_3_THREAD_7_ATOM_CH_1,
+    PAL_CPPI_PP_QSMON_3_THREAD_8_ATOM_CH_2,
+    PAL_CPPI_PP_QSMON_3_THREAD_9_ATOM_CH_4,
+    PAL_CPPI_PP_QSMON_3_THREAD_10_ATOM_CH_5,
+    PAL_CPPI_PP_QSMON_3_THREAD_11_ATOM_CH_6,
+
+    PAL_CPPI_PP_QSMON_3_THREAD_12_MoCA_CH_0,
+    PAL_CPPI_PP_QSMON_3_THREAD_13_MoCA_CH_1,
+    PAL_CPPI_PP_QSMON_3_THREAD_14_MoCA_CH_2,
+    PAL_CPPI_PP_QSMON_3_THREAD_15_MoCA_CH_4,
+    PAL_CPPI_PP_QSMON_3_THREAD_16_MoCA_CH_5,
+    PAL_CPPI_PP_QSMON_3_THREAD_17_MoCA_CH_6,
+
+    PAL_CPPI_PP_QSMON_3_THREAD_18_RGMII0_CH_0,
+    PAL_CPPI_PP_QSMON_3_THREAD_19_RGMII0_CH_1,
+    PAL_CPPI_PP_QSMON_3_THREAD_20_RGMII0_CH_2,
+    PAL_CPPI_PP_QSMON_3_THREAD_21_RGMII0_CH_4,
+    PAL_CPPI_PP_QSMON_3_THREAD_22_RGMII0_CH_5,
+    PAL_CPPI_PP_QSMON_3_THREAD_23_RGMII0_CH_6,
+
+    PAL_CPPI_PP_QSMON_3_THREAD_24_SGMII1_CH_0,
+    PAL_CPPI_PP_QSMON_3_THREAD_25_SGMII1_CH_1,
+    PAL_CPPI_PP_QSMON_3_THREAD_26_SGMII1_CH_2,
+    PAL_CPPI_PP_QSMON_3_THREAD_27_SGMII1_CH_4,
+    PAL_CPPI_PP_QSMON_3_THREAD_28_SGMII1_CH_5,
+    PAL_CPPI_PP_QSMON_3_THREAD_29_SGMII1_CH_6,
+
+    PAL_CPPI_PP_QSMON_3_THREAD_30_UNUSED,
+    PAL_CPPI_PP_QSMON_3_THREAD_31_UNUSED,
+}PAL_CPPI_PP_QSMON_3_THREADs_e;
+
+
+#define PAL_CPPI_QSMON_4_CTRL_REGS_BASE             (IO_ADDRESS(0xF93D0700))
+#define PAL_CPPI_QSMON_4_CONFIG_REGS_BASE           (IO_ADDRESS(0xF93D0800))
+#define PAL_CPPI_QSMON_4_STATUS_REGS_BASE           (IO_ADDRESS(0xF93D0900))
+
+typedef enum PAL_CPPI_PP_QSMON_4_THREADs
+{
+    PAL_CPPI_PP_QSMON_4_THREAD_0_SGMII0_CH_0,
+    PAL_CPPI_PP_QSMON_4_THREAD_1_SGMII0_CH_1,
+    PAL_CPPI_PP_QSMON_4_THREAD_2_SGMII0_CH_2,
+    PAL_CPPI_PP_QSMON_4_THREAD_3_SGMII0_CH_4,
+    PAL_CPPI_PP_QSMON_4_THREAD_4_SGMII0_CH_5,
+    PAL_CPPI_PP_QSMON_4_THREAD_5_SGMII0_CH_6,
+
+    PAL_CPPI_PP_QSMON_4_THREAD_6_SCQAM0_CH_0,
+    PAL_CPPI_PP_QSMON_4_THREAD_7_SCQAM0_CH_1,
+    PAL_CPPI_PP_QSMON_4_THREAD_8_SCQAM0_CH_2,
+    PAL_CPPI_PP_QSMON_4_THREAD_9_SCQAM0_CH_4,
+    PAL_CPPI_PP_QSMON_4_THREAD_10_SCQAM0_CH_5,
+    PAL_CPPI_PP_QSMON_4_THREAD_11_SCQAM0_CH_6,
+
+    PAL_CPPI_PP_QSMON_4_THREAD_12_OFDM1_CH_0,
+    PAL_CPPI_PP_QSMON_4_THREAD_13_OFDM1_CH_1,
+    PAL_CPPI_PP_QSMON_4_THREAD_14_OFDM1_CH_2,
+    PAL_CPPI_PP_QSMON_4_THREAD_15_OFDM1_CH_4,
+    PAL_CPPI_PP_QSMON_4_THREAD_16_OFDM1_CH_5,
+    PAL_CPPI_PP_QSMON_4_THREAD_17_OFDM1_CH_6,
+
+    PAL_CPPI_PP_QSMON_4_THREAD_18_OFDM0_CH_0,
+    PAL_CPPI_PP_QSMON_4_THREAD_19_OFDM0_CH_1,
+    PAL_CPPI_PP_QSMON_4_THREAD_20_OFDM0_CH_2,
+    PAL_CPPI_PP_QSMON_4_THREAD_21_OFDM0_CH_4,
+    PAL_CPPI_PP_QSMON_4_THREAD_22_OFDM0_CH_5,
+    PAL_CPPI_PP_QSMON_4_THREAD_23_OFDM0_CH_6,
+
+    PAL_CPPI_PP_QSMON_4_THREAD_24_UNUSED,
+    PAL_CPPI_PP_QSMON_4_THREAD_25_UNUSED,
+    PAL_CPPI_PP_QSMON_4_THREAD_26_UNUSED,
+    PAL_CPPI_PP_QSMON_4_THREAD_27_UNUSED,
+    PAL_CPPI_PP_QSMON_4_THREAD_28_UNUSED,
+    PAL_CPPI_PP_QSMON_4_THREAD_29_UNUSED,
+    PAL_CPPI_PP_QSMON_4_THREAD_30_UNUSED,
+    PAL_CPPI_PP_QSMON_4_THREAD_31_UNUSED,
+}PAL_CPPI_PP_QSMON_4_THREADs_e;
+
+
+#define PAL_CPPI_BSMON_CTRL_REGS_BASE               (IO_ADDRESS(0xF9188000))
+#define PAL_CPPI_BSMON_CONFIG_REGS_BASE             (IO_ADDRESS(0xF9188100))
+#define PAL_CPPI_BSMON_STATUS_REGS_BASE             (IO_ADDRESS(0xF9188200))
+
+
+/**********************************************************************************************************************
+
+########  ########  ######   ######     ########  ########  ######   ####  #######  ##    ##  ######
+##     ## ##       ##    ## ##    ##    ##     ## ##       ##    ##   ##  ##     ## ###   ## ##    ##
+##     ## ##       ##       ##          ##     ## ##       ##         ##  ##     ## ####  ## ##
+##     ## ######    ######  ##          ########  ######   ##   ####  ##  ##     ## ## ## ##  ######
+##     ## ##             ## ##          ##   ##   ##       ##    ##   ##  ##     ## ##  ####       ##
+##     ## ##       ##    ## ##    ##    ##    ##  ##       ##    ##   ##  ##     ## ##   ### ##    ##
+########  ########  ######   ######     ##     ## ########  ######   ####  #######  ##    ##  ######
+
+**********************************************************************************************************************/
+
+/*
++-+-+-+-+-+ +-+-+-+-+ +-+-+-+-+-+-+
+|L|o|c|a|l| |D|e|s|c| |R|e|g|i|o|n|
++-+-+-+-+-+ +-+-+-+-+ +-+-+-+-+-+-+
+*/
+
+#define PAL_CPPI_PP_INTERNAL_EMB_LOCAL_DESC_REGION      0
+
+#define PAL_CPPI_PP_QMGR_LOCAL_PREFETCH_FD_BASE                         (IO_ADDRESS(0xF3500000))
+#define PAL_CPPI_PP_QMGR_LOCAL_PREFETCH_FD_DESC_COUNT                   64
+#define PAL_CPPI_PP_QMGR_LOCAL_PREFETCH_FD_DESC_SIZE                    512
+
+
+/*
++-+-+-+-+-+-+ +-+-+-+-+ +-+-+-+-+-+-+
+|G|l|o|b|a|l| |D|e|s|c| |R|e|g|i|o|n|
++-+-+-+-+-+-+ +-+-+-+-+ +-+-+-+-+-+-+
+*/
+
+typedef enum PAL_CPPI_PP_DESC_REGIONs
+{
+    PAL_CPPI_PP_VOICE_GLOBAL_DESC_REGION,                               // 0
+    PAL_CPPI_PP_RX_SHORT_NON_DOCSIS_INFRA_GLOBAL_DESC_REGION,           // 1
+    PAL_CPPI_PP_RX_LONG_RX_XL_DOCSIS_GLOBAL_DESC_REGION,                // 2
+    PAL_CPPI_PP_DESC_REGION3,                                           // 3
+    PAL_CPPI_PP_DESC_REGION4,                                           // 4
+    PAL_CPPI_PP_DESC_REGION5,                                           // 5
+    PAL_CPPI_PP_DESC_REGION6,                                           // 6
+    PAL_CPPI_PP_DESC_REGION7,                                           // 7
+    PAL_CPPI_PP_DESC_REGION8,                                           // 8
+    PAL_CPPI_PP_DESC_REGION9,                                           // 9
+    PAL_CPPI_PP_TEARDOWN_GLOBAL_DESC_REGION,                            // 10
+
+    // On-Chip regions...
+    PAL_CPPI_PP_INTERNAL_EMB_GLOBAL_DESC_REGION,                        // 11
+    PAL_CPPI_PP_WIFI_FW_TX_INTERNAL_EMB_DESC_REGION,                    // 12
+    PAL_CPPI_PP_IPSEC_MONOLITHIC_GLOBAL_DESC_REGION,                    // 13
+    PAL_CPPI_PP_US_FW_MONO_DESC_REGION,                                 // 14
+    PAL_CPPI_PP_PACKET_RAM_GLOBAL_DESC_REGION,                          // 15
+
+    PAL_CPPI41_MAX_DESC_REGIONS
+}PAL_CPPI_PP_DESC_REGIONs_e;
+
+
+
+/* Descriptors information - count, size and base address if internal */
+#define PAL_CPPI_PP_QMGR_GLOBAL_DEFAULT_DESC_SIZE                                           64
+#define PAL_CPPI_PP_START_OF_PACKET_OFFSET                                                  128
+
+#define PAL_CPPI_PP_PACKET_RAM_SHARED_FD_BASE                                               (IO_ADDRESS(0xF9060000))
+#ifdef CONFIG_MACH_PUMA7_FPGA
+#define PAL_CPPI_PP_PACKET_RAM_SHARED_FD_DESC_COUNT                                         96
+#else
+#define PAL_CPPI_PP_PACKET_RAM_SHARED_FD_DESC_COUNT                                         1088
+#endif
+
+#ifdef CONFIG_MACH_PUMA7_FPGA
+#define PAL_CPPI_PP_RX_LOW_SHORT_SHARED_PACKET_RAM_EMB_FD_DESC_COUNT                        0
+#define PAL_CPPI_PP_RX_LOW_SHORT_SHARED_DDR_EMB_FD_DESC_COUNT                               64
+#define PAL_CPPI_PP_RX_LOW_LONG_SHARED_PACKET_RAM_EMB_FD_DESC_COUNT                         0
+#define PAL_CPPI_PP_RX_LOW_LONG_SHARED_DDR_EMB_FD_DESC_COUNT                                64
+#else
+#define PAL_CPPI_PP_RX_LOW_SHORT_SHARED_PACKET_RAM_EMB_FD_DESC_COUNT                        0
+#define PAL_CPPI_PP_RX_LOW_SHORT_SHARED_DDR_EMB_FD_DESC_COUNT                               (12 * 1024)
+#define PAL_CPPI_PP_RX_LOW_LONG_SHARED_PACKET_RAM_EMB_FD_DESC_COUNT                         0
+#define PAL_CPPI_PP_RX_LOW_LONG_SHARED_DDR_EMB_FD_DESC_COUNT                                (12 * 1024)
+#endif
+#define PAL_CPPI_PP_RX_LOW_XLONG_SHARED_DDR_EMB_FD_DESC_COUNT                               64
+
+#ifdef CONFIG_MACH_PUMA7_FPGA
+#define PAL_CPPI_PP_SHARED_LOW_INFRA_HOST_FD_DESC_COUNT                                     64
+#else
+#define PAL_CPPI_PP_SHARED_LOW_INFRA_HOST_FD_DESC_COUNT                                     512
+#endif
+
+
+#define PAL_CPPI_PP_DOCSIS_LOW_INFRA_HOST_FD_DESC_COUNT                                     128
+#define PAL_CPPI_PP_DOCSIS_HI_INFRA_HOST_FD_DESC_COUNT                                      64
+#define PAL_CPPI_PP_DOCSIS_RX_MGMT_HOST_FD_DESC_COUNT                                       64
+#define PAL_CPPI_PP_DOCSIS_TX_MGMT_HOST_FD_DESC_COUNT                                       64
+
+#ifdef CONFIG_MACH_PUMA7_FPGA
+#define PAL_CPPI_PP_DOCSIS_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                0
+#define PAL_CPPI_PP_DOCSIS_RX_LOW_SHORT_PRIVATE_DESC_PACKET_RAM_BUFF_DDR_EMB_FD_DESC_COUNT  0
+#define PAL_CPPI_PP_DOCSIS_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                 0
+#define PAL_CPPI_PP_DOCSIS_RX_LOW_LONG_PRIVATE_DESC_PACKET_RAM_BUFF_DDR_EMB_FD_DESC_COUNT   0
+#define PAL_CPPI_PP_DOCSIS_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            64
+#else
+#define PAL_CPPI_PP_DOCSIS_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                0
+#define PAL_CPPI_PP_DOCSIS_RX_LOW_SHORT_PRIVATE_DESC_PACKET_RAM_BUFF_DDR_EMB_FD_DESC_COUNT  0
+#define PAL_CPPI_PP_DOCSIS_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                 0
+#define PAL_CPPI_PP_DOCSIS_RX_LOW_LONG_PRIVATE_DESC_PACKET_RAM_BUFF_DDR_EMB_FD_DESC_COUNT   0
+#define PAL_CPPI_PP_DOCSIS_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            256
+#endif
+
+#define PAL_CPPI_PP_IPSEC_MONOLITHIC_FD_BASE                                                (IO_ADDRESS(0xF3E40900))
+#define PAL_CPPI_PP_IPSEC_MONOLITHIC_FD_DESC_COUNT                                          16
+#define PAL_CPPI_PP_IPSEC_MONOLITHIC_FD_DESC_SIZE                                           2048
+#define PAL_CPPI_PP_IPSEC_HOST_FD_DESC_COUNT                                                2048
+#define PAL_CPPI_PP_IPSEC_HOST_FD_DESC_SIZE                                                 64
+
+#define PAL_CPPI_PP_US_FW_MONO_FD_BASE                                                      (IO_ADDRESS(0xF3FA0000))
+#define PAL_CPPI_PP_US_FW_MONO_FD_DESC_COUNT                                                64
+#define PAL_CPPI_PP_US_FW_MONO_FD_DESC_SIZE                                                 128
+
+#define PAL_CPPI_PP_ATOM_HI_INFRA_HOST_FD_DESC_COUNT                                        32
+#define PAL_CPPI_PP_RGMII0_HI_INFRA_HOST_FD_DESC_COUNT                                      32
+#define PAL_CPPI_PP_RGMII1_HI_INFRA_HOST_FD_DESC_COUNT                                      32
+#define PAL_CPPI_PP_SGMII0_HI_INFRA_HOST_FD_DESC_COUNT                                      32
+#define PAL_CPPI_PP_SGMII1_HI_INFRA_HOST_FD_DESC_COUNT                                      32
+#ifdef CONFIG_WIFI_PROXY
+#define PAL_CPPI_PP_WIFI_INFRA_HOST_RX_FD_DESC_COUNT                                        128
+#endif
+
+#ifdef CONFIG_MACH_PUMA7_BOARD
+#define PAL_CPPI_PP_MoCA_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                  64
+#define PAL_CPPI_PP_MoCA_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                         64
+#define PAL_CPPI_PP_MoCA_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                   8
+#define PAL_CPPI_PP_MoCA_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                          128
+#else
+#define PAL_CPPI_PP_MoCA_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                  4
+#define PAL_CPPI_PP_MoCA_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                         2
+#define PAL_CPPI_PP_MoCA_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                   4
+#define PAL_CPPI_PP_MoCA_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                          2
+#endif
+
+#ifdef CONFIG_MACH_PUMA7_BOARD
+#define PAL_CPPI_PP_ATOM_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                  64
+#define PAL_CPPI_PP_ATOM_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                         64
+#define PAL_CPPI_PP_ATOM_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                   8
+#define PAL_CPPI_PP_ATOM_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                          128
+#define PAL_CPPI_PP_ATOM_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                              64
+#else
+#define PAL_CPPI_PP_ATOM_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                  4
+#define PAL_CPPI_PP_ATOM_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                         64
+#define PAL_CPPI_PP_ATOM_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                   4
+#define PAL_CPPI_PP_ATOM_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                          128
+#define PAL_CPPI_PP_ATOM_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                              64
+#endif
+
+#ifdef CONFIG_MACH_PUMA7_BOARD
+#define PAL_CPPI_PP_RGMII0_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                64
+#define PAL_CPPI_PP_RGMII0_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                       64
+#define PAL_CPPI_PP_RGMII0_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                 8
+#define PAL_CPPI_PP_RGMII0_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                        128
+#define PAL_CPPI_PP_RGMII0_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            64
+
+#else
+#define PAL_CPPI_PP_RGMII0_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                12
+#define PAL_CPPI_PP_RGMII0_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                       64
+#define PAL_CPPI_PP_RGMII0_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                 6
+#define PAL_CPPI_PP_RGMII0_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                        128
+#define PAL_CPPI_PP_RGMII0_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            64
+#endif
+
+#ifdef CONFIG_MACH_PUMA7_BOARD
+#define PAL_CPPI_PP_RGMII1_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                32
+#define PAL_CPPI_PP_RGMII1_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                       64
+#define PAL_CPPI_PP_RGMII1_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                 6
+#define PAL_CPPI_PP_RGMII1_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                        128
+#define PAL_CPPI_PP_RGMII1_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            64
+#else
+#define PAL_CPPI_PP_RGMII1_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                12
+#define PAL_CPPI_PP_RGMII1_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                       64
+#define PAL_CPPI_PP_RGMII1_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                 6
+#define PAL_CPPI_PP_RGMII1_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                        128
+#define PAL_CPPI_PP_RGMII1_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            64
+#endif
+
+#ifdef CONFIG_MACH_PUMA7_BOARD
+#define PAL_CPPI_PP_SGMII0_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                32
+#define PAL_CPPI_PP_SGMII0_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                       64
+#define PAL_CPPI_PP_SGMII0_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                 6
+#define PAL_CPPI_PP_SGMII0_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                        128
+#define PAL_CPPI_PP_SGMII0_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            64
+#else
+#define PAL_CPPI_PP_SGMII0_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                28
+#define PAL_CPPI_PP_SGMII0_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                       64
+#define PAL_CPPI_PP_SGMII0_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                 6
+#define PAL_CPPI_PP_SGMII0_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                        128
+#define PAL_CPPI_PP_SGMII0_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            64
+#endif
+
+#ifdef CONFIG_MACH_PUMA7_BOARD
+#define PAL_CPPI_PP_SGMII1_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                256
+#define PAL_CPPI_PP_SGMII1_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                       64
+#define PAL_CPPI_PP_SGMII1_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                 28
+#define PAL_CPPI_PP_SGMII1_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                        128
+#define PAL_CPPI_PP_SGMII1_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            64
+#else
+#define PAL_CPPI_PP_SGMII1_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                4
+#define PAL_CPPI_PP_SGMII1_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                       64
+#define PAL_CPPI_PP_SGMII1_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                 6
+#define PAL_CPPI_PP_SGMII1_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                        128
+#define PAL_CPPI_PP_SGMII1_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            64
+#endif
+
+#define PAL_CPPI_PP_WIFI_FW_TX_FD_BASE                                                      (IO_ADDRESS(0xF3508000))
+#define PAL_CPPI_PP_WIFI_FW_TX_INTERNAL_EMB_FD_DESC_COUNT                                   (128)
+#define PAL_CPPI_PP_WIFI_FW_RX_EMB_FD_DESC_COUNT                                            (16384) /* must be aligned to number of buffers allocated by app-cpu for wifi buffers pool */
+
+#ifdef CONFIG_MACH_PUMA7_BOARD
+#define PAL_CPPI_PP_HOST2PP_LOW_HOST_FD_DESC_COUNT                                          512
+#define PAL_CPPI_PP_HOST2PP_HI_HOST_FD_DESC_COUNT                                           64
+#define PAL_CPPI_PP_HOST2PP_LOW_INFRA_EMB_FD_DESC_COUNT                                     512
+#define PAL_CPPI_PP_HOST2PP_HI_INFRA_EMB_FD_DESC_COUNT                                      64
+#else
+#define PAL_CPPI_PP_HOST2PP_LOW_HOST_FD_DESC_COUNT                                          64
+#define PAL_CPPI_PP_HOST2PP_HI_HOST_FD_DESC_COUNT                                           64
+#define PAL_CPPI_PP_HOST2PP_LOW_INFRA_EMB_FD_DESC_COUNT                                     64
+#define PAL_CPPI_PP_HOST2PP_HI_INFRA_EMB_FD_DESC_COUNT                                      64
+#endif
+
+
+#ifdef CONFIG_MACH_PUMA7_BOARD
+#define PAL_CPPI_PP_NP2APP_HOST_FD_DESC_COUNT                                               256
+#define PAL_CPPI_PP_NP2APP_INFRA_PPINFO_HOST_FD_DESC_COUNT                                  128
+#define PAL_CPPI_PP_NP2APP_INFRA_DATA_HOST_FD_DESC_COUNT                                    128
+#define PAL_CPPI_PP_APP2NP_HOST_FD_DESC_COUNT                                               256
+#define PAL_CPPI_PP_APP2NP_INFRA_PPINFO_HOST_FD_DESC_COUNT                                  128
+#define PAL_CPPI_PP_APP2NP_INFRA_DATA_HOST_FD_DESC_COUNT                                    128
+#else
+#define PAL_CPPI_PP_NP2APP_HOST_FD_DESC_COUNT                                               64
+#define PAL_CPPI_PP_NP2APP_INFRA_PPINFO_HOST_FD_DESC_COUNT                                  32
+#define PAL_CPPI_PP_NP2APP_INFRA_DATA_HOST_FD_DESC_COUNT                                    32
+#define PAL_CPPI_PP_APP2NP_HOST_FD_DESC_COUNT                                               64
+#define PAL_CPPI_PP_APP2NP_INFRA_PPINFO_HOST_FD_DESC_COUNT                                  32
+#define PAL_CPPI_PP_APP2NP_INFRA_DATA_HOST_FD_DESC_COUNT                                    32
+#endif
+
+#define PAL_CPPI_PP_VOICE_DSP_RX_EMB_FD_DESC_COUNT                                          128
+#define PAL_CPPI_PP_VOICE_INFRA_RX_EMB_FD_DESC_COUNT                                        128
+
+
+#define PAL_CPPI_DSG_FD_EMB_DESC_REGION             0
+
+
+/**********************************************************************************************************************
+
+########  ##     ## ######## ######## ######## ########     ##     ##    ###    ##    ##    ###     ######   ######## ########
+##     ## ##     ## ##       ##       ##       ##     ##    ###   ###   ## ##   ###   ##   ## ##   ##    ##  ##       ##     ##
+##     ## ##     ## ##       ##       ##       ##     ##    #### ####  ##   ##  ####  ##  ##   ##  ##        ##       ##     ##
+########  ##     ## ######   ######   ######   ########     ## ### ## ##     ## ## ## ## ##     ## ##   #### ######   ########
+##     ## ##     ## ##       ##       ##       ##   ##      ##     ## ######### ##  #### ######### ##    ##  ##       ##   ##
+##     ## ##     ## ##       ##       ##       ##    ##     ##     ## ##     ## ##   ### ##     ## ##    ##  ##       ##    ##
+########   #######  ##       ##       ######## ##     ##    ##     ## ##     ## ##    ## ##     ##  ######   ######## ##     ##
+
+**********************************************************************************************************************/
+
+/*
++-+-+ +-+-+-+-+-+-+ +-+-+-+-+-+-+-+
+|P|P| |B|u|f|f|e|r| |M|a|n|a|g|e|r|
++-+-+ +-+-+-+-+-+-+ +-+-+-+-+-+-+-+
+*/
+
+#define PAL_CPPI_PP_BUF_MGR                     0
+#define PAL_CPPI_PP_BUF_MGR_BASE                (IO_ADDRESS(0xF9180000))
+
+typedef enum PAL_CPPI_PP_BUFFER_POOLs
+{
+    PAL_CPPI_PP_BUFFER_POOL0,
+
+    PAL_CPPI_PP_SHARED_RX_LOW_512B_BUFFER_POOL = PAL_CPPI_PP_BUFFER_POOL0,
+    PAL_CPPI_PP_SHARED_RX_LOW_2KB_BUFFER_POOL,
+    PAL_CPPI_PP_SHARED_RX_LOW_4KB_BUFFER_POOL,
+    PAL_CPPI_PP_SHARED_RX_HIGH_BUFFER_POOL,
+    PAL_CPPI_PP_WIFI_RX_TX_POOL,
+    PAL_CPPI_PP_BUFFER_POOL5,
+    PAL_CPPI_PP_BUFFER_POOL6,
+    PAL_CPPI_PP_BUFFER_POOL7,
+    PAL_CPPI_PP_BUFFER_POOL8,
+    PAL_CPPI_PP_PACKET_RAM_512B_BUFFER_POOL,
+    PAL_CPPI_PP_PACKET_RAM_2KB_BUFFER_POOL,
+    PAL_CPPI_PP_VOICE_DSP_BUFFER_POOL,
+
+    PAL_CPPI41_BMGR_MAX_POOLS
+}PAL_CPPI_PP_BUFFER_POOLs_e;
+
+
+#define PAL_CPPI_PP_SHARED_RX_LOW_512B_BUFFER_COUNT                 PAL_CPPI_PP_RX_LOW_SHORT_SHARED_DDR_EMB_FD_DESC_COUNT                               +   \
+                                                                    PAL_CPPI_PP_DOCSIS_RX_LOW_SHORT_PRIVATE_DESC_PACKET_RAM_BUFF_DDR_EMB_FD_DESC_COUNT  +   \
+                                                                    PAL_CPPI_PP_MoCA_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                         +   \
+                                                                    PAL_CPPI_PP_ATOM_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                         +   \
+                                                                    PAL_CPPI_PP_RGMII0_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                       +   \
+                                                                    PAL_CPPI_PP_RGMII1_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                       +   \
+                                                                    PAL_CPPI_PP_SGMII0_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT                       +   \
+                                                                    PAL_CPPI_PP_SGMII1_RX_LOW_SHORT_PRIVATE_DDR_EMB_FD_DESC_COUNT
+#define PAL_CPPI_PP_SHARED_RX_LOW_512B_BUFFER_SIZE                  512
+#define PAL_CPPI_PP_SHARED_RX_LOW_512B_BUFFER_REF_CNT               0
+
+#define PAL_CPPI_PP_SHARED_RX_LOW_2KB_BUFFER_COUNT                  PAL_CPPI_PP_RX_LOW_LONG_SHARED_DDR_EMB_FD_DESC_COUNT                                +   \
+                                                                    PAL_CPPI_PP_DOCSIS_RX_LOW_LONG_PRIVATE_DESC_PACKET_RAM_BUFF_DDR_EMB_FD_DESC_COUNT   +   \
+                                                                    PAL_CPPI_PP_MoCA_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                          +   \
+                                                                    PAL_CPPI_PP_ATOM_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                          +   \
+                                                                    PAL_CPPI_PP_RGMII0_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                        +   \
+                                                                    PAL_CPPI_PP_RGMII1_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                        +   \
+                                                                    PAL_CPPI_PP_SGMII0_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                        +   \
+                                                                    PAL_CPPI_PP_SGMII1_RX_LOW_LONG_PRIVATE_DDR_EMB_FD_DESC_COUNT                        +   \
+                                                                    PAL_CPPI_PP_HOST2PP_LOW_INFRA_EMB_FD_DESC_COUNT                                     +   \
+                                                                    PAL_CPPI_PP_HOST2PP_HI_INFRA_EMB_FD_DESC_COUNT
+#define PAL_CPPI_PP_SHARED_RX_LOW_2KB_BUFFER_SIZE                   (2 * 1024)
+#define PAL_CPPI_PP_SHARED_RX_LOW_2KB_BUFFER_REF_CNT                0
+
+#define PAL_CPPI_PP_SHARED_RX_LOW_4KB_BUFFER_COUNT                  PAL_CPPI_PP_RX_LOW_XLONG_SHARED_DDR_EMB_FD_DESC_COUNT
+#define PAL_CPPI_PP_SHARED_RX_LOW_4KB_BUFFER_SIZE                   (4 * 1024)
+#define PAL_CPPI_PP_SHARED_RX_LOW_4KB_BUFFER_REF_CNT                0
+
+#define PAL_CPPI_PP_SHARED_RX_HIGH_BUFFER_COUNT                     PAL_CPPI_PP_DOCSIS_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            +   \
+                                                                    PAL_CPPI_PP_ATOM_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                              +   \
+                                                                    PAL_CPPI_PP_RGMII0_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            +   \
+                                                                    PAL_CPPI_PP_RGMII1_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            +   \
+                                                                    PAL_CPPI_PP_SGMII0_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT                            +   \
+                                                                    PAL_CPPI_PP_SGMII1_RX_HIGH_PRIVATE_DDR_EMB_FD_DESC_COUNT
+#define PAL_CPPI_PP_SHARED_RX_HIGH_BUFFER_SIZE                      (2 * 1024)
+#define PAL_CPPI_PP_SHARED_RX_HIGH_BUFFER_REF_CNT                   0
+
+#define PAL_CPPI_PP_BUFFER_POOL4_COUNT                              0
+#define PAL_CPPI_PP_BUFFER_POOL4_SIZE                               0
+#define PAL_CPPI_PP_WIFI_RX_TX_POOL_REF_CNT                         0
+
+#define PAL_CPPI_PP_BUFFER_POOL5_COUNT                              0
+#define PAL_CPPI_PP_BUFFER_POOL5_SIZE                               0
+#define PAL_CPPI_PP_BUFFER_POOL5_REF_CNT                            0
+
+#define PAL_CPPI_PP_BUFFER_POOL6_COUNT                              0
+#define PAL_CPPI_PP_BUFFER_POOL6_SIZE                               0
+#define PAL_CPPI_PP_BUFFER_POOL6_REF_CNT                            0
+
+#define PAL_CPPI_PP_BUFFER_POOL7_COUNT                              0
+#define PAL_CPPI_PP_BUFFER_POOL7_SIZE                               0
+#define PAL_CPPI_PP_BUFFER_POOL7_REF_CNT                            0
+
+#define PAL_CPPI_PP_BUFFER_POOL8_COUNT                              0
+#define PAL_CPPI_PP_BUFFER_POOL8_SIZE                               0
+#define PAL_CPPI_PP_BUFFER_POOL8_REF_CNT                            0
+
+#define PAL_CPPI_PP_PACKET_RAM_512B_BUFFER_COUNT                    PAL_CPPI_PP_DOCSIS_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                +   \
+                                                                    PAL_CPPI_PP_RX_LOW_SHORT_SHARED_PACKET_RAM_EMB_FD_DESC_COUNT                        +   \
+                                                                    PAL_CPPI_PP_MoCA_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                  +   \
+                                                                    PAL_CPPI_PP_ATOM_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                  +   \
+                                                                    PAL_CPPI_PP_RGMII0_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                +   \
+                                                                    PAL_CPPI_PP_RGMII1_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                +   \
+                                                                    PAL_CPPI_PP_SGMII0_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                +   \
+                                                                    PAL_CPPI_PP_SGMII1_RX_LOW_SHORT_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT
+#define PAL_CPPI_PP_PACKET_RAM_512B_BUFFER_SIZE                     512
+#define PAL_CPPI_PP_PACKET_RAM_512B_BUFFER_REF_CNT                  0
+#define PAL_CPPI_PP_PACKET_RAM_512B_BUFFER_BASE                     0xF9000000
+
+#define PAL_CPPI_PP_PACKET_RAM_2KB_BUFFER_COUNT                     PAL_CPPI_PP_DOCSIS_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                 +   \
+                                                                    PAL_CPPI_PP_RX_LOW_LONG_SHARED_PACKET_RAM_EMB_FD_DESC_COUNT                         +   \
+                                                                    PAL_CPPI_PP_MoCA_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                   +   \
+                                                                    PAL_CPPI_PP_ATOM_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                   +   \
+                                                                    PAL_CPPI_PP_RGMII0_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                 +   \
+                                                                    PAL_CPPI_PP_RGMII1_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                 +   \
+                                                                    PAL_CPPI_PP_SGMII0_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT                 +   \
+                                                                    PAL_CPPI_PP_SGMII1_RX_LOW_LONG_PRIVATE_PACKET_RAM_EMB_FD_DESC_COUNT
+#define PAL_CPPI_PP_PACKET_RAM_2KB_BUFFER_SIZE                      (2 * 1024)
+#define PAL_CPPI_PP_PACKET_RAM_2KB_BUFFER_REF_CNT                   0
+#define PAL_CPPI_PP_PACKET_RAM_2KB_BUFFER_BASE                      0xF9040000
+
+#define PAL_CPPI_PP_VOICE_DSP_BUFFER_COUNT                          512
+#define PAL_CPPI_PP_VOICE_DSP_BUFFER_SIZE                           1024
+#define PAL_CPPI_PP_VOICE_DSP_BUFFER_REF_CNT                        0
+
+
+
+
+/*
++-+-+-+ +-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
+|D|S|G| |B|u|f|f|e|r| |M|a|n|a|g|e|r|s|
++-+-+-+ +-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
+*/
+
+typedef enum PAL_CPPI_DSG_BUF_MNGRS
+{
+    PAL_CPPI_OFDM0_BUF_MGR,                          /* OFDM0  */
+    PAL_CPPI_OFDM1_BUF_MGR,                          /* OFDM1  */
+    PAL_CPPI_SC_QAM0_BUF_MGR,                        /* SC-QAM */
+}
+PAL_CPPI_DSG_BUF_MNGRS_e;
+
+#define PAL_CPPI_OFDM0_BUF_MGR_BASE                                 (IO_ADDRESS(0xF2168000))
+#define PAL_CPPI_OFDM1_BUF_MGR_BASE                                 (IO_ADDRESS(0xF21E8000))
+#define PAL_CPPI_SC_QAM0_BUF_MGR_BASE                               (IO_ADDRESS(0xF2068000))
+
+/* OFDM0 DSG Buffer Pool Info */
+#define PAL_CPPI_OFDM0_BUFFER_POOL00                                0
+#define PAL_CPPI_OFDM0_BUFFER_POOL00_BUF_COUNT                      128
+#define PAL_CPPI_OFDM0_BUFFER_RAM_INTERNAL_ADDRESS                  0x20000
+
+/* OFDM1 DSG Buffer Pool Info */
+#define PAL_CPPI_OFDM1_BUFFER_POOL00                                0
+#define PAL_CPPI_OFDM1_BUFFER_POOL00_BUF_COUNT                      128
+#define PAL_CPPI_OFDM1_BUFFER_RAM_INTERNAL_ADDRESS                  0x20000
+
+/* SC-QAMs DSG Buffer Pool Info */
+#define PAL_CPPI_SC_QAM0_BUFFER_POOL00                              0
+#define PAL_CPPI_SC_QAM0_BUFFER_POOL00_BUF_COUNT                    256
+#define PAL_CPPI_SC_QAM0_BUFFER_RAM_INTERNAL_ADDRESS                0x20000
+
+/* DSGs Common Buffer Pool Info */
+#define PAL_CPPI_DS_DSG_BUFFER_POOL00_BUF_SIZE                      512
+#define PAL_CPPI_DS_DSG_BUFFER_POOL00_REF_CNT                       0
+
+/*
++-+-+ +-+-+-+-+-+-+ +-+-+-+-+-+-+-+
+|U|S| |B|u|f|f|e|r| |M|a|n|a|g|e|r|
++-+-+ +-+-+-+-+-+-+ +-+-+-+-+-+-+-+
+*/
+
+#define PAL_CPPI_MAC_US_BUF_MGR                 3
+#define PAL_CPPI41_NUM_BUF_MGR                  (PAL_CPPI_MAC_US_BUF_MGR + 1)           /* DSG domain has the maximum number of buffer managers */
+
+#define PAL_CPPI_MAC_US_BUF_MGR_BASE            (IO_ADDRESS(0xF2540000))
+
+typedef enum PAL_CPPI_MAC_US_BUFFER_POOLs
+{
+    PAL_CPPI_MAC_US_BUFFER_POOL0,
+
+    PAL_CPPI_MAC_US_TX_EMB_2K_BUFFER_POOL = PAL_CPPI_MAC_US_BUFFER_POOL0
+}
+PAL_CPPI_MAC_US_BUFFER_POOLs_e;
+
+
+#ifdef CONFIG_MACH_PUMA7_FPGA_US
+#define PAL_CPPI_MAC_US_TX_EMB_2K_BUFFER_COUNT                  256
+#else
+#define PAL_CPPI_MAC_US_TX_EMB_2K_BUFFER_COUNT                  (3 * 1024)
+#endif
+#define PAL_CPPI_MAC_US_TX_EMB_2K_BUFFER_SIZE                   2048
+#define PAL_CPPI_MAC_US_TX_EMB_2K_BUFFER_REF_CNT                1
+
+
+
+/**********************************************************************************************************************
+
+########  ##     ##    ###        ######  ##     ##    ###    ##    ## ##    ## ######## ##        ######
+##     ## ###   ###   ## ##      ##    ## ##     ##   ## ##   ###   ## ###   ## ##       ##       ##    ##
+##     ## #### ####  ##   ##     ##       ##     ##  ##   ##  ####  ## ####  ## ##       ##       ##
+##     ## ## ### ## ##     ##    ##       ######### ##     ## ## ## ## ## ## ## ######   ##        ######
+##     ## ##     ## #########    ##       ##     ## ######### ##  #### ##  #### ##       ##             ##
+##     ## ##     ## ##     ##    ##    ## ##     ## ##     ## ##   ### ##   ### ##       ##       ##    ##
+########  ##     ## ##     ##     ######  ##     ## ##     ## ##    ## ##    ## ######## ########  ######
+
+**********************************************************************************************************************/
+
+/*
++-+-+ +-+-+-+-+
+|P|P| |D|M|A|s|
++-+-+ +-+-+-+-+
+*/
+
+typedef enum PAL_CPPI_PP_DMA_BLOCKS
+{
+    PAL_CPPI_PP_DMA00_OFDM0_RX,
+    PAL_CPPI_PP_DMA01_OFDM1_RX,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX,
+    PAL_CPPI_PP_DMA03_SGMII0_RX,
+    PAL_CPPI_PP_DMA04_SGMII1_RX,
+    PAL_CPPI_PP_DMA05_RGMII0_RX,
+    PAL_CPPI_PP_DMA06_MoCA_RX_TX,
+    PAL_CPPI_PP_DMA07_ATOM_RX_TX,
+    PAL_CPPI_PP_DMA08_RX_TX_INFRA_WIFI_PROXY_RX_TX,
+    PAL_CPPI_PP_DMA09_INFRA_RX_TX,
+    PAL_CPPI_PP_DMA10_INFRA_RX_TX,
+    PAL_CPPI_PP_DMA11_INFRA_RX_TX,
+    PAL_CPPI_PP_DMA12_OFDM0_TX_QAM_0_3_TX,
+    PAL_CPPI_PP_DMA13_OFDM1_TX_QAM_4_7_TX,
+    PAL_CPPI_PP_DMA14_SGMII0_TX,
+    PAL_CPPI_PP_DMA15_SGMII1_TX,
+    PAL_CPPI_PP_DMA16_RGMII0_TX,
+    PAL_CPPI_PP_DMA17_UNUSED,
+    PAL_CPPI_PP_DMA18_UNUSED,
+    PAL_CPPI_PP_DMA19_UNUSED,
+    PAL_CPPI_PP_DMA20_UNUSED,
+    PAL_CPPI_PP_DMA21_US_COP_RX,
+    PAL_CPPI_PP_DMA22_US_COP_TX,
+    PAL_CPPI_PP_DMA23_RGMII1_RX_TX,
+
+    PAL_CPPI41_NUM_DMA_BLOCK
+
+}PAL_CPPI_PP_DMA_BLOCKS_e;
+
+
+// PAL_CPPI_PP_DMA00_OFDM0_RX
+#define PAL_CPPI_PP_DMA00_OFDM0_RX_CH_CFG_BASE          (IO_ADDRESS(0xF3900000))
+#define PAL_CPPI_PP_DMA00_OFDM0_RX_GLOBAL_CTRL_BASE     (IO_ADDRESS(0xF3901000))
+#define PAL_CPPI_PP_DMA00_OFDM0_RX_SCHEDULER_BASE       (IO_ADDRESS(0xF3901020))
+#define PAL_CPPI_PP_DMA00_OFDM0_RX_RAL_CFG_BASE         (IO_ADDRESS(0xF3940018))
+typedef enum PAL_CPPI_PP_DMA00_OFDM0_RX_CHANNELS
+{
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_LOW_512B_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_LOW_512B_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_LOW_512B_DESC_PACKET_RAM_BUFF_DDR,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_LOW_512B_SHARED_DDR,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_LOW_2KB_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_LOW_2KB_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_LOW_2KB_DESC_PACKET_RAM_BUFF_DDR,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_LOW_2KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_LOW_4KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_HIGH_DDR,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_MGMT_DDR,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_PLC_EM,       /* PLC Energy Management */
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_FCC_DDR,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_13,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_14,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CH_15,
+    PAL_CPPI_PP_DMA00_OFDM0_RX_CHANNELS_NUM
+} PAL_CPPI_PP_DMA00_OFDM0_RX_CHANNELS_e;
+
+// PAL_CPPI_PP_DMA01_OFDM1_RX
+#define PAL_CPPI_PP_DMA01_OFDM1_RX_CH_CFG_BASE          (IO_ADDRESS(0xF3902000))
+#define PAL_CPPI_PP_DMA01_OFDM1_RX_GLOBAL_CTRL_BASE     (IO_ADDRESS(0xF3903000))
+#define PAL_CPPI_PP_DMA01_OFDM1_RX_SCHEDULER_BASE       (IO_ADDRESS(0xF3903020))
+#define PAL_CPPI_PP_DMA01_OFDM1_RX_RAL_CFG_BASE         (IO_ADDRESS(0xF394001C))
+typedef enum PAL_CPPI_PP_DMA01_OFDM1_RX_CHANNELS
+{
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_LOW_512B_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_LOW_512B_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_LOW_512B_DESC_PACKET_RAM_BUFF_DDR,
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_LOW_512B_SHARED_DDR,
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_LOW_2KB_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_LOW_2KB_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_LOW_2KB_DESC_PACKET_RAM_BUFF_DDR,
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_LOW_2KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_LOW_4KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_HIGH_DDR,
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_MGMT_DDR,
+    PAL_CPPI_PP_DMA00_OFDM1_RX_CH_PLC_EM,       /* PLC Energy Management */
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_FCC_DDR,
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_13,
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_14,
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CH_15,
+    PAL_CPPI_PP_DMA01_OFDM1_RX_CHANNELS_NUM
+} PAL_CPPI_PP_DMA01_OFDM1_RX_CHANNELS_e;
+
+// PAL_CPPI_PP_DMA02_SC_QAM_RX
+#define PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_CFG_BASE         (IO_ADDRESS(0xF3904000))
+#define PAL_CPPI_PP_DMA02_SC_QAM_RX_GLOBAL_CTRL_BASE    (IO_ADDRESS(0xF3905000))
+#define PAL_CPPI_PP_DMA02_SC_QAM_RX_SCHEDULER_BASE      (IO_ADDRESS(0xF3905020))
+#define PAL_CPPI_PP_DMA02_SC_QAM_RX_RAL_CFG_BASE        (IO_ADDRESS(0xF3940020))
+typedef enum PAL_CPPI_PP_DMA02_SC_QAM_RX_CHANNELS
+{
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_LOW_512B_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_LOW_512B_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_LOW_512B_DESC_PACKET_RAM_BUFF_DDR,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_LOW_512B_SHARED_DDR,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_LOW_2KB_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_LOW_2KB_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_LOW_2KB_DESC_PACKET_RAM_BUFF_DDR,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_LOW_2KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_LOW_4KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_HIGH_DDR,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_MGMT_DDR,
+    PAL_CPPI_PP_DMA00_SC_QAM_RX_CH_PLC_EM,      /* to be align with OFDM DMAs */
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_FCC_DDR,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_13,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_14,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CH_15,
+    PAL_CPPI_PP_DMA02_SC_QAM_RX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA02_SC_QAM_RX_CHANNELS_e;
+
+// PAL_CPPI_PP_DMA03_SGMII0_RX
+#define PAL_CPPI_PP_DMA03_SGMII0_RX_CH_CFG_BASE         (IO_ADDRESS(0xF3906000))
+#define PAL_CPPI_PP_DMA03_SGMII0_RX_GLOBAL_CTRL_BASE    (IO_ADDRESS(0xF3907000))
+#define PAL_CPPI_PP_DMA03_SGMII0_RX_SCHEDULER_BASE      (IO_ADDRESS(0xF3907020))
+#define PAL_CPPI_PP_DMA03_SGMII0_RX_RAL_CFG_BASE        (IO_ADDRESS(0xF3940024))
+typedef enum PAL_CPPI_PP_DMA03_SGMII0_RX_CHANNELS
+{
+    PAL_CPPI_PP_DMA03_SGMII0_RX_CH_LOW_512B_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA03_SGMII0_RX_CH_LOW_512B_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA03_SGMII0_RX_CH_LOW_512B_PRIVATE_DDR,
+    PAL_CPPI_PP_DMA03_SGMII0_RX_CH_LOW_512B_SHARED_DDR,
+    PAL_CPPI_PP_DMA03_SGMII0_RX_CH_LOW_2KB_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA03_SGMII0_RX_CH_LOW_2KB_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA03_SGMII0_RX_CH_LOW_2KB_PRIVATE_DDR,
+    PAL_CPPI_PP_DMA03_SGMII0_RX_CH_LOW_2KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA03_SGMII0_RX_CH_LOW_4KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA03_SGMII0_RX_CH_HIGH_DDR,
+    PAL_CPPI_PP_DMA03_SGMII0_RX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA03_SGMII0_RX_CHANNELS_e;
+
+// PAL_CPPI_PP_DMA04_SGMII1_RX
+#define PAL_CPPI_PP_DMA04_SGMII1_RX_CH_CFG_BASE         (IO_ADDRESS(0xF3908000))
+#define PAL_CPPI_PP_DMA04_SGMII1_RX_GLOBAL_CTRL_BASE    (IO_ADDRESS(0xF3909000))
+#define PAL_CPPI_PP_DMA04_SGMII1_RX_SCHEDULER_BASE      (IO_ADDRESS(0xF3909020))
+#define PAL_CPPI_PP_DMA04_SGMII1_RX_RAL_CFG_BASE        (IO_ADDRESS(0xF3940028))
+typedef enum PAL_CPPI_PP_DMA04_SGMII1_RX_CHANNELS
+{
+    PAL_CPPI_PP_DMA04_SGMII1_RX_CH_LOW_512B_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA04_SGMII1_RX_CH_LOW_512B_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA04_SGMII1_RX_CH_LOW_512B_PRIVATE_DDR,
+    PAL_CPPI_PP_DMA04_SGMII1_RX_CH_LOW_512B_SHARED_DDR,
+    PAL_CPPI_PP_DMA04_SGMII1_RX_CH_LOW_2KB_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA04_SGMII1_RX_CH_LOW_2KB_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA04_SGMII1_RX_CH_LOW_2KB_PRIVATE_DDR,
+    PAL_CPPI_PP_DMA04_SGMII1_RX_CH_LOW_2KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA04_SGMII1_RX_CH_LOW_4KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA04_SGMII1_RX_CH_HIGH_DDR,
+    PAL_CPPI_PP_DMA04_SGMII1_RX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA04_SGMII1_RX_CHANNELS_e;
+
+// PAL_CPPI_PP_DMA05_RGMII0_RX
+#define PAL_CPPI_PP_DMA05_RGMII0_RX_CH_CFG_BASE         (IO_ADDRESS(0xF390A000))
+#define PAL_CPPI_PP_DMA05_RGMII0_RX_GLOBAL_CTRL_BASE    (IO_ADDRESS(0xF390B000))
+#define PAL_CPPI_PP_DMA05_RGMII0_RX_SCHEDULER_BASE      (IO_ADDRESS(0xF390B020))
+#define PAL_CPPI_PP_DMA05_RGMII0_RX_RAL_CFG_BASE        (IO_ADDRESS(0xF394002C))
+typedef enum PAL_CPPI_PP_DMA05_RGMII0_RX_CHANNELS
+{
+    PAL_CPPI_PP_DMA05_RGMII0_RX_CH_LOW_512B_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA05_RGMII0_RX_CH_LOW_512B_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA05_RGMII0_RX_CH_LOW_512B_PRIVATE_DDR,
+    PAL_CPPI_PP_DMA05_RGMII0_RX_CH_LOW_512B_SHARED_DDR,
+    PAL_CPPI_PP_DMA05_RGMII0_RX_CH_LOW_2KB_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA05_RGMII0_RX_CH_LOW_2KB_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA05_RGMII0_RX_CH_LOW_2KB_PRIVATE_DDR,
+    PAL_CPPI_PP_DMA05_RGMII0_RX_CH_LOW_2KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA05_RGMII0_RX_CH_LOW_4KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA05_RGMII0_RX_CH_HIGH_DDR,
+    PAL_CPPI_PP_DMA05_RGMII0_RX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA05_RGMII0_RX_CHANNELS_e;
+
+// PAL_CPPI_PP_DMA06_MoCA_RX_TX
+#define PAL_CPPI_PP_DMA06_MoCA_RX_TX_CH_CFG_BASE        (IO_ADDRESS(0xF390C000))
+#define PAL_CPPI_PP_DMA06_MoCA_RX_TX_GLOBAL_CTRL_BASE   (IO_ADDRESS(0xF390D000))
+#define PAL_CPPI_PP_DMA06_MoCA_RX_TX_SCHEDULER_BASE     (IO_ADDRESS(0xF390D020))
+#define PAL_CPPI_PP_DMA06_MoCA_RX_RAL_CFG_BASE          (IO_ADDRESS(0xF3940030))
+#define PAL_CPPI_PP_DMA06_MoCA_RX_CMD1                  (IO_ADDRESS(0xf3940008))
+#define PAL_CPPI_PP_DMA06_MoCA_RX_CFG0                  (IO_ADDRESS(0xf394000c))
+#define PAL_CPPI_PP_DMA06_MoCA_RX_CFG1                  (IO_ADDRESS(0xf3940010))
+
+// PAL_CPPI_PP_DMA06_MoCA_RX
+typedef enum PAL_CPPI_PP_DMA06_MoCA_RX_CHANNELS
+{
+    PAL_CPPI_PP_DMA06_MoCA_RX_CH_LOW_512B_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA06_MoCA_RX_CH_LOW_512B_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA06_MoCA_RX_CH_LOW_512B_PRIVATE_DDR,
+    PAL_CPPI_PP_DMA06_MoCA_RX_CH_LOW_512B_SHARED_DDR,
+    PAL_CPPI_PP_DMA06_MoCA_RX_CH_LOW_2KB_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA06_MoCA_RX_CH_LOW_2KB_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA06_MoCA_RX_CH_LOW_2KB_PRIVATE_DDR,
+    PAL_CPPI_PP_DMA06_MoCA_RX_CH_LOW_2KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA06_MoCA_RX_CH_LOW_4KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA06_MoCA_RX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA06_MoCA_RX_CHANNELS_e;
+// PAL_CPPI_PP_DMA06_MoCA_TX
+#define PAL_CPPI_PP_DMA06_MoCA_TX_CH            0
+#define PAL_CPPI_PP_DMA06_MoCA_TX_CHANNELS_NUM  1
+
+// PAL_CPPI_PP_DMA07_ATOM_RX_TX
+#define PAL_CPPI_PP_DMA07_ATOM_RX_TX_CH_CFG_BASE        (IO_ADDRESS(0xF390E000))
+#define PAL_CPPI_PP_DMA07_ATOM_RX_TX_GLOBAL_CTRL_BASE   (IO_ADDRESS(0xF390F000))
+#define PAL_CPPI_PP_DMA07_ATOM_RX_TX_SCHEDULER_BASE     (IO_ADDRESS(0xF390F020))
+#define PAL_CPPI_PP_DMA07_ATOM_RX_RAL_CFG_BASE          (IO_ADDRESS(0xF3940034))
+// PAL_CPPI_PP_DMA07_ATOM_RX
+typedef enum PAL_CPPI_PP_DMA07_ATOM_RX_CHANNELS
+{
+    PAL_CPPI_PP_DMA07_ATOM_RX_CH_LOW_512B_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA07_ATOM_RX_CH_LOW_512B_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA07_ATOM_RX_CH_LOW_512B_PRIVATE_DDR,
+    PAL_CPPI_PP_DMA07_ATOM_RX_CH_LOW_512B_SHARED_DDR,
+    PAL_CPPI_PP_DMA07_ATOM_RX_CH_LOW_2KB_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA07_ATOM_RX_CH_LOW_2KB_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA07_ATOM_RX_CH_LOW_2KB_PRIVATE_DDR,
+    PAL_CPPI_PP_DMA07_ATOM_RX_CH_LOW_2KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA07_ATOM_RX_CH_LOW_4KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA07_ATOM_RX_CH_HIGH_DDR,
+    PAL_CPPI_PP_DMA07_ATOM_RX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA07_ATOM_RX_CHANNELS_e;
+// PAL_CPPI_PP_DMA07_ATOM_TX
+#define PAL_CPPI_PP_DMA07_ATOM_TX_CH            0
+#define PAL_CPPI_PP_DMA07_ATOM_TX_CHANNELS_NUM  1
+
+// PAL_CPPI_PP_DMA08_RX_TX_INFRA_WIFI_PROXY_RX_TX
+#define PAL_CPPI_PP_DMA08_RX_TX_INFRA_WIFI_PROXY_RX_TX_CH_CFG_BASE        (IO_ADDRESS(0xF3910000))
+#define PAL_CPPI_PP_DMA08_RX_TX_INFRA_WIFI_PROXY_RX_TX_GLOBAL_CTRL_BASE   (IO_ADDRESS(0xF3911000))
+#define PAL_CPPI_PP_DMA08_RX_TX_INFRA_WIFI_PROXY_RX_TX_SCHEDULER_BASE     (IO_ADDRESS(0xF3911020))
+// PAL_CPPI_PP_DMA08_MPEG_RX_INFRA_RX
+typedef enum PAL_CPPI_PP_DMA08_RX_WIFI_PROXY_INFRA_RX_CHANNELS
+{
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_0,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_1,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_2,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_3,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_4,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_5,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_6,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_7,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_8,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_9,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_10,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_11,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_12,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_13,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_14,
+    PAL_CPPI_PP_DMA08_MP2TS_RX_CH_15,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE0_HOST_RX_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE1_HOST_RX_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE2_HOST_RX_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE3_HOST_RX_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE0_TX_FW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE1_TX_FW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE2_TX_FW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE3_TX_FW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA08_RX_WIFI_PROXY_INFRA_RX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA08_RX_WIFI_PROXY_INFRA_RX_CHANNELS_e;
+// PAL_CPPI_PP_DMA08_RX_WIFI_PROXY_INFRA_TX_CHANNELS
+typedef enum PAL_CPPI_PP_DMA08_RX_WIFI_PROXY_INFRA_TX_CHANNELS
+{
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_0,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_1,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_2,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_3,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_4,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_5,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_6,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_7,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_8,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_9,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_10,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_11,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_12,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_13,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_14,
+    PAL_CPPI_PP_DMA08_UNUSED_TX_CH_15,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE0_HOST_RX_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE1_HOST_RX_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE2_HOST_RX_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE3_HOST_RX_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE0_TX_FW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE1_TX_FW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE2_TX_FW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA08_WIFI_DEVICE3_TX_FW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA08_RX_WIFI_PROXY_INFRA_TX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA08_RX_WIFI_PROXY_INFRA_TX_CHANNELS_e;
+
+
+// PAL_CPPI_PP_DMA09_INFRA_RX_TX
+#define PAL_CPPI_PP_DMA09_INFRA_RX_TX_CH_CFG_BASE           (IO_ADDRESS(0xF3912000))
+#define PAL_CPPI_PP_DMA09_INFRA_RX_TX_GLOBAL_CTRL_BASE      (IO_ADDRESS(0xF3913000))
+#define PAL_CPPI_PP_DMA09_INFRA_RX_TX_SCHEDULER_BASE        (IO_ADDRESS(0xF3913020))
+// PAL_CPPI_PP_DMA09_INFRA_RX
+typedef enum PAL_CPPI_PP_DMA09_INFRA_RX_CHANNELS
+{
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_0,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_1,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_2,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_3,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_4,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_5,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_6,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_7,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_8,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_9,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_10,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_11,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_12,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_13,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_14,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_15,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_16,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_17,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_18,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CH_19,
+    PAL_CPPI_PP_DMA09_WIFI_DEVICE0_TX_FW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA09_WIFI_DEVICE1_TX_FW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA09_WIFI_DEVICE2_TX_FW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA09_WIFI_DEVICE3_TX_FW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA09_INFRA_RX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA09_INFRA_RX_CHANNELS_e;
+// PAL_CPPI_PP_DMA09_INFRA_TX
+typedef enum PAL_CPPI_PP_DMA09_INFRA_TX_CHANNELS
+{
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_0,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_1,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_2,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_3,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_4,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_5,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_6,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_7,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_8,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_9,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_10,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_11,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_12,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_13,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_14,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_15,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_16,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_17,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_18,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CH_19,
+    PAL_CPPI_PP_DMA09_WIFI_DEVICE0_TX_FW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA09_WIFI_DEVICE1_TX_FW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA09_WIFI_DEVICE2_TX_FW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA09_WIFI_DEVICE3_TX_FW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA09_INFRA_TX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA09_INFRA_TX_CHANNELS_e;
+
+// PAL_CPPI_PP_DMA10_INFRA_RX_TX
+#define PAL_CPPI_PP_DMA10_INFRA_RX_TX_CH_CFG_BASE           (IO_ADDRESS(0xF3914000))
+#define PAL_CPPI_PP_DMA10_INFRA_RX_TX_GLOBAL_CTRL_BASE      (IO_ADDRESS(0xF3915000))
+#define PAL_CPPI_PP_DMA10_INFRA_RX_TX_SCHEDULER_BASE        (IO_ADDRESS(0xF3915020))
+// PAL_CPPI_PP_DMA10_INFRA_RX
+typedef enum PAL_CPPI_PP_DMA10_INFRA_RX_CHANNELS
+{
+    PAL_CPPI_PP_DMA10_DOCSIS_LOW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_DOCSIS_HIGH_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_MoCA_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_ATOM_LOW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_ATOM_HIGH_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_RGMII0_LOW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_RGMII0_HIGH_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_RGMII1_LOW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_RGMII1_HIGH_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_SGMII0_LOW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_SGMII0_HIGH_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_SGMII1_LOW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_SGMII1_HIGH_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_WiFi_LOW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_WiFi_HIGH_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_INFRA_RX_CH_15,
+    PAL_CPPI_PP_DMA10_INFRA_RX_CH_16,
+    PAL_CPPI_PP_DMA10_VOICE_DSP_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_NP2APP_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_APP2NP_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA10_INFRA_RX_CH_20,
+    PAL_CPPI_PP_DMA10_INFRA_RX_CH_21,
+    PAL_CPPI_PP_DMA10_INFRA_RX_CH_22,
+    PAL_CPPI_PP_DMA10_INFRA_RX_CH_23,
+    PAL_CPPI_PP_DMA10_INFRA_RX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA10_INFRA_RX_CHANNELS_e;
+// PAL_CPPI_PP_DMA10_INFRA_TX
+typedef enum PAL_CPPI_PP_DMA10_INFRA_TX_CHANNELS
+{
+    PAL_CPPI_PP_DMA10_DOCSIS_LOW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_DOCSIS_HIGH_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_MoCA_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_ATOM_LOW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_ATOM_HIGH_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_RGMII0_LOW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_RGMII0_HIGH_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_RGMII1_LOW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_RGMII1_HIGH_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_SGMII0_LOW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_SGMII0_HIGH_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_SGMII1_LOW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_SGMII1_HIGH_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_WiFi_LOW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_WiFi_HIGH_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_INFRA_TX_CH_15,
+    PAL_CPPI_PP_DMA10_INFRA_TX_CH_16,
+    PAL_CPPI_PP_DMA10_VOICE_DSP_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_NP2APP_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_APP2NP_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA10_INFRA_TX_CH_20,
+    PAL_CPPI_PP_DMA10_INFRA_TX_CH_21,
+    PAL_CPPI_PP_DMA10_INFRA_TX_CH_22,
+    PAL_CPPI_PP_DMA10_INFRA_TX_CH_23,
+    PAL_CPPI_PP_DMA10_INFRA_TX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA10_INFRA_TX_CHANNELS_e;
+
+
+// PAL_CPPI_PP_DMA11_INFRA_RX_TX
+#define PAL_CPPI_PP_DMA11_INFRA_RX_TX_CH_CFG_BASE           (IO_ADDRESS(0xF3916000))
+#define PAL_CPPI_PP_DMA11_INFRA_RX_TX_GLOBAL_CTRL_BASE      (IO_ADDRESS(0xF3917000))
+#define PAL_CPPI_PP_DMA11_INFRA_RX_TX_SCHEDULER_BASE        (IO_ADDRESS(0xF3917020))
+// PAL_CPPI_PP_DMA11_INFRA_RX
+typedef enum PAL_CPPI_PP_DMA11_INFRA_RX_CHANNELS
+{
+    PAL_CPPI_PP_DMA11_HOST2PP_LOW_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA11_HOST2PP_HIGH_INFRA_RX_CH,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_2,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_3,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_4,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_5,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_6,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_7,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_8,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_9,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_10,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_11,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_12,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_13,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_14,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_15,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_16,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_17,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_18,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_19,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_20,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_21,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_22,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CH_23,
+    PAL_CPPI_PP_DMA11_INFRA_RX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA11_INFRA_RX_CHANNELS_e;
+// PAL_CPPI_PP_DMA11_INFRA_TX
+typedef enum PAL_CPPI_PP_DMA11_INFRA_TX_CHANNELS
+{
+    PAL_CPPI_PP_DMA11_HOST2PP_LOW_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA11_HOST2PP_HIGH_INFRA_TX_CH,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_2,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_3,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_4,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_5,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_6,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_7,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_8,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_9,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_10,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_11,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_12,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_13,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_14,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_15,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_16,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_17,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_18,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_19,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_20,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_21,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_22,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CH_23,
+    PAL_CPPI_PP_DMA11_INFRA_TX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA11_INFRA_TX_CHANNELS_e;
+
+
+// PAL_CPPI_PP_DMA12_OFDM0_TX_QAM_0_3_TX
+#define PAL_CPPI_PP_DMA12_OFDM0_TX_QAM_0_3_TX_CH_CFG_BASE           (IO_ADDRESS(0xF3918000))
+#define PAL_CPPI_PP_DMA12_OFDM0_TX_QAM_0_3_TX_GLOBAL_CTRL_BASE      (IO_ADDRESS(0xF3919000))
+#define PAL_CPPI_PP_DMA12_OFDM0_TX_QAM_0_3_TX_SCHEDULER_BASE        (IO_ADDRESS(0xF3919020))
+typedef enum PAL_CPPI_PP_DMA12_OFDM0_TX_QAM_0_3_TX_CHANNELS
+{
+    PAL_CPPI_PP_DMA12_OFDM0_TX_CH,
+    PAL_CPPI_PP_DMA12_SC_QAM0_TX_CH,
+    PAL_CPPI_PP_DMA12_SC_QAM1_TX_CH,
+    PAL_CPPI_PP_DMA12_SC_QAM2_TX_CH,
+    PAL_CPPI_PP_DMA12_SC_QAM3_TX_CH,
+    PAL_CPPI_PP_DMA12_OFDM0_TX_QAM_0_3_TX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA12_OFDM0_TX_QAM_0_3_TX_CHANNELS_e;
+
+// PAL_CPPI_PP_DMA13_OFDM1_TX_QAM_4_7_TX
+#define PAL_CPPI_PP_DMA13_OFDM1_TX_QAM_4_7_TX_CH_CFG_BASE           (IO_ADDRESS(0xF391A000))
+#define PAL_CPPI_PP_DMA13_OFDM1_TX_QAM_4_7_TX_GLOBAL_CTRL_BASE      (IO_ADDRESS(0xF391B000))
+#define PAL_CPPI_PP_DMA13_OFDM1_TX_QAM_4_7_TX_SCHEDULER_BASE        (IO_ADDRESS(0xF391B020))
+typedef enum PAL_CPPI_PP_DMA13_OFDM1_TX_QAM_4_7_TX_CHANNELS
+{
+    PAL_CPPI_PP_DMA13_OFDM1_TX_CH,
+    PAL_CPPI_PP_DMA13_SC_QAM4_TX_CH,
+    PAL_CPPI_PP_DMA13_SC_QAM5_TX_CH,
+    PAL_CPPI_PP_DMA13_SC_QAM6_TX_CH,
+    PAL_CPPI_PP_DMA13_SC_QAM7_TX_CH,
+    PAL_CPPI_PP_DMA13_OFDM1_TX_QAM_4_7_TX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA13_OFDM1_TX_QAM_4_7_TX_CHANNELS_e;
+
+// PAL_CPPI_PP_DMA14_SGMII0_TX
+#define PAL_CPPI_PP_DMA14_SGMII0_TX_CH_CFG_BASE         (IO_ADDRESS(0xF391C000))
+#define PAL_CPPI_PP_DMA14_SGMII0_TX_GLOBAL_CTRL_BASE    (IO_ADDRESS(0xF391D000))
+#define PAL_CPPI_PP_DMA14_SGMII0_TX_SCHEDULER_BASE      (IO_ADDRESS(0xF391D020))
+#define PAL_CPPI_PP_DMA14_SGMII0_TX_CH                  0
+#define PAL_CPPI_PP_DMA14_SGMII0_TX_CHANNELS_NUM        1
+
+// PAL_CPPI_PP_DMA15_SGMII1_TX
+#define PAL_CPPI_PP_DMA15_SGMII1_TX_CH_CFG_BASE         (IO_ADDRESS(0xF391E000))
+#define PAL_CPPI_PP_DMA15_SGMII1_TX_GLOBAL_CTRL_BASE    (IO_ADDRESS(0xF391F000))
+#define PAL_CPPI_PP_DMA15_SGMII1_TX_SCHEDULER_BASE      (IO_ADDRESS(0xF391F020))
+#define PAL_CPPI_PP_DMA15_SGMII1_TX_CH                  0
+#define PAL_CPPI_PP_DMA15_SGMII1_TX_CHANNELS_NUM        1
+
+// PAL_CPPI_PP_DMA16_RGMII0_TX
+#define PAL_CPPI_PP_DMA16_RGMII0_TX_CH_CFG_BASE         (IO_ADDRESS(0xF3920000))
+#define PAL_CPPI_PP_DMA16_RGMII0_TX_GLOBAL_CTRL_BASE    (IO_ADDRESS(0xF3921000))
+#define PAL_CPPI_PP_DMA16_RGMII0_TX_SCHEDULER_BASE      (IO_ADDRESS(0xF3921020))
+#define PAL_CPPI_PP_DMA16_RGMII0_TX_CH                  0
+#define PAL_CPPI_PP_DMA16_RGMII0_TX_CHANNELS_NUM        1
+
+// PAL_CPPI_PP_DMA21_US_COP_RX
+#define PAL_CPPI_PP_DMA21_US_COP_RX_CH_CFG_BASE         (IO_ADDRESS(0xF392A000))
+#define PAL_CPPI_PP_DMA21_US_COP_RX_GLOBAL_CTRL_BASE    (IO_ADDRESS(0xF392B000))
+#define PAL_CPPI_PP_DMA21_US_COP_RX_SCHEDULER_BASE      (IO_ADDRESS(0xF392B020))
+#define PAL_CPPI_PP_DMA21_US_COP_RX_CH                  0
+#define PAL_CPPI_PP_DMA21_US_COP_RX_CHANNELS_NUM        1
+
+// PAL_CPPI_PP_DMA22_US_COP_TX
+#define PAL_CPPI_PP_DMA22_US_COP_TX_CH_CFG_BASE         (IO_ADDRESS(0xF392C000))
+#define PAL_CPPI_PP_DMA22_US_COP_TX_GLOBAL_CTRL_BASE    (IO_ADDRESS(0xF392D000))
+#define PAL_CPPI_PP_DMA22_US_COP_TX_SCHEDULER_BASE      (IO_ADDRESS(0xF392D020))
+#define PAL_CPPI_PP_DMA22_US_COP_TX_CH                  0
+#define PAL_CPPI_PP_DMA22_US_COP_TX_CHANNELS_NUM        1
+
+
+// PAL_CPPI_PP_DMA23_RGMII1_RX_TX
+#define PAL_CPPI_PP_DMA23_RGMII1_RX_TX_CH_CFG_BASE      (IO_ADDRESS(0xF392E000))
+#define PAL_CPPI_PP_DMA23_RGMII1_RX_TX_GLOBAL_CTRL_BASE (IO_ADDRESS(0xF392F000))
+#define PAL_CPPI_PP_DMA23_RGMII1_RX_TX_SCHEDULER_BASE   (IO_ADDRESS(0xF392F020))
+#define PAL_CPPI_PP_DMA23_RGMII1_RX_RAL_CFG_BASE        (IO_ADDRESS(0xF3940038))
+// PAL_CPPI_PP_DMA23_RGMII1_RX
+typedef enum PAL_CPPI_PP_DMA23_RGMII1_RX_CHANNELS
+{
+    PAL_CPPI_PP_DMA23_RGMII1_RX_CH_LOW_512B_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA23_RGMII1_RX_CH_LOW_512B_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA23_RGMII1_RX_CH_LOW_512B_PRIVATE_DDR,
+    PAL_CPPI_PP_DMA23_RGMII1_RX_CH_LOW_512B_SHARED_DDR,
+    PAL_CPPI_PP_DMA23_RGMII1_RX_CH_LOW_2KB_PRIVATE_PACKET_RAM,
+    PAL_CPPI_PP_DMA23_RGMII1_RX_CH_LOW_2KB_SHARED_PACKET_RAM,
+    PAL_CPPI_PP_DMA23_RGMII1_RX_CH_LOW_2KB_PRIVATE_DDR,
+    PAL_CPPI_PP_DMA23_RGMII1_RX_CH_LOW_2KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA23_RGMII1_RX_CH_LOW_4KB_SHARED_DDR,
+    PAL_CPPI_PP_DMA23_RGMII1_RX_CH_HIGH_DDR,
+    PAL_CPPI_PP_DMA23_RGMII1_RX_CHANNELS_NUM
+}PAL_CPPI_PP_DMA23_RGMII1_RX_CHANNELS_e;
+// PAL_CPPI_PP_DMA23_RGMII_TX
+#define PAL_CPPI_PP_DMA23_RGMII_TX_CH                   0
+#define PAL_CPPI_PP_DMA23_RGMII_TX_CHANNELS_NUM         1
+
+
+#define PAL_CPPI41_NUM_TOTAL_CHAN                       24
+#define PAL_CPPI41_PP_NUM_TOTAL_CHAN                    24
+#define PAL_CPPI41_DSG_NUM_TOTAL_CHAN                   32
+// TBD - US team to set their own value
+#define PAL_CPPI41_MAX_TOTAL_CHAN                       32
+
+
+/*
++-+-+-+ +-+-+-+-+
+|D|S|G| |D|M|A|s|
++-+-+-+ +-+-+-+-+
+*/
+
+
+typedef enum PAL_CPPI_DSG_DMA_BLOCKS
+{
+    PAL_CPPI_OFDM0_RX_DMA,                           /* OFDM0  */
+    PAL_CPPI_OFDM1_RX_DMA,                           /* OFDM1  */
+    PAL_CPPI_SC_QAM0_RX_DMA,                         /* SC-QAM */
+
+    PAL_CPPI_OFDM0_TX_DMA,                           /* OFDM0  */
+    PAL_CPPI_OFDM1_TX_DMA,                           /* OFDM1  */
+    PAL_CPPI_SC_QAM0_TX_DMA,                         /* SC-QAM */
+
+    PAL_CPPI_DSG_NUM_DMA_BLOCK
+
+}PAL_CPPI_DSG_DMA_BLOCKS_e;
+
+#define PAL_CPPI_DMA_NUM_TO_QMGR_NUM(dmaNum)        0
+
+#define PAL_CPPI_DSG_NUM_TOTAL_CHAN                 32
+
+/* PAL_CPPI_OFDM0_RX_DMA */
+#define PAL_CPPI_OFDM0_RX_DMA_CH_CFG_BASE              (IO_ADDRESS(0xF2150000))
+#define PAL_CPPI_OFDM0_RX_DMA_GLOBAL_CTRL_BASE         (IO_ADDRESS(0xF2151000))
+#define PAL_CPPI_OFDM0_RX_DMA_SCHEDULER_BASE           (IO_ADDRESS(0xF214E000))
+
+/* PAL_CPPI_OFDM0_TX_DMA */
+#define PAL_CPPI_OFDM0_TX_DMA_CH_CFG_BASE              (IO_ADDRESS(0xF2152000))
+#define PAL_CPPI_OFDM0_TX_DMA_GLOBAL_CTRL_BASE         (IO_ADDRESS(0xF2153000))
+#define PAL_CPPI_OFDM0_TX_DMA_SCHEDULER_BASE           NULL
+
+/* PAL_CPPI_OFDM1_RX_DMA */
+#define PAL_CPPI_OFDM1_RX_DMA_CH_CFG_BASE              (IO_ADDRESS(0xF21D0000))
+#define PAL_CPPI_OFDM1_RX_DMA_GLOBAL_CTRL_BASE         (IO_ADDRESS(0xF21D1000))
+#define PAL_CPPI_OFDM1_RX_DMA_SCHEDULER_BASE           (IO_ADDRESS(0xF21CE000))
+
+/* PAL_CPPI_OFDM1_TX_DMA */
+#define PAL_CPPI_OFDM1_TX_DMA_CH_CFG_BASE              (IO_ADDRESS(0xF21D2000))
+#define PAL_CPPI_OFDM1_TX_DMA_GLOBAL_CTRL_BASE         (IO_ADDRESS(0xF21D3000))
+#define PAL_CPPI_OFDM1_TX_DMA_SCHEDULER_BASE           NULL
+
+/* PAL_CPPI_SC_QAM0_RX_DMA */
+#define PAL_CPPI_SC_QAM0_RX_DMA_CH_CFG_BASE            (IO_ADDRESS(0xF2050000))
+#define PAL_CPPI_SC_QAM0_RX_DMA_GLOBAL_CTRL_BASE       (IO_ADDRESS(0xF2051000))
+#define PAL_CPPI_SC_QAM0_RX_DMA_SCHEDULER_BASE         (IO_ADDRESS(0xF204E000))
+
+/* PAL_CPPI_SC_QAM0_TX_DMA */
+#define PAL_CPPI_SC_QAM0_TX_DMA_CH_CFG_BASE            (IO_ADDRESS(0xF2052000))
+#define PAL_CPPI_SC_QAM0_TX_DMA_GLOBAL_CTRL_BASE       (IO_ADDRESS(0xF2053000))
+#define PAL_CPPI_SC_QAM0_TX_DMA_SCHEDULER_BASE         NULL
+
+
+/**********************************************************************************************************************
+
+   ###     ######   ######  ##     ## ##     ## ##     ## ##          ###    ########  #######  ########
+  ## ##   ##    ## ##    ## ##     ## ###   ### ##     ## ##         ## ##      ##    ##     ## ##     ##
+ ##   ##  ##       ##       ##     ## #### #### ##     ## ##        ##   ##     ##    ##     ## ##     ##
+##     ## ##       ##       ##     ## ## ### ## ##     ## ##       ##     ##    ##    ##     ## ########
+######### ##       ##       ##     ## ##     ## ##     ## ##       #########    ##    ##     ## ##   ##
+##     ## ##    ## ##    ## ##     ## ##     ## ##     ## ##       ##     ##    ##    ##     ## ##    ##
+##     ##  ######   ######   #######  ##     ##  #######  ######## ##     ##    ##     #######  ##     ##
+
+    Accumulator INTD0 Configuration                                             Accumulator INTD1 Configuration
+    ===============================                                             ===============================
+
+    Channel Interrupt   Usage                                                   Channel Interrupt   Usage
+    -------------------------------------------                                 -------------------------------------------
+    0       0           HOST to PP Tx Complete LOW                              0       0
+    1                   HOST to PP Tx Complete HIGH                             1
+    -------------------------------------------                                 -------------------------------------------
+    2       1           MoCA RX                                                 2       1
+    3                                                                           3
+    4                                                                           4
+    5                                                                           5
+    -------------------------------------------                                 -------------------------------------------
+    6       2           SGMII0 RX Low                                           6       2
+    -------------------------------------------                                 -------------------------------------------
+    7       3           SGMII0 RX High                                          7       3
+    -------------------------------------------                                 -------------------------------------------
+    8       4           SGMII1 RX Low                                           8       4           NP2APP RX
+    -------------------------------------------                                 -------------------------------------------
+    9       5           SGMII1 RX High                                          9       5           APP2NP RX
+    -------------------------------------------                                 -------------------------------------------
+    10      6           RGMII0 RX Low                                           10      6           NP2APP TX Complete
+    -------------------------------------------                                 -------------------------------------------
+    11      7           RGMII0 RX High                                          11      7           APP2NP TX Complete
+    -------------------------------------------                                 -------------------------------------------
+    12      8           RGMII1 RX Low                                           12      8           WiFi RX 0
+    -------------------------------------------                                 -------------------------------------------
+    13      9           RGMII1 RX High                                          13      9           WiFi RX 1
+    -------------------------------------------                                 -------------------------------------------
+    14      10          ATOM RX Low                                             14      10          WiFi RX 2
+    -------------------------------------------                                 -------------------------------------------
+    15      11          ATOM RX High                                            15      11          WiFi RX 3
+    -------------------------------------------                                 -------------------------------------------
+    16      12          DOCSIS Management RX
+    17
+    18
+    19
+    -------------------------------------------
+    20      13          DOCSIS RX Low
+    21
+    22
+    23
+    -------------------------------------------
+    24      14          DOCSIS RX High
+    25
+    26
+    27
+    -------------------------------------------
+    28      15          Voice RX
+    29
+    30
+    31
+    -------------------------------------------
+
+**********************************************************************************************************************/
+
+/*
++-+-+-+-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
+|A|c|c|u|m|u|l|a|t|o|r| |C|h|a|n|n|e|l|s|
++-+-+-+-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+
+*/
+typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD0_CHANNELS
+{
+    PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_CH_BASE,
+        PAL_CPPI_PP_HOST2PP_TX_COMPLETE_LOW_INTD0_ACC_CH_NUM = PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_CH_BASE,   // 0
+        PAL_CPPI_PP_HOST2PP_TX_COMPLETE_HIGH_INTD0_ACC_CH_NUM,                                                      // 1
+    PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_CH_LAST = PAL_CPPI_PP_HOST2PP_TX_COMPLETE_HIGH_INTD0_ACC_CH_NUM,
+
+    PAL_CPPI_PP_MoCA_RX_INTD0_ACC_CH_NUM,                                                                           // 2
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_3,                                                                        // 3
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_4,                                                                        // 4
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_5,                                                                        // 5
+    PAL_CPPI_PP_SGMII0_RX_LOW_INTD0_ACC_CH_NUM,                                                                     // 6
+    PAL_CPPI_PP_SGMII0_RX_HIGH_INTD0_ACC_CH_NUM,                                                                    // 7
+    PAL_CPPI_PP_SGMII1_RX_LOW_INTD0_ACC_CH_NUM,                                                                     // 8
+    PAL_CPPI_PP_SGMII1_RX_HIGH_INTD0_ACC_CH_NUM,                                                                    // 9
+    PAL_CPPI_PP_RGMII0_RX_LOW_INTD0_ACC_CH_NUM,                                                                     // 10
+    PAL_CPPI_PP_RGMII0_RX_HIGH_INTD0_ACC_CH_NUM,                                                                    // 11
+    PAL_CPPI_PP_RGMII1_RX_LOW_INTD0_ACC_CH_NUM,                                                                     // 12
+    PAL_CPPI_PP_RGMII1_RX_HIGH_INTD0_ACC_CH_NUM,                                                                    // 13
+    PAL_CPPI_PP_ATOM_RX_LOW_INTD0_ACC_CH_NUM,                                                                       // 14
+    PAL_CPPI_PP_ATOM_RX_HIGH_INTD0_ACC_CH_NUM,                                                                      // 15
+    PAL_CPPI_PP_DOCSIS_RX_MGMT_INTD0_ACC_CH_NUM,                                                                    // 16
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_17,                                                                       // 17
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_18,                                                                       // 18
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_19,                                                                       // 19
+    PAL_CPPI_PP_DOCSIS_RX_LOW_INTD0_ACC_CH_NUM,                                                                     // 20
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_21,                                                                       // 21
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_22,                                                                       // 22
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_23,                                                                       // 23
+    PAL_CPPI_PP_DOCSIS_RX_HIGH_INTD0_ACC_CH_NUM,                                                                    // 24
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_25,                                                                       // 25
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_26,                                                                       // 26
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_27,                                                                       // 27
+    PAL_CPPI_PP_VOICE_RX_INTD0_ACC_CH_NUM,                                                                         // 28
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_29,                                                                       // 29
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_30,                                                                       // 30
+    PAL_CPPI_PP_RESERVED_INTD0_ACC_CH_NUM_31,                                                                       // 31
+    PAL_CPPI_PP_INTD0_ACCUMULATOR_MAX_CHANNELS
+}PAL_CPPI_PP_ACCUMULATOR_INTD0_CHANNELS_e;
+
+typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD1_CHANNELS
+{
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_0,                                                                        // 0
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_1,                                                                        // 1
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_2,                                                                        // 2
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_3,                                                                        // 3
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_4,                                                                        // 4
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_CH_NUM_5,                                                                        // 5
+    PAL_CPPI_PP_IPSEC_ENCRYPT_INTD1_ACC_CH_NUM,                                                                     // 6
+    PAL_CPPI_PP_IPSEC_DECRYPT_INTD1_ACC_CH_NUM,                                                                     // 7
+    PAL_CPPI_PP_NP2APP_RX_INTD1_ACC_CH_NUM,                                                                         // 8
+    PAL_CPPI_PP_NP2APP_TX_COMPLETE_INTD1_ACC_CH_NUM,                                                                // 9
+    PAL_CPPI_PP_APP2NP_RX_INTD1_ACC_CH_NUM,                                                                         // 10
+    PAL_CPPI_PP_APP2NP_TX_COMPLETE_INTD1_ACC_CH_NUM,                                                                // 11
+    PAL_CPPI_PP_WiFi_RX_0_INTD1_ACC_CH_NUM,                                                                         // 12
+    PAL_CPPI_PP_WiFi_RX_1_INTD1_ACC_CH_NUM,                                                                         // 13
+    PAL_CPPI_PP_WiFi_RX_2_INTD1_ACC_CH_NUM,                                                                         // 14
+    PAL_CPPI_PP_WiFi_RX_3_INTD1_ACC_CH_NUM,                                                                         // 15
+    PAL_CPPI_PP_INTD1_ACCUMULATOR_MAX_CHANNELS
+}PAL_CPPI_PP_ACCUMULATOR_INTD1_CHANNELS_e;
+
+#define PAL_CPPI_PP_ACC_INTD1_CH_TO_ACC_CH(ch)		    ((ch) + PAL_CPPI_PP_INTD0_ACCUMULATOR_MAX_CHANNELS)
+
+/*
++-+-+-+-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+
+|A|c|c|u|m|u|l|a|t|o|r| |I|n|t|e|r|r|u|p|t| |V|e|c|t|o|r|s|
++-+-+-+-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+-+-+ +-+-+-+-+-+-+-+
+*/
+typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD0_INTERRUPT_VECTORS
+{
+    PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_INTV_NUM,                                                             // 0
+    PAL_CPPI_PP_MoCA_RX_INTD0_ACC_INTV_NUM,                                                                         // 1
+    PAL_CPPI_PP_SGMII0_LOW_RX_INTD0_ACC_INTV_NUM,                                                                   // 2
+    PAL_CPPI_PP_SGMII0_HIGH_RX_INTD0_ACC_INTV_NUM,                                                                  // 3
+    PAL_CPPI_PP_SGMII1_LOW_RX_INTD0_ACC_INTV_NUM,                                                                   // 4
+    PAL_CPPI_PP_SGMII1_HIGH_RX_INTD0_ACC_INTV_NUM,                                                                  // 5
+    PAL_CPPI_PP_RGMII0_LOW_RX_INTD0_ACC_INTV_NUM,                                                                   // 6
+    PAL_CPPI_PP_RGMII0_HIGH_RX_INTD0_ACC_INTV_NUM,                                                                  // 7
+    PAL_CPPI_PP_RGMII1_LOW_RX_INTD0_ACC_INTV_NUM,                                                                   // 8
+    PAL_CPPI_PP_RGMII1_HIGH_RX_INTD0_ACC_INTV_NUM,                                                                  // 9
+    PAL_CPPI_PP_ATOM_LOW_RX_INTD0_ACC_INTV_NUM,                                                                     // 10
+    PAL_CPPI_PP_ATOM_HIGH_RX_INTD0_ACC_INTV_NUM,                                                                    // 11
+    PAL_CPPI_PP_DOCSIS_RX_MGMT_INTD0_ACC_INTV_NUM,                                                                  // 12
+    PAL_CPPI_PP_DOCSIS_RX_LOW_INTD0_ACC_INTV_NUM,                                                                   // 13
+    PAL_CPPI_PP_DOCSIS_RX_HIGH_INTD0_ACC_INTV_NUM,                                                                  // 14
+    PAL_CPPI_PP_VOICE_RX_INTD0_INTV_NUM,                                                                            // 15
+    PAL_CPPI_PP_ACCUMULATOR_INTD0_MAX_INTERRUPT_VECTORS
+}PAL_CPPI_PP_ACCUMULATOR_INTERRUPT_VECTORS_e;
+
+#define PAL_CPPI41_GBE_ACC_INTV_NUM(devInstance, pri)       (PAL_CPPI_PP_SGMII0_LOW_RX_INTD0_ACC_INTV_NUM + ((devInstance)*2) + (pri))
+
+typedef enum PAL_CPPI_PP_ACCUMULATOR_INTD1_INTERRUPT_VECTORS
+{
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_INTV_NUM_0,                                                                      // 0
+    PAL_CPPI_PP_RESERVED_INTD1_ACC_INTV_NUM_1,                                                                      // 1
+    PAL_CPPI_PP_IPSEC_ENCRYPT_INTD1_ACC_INTV_NUM,                                                                     // 2
+    PAL_CPPI_PP_IPSEC_DECRYPT_INTD1_ACC_INTV_NUM,                                                                    // 3
+    PAL_CPPI_PP_NP2APP_RX_INTD1_ACC_INTV_NUM,                                                                       // 4
+    PAL_CPPI_PP_NP2APP_TX_COMPLETE_INTD1_ACC_INTV_NUM,                                                              // 5
+    PAL_CPPI_PP_APP2NP_RX_INTD1_ACC_INTV_NUM,                                                                       // 6
+    PAL_CPPI_PP_APP2NP_TX_COMPLETE_INTD1_ACC_INTV_NUM,                                                              // 7
+    PAL_CPPI_PP_WiFi_0_INTD1_ACC_INTV_NUM,                                                                          // 8
+    PAL_CPPI_PP_WiFi_1_INTD1_ACC_INTV_NUM,                                                                          // 9
+    PAL_CPPI_PP_WiFi_2_INTD1_ACC_INTV_NUM,                                                                          // 10
+    PAL_CPPI_PP_WiFi_3_INTD1_ACC_INTV_NUM,                                                                          // 11
+    PAL_CPPI_PP_ACCUMULATOR_INTD1_MAX_INTERRUPT_VECTORS
+}PAL_CPPI_PP_ACCUMULATOR_INTD1_INTERRUPT_VECTORS_e;
+
+#define PAL_CPPI41_WPD_ACC_INTV_NUM(devInstance)       (PAL_CPPI_PP_WiFi_0_INTD1_ACC_INTV_NUM + (devInstance))
+
+/**********************************************************************************************************************
+
+ ######   #######  ##     ## ########   ######  ########    ########   #######  ########  ########  ######
+##    ## ##     ## ##     ## ##     ## ##    ## ##          ##     ## ##     ## ##     ##    ##    ##    ##
+##       ##     ## ##     ## ##     ## ##       ##          ##     ## ##     ## ##     ##    ##    ##
+ ######  ##     ## ##     ## ########  ##       ######      ########  ##     ## ########     ##     ######
+      ## ##     ## ##     ## ##   ##   ##       ##          ##        ##     ## ##   ##      ##          ##
+##    ## ##     ## ##     ## ##    ##  ##    ## ##          ##        ##     ## ##    ##     ##    ##    ##
+ ######   #######   #######  ##     ##  ######  ########    ##         #######  ##     ##    ##     ######
+
+**********************************************************************************************************************/
+
+typedef enum PAL_CPPI_PP_SOURCE_PORTS
+{
+    PAL_CPPI_PP_OFDM0_RX_SOURCE_PORT,               // 0
+    PAL_CPPI_PP_OFDM1_RX_SOURCE_PORT,               // 1
+    PAL_CPPI_PP_SC_QAM_RX_SOURCE_PORT,              // 2
+    PAL_CPPI_PP_SGMII0_RX_SOURCE_PORT,              // 3
+    PAL_CPPI_PP_SGMII1_RX_SOURCE_PORT,              // 4
+    PAL_CPPI_PP_RGMII0_RX_SOURCE_PORT,              // 5
+    PAL_CPPI_PP_MoCA_RX_SOURCE_PORT,                // 6
+    PAL_CPPI_PP_ATOM_RX_SOURCE_PORT,                // 7
+    PAL_CPPI_PP_RGMII1_RX_SOURCE_PORT,              // 8
+    PAL_CPPI_PP_VOICE_DSP_C55_SOURCE_PORT,          // 9
+    PAL_CPPI_PP_RESERVED_SOURCE_PORT_10,            // 10
+    PAL_CPPI_PP_RESERVED_SOURCE_PORT_11,            // 11
+    PAL_CPPI_PP_RESERVED_SOURCE_PORT_12,            // 12
+    PAL_CPPI_PP_RESERVED_SOURCE_PORT_13,            // 13
+    PAL_CPPI_PP_RESERVED_SOURCE_PORT_14,            // 14
+    PAL_CPPI_PP_RESERVED_SOURCE_PORT_15,            // 15
+    PAL_CPPI_PP_WiFi_PORT0_SOURCE_PORT,             // 16
+    PAL_CPPI_PP_WiFi_PORT1_SOURCE_PORT,             // 17
+    PAL_CPPI_PP_WiFi_PORT2_SOURCE_PORT,             // 18
+    PAL_CPPI_PP_WiFi_PORT3_SOURCE_PORT,             // 19
+    PAL_CPPI_PP_WiFi_PORT4_SOURCE_PORT,             // 20
+    PAL_CPPI_PP_WiFi_PORT5_SOURCE_PORT,             // 21
+    PAL_CPPI_PP_WiFi_PORT6_SOURCE_PORT,             // 22
+    PAL_CPPI_PP_WiFi_PORT7_SOURCE_PORT,             // 23
+    PAL_CPPI_PP_WiFi_PORT8_SOURCE_PORT,             // 24
+    PAL_CPPI_PP_WiFi_PORT9_SOURCE_PORT,             // 25
+    PAL_CPPI_PP_WiFi_PORT10_SOURCE_PORT,            // 26
+    PAL_CPPI_PP_WiFi_PORT11_SOURCE_PORT,            // 27
+    PAL_CPPI_PP_WiFi_PORT12_SOURCE_PORT,            // 28
+    PAL_CPPI_PP_WiFi_PORT13_SOURCE_PORT,            // 29
+    PAL_CPPI_PP_WiFi_PORT14_SOURCE_PORT,            // 30
+    PAL_CPPI_PP_WiFi_PORT15_SOURCE_PORT,            // 31
+
+    PAL_CPPI_PP_MAX_SOURCE_PORTS
+
+}PAL_CPPI_PP_SOURCE_PORTS_e;
+
+#define CPPI41_SRCPORT_VOICE_DSP_C55      PAL_CPPI_PP_VOICE_DSP_C55_SOURCE_PORT
+
+
+
+
+
+
+/**********************************************************************************************************************
+
+ ######   ######## ##    ## ######## ########     ###    ##
+##    ##  ##       ###   ## ##       ##     ##   ## ##   ##
+##        ##       ####  ## ##       ##     ##  ##   ##  ##
+##   #### ######   ## ## ## ######   ########  ##     ## ##
+##    ##  ##       ##  #### ##       ##   ##   ######### ##
+##    ##  ##       ##   ### ##       ##    ##  ##     ## ##
+ ######   ######## ##    ## ######## ##     ## ##     ## ########
+
+**********************************************************************************************************************/
+
+/*
++-+-+ +-+-+-+-+-+-+-+
+|P|P| |G|e|n|e|r|a|l|
++-+-+ +-+-+-+-+-+-+-+
+*/
+#define PAL_CPPI_PP_ATOM_INFRA_INPUT_Q_NUM(pri)                                (PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_ATOM_LOW_Q_NUM + (2*(pri)))
+#define PAL_CPPI_PP_RGMII0_INFRA_INPUT_Q_NUM(pri)                              (PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_RGMII0_LOW_Q_NUM + (2*(pri)))
+#define PAL_CPPI_PP_RGMII1_INFRA_INPUT_Q_NUM(pri)                              (PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_RGMII1_LOW_Q_NUM + (2*(pri)))
+#define PAL_CPPI_PP_SGMII0_INFRA_INPUT_Q_NUM(pri)                              (PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_SGMII0_LOW_Q_NUM + (2*(pri)))
+#define PAL_CPPI_PP_SGMII1_INFRA_INPUT_Q_NUM(pri)                              (PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_SGMII1_LOW_Q_NUM + (2*(pri)))
+#define PAL_CPPI_PP_ATOM_HOST_RX_COMPLETE_Q_NUM(pri)                           (PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_ATOM_LOW_Q_NUM + (pri))
+#define PAL_CPPI_PP_RGMII0_HOST_RX_COMPLETE_Q_NUM(pri)                         (PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_RGMII0_LOW_Q_NUM + (pri))
+#define PAL_CPPI_PP_RGMII1_HOST_RX_COMPLETE_Q_NUM(pri)                         (PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_RGMII1_LOW_Q_NUM + (pri))
+#define PAL_CPPI_PP_SGMII0_HOST_RX_COMPLETE_Q_NUM(pri)                         (PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_SGMII0_LOW_Q_NUM + (pri))
+#define PAL_CPPI_PP_SGMII1_HOST_RX_COMPLETE_Q_NUM(pri)                         (PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_SGMII1_LOW_Q_NUM + (pri))
+#define PAL_CPPI_PP_ATOM_INFRA_DMA_CH_COUNT                                    (PAL_CPPI_PP_DMA10_ATOM_HIGH_INFRA_RX_CH - PAL_CPPI_PP_DMA10_ATOM_LOW_INFRA_RX_CH + 1)
+#define PAL_CPPI_PP_RGMII0_INFRA_DMA_CH_COUNT                                  (PAL_CPPI_PP_DMA10_RGMII0_HIGH_INFRA_RX_CH - PAL_CPPI_PP_DMA10_RGMII0_LOW_INFRA_RX_CH + 1)
+#define PAL_CPPI_PP_RGMII1_INFRA_DMA_CH_COUNT                                  (PAL_CPPI_PP_DMA10_RGMII1_HIGH_INFRA_RX_CH - PAL_CPPI_PP_DMA10_RGMII1_LOW_INFRA_RX_CH + 1)
+#define PAL_CPPI_PP_SGMII0_INFRA_DMA_CH_COUNT                                  (PAL_CPPI_PP_DMA10_SGMII0_HIGH_INFRA_RX_CH - PAL_CPPI_PP_DMA10_SGMII0_LOW_INFRA_RX_CH + 1)
+#define PAL_CPPI_PP_SGMII1_INFRA_DMA_CH_COUNT                                  (PAL_CPPI_PP_DMA10_SGMII1_HIGH_INFRA_RX_CH - PAL_CPPI_PP_DMA10_SGMII1_LOW_INFRA_RX_CH + 1)
+#define PAL_CPPI_PP_ATOM_INFRA_DMA_CH_NUM(ch)                                  (PAL_CPPI_PP_DMA10_ATOM_LOW_INFRA_RX_CH + (ch))
+#define PAL_CPPI_PP_RGMII0_INFRA_DMA_CH_NUM(ch)                                (PAL_CPPI_PP_DMA10_RGMII0_LOW_INFRA_RX_CH + (ch))
+#define PAL_CPPI_PP_RGMII1_INFRA_DMA_CH_NUM(ch)                                (PAL_CPPI_PP_DMA10_RGMII1_LOW_INFRA_RX_CH + (ch))
+#define PAL_CPPI_PP_SGMII0_INFRA_DMA_CH_NUM(ch)                                (PAL_CPPI_PP_DMA10_SGMII0_LOW_INFRA_RX_CH + (ch))
+#define PAL_CPPI_PP_SGMII1_INFRA_DMA_CH_NUM(ch)                                (PAL_CPPI_PP_DMA10_SGMII1_LOW_INFRA_RX_CH + (ch))
+#define PAL_CPPI_PP_ATOM_INFRA_HOST_FD_Q_NUM(pri)                              ((pri) == 0 ? PAL_CPPI_PP_QMGR_G2_SHARED_LOW_INFRA_HOST_FD_Q_NUM : PAL_CPPI_PP_QMGR_G2_ATOM_HI_INFRA_HOST_FD_Q_NUM)
+#define PAL_CPPI_PP_RGMII0_INFRA_HOST_FD_Q_NUM(pri)                            ((pri) == 0 ? PAL_CPPI_PP_QMGR_G2_SHARED_LOW_INFRA_HOST_FD_Q_NUM : PAL_CPPI_PP_QMGR_G2_RGMII0_HI_INFRA_HOST_FD_Q_NUM)
+#define PAL_CPPI_PP_RGMII1_INFRA_HOST_FD_Q_NUM(pri)                            ((pri) == 0 ? PAL_CPPI_PP_QMGR_G2_SHARED_LOW_INFRA_HOST_FD_Q_NUM : PAL_CPPI_PP_QMGR_G2_RGMII1_HI_INFRA_HOST_FD_Q_NUM)
+#define PAL_CPPI_PP_SGMII0_INFRA_HOST_FD_Q_NUM(pri)                            ((pri) == 0 ? PAL_CPPI_PP_QMGR_G2_SHARED_LOW_INFRA_HOST_FD_Q_NUM : PAL_CPPI_PP_QMGR_G2_SGMII0_HI_INFRA_HOST_FD_Q_NUM)
+#define PAL_CPPI_PP_SGMII1_INFRA_HOST_FD_Q_NUM(pri)                            ((pri) == 0 ? PAL_CPPI_PP_QMGR_G2_SHARED_LOW_INFRA_HOST_FD_Q_NUM : PAL_CPPI_PP_QMGR_G2_SGMII1_HI_INFRA_HOST_FD_Q_NUM)
+#define PAL_CPPI_PP_WIFI_INFRA_HOST_FD_Q_NUM(pri)                              ((pri) == 0 ? PAL_CPPI_PP_QMGR_G2_SHARED_LOW_INFRA_HOST_FD_Q_NUM : PAL_CPPI_PP_QMGR_G2_WIFI_INFRA_HOST_RX_FD_Q_NUM)
+
+
+/* DOCSIS */
+#define PAL_CPPI_PP_DOCSIS_INFRA_INPUT_Q_NUM(pri)                               (PAL_CPPI_PP_QMGR_G1_CDMA10_INFRA_INPUT_LOW_DOCSIS_LOW_Q_NUM + (2*(pri)))
+#define PAL_CPPI_PP_DOCSIS_HOST_RX_COMPLETE_Q_NUM(pri)                          (PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_DOCSIS_LOW_Q_NUM + (pri))
+#define PAL_CPPI_PP_DOCSIS_INFRA_DMA_CH_COUNT                                   (PAL_CPPI_PP_DMA10_DOCSIS_HIGH_INFRA_RX_CH - PAL_CPPI_PP_DMA10_DOCSIS_LOW_INFRA_RX_CH + 1)
+#define PAL_CPPI_PP_DOCSIS_INFRA_DMA_CH_NUM(ch)                                 (PAL_CPPI_PP_DMA10_DOCSIS_LOW_INFRA_RX_CH + (ch))
+#define PAL_CPPI_PP_DOCSIS_INFRA_HOST_FD_Q_NUM(pri)                             (PAL_CPPI_PP_QMGR_G2_DOCSIS_LOW_INFRA_HOST_FD_Q_NUM + (pri))
+#define PAL_CPPI_PP_DOCSIS_TX_DATA_Q_NUM(pri)                                   (PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_VOICE_Q_NUM + (pri))
+#define PAL_CPPI_PP_DOCSIS_TX_DATA_Q_COUNT                                      (PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_BE15_LOW_Q_NUM - PAL_CPPI_PP_QMGR_G1_US_PREPROCESSING_VOICE_Q_NUM + 1)
+#define PAL_CPPI_PP_DOCSIS_RX_SOURCE_PORTS_COUNT                                (PAL_CPPI_PP_SC_QAM_RX_SOURCE_PORT - PAL_CPPI_PP_OFDM0_RX_SOURCE_PORT + 1)
+#define PAL_CPPI_PP_DOCSIS_RX_SOURCE_PORT(dsg)                                  (PAL_CPPI_PP_OFDM0_RX_SOURCE_PORT + (dsg))
+
+#ifdef CONFIG_MACH_PUMA7_FPGA_US
+#define PAL_CPPI_PP_DOCSIS_TX_DMA_CH_COUNT                          (PAL_CPPI_PP_DMA12_OFDM0_TX_QAM_0_3_TX_CHANNELS_NUM)
+#else
+#define PAL_CPPI_PP_DOCSIS_TX_DMA_CH_COUNT                          (PAL_CPPI_PP_DMA12_OFDM0_TX_QAM_0_3_TX_CHANNELS_NUM + PAL_CPPI_PP_DMA13_OFDM1_TX_QAM_4_7_TX_CHANNELS_NUM)
+#endif
+#define PAL_CPPI_PP_DOCSIS_TX_DMA_CH_NUM(ch)                        (((ch) <  PAL_CPPI_PP_DMA12_OFDM0_TX_QAM_0_3_TX_CHANNELS_NUM)? (ch):(ch)-PAL_CPPI_PP_DMA12_OFDM0_TX_QAM_0_3_TX_CHANNELS_NUM)
+#define PAL_CPPI_PP_DOCSIS_TX_DMA_BLOCK(ch)                         (((ch) <  PAL_CPPI_PP_DMA12_OFDM0_TX_QAM_0_3_TX_CHANNELS_NUM)? PAL_CPPI_PP_DMA12_OFDM0_TX_QAM_0_3_TX : PAL_CPPI_PP_DMA13_OFDM1_TX_QAM_4_7_TX )
+
+#define PAL_CPPI_PP_DOCSIS_US_COP_TX_DMA_BLOCK                      ( PAL_CPPI_PP_DMA22_US_COP_TX )
+#define PAL_CPPI_PP_DOCSIS_US_COP_RX_DMA_BLOCK                      ( PAL_CPPI_PP_DMA21_US_COP_RX )
+
+/* Host --> PP */
+#define PAL_CPPI_PP_HOST2PP_Q_COUNT                                             (PAL_CPPI_PP_QMGR_G2_HOST2PP_HI_HOST_FD_Q_NUM - PAL_CPPI_PP_QMGR_G2_HOST2PP_LOW_HOST_FD_Q_NUM + 1)
+#define PAL_CPPI_PP_HOST2PP_PP_INPUT_Q_NUM(pri)                                 (PAL_CPPI_PP_QMGR_G2_HOST2PP_RESEQUENCER_INPUT_Q0 + (pri))
+#define PAL_CPPI_PP_HOST2PP_INFRA_INPUT_Q_NUM(pri)                              (PAL_CPPI_PP_QMGR_G1_CDMA11_INFRA_INPUT_HI_HOST2PP_LOW_Q_NUM + (2*(pri)))
+#define PAL_CPPI_PP_HOST2PP_INFRA_EMB_FD_Q_NUM(pri)                             (PAL_CPPI_PP_QMGR_G2_HOST2PP_INFRA_LOW_EMB_FD_Q_NUM + (pri))
+#define PAL_CPPI_PP_HOST2PP_INFRA_DMA_CH_COUNT                                  (PAL_CPPI_PP_DMA11_HOST2PP_HIGH_INFRA_RX_CH - PAL_CPPI_PP_DMA11_HOST2PP_LOW_INFRA_RX_CH + 1)
+#define PAL_CPPI_PP_HOST2PP_INFRA_DMA_CH_NUM(ch)                                (PAL_CPPI_PP_DMA11_HOST2PP_LOW_INFRA_RX_CH + (ch))
+#define PAL_CPPI_PP_HOST2PP_TX_COMPLETE_Q_NUM(pri)                              (PAL_CPPI_PP_QMGR_G2_HOST2PP_LOW_TX_COMPLETE_Q_NUM + (pri))
+#define PAL_CPPI_PP_HOST2PP_HOST_FD_Q_NUM(pri)                                  (PAL_CPPI_PP_QMGR_G2_HOST2PP_LOW_HOST_FD_Q_NUM + (pri))
+#define PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_NUM(pri)                         (PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_CH_BASE + (pri))
+#define PAL_CPPI_PP_HOST2PP_TX_COMPLETE_ACC_CH_COUNT                            (PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_CH_LAST - PAL_CPPI_PP_HOST2PP_TX_COMPLETE_INTD0_ACC_CH_BASE + 1)
+#define PAL_CPPI_NETDEV_BUILD_Q_INFO(qMgr, qNum)                                ( ((qMgr) << CPPI41_EM_PKTINFO_RETQMGR_SHIFT) | (qNum) )
+
+#ifdef CONFIG_MACH_PUMA7_FPGA
+#define PAL_CPPI_PP_TEARDOWN_FD_DESC_COUNT                                      (2 * PAL_CPPI41_NUM_DMA_BLOCK)
+#else
+#define PAL_CPPI_PP_TEARDOWN_FD_DESC_COUNT                                      (PAL_CPPI41_NUM_TOTAL_CHAN * 2 * PAL_CPPI41_NUM_DMA_BLOCK)
+#endif
+#define PAL_CPPI_PP_TEARDOWN_FD_DESC_SIZE                                       (32)
+
+
+#define PAL_CPPI41_SR_GBE_INFRA_FD_HOST_DESC_COUNT                              (512)
+
+#define PAL_CPPI41_SR_GBE_HOST_RX_Q_BASE                                        (20)
+#define PAL_CPPI41_SR_DMA_FD_TEARDOWN_Q_NUM                                     (PAL_CPPI_PP_QMGR_G2_TEARDOWN_FD_Q_NUM)
+#define PAL_CPPI_GBE_INFRA_DMA_CH_COUNT                                         (2)
+#define PAL_CPPI_WPD_INFRA_DMA_CH_COUNT                                         (2)
+
+
+#define PAL_CPPI41_SR_GBE_TX_DATA_Q_COUNT                                       (1)
+#define PAL_CPPI41_SR_WPD_TX_DATA_Q_COUNT                                       (1)
+
+#define PAL_CPPI41_SR_GBE_QOS_Q_PRIORITIES_COUNT                                (4)
+#define PAL_CPPI41_SR_GBE_QOS_Q_PRIORITY_HIGH                                   (3)
+#define PAL_CPPI41_SR_GBE_QOS_Q_PRIORITY_MEDHIGH                                (2)
+#define PAL_CPPI41_SR_GBE_QOS_Q_PRIORITY_MEDLOW                                 (1)
+#define PAL_CPPI41_SR_GBE_QOS_Q_PRIORITY_LOW                                    (0)
+
+#define PAL_CPPI41_SR_WPD_QOS_Q_PRIORITIES_COUNT                                (4)
+#define PAL_CPPI41_SR_WPD_QOS_Q_PRIORITY_HIGH                                   (3)
+#define PAL_CPPI41_SR_WPD_QOS_Q_PRIORITY_MEDHIGH                                (2)
+#define PAL_CPPI41_SR_WPD_QOS_Q_PRIORITY_MEDLOW                                 (1)
+#define PAL_CPPI41_SR_WPD_QOS_Q_PRIORITY_LOW                                    (0)
+
+#define PAL_CPPI41_SR_HOST_TO_PP_Q_COUNT                                        (PAL_CPPI_PP_HOST2PP_Q_COUNT)
+
+
+/* WIFI */
+/* host rx - rx channels */
+/* convert wifi device id to host rx infra dma rx channel */
+#define WIFI_DEVICE_TO_WIFI_HOST_RX_INFRA_RX_CH(dev_id)                         \
+    ((dev_id) + PAL_CPPI_PP_DMA08_WIFI_DEVICE0_HOST_RX_INFRA_RX_CH)
+
+/* convert wifi device id to host rx infra dma rx channel output queue */
+#define WIFI_DEVICE_TO_WIFI_HOST_RX_INFRA_RX_CH_OUT_Q(dev_id)                   \
+    ((dev_id) + PAL_CPPI_PP_QMGR_G2_HOST_RX_COMPLETE_WIFI_DEVICE0_Q_NUM)
+
+/* host rx infra dma rx channel output queue manager */
+#define WIFI_DEVICE_TO_WIFI_HOST_RX_INFRA_RX_CH_OUT_Q_MGR                       \
+    (PAL_CPPI_PP_QMGR_G2)
+
+/* host rx - tx channels */
+/* convert wifi device id to host rx infra dma tx channel */
+#define WIFI_DEVICE_TO_WIFI_HOST_RX_INFRA_TX_CH(dev_id)                         \
+    ((dev_id) + PAL_CPPI_PP_DMA08_WIFI_DEVICE0_HOST_RX_INFRA_TX_CH)
+
+/* convert wifi device id to host rx infra dma tx channel input queue */
+#define WIFI_DEVICE_TO_WIFI_HOST_RX_INFRA_TX_CH_INPUT_Q(dev_id)                 \
+    (((dev_id)*2) + PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE0_HOST_RX_HI_Q_NUM)
+
+/* host rx infra dma tx channel input queue manager*/
+#define WIFI_DEVICE_TO_WIFI_HOST_RX_INFRA_TX_CH_INPUT_Q_MGR                     \
+    (PAL_CPPI_PP_QMGR_G2)
+
+/* tx fw - rx channels */
+/* convert wifi device id to tx fw infra dma 08 rx channel */
+#define WIFI_DEVICE_TO_WIFI_TX_FW_INFRA_08_RX_CH(dev_id)                        \
+    ((dev_id) + PAL_CPPI_PP_DMA08_WIFI_DEVICE0_TX_FW_INFRA_RX_CH)
+
+/* convert wifi device id to tx fw infra dma 09 rx channel */
+#define WIFI_DEVICE_TO_WIFI_TX_FW_INFRA_09_RX_CH(dev_id)                        \
+    ((dev_id) + PAL_CPPI_PP_DMA09_WIFI_DEVICE0_TX_FW_INFRA_RX_CH)
+
+
+/* convert wifi device id to tx fw infra dma rx channel output queue */
+#define WIFI_DEVICE_TO_WIFI_TX_FW_INFRA_RX_CH_OUT_Q(dev_id)                     \
+    ((dev_id) + PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV0_INTERNAL_Q)
+
+/* tx fw infra dma rx channel output queue manager */
+#define WIFI_DEVICE_TO_WIFI_TX_FW_INFRA_RX_CH_OUT_Q_MGR                         \
+    (PAL_CPPI_PP_QMGR_G1)
+
+/* convert wifi device id to device's tx fw input queue */
+#define WIFI_DEVICE_TO_WIFI_TX_FW_INPUT_Q(dev_id)                               \
+    ((dev_id) + PAL_CPPI_PP_QMGR_G1_WIFI_TX_DEV0_INPUT_Q)
+
+/* wifi device's tx fw input queue */
+#define WIFI_DEVICE_TO_WIFI_TX_FW_INPUT_Q_MGR                                   \
+    (PAL_CPPI_PP_QMGR_G1)
+
+/* tx fw - tx channels */
+/* convert wifi device id to tx fw infra dma 08 tx channel */
+#define WIFI_DEVICE_TO_WIFI_TX_FW_INFRA_08_TX_CH(dev_id)                        \
+    ((dev_id) + PAL_CPPI_PP_DMA08_WIFI_DEVICE0_TX_FW_INFRA_TX_CH)
+
+/* convert wifi device id to tx fw infra dma 09 tx channel */
+#define WIFI_DEVICE_TO_WIFI_TX_FW_INFRA_09_TX_CH(dev_id)                        \
+    ((dev_id) + PAL_CPPI_PP_DMA09_WIFI_DEVICE0_TX_FW_INFRA_TX_CH)
+
+/* convert wifi device id to tx fw infra dma tx channel input queue */
+#define WIFI_DEVICE_TO_WIFI_TX_FW_INFRA_TX_CH_INPUT_Q(dev_id)                   \
+    (((dev_id)*2) + PAL_CPPI_PP_QMGR_G2_CDMA8_INFRA_INPUT_WIFI_DEVICE0_TX_FW_HI_Q_NUM)
+
+/* tx fw infra dma tx channel input queue manager */
+#define WIFI_DEVICE_TO_WIFI_TX_FW_INFRA_TX_CH_INPUT_Q_MGR                       \
+    (PAL_CPPI_PP_QMGR_G2)
+
+
+/* VOICE */
+#define PAL_CPPI_PP_VOICE_DSP_C55_EMB_BD_COUNT                                  (256)
+#define PAL_CPPI41_VOICE_DSP_C55_EMB_BD_SIZE                                    (PAL_CPPI_PP_QMGR_GLOBAL_DEFAULT_DESC_SIZE)
+
+#if 0
+
+/************************************************************************/
+/*                                                                      */
+/*                ____ ____ ____    ____  ____  ____                    */
+/*               / ___| ___| ___|  |  _ \/ ___||  _ \                   */
+/*              | |   |___ \___ \  | | | \___ \| |_) |                  */
+/*              | |___ ___) |__) | | |_| |___) |  __/                   */
+/*               \____|____/____/  |____/|____/|_|                      */
+/*                                                                      */
+/*                                                                      */
+/************************************************************************/
+#define PAL_CPPI41_VOICE_DSP_C55_QMGR                       PAL_CPPI41_QUEUE_MGR_PARTITION_SR
+
+#define PAL_CPPI41_VOICE_DSP_C55_ACC_RX_INTV                PAL_CPPI41_VOICE_DSP_C55_ACC_RX_INTV_NUM
+#define PAL_CPPI41_VOICE_DSP_C55_ACC_RX_CHNUM               PAL_CPPI41_VOICE_DSP_C55_ACC_RX_CH_NUM
+
+#define PAL_CPPI41_VOICE_DSP_C55_INFRA_CHN                  PAL_CPPI41_SR_C55_INFRA_DMA2_TX_CH_NUM
+#define PAL_CPPI41_VOICE_DSP_C55_INFRA_DMA_ID               PAL_CPPI41_DMA_BLOCK2
+#define PAL_CPPI41_VOICE_DSP_C55_INFRA_QMGR                 PAL_CPPI41_QUEUE_MGR_PARTITION_SR
+#define PAL_CPPI41_VOICE_DSP_C55_INFRA_TD_QNUM              PAL_CPPI41_SR_DMA_FD_TEARDOWN_Q_NUM
+#define PAL_CPPI41_VOICE_DSP_C55_INFRA_INPUT_LOW_Q_NUM      (PAL_CPPI41_SR_DMA2_C55_INFRA_INPUT_LOW_Q_NUM)
+
+#ifdef CONFIG_INTEL_KERNEL_VOICE_SUPPORT
+#define PAL_CPPI41_VOICE_DSP_C55_EMB_BD_COUNT                 256
+#define PAL_CPPI41_SR_VOICE_DSP_VNI_FD_EMB_Q_COUNT            ((PAL_CPPI41_VOICE_DSP_C55_EMB_BD_COUNT) / 2)
+#define PAL_CPPI41_SR_VOICE_INFRA_FD_EMB_Q_COUNT              ((PAL_CPPI41_VOICE_DSP_C55_EMB_BD_COUNT) / 2)
+#define PAL_CPPI41_VOICE_DSP_C55_EMB_BD_SIZE                  64
+#else
+#define PAL_CPPI41_VOICE_DSP_C55_EMB_BD_COUNT                 0
+#define PAL_CPPI41_SR_VOICE_DSP_VNI_FD_EMB_Q_COUNT            0
+#define PAL_CPPI41_SR_VOICE_INFRA_FD_EMB_Q_COUNT              0
+#define PAL_CPPI41_VOICE_DSP_C55_EMB_BD_SIZE                  0
+#endif
+
+
+#define PAL_CPPI41_VOICE_DSP_C55_INPUT_QNUM         PAL_CPPI41_SR_VOICE_DSP_C55_INPUT_Q_NUM
+
+#define PAL_CPPI41_VOICE_DSP_C55_HOST_RX_Q_NUM      PAL_CPPI41_SR_VOICE_DSP_C55_HOST_RX_Q_NUM
+
+
+#define PAL_CPPI41_VOICE_NI_OUTPUT_QNUM             PAL_CPPI41_SR_HOST_TO_QPDSP_EMB_TYPE_Q_NUM(PAL_CPPI4x_PRTY_HIGH)
+#endif
+
+#endif
+
diff --git a/include/linux/avalanche/puma7/puma7_cppi_usqmgr_q.h b/include/linux/avalanche/puma7/puma7_cppi_usqmgr_q.h
new file mode 100755
index 0000000..cdb9717
--- /dev/null
+++ b/include/linux/avalanche/puma7/puma7_cppi_usqmgr_q.h
@@ -0,0 +1,574 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+    Intel Corporation
+    2200 Mission College Blvd.
+    Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#define PAL_CPPI_MAC_US_QMGR_DOCSIS_Q_LIST      \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_0_Q_HIGH_ID )               /*   Q0     */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_0_Q_LOW_ID  )               /*   Q1     */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_1_Q_HIGH_ID )               /*   Q2     */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_1_Q_LOW_ID  )               /*   Q3     */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_2_Q_HIGH_ID )               /*   Q4     */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_2_Q_LOW_ID  )               /*   Q5     */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_3_Q_HIGH_ID )               /*   Q6     */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_3_Q_LOW_ID  )               /*   Q7     */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_4_Q_HIGH_ID )               /*   Q8     */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_4_Q_LOW_ID  )               /*   Q9     */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_5_Q_HIGH_ID )               /*   Q10    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_5_Q_LOW_ID  )               /*   Q11    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_6_Q_HIGH_ID )               /*   Q12    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_6_Q_LOW_ID  )               /*   Q13    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_7_Q_HIGH_ID )               /*   Q14    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_7_Q_LOW_ID  )               /*   Q15    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_8_Q_HIGH_ID )               /*   Q16    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_8_Q_LOW_ID  )               /*   Q17    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_9_Q_HIGH_ID )               /*   Q18    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_9_Q_LOW_ID  )               /*   Q19    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_10_Q_HIGH_ID )              /*   Q20    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_10_Q_LOW_ID  )              /*   Q21    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_11_Q_HIGH_ID )              /*   Q22    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_11_Q_LOW_ID  )              /*   Q23    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_12_Q_HIGH_ID )              /*   Q24    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_12_Q_LOW_ID  )              /*   Q25    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_13_Q_HIGH_ID )              /*   Q26    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_13_Q_LOW_ID  )              /*   Q27    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_14_Q_HIGH_ID )              /*   Q28    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_14_Q_LOW_ID  )              /*   Q29    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_15_Q_HIGH_ID )              /*   Q30    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_15_Q_LOW_ID  )              /*   Q31    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_16_Q_HIGH_ID )              /*   Q32    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_16_Q_LOW_ID  )              /*   Q33    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_17_Q_HIGH_ID )              /*   Q34    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_17_Q_LOW_ID  )              /*   Q35    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_18_Q_HIGH_ID )              /*   Q36    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_18_Q_LOW_ID  )              /*   Q37    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_19_Q_HIGH_ID )              /*   Q38    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_19_Q_LOW_ID  )              /*   Q39    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_20_Q_HIGH_ID )              /*   Q40    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_20_Q_LOW_ID  )              /*   Q41    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_21_Q_HIGH_ID )              /*   Q42    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_21_Q_LOW_ID  )              /*   Q43    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_22_Q_HIGH_ID )              /*   Q44    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_22_Q_LOW_ID  )              /*   Q45    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_23_Q_HIGH_ID )              /*   Q46    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_23_Q_LOW_ID  )              /*   Q47    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_24_Q_HIGH_ID )              /*   Q48    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_24_Q_LOW_ID  )              /*   Q49    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_25_Q_HIGH_ID )              /*   Q50    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_25_Q_LOW_ID  )              /*   Q51    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_26_Q_HIGH_ID )              /*   Q52    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_26_Q_LOW_ID  )              /*   Q53    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_27_Q_HIGH_ID )              /*   Q54    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_27_Q_LOW_ID  )              /*   Q55    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_28_Q_HIGH_ID )              /*   Q56    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_28_Q_LOW_ID  )              /*   Q57    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_29_Q_HIGH_ID )              /*   Q58    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_29_Q_LOW_ID  )              /*   Q59    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_30_Q_HIGH_ID )              /*   Q60    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_30_Q_LOW_ID  )              /*   Q61    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_31_Q_HIGH_ID )              /*   Q62    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_31_Q_LOW_ID  )              /*   Q63    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_32_Q_HIGH_ID )              /*   Q64    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_32_Q_LOW_ID  )              /*   Q65    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_33_Q_HIGH_ID )              /*   Q66    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_33_Q_LOW_ID  )              /*   Q67    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_34_Q_HIGH_ID )              /*   Q68    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_34_Q_LOW_ID  )              /*   Q69    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_35_Q_HIGH_ID )              /*   Q70    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_35_Q_LOW_ID  )              /*   Q71    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_36_Q_HIGH_ID )              /*   Q72    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_36_Q_LOW_ID  )              /*   Q73    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_37_Q_HIGH_ID )              /*   Q74    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_37_Q_LOW_ID  )              /*   Q75    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_38_Q_HIGH_ID )              /*   Q76    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_38_Q_LOW_ID  )              /*   Q77    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_39_Q_HIGH_ID )              /*   Q78    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_39_Q_LOW_ID  )              /*   Q79    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_40_Q_HIGH_ID )              /*   Q80    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_40_Q_LOW_ID  )              /*   Q81    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_41_Q_HIGH_ID )              /*   Q82    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_41_Q_LOW_ID  )              /*   Q83    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_42_Q_HIGH_ID )              /*   Q84    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_42_Q_LOW_ID  )              /*   Q85    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_43_Q_HIGH_ID )              /*   Q86    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_43_Q_LOW_ID  )              /*   Q87    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_44_Q_HIGH_ID )              /*   Q88    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_44_Q_LOW_ID  )              /*   Q89    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_45_Q_HIGH_ID )              /*   Q90    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_45_Q_LOW_ID  )              /*   Q91    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_46_Q_HIGH_ID )              /*   Q92    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_46_Q_LOW_ID  )              /*   Q93    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_47_Q_HIGH_ID )              /*   Q94    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_47_Q_LOW_ID  )              /*   Q95    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_48_Q_HIGH_ID )              /*   Q96    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_48_Q_LOW_ID  )              /*   Q97    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_49_Q_HIGH_ID )              /*   Q98    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_49_Q_LOW_ID  )              /*   Q99    */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_50_Q_HIGH_ID )              /*   Q100   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_50_Q_LOW_ID  )              /*   Q101   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_51_Q_HIGH_ID )              /*   Q102   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_51_Q_LOW_ID  )              /*   Q103   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_52_Q_HIGH_ID )              /*   Q104   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_52_Q_LOW_ID  )              /*   Q105   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_53_Q_HIGH_ID )              /*   Q106   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_53_Q_LOW_ID  )              /*   Q107   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_54_Q_HIGH_ID )              /*   Q108   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_54_Q_LOW_ID  )              /*   Q109   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_55_Q_HIGH_ID )              /*   Q110   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_55_Q_LOW_ID  )              /*   Q111   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_56_Q_HIGH_ID )              /*   Q112   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_56_Q_LOW_ID  )              /*   Q113   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_57_Q_HIGH_ID )              /*   Q114   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_57_Q_LOW_ID  )              /*   Q115   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_58_Q_HIGH_ID )              /*   Q116   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_58_Q_LOW_ID  )              /*   Q117   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_59_Q_HIGH_ID )              /*   Q118   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_59_Q_LOW_ID  )              /*   Q119   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_60_Q_HIGH_ID )              /*   Q120   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_60_Q_LOW_ID  )              /*   Q121   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_61_Q_HIGH_ID )              /*   Q122   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_61_Q_LOW_ID  )              /*   Q123   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_62_Q_HIGH_ID )              /*   Q124   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_62_Q_LOW_ID  )              /*   Q125   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_63_Q_HIGH_ID )              /*   Q126   */ \
+PAL_CPPI_QMGR_Q_ADD( OUTSTANDING_SF_63_Q_LOW_ID  )              /*   Q127   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE0_Q_MGMT_ID    )              /*   Q128   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE0_Q_TDOX_ID    )              /*   Q129   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE0_Q_HIGH_ID    )              /*   Q130   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE0_Q_LOW_ID     )              /*   Q131   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE1_Q_MGMT_ID    )              /*   Q132   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE1_Q_TDOX_ID    )              /*   Q133   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE1_Q_HIGH_ID    )              /*   Q134   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE1_Q_LOW_ID     )              /*   Q135   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE2_Q_MGMT_ID    )              /*   Q136   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE2_Q_TDOX_ID    )              /*   Q137   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE2_Q_HIGH_ID    )              /*   Q138   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE2_Q_LOW_ID     )              /*   Q139   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE3_Q_MGMT_ID    )              /*   Q140   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE3_Q_TDOX_ID    )              /*   Q141   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE3_Q_HIGH_ID    )              /*   Q142   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE3_Q_LOW_ID     )              /*   Q143   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE4_Q_MGMT_ID    )              /*   Q144   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE4_Q_TDOX_ID    )              /*   Q145   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE4_Q_HIGH_ID    )              /*   Q146   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE4_Q_LOW_ID     )              /*   Q147   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE5_Q_MGMT_ID    )              /*   Q148   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE5_Q_TDOX_ID    )              /*   Q149   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE5_Q_HIGH_ID    )              /*   Q150   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE5_Q_LOW_ID     )              /*   Q151   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE6_Q_MGMT_ID    )              /*   Q152   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE6_Q_TDOX_ID    )              /*   Q153   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE6_Q_HIGH_ID    )              /*   Q154   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE6_Q_LOW_ID     )              /*   Q155   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE7_Q_MGMT_ID    )              /*   Q156   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE7_Q_TDOX_ID    )              /*   Q157   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE7_Q_HIGH_ID    )              /*   Q158   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE7_Q_LOW_ID     )              /*   Q159   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE8_Q_MGMT_ID    )              /*   Q160   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE8_Q_TDOX_ID    )              /*   Q161   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE8_Q_HIGH_ID    )              /*   Q162   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE8_Q_LOW_ID     )              /*   Q163   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE9_Q_MGMT_ID    )              /*   Q164   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE9_Q_TDOX_ID    )              /*   Q165   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE9_Q_HIGH_ID    )              /*   Q166   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE9_Q_LOW_ID     )              /*   Q167   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE10_Q_MGMT_ID   )              /*   Q168   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE10_Q_TDOX_ID   )              /*   Q169   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE10_Q_HIGH_ID   )              /*   Q170   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE10_Q_LOW_ID    )              /*   Q171   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE11_Q_MGMT_ID   )              /*   Q172   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE11_Q_TDOX_ID   )              /*   Q173   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE11_Q_HIGH_ID   )              /*   Q174   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE11_Q_LOW_ID    )              /*   Q175   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE12_Q_MGMT_ID   )              /*   Q176   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE12_Q_TDOX_ID   )              /*   Q177   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE12_Q_HIGH_ID   )              /*   Q178   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE12_Q_LOW_ID    )              /*   Q179   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE13_Q_MGMT_ID   )              /*   Q180   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE13_Q_TDOX_ID   )              /*   Q181   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE13_Q_HIGH_ID   )              /*   Q182   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE13_Q_LOW_ID    )              /*   Q183   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE14_Q_MGMT_ID   )              /*   Q184   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE14_Q_TDOX_ID   )              /*   Q185   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE14_Q_HIGH_ID   )              /*   Q186   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE14_Q_LOW_ID    )              /*   Q187   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE15_Q_MGMT_ID   )              /*   Q188   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE15_Q_TDOX_ID   )              /*   Q189   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE15_Q_HIGH_ID   )              /*   Q190   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_BE15_Q_LOW_ID    )              /*   Q191   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS0_Q_ID        )              /*   Q192   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS1_Q_ID        )              /*   Q193   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS2_Q_ID        )              /*   Q194   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS3_Q_ID        )              /*   Q195   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS4_Q_ID        )              /*   Q196   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS5_Q_ID        )              /*   Q197   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS6_Q_ID        )              /*   Q198   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS7_Q_ID        )              /*   Q199   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS8_Q_ID        )              /*   Q200   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS9_Q_ID        )              /*   Q201   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS10_Q_ID       )              /*   Q202   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS11_Q_ID       )              /*   Q203   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS12_Q_ID       )              /*   Q204   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS13_Q_ID       )              /*   Q205   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS14_Q_ID       )              /*   Q206   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS15_Q_ID       )              /*   Q207   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS16_Q_ID       )              /*   Q208   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS17_Q_ID       )              /*   Q209   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS18_Q_ID       )              /*   Q210   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS19_Q_ID       )              /*   Q211   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS20_Q_ID       )              /*   Q212   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS21_Q_ID       )              /*   Q213   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS22_Q_ID       )              /*   Q214   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS23_Q_ID       )              /*   Q215   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS24_Q_ID       )              /*   Q216   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS25_Q_ID       )              /*   Q217   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS26_Q_ID       )              /*   Q218   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS27_Q_ID       )              /*   Q219   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS28_Q_ID       )              /*   Q220   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS29_Q_ID       )              /*   Q221   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS30_Q_ID       )              /*   Q222   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS31_Q_ID       )              /*   Q223   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS32_Q_ID       )              /*   Q224   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS33_Q_ID       )              /*   Q225   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS34_Q_ID       )              /*   Q226   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS35_Q_ID       )              /*   Q227   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS36_Q_ID       )              /*   Q228   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS37_Q_ID       )              /*   Q229   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS38_Q_ID       )              /*   Q230   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS39_Q_ID       )              /*   Q231   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS40_Q_ID       )              /*   Q232   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS41_Q_ID       )              /*   Q233   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS42_Q_ID       )              /*   Q234   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS43_Q_ID       )              /*   Q235   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS44_Q_ID       )              /*   Q236   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS45_Q_ID       )              /*   Q237   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS46_Q_ID       )              /*   Q238   */ \
+PAL_CPPI_QMGR_Q_ADD( RX_CO_PROC_UGS47_Q_ID       )              /*   Q239   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_0         )              /*   Q240   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_1         )              /*   Q241   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_2         )              /*   Q242   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_3         )              /*   Q243   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_4         )              /*   Q244   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_5         )              /*   Q245   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_6         )              /*   Q246   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_7         )              /*   Q247   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_8         )              /*   Q248   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_9         )              /*   Q249   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_10        )              /*   Q250   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_11        )              /*   Q251   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_12        )              /*   Q252   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_13        )              /*   Q253   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_14        )              /*   Q254   */ \
+PAL_CPPI_QMGR_Q_ADD( US_GRANT_QUEUE_CH_15        )              /*   Q255   */ \
+PAL_CPPI_QMGR_Q_ADD( TX_MAC_QAM0_ID              )              /*   Q256   */ \
+PAL_CPPI_QMGR_Q_ADD( TX_MAC_QAM1_ID              )              /*   Q257   */ \
+PAL_CPPI_QMGR_Q_ADD( TX_MAC_QAM2_ID              )              /*   Q258   */ \
+PAL_CPPI_QMGR_Q_ADD( TX_MAC_QAM3_ID              )              /*   Q259   */ \
+PAL_CPPI_QMGR_Q_ADD( TX_MAC_OFDMA0_ID            )              /*   Q260   */ \
+PAL_CPPI_QMGR_Q_ADD( TX_MAC_QAM4_ID              )              /*   Q261   */ \
+PAL_CPPI_QMGR_Q_ADD( TX_MAC_QAM5_ID              )              /*   Q262   */ \
+PAL_CPPI_QMGR_Q_ADD( TX_MAC_QAM6_ID              )              /*   Q263   */ \
+PAL_CPPI_QMGR_Q_ADD( TX_MAC_QAM7_ID              )              /*   Q264   */ \
+PAL_CPPI_QMGR_Q_ADD( TX_MAC_OFDMA1_ID            )              /*   Q265   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q266_ID         )              /*   Q266   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q267_ID         )              /*   Q267   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q268_ID         )              /*   Q268   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q269_ID         )              /*   Q269   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q270_ID         )              /*   Q270   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q271_ID         )              /*   Q271   */ \
+PAL_CPPI_QMGR_Q_ADD( FRAG_DIVERT_TMP_Q_ID        )              /*   Q272   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC_FD_EMB_ID            )              /*   Q273   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC_FD_DLS_MONOLITIC_ID  )              /*   Q274   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC_FD_MONOLITIC_ID      )              /*   Q275   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q276_ID         )              /*   Q276   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q277_ID         )              /*   Q277   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q278_ID         )              /*   Q278   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q279_ID         )              /*   Q279   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC_DLS_COMMAND_FROM_EXT_APP_ID )       /*   Q280   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q281_ID         )              /*   Q281   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q282_ID         )              /*   Q282   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q283_ID         )              /*   Q283   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q284_ID         )              /*   Q284   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q285_ID         )              /*   Q285   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q286_ID         )              /*   Q286   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q287_ID         )              /*   Q287   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q288_ID         )              /*   Q288   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q289_ID         )              /*   Q289   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q290_ID         )              /*   Q290   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q291_ID         )              /*   Q291   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q292_ID         )              /*   Q292   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q293_ID         )              /*   Q293   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q294_ID         )              /*   Q294   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q295_ID         )              /*   Q295   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q296_ID         )              /*   Q296   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q297_ID         )              /*   Q297   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q298_ID         )              /*   Q298   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q299_ID         )              /*   Q299   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q300_ID         )              /*   Q300   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q301_ID         )              /*   Q301   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q302_ID         )              /*   Q302   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q303_ID         )              /*   Q303   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q304_ID         )              /*   Q304   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q305_ID         )              /*   Q305   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q306_ID         )              /*   Q306   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q307_ID         )              /*   Q307   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q308_ID         )              /*   Q308   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q309_ID         )              /*   Q309   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q310_ID         )              /*   Q310   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q311_ID         )              /*   Q311   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q312_ID         )              /*   Q312   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q313_ID         )              /*   Q313   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q314_ID         )              /*   Q314   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q315_ID         )              /*   Q315   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q316_ID         )              /*   Q316   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q317_ID         )              /*   Q317   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q318_ID         )              /*   Q318   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q319_ID         )              /*   Q319   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q320_ID         )              /*   Q320   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q321_ID         )              /*   Q321   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q322_ID         )              /*   Q322   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q323_ID         )              /*   Q323   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q324_ID         )              /*   Q324   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q325_ID         )              /*   Q325   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q326_ID         )              /*   Q326   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q327_ID         )              /*   Q327   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q328_ID         )              /*   Q328   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q329_ID         )              /*   Q329   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q330_ID         )              /*   Q330   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q331_ID         )              /*   Q331   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q332_ID         )              /*   Q332   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q333_ID         )              /*   Q333   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q334_ID         )              /*   Q334   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q335_ID         )              /*   Q335   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q336_ID         )              /*   Q336   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q337_ID         )              /*   Q337   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q338_ID         )              /*   Q338   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q339_ID         )              /*   Q339   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q340_ID         )              /*   Q340   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q341_ID         )              /*   Q341   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q342_ID         )              /*   Q342   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q343_ID         )              /*   Q343   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q344_ID         )              /*   Q344   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q345_ID         )              /*   Q345   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q346_ID         )              /*   Q346   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q347_ID         )              /*   Q347   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q348_ID         )              /*   Q348   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q349_ID         )              /*   Q349   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q350_ID         )              /*   Q350   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q351_ID         )              /*   Q351   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q352_ID         )              /*   Q352   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q353_ID         )              /*   Q353   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q354_ID         )              /*   Q354   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q355_ID         )              /*   Q355   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q356_ID         )              /*   Q356   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q357_ID         )              /*   Q357   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q358_ID         )              /*   Q358   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q359_ID         )              /*   Q359   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q360_ID         )              /*   Q360   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q361_ID         )              /*   Q361   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q362_ID         )              /*   Q362   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q363_ID         )              /*   Q363   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q364_ID         )              /*   Q364   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q365_ID         )              /*   Q365   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q366_ID         )              /*   Q366   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q367_ID         )              /*   Q367   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q368_ID         )              /*   Q368   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q369_ID         )              /*   Q369   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q370_ID         )              /*   Q370   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q371_ID         )              /*   Q371   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q372_ID         )              /*   Q372   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q373_ID         )              /*   Q373   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q374_ID         )              /*   Q374   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q375_ID         )              /*   Q375   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q376_ID         )              /*   Q376   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q377_ID         )              /*   Q377   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q378_ID         )              /*   Q378   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q379_ID         )              /*   Q379   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q380_ID         )              /*   Q380   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q381_ID         )              /*   Q381   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q382_ID         )              /*   Q382   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q383_ID         )              /*   Q383   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q384_ID         )              /*   Q384   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q385_ID         )              /*   Q385   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q386_ID         )              /*   Q386   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q387_ID         )              /*   Q387   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q388_ID         )              /*   Q388   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q389_ID         )              /*   Q389   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q390_ID         )              /*   Q390   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q391_ID         )              /*   Q391   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q392_ID         )              /*   Q392   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q393_ID         )              /*   Q393   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q394_ID         )              /*   Q394   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q395_ID         )              /*   Q395   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q396_ID         )              /*   Q396   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q397_ID         )              /*   Q397   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q398_ID         )              /*   Q398   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q399_ID         )              /*   Q399   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q400_ID         )              /*   Q400   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q401_ID         )              /*   Q401   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q402_ID         )              /*   Q402   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q403_ID         )              /*   Q403   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q404_ID         )              /*   Q404   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q405_ID         )              /*   Q405   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q406_ID         )              /*   Q406   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q407_ID         )              /*   Q407   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q408_ID         )              /*   Q408   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q409_ID         )              /*   Q409   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q410_ID         )              /*   Q410   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q411_ID         )              /*   Q411   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q412_ID         )              /*   Q412   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q413_ID         )              /*   Q413   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q414_ID         )              /*   Q414   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q415_ID         )              /*   Q415   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q416_ID         )              /*   Q416   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q417_ID         )              /*   Q417   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q418_ID         )              /*   Q418   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q419_ID         )              /*   Q419   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q420_ID         )              /*   Q420   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q421_ID         )              /*   Q421   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q422_ID         )              /*   Q422   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q423_ID         )              /*   Q423   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q424_ID         )              /*   Q424   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q425_ID         )              /*   Q425   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q426_ID         )              /*   Q426   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q427_ID         )              /*   Q427   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q428_ID         )              /*   Q428   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q429_ID         )              /*   Q429   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q430_ID         )              /*   Q430   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q431_ID         )              /*   Q431   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q432_ID         )              /*   Q432   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q433_ID         )              /*   Q433   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q434_ID         )              /*   Q434   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q435_ID         )              /*   Q435   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q436_ID         )              /*   Q436   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q437_ID         )              /*   Q437   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q438_ID         )              /*   Q438   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q439_ID         )              /*   Q439   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q440_ID         )              /*   Q440   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q441_ID         )              /*   Q441   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q442_ID         )              /*   Q442   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q443_ID         )              /*   Q443   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q444_ID         )              /*   Q444   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q445_ID         )              /*   Q445   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q446_ID         )              /*   Q446   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q447_ID         )              /*   Q447   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q448_ID         )              /*   Q448   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q449_ID         )              /*   Q449   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q450_ID         )              /*   Q450   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q451_ID         )              /*   Q451   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q452_ID         )              /*   Q452   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q453_ID         )              /*   Q453   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q454_ID         )              /*   Q454   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q455_ID         )              /*   Q455   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q456_ID         )              /*   Q456   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q457_ID         )              /*   Q457   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q458_ID         )              /*   Q458   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q459_ID         )              /*   Q459   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q460_ID         )              /*   Q460   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q461_ID         )              /*   Q461   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q462_ID         )              /*   Q462   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q463_ID         )              /*   Q463   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q464_ID         )              /*   Q464   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q465_ID         )              /*   Q465   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q466_ID         )              /*   Q466   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q467_ID         )              /*   Q467   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q468_ID         )              /*   Q468   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q469_ID         )              /*   Q469   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q470_ID         )              /*   Q470   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q471_ID         )              /*   Q471   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q472_ID         )              /*   Q472   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q473_ID         )              /*   Q473   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q474_ID         )              /*   Q474   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q475_ID         )              /*   Q475   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q476_ID         )              /*   Q476   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q477_ID         )              /*   Q477   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q478_ID         )              /*   Q478   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q479_ID         )              /*   Q479   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q480_ID         )              /*   Q480   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q481_ID         )              /*   Q481   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q482_ID         )              /*   Q482   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q483_ID         )              /*   Q483   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q484_ID         )              /*   Q484   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q485_ID         )              /*   Q485   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q486_ID         )              /*   Q486   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q487_ID         )              /*   Q487   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q488_ID         )              /*   Q488   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q489_ID         )              /*   Q489   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q490_ID         )              /*   Q490   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q491_ID         )              /*   Q491   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q492_ID         )              /*   Q492   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q493_ID         )              /*   Q493   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q494_ID         )              /*   Q494   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q495_ID         )              /*   Q495   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q496_ID         )              /*   Q496   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q497_ID         )              /*   Q497   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q498_ID         )              /*   Q498   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q499_ID         )              /*   Q499   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q500_ID         )              /*   Q500   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q501_ID         )              /*   Q501   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q502_ID         )              /*   Q502   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q503_ID         )              /*   Q503   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q504_ID         )              /*   Q504   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q505_ID         )              /*   Q505   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q506_ID         )              /*   Q506   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q507_ID         )              /*   Q507   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q508_ID         )              /*   Q508   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q509_ID         )              /*   Q509   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q510_ID         )              /*   Q510   */ \
+PAL_CPPI_QMGR_Q_ADD( US_MAC______Q511_ID         )              /*   Q511   */
diff --git a/include/linux/avalanche/puma7/puma7_cru_ctrl.h b/include/linux/avalanche/puma7/puma7_cru_ctrl.h
new file mode 100755
index 0000000..284ad77
--- /dev/null
+++ b/include/linux/avalanche/puma7/puma7_cru_ctrl.h
@@ -0,0 +1,125 @@
+/* 
+  This file is provided under a dual BSD/GPLv2 license.  When using or 
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE 
+
+  Copyright(c) 2014 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without 
+  modification, are permitted provided that the following conditions 
+  are met:
+
+    * Redistributions of source code must retain the above copyright 
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright 
+      notice, this list of conditions and the following disclaimer in 
+      the documentation and/or other materials provided with the 
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its 
+      contributors may be used to endorse or promote products derived 
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <asm-generic/ioctls.h>
+#ifndef _PUMA7_CRU_H
+#define _PUMA7_CRU_H
+
+/** \enum PAL_SYS_CRU_MODULE_T
+    \brief  Enum for modules which can do Power an Reset
+            management using CRU. Use these defines for all Pal
+            APIs. CRU - Clock and Reset UNIT One per module (in
+            some cases more than one) gate the clocks for power
+            saving, and module reset controllability.
+            The Output clocks from the pll's are connected to
+            the CRU module which implemented clock gating and
+            reset assertion for the IP modules.
+*/
+typedef enum PAL_SYS_CRU_MODULE_tag       /* NOTE: the enum list is based on the document "NET IP Clock Control, Revision 0.5" */
+{
+ /* 0 */   CRU_NUM_ARM11,                 /* ATOM must enable this module's clocks to take ARM11 out of reset, after it uses DOCSIS_CNTL register to take Docsis IP out of reset */
+ /* 1 */   CRU_NUM_C55,                 
+ /* 2 */   CRU_NUM_I2C_W_CONTROLLER,             
+ /* 3 */   CRU_NUM_DOCSIS_MAC0,         
+ /* 4 */   CRU_NUM_ARM11_L2,         
+ /* 5 */   CRU_NUM_DOCSIS_PHY0,            /* docsis_phy_ofdm */      
+ /* 6 */   CRU_NUM_DOCSIS_PHY1,            /* docsis_phy_legacy */
+ /* 7 */   CRU_NUM_PKT_PROCESSOR,         
+ /* 8 */   CRU_NUM_ATOM_INTC,       
+ /* 9 */   CRU_NUM_DOCSIS_IP_INFRA,        /* This module's clocks are enabled by defualt */
+ /* 10 */  CRU_NUM_BBU,                 
+ /* 11 */  CRU_NUM_WDT,                 
+ /* 12 */  CRU_NUM_RAM,                    /* This module's clocks are enabled by defualt */
+ /* 13 */  CRU_NUM_TIMER0,              
+ /* 14 */  CRU_NUM_TIMER1,              
+ /* 15 */  CRU_NUM_TIMER2,              
+ /* 16 */  CRU_NUM_UART0,               
+ /* 17 */  CRU_NUM_UART1,               
+ /* 18 */  CRU_NUM_UART2,               
+ /* 19 */  CRU_NUM_CPSPDMA0,            
+ /* 20 */  CRU_NUM_CPSPDMA1,            
+ /* 21 */  CRU_NUM_BOOT_CFG,               /* This module's clocks are enabled by defualt */
+ /* 22 */  CRU_NUM_TDM00,               
+ /* 23 */  CRU_NUM_TDM01,               
+ /* 24 */  CRU_NUM_TDM10,               
+ /* 25 */  CRU_NUM_TDM11,               
+ /* 26 */  CRU_NUM_DSP_PROXY,           
+ /* 27 */  CRU_NUM_DSP_INC,             
+ /* 28 */  CRU_NUM_I2C,                 
+ /* 29 */  CRU_NUM_PREF_MON,            
+ /* 30 */  CRU_NUM_RESERVED,             
+ /* 31 */  CRU_NUM_MOCA0,               
+ /* 32 */  CRU_NUM_MOCA1,               
+ /* 33 */  CRU_NUM_MOCA2,
+ /* 34 */  CRU_NUM_C55_L2_CACHE,
+ /* 35 */  CRU_NUM_GPIO96,
+ /* 36 */  CRU_NUM_CNT64_4_COUNTERS,
+ /* 37 */  CRU_NUM_MAIN_SSX,
+ /* 38 */  CRU_NUM_GBE,
+ /* 39 */  CRU_NUM_UART3,
+ /* 40 */  CRU_NUM_TDM20,
+ /* 41 */  CRU_NUM_TDM21,
+ /* 42 */  CRU_NUM_SPI_MASTER,
+ /* 43 */  CRU_MAX,
+}PAL_SYS_CRU_MODULE_T;
+
+#endif /* _PUMA7_CRU_H */
diff --git a/include/linux/avalanche/puma7/puma7_defs.h b/include/linux/avalanche/puma7/puma7_defs.h
new file mode 100644
index 0000000..9830123
--- /dev/null
+++ b/include/linux/avalanche/puma7/puma7_defs.h
@@ -0,0 +1,69 @@
+/*
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+    Intel Corporation
+    2200 Mission College Blvd.
+    Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2016 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*/
+
+#ifndef _PUMA7_DEFS_H
+#define _PUMA7_DEFS_H
+
+#define PUMA7_OR_NEWER_SOC_TYPE     (1)
+#define PUMA7_SOC_TYPE              (1)
+#define PUMA6_OR_NEWER_SOC_TYPE     (1)
+
+#endif
diff --git a/include/linux/avalanche/puma7/puma7_interrupts.h b/include/linux/avalanche/puma7/puma7_interrupts.h
new file mode 100755
index 0000000..ed0b008
--- /dev/null
+++ b/include/linux/avalanche/puma7/puma7_interrupts.h
@@ -0,0 +1,180 @@
+/*
+ *
+ * puma7_interrups.h
+ * Description:
+ * all puma7 interrupts related information
+ *
+
+  This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014-2015 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2014-2015 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef __PUMA7_INTERRUPTS_H
+#define __PUMA7_INTERRUPTS_H
+
+                                                    /*----------------------------------------------------
+                                                     * Puma7 Interrupt Map
+                                                     *--------------------------------------------------*/
+typedef enum                                        // Int | Acronym         | Type              | Source                  | Signal Name
+{                                                   // ===================================================================================================
+    AVALANCHE_CPSDMA0_RX_INT,                       // 0   | CPSDMA0RXINT    | Active high pulse | CPSDMA0                 | cpspdma0_rx_int
+    AVALANCHE_CPSDMA0_TX_INT,                       // 1   | CPSDMA0TXINT    | Active high pulse | pulCPSDMA0              | cpspdma0_tx_int
+    AVALANCHE_CPSDMA1_RX_INT,                       // 2   | CPSDMA1RXINT    | Active high pulse | pulCPSDMA1              | cpspdma1_rx_int
+    AVALANCHE_CPSDMA1_TX_INT,                       // 3   | CPSDMA1TXINT    | Active high pulse | pulCPSDMA1              | cpspdma1_tx_int
+    AVALANCHE_I2C_INT,                              // 4   | IICINT          | Active high level | levIIC                  | iicm_intr
+    AVALANCHE_TIMER_0_INT,                          // 5   | TINT0           | Active high pulse | pulTimer0               | timer0_intr
+    AVALANCHE_TIMER_1_INT,                          // 6   | TINT1           | Active high pulse | pulTimer1               | timer1_intr
+    AVALANCHE_UART0_INT,                            // 7   | UARTINT0        | Active high level | levUart0                | uart0_intr
+    AVALANCHE_UART1_INT,                            // 8   | UARTINT1        | Active high level | levUart1                | uart1_intr
+    AVALANCHE_UART2_INT,                            // 9   | UARTINT2        | Active high level | levUart2                | uart2_intr
+    AVALANCHE_TIMER_2_INT,                          // 10  | TINT2           | Active high pulse | pulTimer2               | timer2_intr
+    AVALANCHE_INT_11,                               // 11  | I2C controller  | Active high level | levI2C (second)         | i2c_intr
+    AVALANCHE_INT_12,                               // 12  | ZDSINT          | Active low level  | Zsi                     | zds_lowpin_int_n_sync
+    AVALANCHE_CPU_SW_INT,                           // 13  | CPUSWINT        | Active high pulse | boot config             | cpu_sw_intr
+    AVALANCHE_INT_14,                               // 14  | EXT_DECT_INT    | Active high level | external DECT           | ext_dect_int_in/pad_dect_irq_gpio_090_o_di
+    AVALANCHE_CODEC_SPI_INT,                        // 15  | EXT_SLAC_INT    | Active high level | external SLAC           | ext_slac_int_in/pad_codec_int_gpio_093_o_di
+    AVALANCHE_INT_16,                               // 16  | BBUINT          | Active high level | BBU Ctrl                | bbu_intr
+    PHY_PGA_GRT_IRQ_NUM_PUMA7,                      // 17  | EPGAINT         | Active high level | PHY                     | epga_we_n_sync
+    AVALANCHE_INT_18,                               // 18  | ATTINT          | Active high level | SSX- address translator | att_interrupt_sync
+    AVALANCHE_INT_19,                               // 19  | I2C controller  | Active high pulse | I2C controller          | i2c_ctrl_trans_end_intr
+    MAC_UCD_INT_IRQ_NUM,                            // 20  | DMACNWEUCD      | Active high level | Docsis MAC              | dmac_top_hst_new_ucd_int_sync
+    MAC_DS_FW_INT_IRQ_NUM,                          // 21  | DMACPDSP        | Active high level | Docsis MAC              | dmac_top_pdsp_int_sync
+    MAC_US_FW_INT_IRQ_NUM,                          // 22  | DMACARMINT      | Active high level | Docsis MAC              | dmac_top_arm_int_sync
+    PHY_INT_IRQ_NUM,                                // 23  | DPHYINT         | Active high level | Docsis PHY              | docsis_phy_interrupt
+    AVALANCHE_INTD_BASE_INT,                        // 24  | SRTR_INTD0      | Active high level | packet Processor        | srtr_intr_0
+    AVALANCHE_INT_25,                               // 25  | SRTR_INTD1      | Active high level | packet Processor        | srtr_intr_1
+    AVALANCHE_INT_26,                               // 26  | SRTR_INTD2      | Active high level | packet Processor        | srtr_intr_2
+    AVALANCHE_INT_27,                               // 27  | SRTR_INTD3      | Active high level | packet Processor        | srtr_intr_3
+    AVALANCHE_INT_28,                               // 28  | SRTR_INTD4      | Active high level | packet Processor        | srtr_intr_4
+    AVALANCHE_INT_29,                               // 29  | SRTR_INTD5      | Active high level | packet Processor        | srtr_intr_5
+    AVALANCHE_INT_30,                               // 30  | SRTR_INTD6      | Active high level | packet Processor        | srtr_intr_6
+    AVALANCHE_INT_31,                               // 31  | SRTR_INTD7      | Active high level | packet Processor        | srtr_intr_7
+    AVALANCHE_INT_32,                               // 32  | SRTR_INTD8      | Active high level | packet Processor        | srtr_intr_8
+    AVALANCHE_INT_33,                               // 33  | SRTR_INTD9      | Active high level | packet Processor        | srtr_intr_9
+    AVALANCHE_INT_34,                               // 34  | SRTR_INTD10     | Active high level | packet Processor        | srtr_intr_10
+    AVALANCHE_INT_35,                               // 35  | SRTR_INTD11     | Active high level | packet Processor        | srtr_intr_11
+    AVALANCHE_INT_36,                               // 36  | SRTR_INTD12     | Active high level | packet Processor        | srtr_intr_12
+    AVALANCHE_INT_37,                               // 37  | SRTR_INTD13     | Active high level | packet Processor        | srtr_intr_13
+    AVALANCHE_INT_38,                               // 38  | SRTR_INTD14     | Active high level | packet Processor        | srtr_intr_14
+    AVALANCHE_INT_39,                               // 39  | SRTR_INTD15     | Active high level | packet Processor        | srtr_intr_15
+    AVALANCHE_INTD1_BASE_INT,                       // 40  | SRTR_INTD16     | Active high level | packet Processor        | srtr_intr_16
+    AVALANCHE_INT_41,                               // 41  | SRTR_INTD17     | Active high level | packet Processor        | srtr_intr_17
+    AVALANCHE_INT_42,                               // 42  | SRTR_INTD18     | Active high level | packet Processor        | srtr_intr_18
+    AVALANCHE_INT_43,                               // 43  | SRTR_INTD19     | Active high level | packet Processor        | srtr_intr_19
+    AVALANCHE_INT_44,                               // 44  | SRTR_INTD20     | Active high level | packet Processor        | srtr_intr_20
+    AVALANCHE_INT_45,                               // 45  | SRTR_INTD21     | Active high level | packet Processor        | srtr_intr_21
+    AVALANCHE_INT_46,                               // 46  | SRTR_INTD22     | Active high level | packet Processor        | srtr_intr_22
+    AVALANCHE_INT_47,                               // 47  | SRTR_INTD23     | Active high level | packet Processor        | srtr_intr_23
+    AVALANCHE_INT_48,                               // 48  | SRTR_INTD24     | Active high level | packet Processor        | srtr_intr_24
+    AVALANCHE_INT_49,                               // 49  | SRTR_INTD25     | Active high level | packet Processor        | srtr_intr_25
+    AVALANCHE_INT_50,                               // 50  | SRTR_INTD26     | Active high level | packet Processor        | srtr_intr_26
+    AVALANCHE_INT_51,                               // 51  | SRTR_INTD27     | Active high level | packet Processor        | srtr_intr_27
+    AVALANCHE_INT_52,                               // 52  | DBG_TRC_INTR    | Active high level | debug HW module         | dbg_intr
+    AVALANCHE_INT_53,                               // 53  | IA_SPI_INTR     | Active high level |                         | ia2netip_spi_intr
+    AVALANCHE_INT_54,                               // 54  | IA_EMMC1_INTR   | Active high level |                         | ia2netip_emmc1_intr
+    AVALANCHE_EMMC_INT,                             // 55  | IA_EMMC0_INTR   | Active high level |                         | ia2netip_emmc0_intr
+    AVALANCHE_INT_56,                               // 56  | GPINT0          | Active low level  | DSPINTC                 | gp_intr_reg_out[0]
+    AVALANCHE_INT_57,                               // 57  | SPI_INTR        | Active high level | SPI_INTR                | spi_master_interrupt
+    AVALANCHE_PP_EVENT_INT,                         // 58  | PPEVENT-INTR    | Active high level | PP to ARM11             | ext_dect_int_in_sync
+    AVALANCHE_INT_59,                               // 59  | L2CCINTR        | Active high level | ARM11 L2$               | ext_slac_int_in_sync
+    PHY_OFDM_INT_IRQ_NUM,                           // 60  | PHYOFDM         | Active high level | PHY OFDM                | phy_ofdm_interrupt_sync
+    AVALANCHE_GBE_CONTROL_INT,                      // 61  | GBEINT          | Active high level | GBE                     | gbe_gmac_int_sync
+    AVALANCHE_INT_62,                               // 62  | CNT64_1_2       | Active high level | CNT 64 1                | cnt2_done_intr
+    AVALANCHE_INT_63,                               // 63  | CNT64_1_3       | Active high level | CNT 64 1                | cnt3_done_intr
+
+    AVALANCHE_INT_64,                               // 64  | Reserved        | tie high          |                         |
+    AVALANCHE_INT_65,                               // 65  | Reserved        | tie high          |                         |
+    AVALANCHE_INT_66,                               // 66  | COMMTXINT       | Active low level  | IC11                    | commtx_n
+    AVALANCHE_INT_67,                               // 67  | COMMRXINT       | Active high level | IC11                    | commrx_n
+    AVALANCHE_INT_68,                               // 68  | ARM11_NPMUIRQ   | Active low level  | IC11                    | arm11_npmuirq_sync
+    AVALANCHE_INT_69,                               // 69  | C55ADDRINT      | Active high pulse | DSPSS                   | c55xss_addr_excp_out
+    AVALANCHE_INT_70,                               // 70  | C55IDLEINT      | Active high level | DSPSS                   | c55xss_idle_int_out
+    AVALANCHE_INT_71,                               // 71  | C55INT          | Active low level  | DSPSS                   | c55xss_int_out
+    MAC_ERR_INT_IRQ_NUM,                            // 72  | DMACHSTERR      | Active high level | DMAC                    | dmac_top_hst_error
+    AVALANCHE_INT_73,                               // 73  | SSXINT          | Active high level | SSX                     | docsis_ssx_top_intr
+    AVALANCHE_INT_74,                               // 74  | EXTINT0         | Active high level | external int            | ext_intr_00_to_excp10_sync
+    AVALANCHE_INT_75,                               // 75  | EXTINT1         | Active high level | external int            | ext_intr_01_to_excp11_sync
+    AVALANCHE_INT_76,                               // 76  | EXTINT2         | Active high level | external int            | ext_intr_02_to_excp12_sync
+    AVALANCHE_INT_77,                               // 77  | EXTINT3         | Active high level | external int            | ext_intr_03_to_excp13_sync
+    AVALANCHE_INT_78,                               // 78  | EXTINT4         | Active high level | external int            | ext_intr_04_to_excp14_sync
+    AVALANCHE_INT_79,                               // 79  | EXTINT5         | Active high level | external int            | ext_intr_05_to_excp15_sync
+    AVALANCHE_INT_80,                               // 80  | EXTINT6         | Active high level | external int            | ext_intr_06_to_excp16_sync
+    AVALANCHE_INT_81,                               // 81  | EXTINT7         | Active high level | external int            | ext_intr_07_to_excp17_sync
+    AVALANCHE_INT_82,                               // 82  | DOC2IOSF        | Active high level | external int            | doc2iosf_brg_non_msk_int_sync
+    AVALANCHE_INT_83,                               // 83  | DOC2IOSF        | Active high level | external int            | doc2iosf_brg_msk_int_sync
+    AVALANCHE_INT_84,                               // 84  | MOCA2ARM11      | Active high level | MOCA2.0                 | moca_host_irq_out_sync
+    AVALANCHE_INT_85,                               // 85  | UARTINT3        | Active high level | Uart3                   | uart3_intr
+    AVALANCHE_HW_MBOX_INT,                          // 86  | MBXINT          | Active high level | Mailbox                 | mbx2arm11_intr
+    AVALANCHE_INT_87,                               // 87  | VCODEC_INTR     | Active high level | VCODEC                  | intel_vcodec_interrupt_sync
+    AVALANCHE_INT_88,                               // 88  | EXTINT8         | Active high level | EMMC                    | ext_intr_08_to_excp24_sync
+    AVALANCHE_INT_89,                               // 89  | EXTINT9         | Active high level | external SPI (from SoC) | ext_intr_09_to_excp25_sync
+    AVALANCHE_INT_90,                               // 90  | I2CRXDMA        | Active high pulse | i2c DMA                 | i2c_ctrl_dma_rx_int
+    AVALANCHE_INT_91,                               // 91  | I2CTXDMA        | Active high pulse | i2c DMA                 | i2c_ctrl_dma_tx_int
+    AVALANCHE_INT_92,                               // 92  | SEC_VIOL        | Active high pulse | Boot config             | sec_viol_inter
+    AVALANCHE_HW_MUTEX_INT,                         // 93  | MUTEXINTR       | Active high level | Mutex                   | mtx2arm11_intr
+    AVALANCHE_INT_94,                               // 94  | CNT64_1_0       | Active high level | CNT 64 1                | cnt0_done_intr
+    AVALANCHE_INT_95                                // 95  | CNT64_1_1       | Active high level | CNT 64 1                | cnt1_done_intr
+
+}PUMA7_INTC_INTERRUPTS_e;
+
+/* Just for compilation p_unit_drv will pass, we should disable p_unit_drv for Puma7 */
+#define AVALANCHE_PUNIT_INT AVALANCHE_INT_79
+
+#endif /* __PUMA7_INTERRUPTS_H */
diff --git a/include/linux/avalanche/puma7/puma7_pp.h b/include/linux/avalanche/puma7/puma7_pp.h
new file mode 100755
index 0000000..43e8579
--- /dev/null
+++ b/include/linux/avalanche/puma7/puma7_pp.h
@@ -0,0 +1,641 @@
+/*
+ * puma7_pp.h
+ * Description:
+ * See below.
+ *
+   This file is provided under a dual BSD/GPLv2 license.  When using or
+  redistributing this file, you may do so under either license.
+
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 - 2016 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution
+  in the file called LICENSE.GPL.
+
+
+  Contact Information:
+  Intel Corporation
+  2200 Mission College Blvd.
+  Santa Clara, CA  97052
+
+  BSD LICENSE
+
+  Copyright(c) 2014 - 2016 Intel Corporation. All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+    * Neither the name of Intel Corporation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+/*
+ * This file contains Packet Processor configuration. All the configurations
+ * here are system level and hence a complete knowledge of configurations of all
+ * devices/drivers related to the Packet Processor is required before modifying
+ * any value.
+ *
+ * The private data structures used by avalanche_ppd_init() are also present in
+ * this file and should not be modified unless the function avalanche_ppd_init
+ * in file puma7_pp.c is also required to be modified for PP configuration.
+ *
+ */
+
+#ifndef _INCLUDE_PUMA7_PP_H
+#define _INCLUDE_PUMA7_PP_H
+
+#define PP_DEFAULT_MTU_SIZE    (1500)
+#define MAX_IP_PACKET_SIZE      1514
+#define MIN_IP_PACKET_SIZE      64
+
+/* Queue threshold (short/long/xl) */
+#define THRESHOLD_0_VALUE       (384)
+#define THRESHOLD_1_VALUE       (1920)
+
+/*
+ * PID Range configurations
+ */
+typedef enum PP_PID_NUM
+{
+    PP_DOCSIS_RX_PID_NUM,              // 0
+    PP_RESERVED_PID_NUM_1,             // 1
+    PP_RESERVED_PID_NUM_2,             // 2
+    PP_SGMII0_RX_PID_NUM,              // 3
+    PP_SGMII1_RX_PID_NUM,              // 4
+    PP_RGMII0_RX_PID_NUM,              // 5
+    PP_MoCA_RX_PID_NUM,                // 6
+    PP_ATOM_RX_PID_NUM,                // 7
+    PP_RGMII1_RX_PID_NUM,              // 8
+    PP_VOICE_DSP_C55_PID_NUM,          // 9
+    PP_RESERVED_PID_NUM_10,            // 10
+    PP_RESERVED_PID_NUM_11,            // 11
+    PP_RESERVED_PID_NUM_12,            // 12
+    PP_RESERVED_PID_NUM_13,            // 13
+    PP_RESERVED_PID_NUM_14,            // 14
+    PP_RESERVED_PID_NUM_15,            // 15
+    PP_WiFi_PORT0_PID_NUM,             // 16
+    PP_WiFi_PORT1_PID_NUM,             // 17
+    PP_WiFi_PORT2_PID_NUM,             // 18
+    PP_WiFi_PORT3_PID_NUM,             // 19
+    PP_RESERVED_PID_NUM_20,            // 20
+    PP_RESERVED_PID_NUM_21,            // 21
+    PP_RESERVED_PID_NUM_22,            // 22
+    PP_RESERVED_PID_NUM_23,            // 23
+    PP_RESERVED_PID_NUM_24,            // 24
+    PP_RESERVED_PID_NUM_25,            // 25
+    PP_RESERVED_PID_NUM_26,            // 26
+    PP_RESERVED_PID_NUM_27,            // 27
+    PP_RESERVED_PID_NUM_28,            // 28
+    PP_RESERVED_PID_NUM_29,            // 29
+    PP_RESERVED_PID_NUM_30,            // 30
+    PP_RESERVED_PID_NUM_31,            // 31
+}PP_PID_NUM_e;
+
+#if 0
+#define PP_ETH_PID_COUNT    1   // for backward compatible
+#define PP_ETH_PID_BASE     31  // for backward compatible
+#define PP_USB_PID_COUNT    4   // for backward compatible
+#define PP_USB_PID_BASE     26  // for backward compatible
+#endif
+
+#define PP_C55_PID_COUNT    1   /* configuration for C55 DSP */
+#define PP_C55_PID_BASE     PP_VOICE_DSP_C55_PID_NUM  /* configuration for C55 DSP */
+
+/* QoS Clusters definitions */
+typedef enum PAL_CPPI41_PP_QOS_CLUSTERS
+{
+    PAL_CPPI41_PP_DOCSIS_TX_QOS_CLUSTER_BASE,
+        PAL_CPPI41_PP_DOCSIS_TX_BE0_QOS_CLUSTER_NUM = PAL_CPPI41_PP_DOCSIS_TX_QOS_CLUSTER_BASE,     // 0
+        PAL_CPPI41_PP_DOCSIS_TX_BE1_QOS_CLUSTER_NUM,                                                // 1
+        PAL_CPPI41_PP_DOCSIS_TX_BE2_QOS_CLUSTER_NUM,                                                // 2
+        PAL_CPPI41_PP_DOCSIS_TX_BE3_QOS_CLUSTER_NUM,                                                // 3
+        PAL_CPPI41_PP_DOCSIS_TX_BE4_QOS_CLUSTER_NUM,                                                // 4
+        PAL_CPPI41_PP_DOCSIS_TX_BE5_QOS_CLUSTER_NUM,                                                // 5
+        PAL_CPPI41_PP_DOCSIS_TX_BE6_QOS_CLUSTER_NUM,                                                // 6
+        PAL_CPPI41_PP_DOCSIS_TX_BE7_QOS_CLUSTER_NUM,                                                // 7
+        PAL_CPPI41_PP_DOCSIS_TX_BE8_QOS_CLUSTER_NUM,                                                // 8
+        PAL_CPPI41_PP_DOCSIS_TX_BE9_QOS_CLUSTER_NUM,                                                // 9
+        PAL_CPPI41_PP_DOCSIS_TX_BE10_QOSl_CLUSTER_NUM,                                               // 10
+        PAL_CPPI41_PP_DOCSIS_TX_BE11_QOS_CLUSTER_NUM,                                               // 11
+        PAL_CPPI41_PP_DOCSIS_TX_BE12_QOS_CLUSTER_NUM,                                               // 12
+        PAL_CPPI41_PP_DOCSIS_TX_BE13_QOS_CLUSTER_NUM,                                               // 13
+        PAL_CPPI41_PP_DOCSIS_TX_BE14_QOS_CLUSTER_NUM,                                               // 14
+        PAL_CPPI41_PP_DOCSIS_TX_BE15_QOS_CLUSTER_NUM,                                               // 15
+    PAL_CPPI41_PP_DOCSIS_TX_QOS_CLUSTER_LAST = PAL_CPPI41_PP_DOCSIS_TX_BE15_QOS_CLUSTER_NUM,
+
+    PAL_CPPI41_PP_MoCA_QOS_CLUSTER_NUM,                                                             // 16
+
+    PAL_CPPI_GBE_QOS_CLUSTER_BASE,
+    PAL_CPPI41_PP_ATOM_QOS_CLUSTER_NUM = PAL_CPPI_GBE_QOS_CLUSTER_BASE,                             // 17
+    PAL_CPPI41_PP_RGMII0_QOS_CLUSTER_NUM,                                                           // 18
+    PAL_CPPI41_PP_RGMII1_QOS_CLUSTER_NUM,                                                           // 19
+    PAL_CPPI41_PP_SGMII0_QOS_CLUSTER_NUM,                                                           // 20
+    PAL_CPPI41_PP_SGMII1_QOS_CLUSTER_NUM,                                                           // 21
+    PAL_CPPI41_PP_GBE_QOS_CLUSTER_LAST = PAL_CPPI41_PP_SGMII1_QOS_CLUSTER_NUM,
+
+    PAL_CPPI41_PP_WiFi_PORT0_QOS_CLUSTER_NUM,                                                       // 22
+    PAL_CPPI41_PP_WiFi_PORT1_QOS_CLUSTER_NUM,                                                       // 23
+    PAL_CPPI41_PP_WiFi_PORT2_QOS_CLUSTER_NUM,                                                       // 24
+    PAL_CPPI41_PP_WiFi_PORT3_QOS_CLUSTER_NUM,                                                       // 25
+    PAL_CPPI41_PP_WiFi_PORT4_QOS_CLUSTER_NUM,                                                       // 26
+    PAL_CPPI41_PP_WiFi_PORT5_QOS_CLUSTER_NUM,                                                       // 27
+    PAL_CPPI41_PP_WiFi_PORT6_QOS_CLUSTER_NUM,                                                       // 28
+    PAL_CPPI41_PP_WiFi_PORT7_QOS_CLUSTER_NUM,                                                       // 29
+    PAL_CPPI41_PP_WiFi_PORT8_QOS_CLUSTER_NUM,                                                       // 30
+    PAL_CPPI41_PP_WiFi_PORT9_QOS_CLUSTER_NUM,                                                       // 31
+    PAL_CPPI41_PP_WiFi_PORT10_QOS_CLUSTER_NUM,                                                      // 32
+    PAL_CPPI41_PP_WiFi_PORT11_QOS_CLUSTER_NUM,                                                      // 33
+    PAL_CPPI41_PP_WiFi_PORT12_QOS_CLUSTER_NUM,                                                      // 34
+    PAL_CPPI41_PP_WiFi_PORT13_QOS_CLUSTER_NUM,                                                      // 35
+    PAL_CPPI41_PP_WiFi_PORT14_QOS_CLUSTER_NUM,                                                      // 36
+    PAL_CPPI41_PP_WiFi_PORT15_QOS_CLUSTER_NUM,                                                      // 37
+
+    PAL_CPPI41_PP_QOS_CLUSTERS_COUNT,
+    PAL_CPPI41_PP_QOS_CLUSTERS_MAX = PAL_CPPI41_PP_QOS_CLUSTERS_COUNT
+
+}PAL_CPPI41_PP_QOS_CLUSTERS_e;
+
+#define PAL_CPPI41_PP_DOCSIS_TX_QOS_CLUSTER_COUNT       (PAL_CPPI41_PP_DOCSIS_TX_QOS_CLUSTER_LAST - PAL_CPPI41_PP_DOCSIS_TX_QOS_CLUSTER_BASE + 1)
+#define PAL_CPPI41_PP_L2SW_QOS_CLUSTER_COUNT            (PAL_CPPI41_PP_L2SW_QOS_CLUSTER_LAST - PAL_CPPI41_PP_L2SW_QOS_CLUSTER_BASE + 1)
+
+/**
+ * wifi device indexes enumeration
+ */
+typedef enum {
+    WIFI_DEV_ID_0,
+    WIFI_DEV_ID_1,
+    WIFI_DEV_ID_2,
+    WIFI_DEV_ID_3,
+    WIFI_DEVS_CNT
+} wifi_dev_id_e;
+
+#if (defined(CONFIG_WIFI_PROXY) || defined(PPA_PUMA7))
+#define WIFI_DEVICE_ID_VALID(dev_id)                    (WIFI_DEV_ID_0 <= (dev_id) && (dev_id) < WIFI_DEVS_CNT)
+#define FOR_EACH_WIFI_DEVICE_ID(i)                      for (i = WIFI_DEV_ID_0; i < WIFI_DEVS_CNT; i++)
+#define WIFI_DEVICE_TO_PID(dev_id)                      ((dev_id) + PP_WiFi_PORT0_PID_NUM)
+#define IS_WIFI_PID(pid)                                (((pid) >= PP_WiFi_PORT0_PID_NUM) && ((pid) <= (PP_WiFi_PORT0_PID_NUM + (WIFI_DEVS_CNT - 1))))
+
+/**
+ * wifi vap indexes enumeration
+ */
+typedef enum {
+    WIFI_VAP_ID_0,
+    WIFI_VAP_ID_1,
+    WIFI_VAP_ID_2,
+    WIFI_VAP_ID_3,
+    WIFI_VAP_ID_4,
+    WIFI_VAP_ID_5,
+    WIFI_VAP_ID_6,
+    WIFI_VAP_ID_7,
+    WIFI_VAP_ID_8,
+    WIFI_VAP_ID_9,
+    WIFI_VAP_ID_10,
+    WIFI_VAP_ID_11,
+    WIFI_VAP_ID_12,
+    WIFI_VAP_ID_13,
+    WIFI_VAP_ID_14,
+    WIFI_VAP_ID_15,
+    WIFI_VAP_ID_16,
+    WIFI_VAP_ID_17,
+    WIFI_VAP_ID_18,
+    WIFI_VAP_ID_19,
+    WIFI_VAP_ID_20,
+    WIFI_VAP_ID_21,
+    WIFI_VAP_ID_22,
+    WIFI_VAP_ID_23,
+    WIFI_VAP_ID_24,
+    WIFI_VAP_ID_25,
+    WIFI_VAP_ID_26,
+    WIFI_VAP_ID_27,
+    WIFI_VAP_ID_28,
+    WIFI_VAP_ID_29,
+    WIFI_VAP_ID_30,
+    WIFI_VAP_ID_31,
+    WIFI_VAPS_CNT
+} wifi_vap_id_e;
+
+#define WIFI_VAP_ID_VALID(vap_id)       \
+            (WIFI_VAP_ID_0 <= (vap_id) && (vap_id) < WIFI_VAPS_CNT)
+#define FOR_EACH_WIFI_VAP_ID(i)         \
+            for (i = WIFI_VAP_ID_0; i < WIFI_VAPS_CNT; i++)
+
+/**
+ * wifi device states enumeration
+ */
+typedef enum {
+    WIFI_DEV_STATE_ACTIVE,
+    WIFI_DEV_STATE_SUSPEND,
+    WIFI_DEV_STATE_INVALID,
+    WIFI_DEV_STATSE_CNT
+} wifi_dev_state_e;
+#endif // defined(CONFIG_WIFI_PROXY) || defined(CONFIG_PPA_PUMA7)
+
+/*************************************/
+/* PP Registers addresses and macros */
+/*************************************/
+#define AVALANCHE_PP_PHY_ADDR_RGN_BASE                  0xF3000000
+#define AVALANCHE_PP_CLOCK                              480000000                                   // 480MHz
+
+#define AVALANCHE_PP_CLASSIFIER_1_0_IRAM_RGN_BASE       (IO_ADDRESS(0xF3000000))
+#define AVALANCHE_PP_CLASSIFIER_1_0_DBG_RGN_BASE        (IO_ADDRESS(0xF3002000))
+#define AVALANCHE_PP_CLASSIFIER_1_0_CTRL_RGN_BASE       (IO_ADDRESS(0xF3003000))
+#define AVALANCHE_PP_CLASSIFIER_1_1_IRAM_RGN_BASE       (IO_ADDRESS(0xF3004000))
+#define AVALANCHE_PP_CLASSIFIER_1_1_DBG_RGN_BASE        (IO_ADDRESS(0xF3006000))
+#define AVALANCHE_PP_CLASSIFIER_1_1_CTRL_RGN_BASE       (IO_ADDRESS(0xF3007000))
+#define AVALANCHE_PP_CLASSIFIER_1_2_IRAM_RGN_BASE       (IO_ADDRESS(0xF3008000))
+#define AVALANCHE_PP_CLASSIFIER_1_2_DBG_RGN_BASE        (IO_ADDRESS(0xF300A000))
+#define AVALANCHE_PP_CLASSIFIER_1_2_CTRL_RGN_BASE       (IO_ADDRESS(0xF300B000))
+#define AVALANCHE_PP_CLASSIFIER_1_3_IRAM_RGN_BASE       (IO_ADDRESS(0xF300C000))
+#define AVALANCHE_PP_CLASSIFIER_1_3_DBG_RGN_BASE        (IO_ADDRESS(0xF300E000))
+#define AVALANCHE_PP_CLASSIFIER_1_3_CTRL_RGN_BASE       (IO_ADDRESS(0xF300F000))
+#define AVALANCHE_PP_CLASSIFIER_1_0_CMD_RGN_BASE        (IO_ADDRESS(0xF3020000))
+#define AVALANCHE_PP_CLASSIFIER_1_1_CMD_RGN_BASE        (IO_ADDRESS(0xF3020000))
+#define AVALANCHE_PP_CLASSIFIER_1_2_CMD_RGN_BASE        (IO_ADDRESS(0xF3020000))
+#define AVALANCHE_PP_CLASSIFIER_1_3_CMD_RGN_BASE        (IO_ADDRESS(0xF3020000))
+#define AVALANCHE_PP_CLASSIFIER_1_0_PARAM_RGN_BASE      (IO_ADDRESS(0xF3020004))
+#define AVALANCHE_PP_CLASSIFIER_1_1_PARAM_RGN_BASE      (IO_ADDRESS(0xF3020004))
+#define AVALANCHE_PP_CLASSIFIER_1_2_PARAM_RGN_BASE      (IO_ADDRESS(0xF3020004))
+#define AVALANCHE_PP_CLASSIFIER_1_3_PARAM_RGN_BASE      (IO_ADDRESS(0xF3020004))
+
+#define AVALANCHE_PP_CLASSIFIER_2_0_IRAM_RGN_BASE       (IO_ADDRESS(0xF3080000))
+#define AVALANCHE_PP_CLASSIFIER_2_0_DBG_RGN_BASE        (IO_ADDRESS(0xF3082000))
+#define AVALANCHE_PP_CLASSIFIER_2_0_CTRL_RGN_BASE       (IO_ADDRESS(0xF3083000))
+#define AVALANCHE_PP_CLASSIFIER_2_1_IRAM_RGN_BASE       (IO_ADDRESS(0xF3084000))
+#define AVALANCHE_PP_CLASSIFIER_2_1_DBG_RGN_BASE        (IO_ADDRESS(0xF3086000))
+#define AVALANCHE_PP_CLASSIFIER_2_1_CTRL_RGN_BASE       (IO_ADDRESS(0xF3087000))
+#define AVALANCHE_PP_CLASSIFIER_2_2_IRAM_RGN_BASE       (IO_ADDRESS(0xF3088000))
+#define AVALANCHE_PP_CLASSIFIER_2_2_DBG_RGN_BASE        (IO_ADDRESS(0xF308A000))
+#define AVALANCHE_PP_CLASSIFIER_2_2_CTRL_RGN_BASE       (IO_ADDRESS(0xF308B000))
+#define AVALANCHE_PP_CLASSIFIER_2_3_IRAM_RGN_BASE       (IO_ADDRESS(0xF308C000))
+#define AVALANCHE_PP_CLASSIFIER_2_3_DBG_RGN_BASE        (IO_ADDRESS(0xF308E000))
+#define AVALANCHE_PP_CLASSIFIER_2_3_CTRL_RGN_BASE       (IO_ADDRESS(0xF308F000))
+#define AVALANCHE_PP_CLASSIFIER_2_0_CMD_RGN_BASE        (IO_ADDRESS(0xF30A0000))
+#define AVALANCHE_PP_CLASSIFIER_2_1_CMD_RGN_BASE        (IO_ADDRESS(0xF30A0000))
+#define AVALANCHE_PP_CLASSIFIER_2_2_CMD_RGN_BASE        (IO_ADDRESS(0xF30A0000))
+#define AVALANCHE_PP_CLASSIFIER_2_3_CMD_RGN_BASE        (IO_ADDRESS(0xF30A0000))
+#define AVALANCHE_PP_CLASSIFIER_2_0_PARAM_RGN_BASE      (IO_ADDRESS(0xF30A0004))
+#define AVALANCHE_PP_CLASSIFIER_2_1_PARAM_RGN_BASE      (IO_ADDRESS(0xF30A0004))
+#define AVALANCHE_PP_CLASSIFIER_2_2_PARAM_RGN_BASE      (IO_ADDRESS(0xF30A0004))
+#define AVALANCHE_PP_CLASSIFIER_2_3_PARAM_RGN_BASE      (IO_ADDRESS(0xF30A0004))
+#define AVALANCHE_PP_MTA_TURN_OFF_HIGH_PRIORITY_QUEUE   (IO_ADDRESS(0xF30A0186)) /* If this byte is not 0 PP will turn off high priority queue. */
+
+#define AVALANCHE_PP_MODIFIER_0_IRAM_RGN_BASE           (IO_ADDRESS(0xF3100000))
+#define AVALANCHE_PP_MODIFIER_0_DBG_RGN_BASE            (IO_ADDRESS(0xF3102000))
+#define AVALANCHE_PP_MODIFIER_0_CTRL_RGN_BASE           (IO_ADDRESS(0xF3103000))
+#define AVALANCHE_PP_MODIFIER_1_IRAM_RGN_BASE           (IO_ADDRESS(0xF3104000))
+#define AVALANCHE_PP_MODIFIER_1_DBG_RGN_BASE            (IO_ADDRESS(0xF3106000))
+#define AVALANCHE_PP_MODIFIER_1_CTRL_RGN_BASE           (IO_ADDRESS(0xF3107000))
+#define AVALANCHE_PP_MODIFIER_2_IRAM_RGN_BASE           (IO_ADDRESS(0xF3108000))
+#define AVALANCHE_PP_MODIFIER_2_DBG_RGN_BASE            (IO_ADDRESS(0xF310A000))
+#define AVALANCHE_PP_MODIFIER_2_CTRL_RGN_BASE           (IO_ADDRESS(0xF310B000))
+#define AVALANCHE_PP_MODIFIER_3_IRAM_RGN_BASE           (IO_ADDRESS(0xF310C000))
+#define AVALANCHE_PP_MODIFIER_3_DBG_RGN_BASE            (IO_ADDRESS(0xF310E000))
+#define AVALANCHE_PP_MODIFIER_3_CTRL_RGN_BASE           (IO_ADDRESS(0xF310F000))
+#define AVALANCHE_PP_MODIFIER_0_CMD_RGN_BASE            (IO_ADDRESS(0xF3120000))
+#define AVALANCHE_PP_MODIFIER_1_CMD_RGN_BASE            (IO_ADDRESS(0xF3120000))
+#define AVALANCHE_PP_MODIFIER_2_CMD_RGN_BASE            (IO_ADDRESS(0xF3120000))
+#define AVALANCHE_PP_MODIFIER_3_CMD_RGN_BASE            (IO_ADDRESS(0xF3120000))
+#define AVALANCHE_PP_MODIFIER_0_PARAM_RGN_BASE          (IO_ADDRESS(0xF3120004))
+#define AVALANCHE_PP_MODIFIER_1_PARAM_RGN_BASE          (IO_ADDRESS(0xF3120004))
+#define AVALANCHE_PP_MODIFIER_2_PARAM_RGN_BASE          (IO_ADDRESS(0xF3120004))
+#define AVALANCHE_PP_MODIFIER_3_PARAM_RGN_BASE          (IO_ADDRESS(0xF3120004))
+#define AVALANCHE_PP_MODIFIER_MTU_TABLE_BASE            (IO_ADDRESS(0xF3120100))    // Modifier PDSP MTU table
+
+#define AVALANCHE_PP_MODIFIER_MTU_TABLE_UPDATE(vpidId, mtuSize)              \
+{                                                                            \
+    volatile Uint16 *mtu_per_vpid = 0;                                       \
+    mtu_per_vpid = (Uint16 *)AVALANCHE_PP_MODIFIER_MTU_TABLE_BASE + (vpidId);\
+    *mtu_per_vpid = cpu_to_be16(mtuSize);                                    \
+}
+
+#define AVALANCHE_PP_DS_RESEQ_CMD_RGN_BASE              (IO_ADDRESS(0xF3EC0000))
+#define AVALANCHE_PP_DS_RESEQ_PARAM_RGN_BASE            (IO_ADDRESS(0xF3EC0004))
+#define AVALANCHE_PP_DS_RESEQ_IRAM_RGN_BASE             (IO_ADDRESS(0xF3EEC000))
+#define AVALANCHE_PP_DS_RESEQ_CTRL_RGN_BASE             (IO_ADDRESS(0xF3EEE000))
+#define AVALANCHE_PP_DS_RESEQ_DBG_RGN_BASE              (IO_ADDRESS(0xF3EEF000))
+#define AVALANCHE_PP_DS_RESEQ_INTRPT_BNDL_RGN_BASE      (IO_ADDRESS(0xF3C21340)) 
+
+
+#define AVALANCHE_PP_SESSION_CACHE_CMD_RGN_BASE         (IO_ADDRESS(0xF3330000))
+#define AVALANCHE_PP_SESSION_CACHE_PARAM_RGN_BASE       (IO_ADDRESS(0xF3330004))
+#define AVALANCHE_PP_SESSION_CACHE_IRAM_RGN_BASE        (IO_ADDRESS(0xF3340000))
+#define AVALANCHE_PP_SESSION_CACHE_DBG_RGN_BASE         (IO_ADDRESS(0xF3342000))
+#define AVALANCHE_PP_SESSION_CACHE_CTRL_RGN_BASE        (IO_ADDRESS(0xF3342300))
+#define AVALANCHE_PP_SESSION_CACHE_TIMER_RGN_BASE       (IO_ADDRESS(0xF3362000))
+
+#define AVALANCHE_PP_PREFETCHER_0_IRAM_RGN_BASE         (IO_ADDRESS(0xF3400000))
+#define AVALANCHE_PP_PREFETCHER_0_DBG_RGN_BASE          (IO_ADDRESS(0xF3402000))
+#define AVALANCHE_PP_PREFETCHER_0_CTRL_RGN_BASE         (IO_ADDRESS(0xF3403000))
+#define AVALANCHE_PP_PREFETCHER_1_IRAM_RGN_BASE         (IO_ADDRESS(0xF3404000))
+#define AVALANCHE_PP_PREFETCHER_1_DBG_RGN_BASE          (IO_ADDRESS(0xF3406000))
+#define AVALANCHE_PP_PREFETCHER_1_CTRL_RGN_BASE         (IO_ADDRESS(0xF3407000))
+#define AVALANCHE_PP_PREFETCHER_2_IRAM_RGN_BASE         (IO_ADDRESS(0xF3408000))
+#define AVALANCHE_PP_PREFETCHER_2_DBG_RGN_BASE          (IO_ADDRESS(0xF340A000))
+#define AVALANCHE_PP_PREFETCHER_2_CTRL_RGN_BASE         (IO_ADDRESS(0xF340B000))
+#define AVALANCHE_PP_PREFETCHER_3_IRAM_RGN_BASE         (IO_ADDRESS(0xF340C000))
+#define AVALANCHE_PP_PREFETCHER_3_DBG_RGN_BASE          (IO_ADDRESS(0xF340E000))
+#define AVALANCHE_PP_PREFETCHER_3_CTRL_RGN_BASE         (IO_ADDRESS(0xF340F000))
+
+#define AVALANCHE_PP_PREFETCHER_0_CMD_RGN_BASE          (IO_ADDRESS(0xF3420000))
+#define AVALANCHE_PP_PREFETCHER_1_CMD_RGN_BASE          (IO_ADDRESS(0xF3420000))
+#define AVALANCHE_PP_PREFETCHER_2_CMD_RGN_BASE          (IO_ADDRESS(0xF3420000))
+#define AVALANCHE_PP_PREFETCHER_3_CMD_RGN_BASE          (IO_ADDRESS(0xF3420000))
+#define AVALANCHE_PP_PREFETCHER_0_PARAM_RGN_BASE        (IO_ADDRESS(0xF3420004))
+#define AVALANCHE_PP_PREFETCHER_1_PARAM_RGN_BASE        (IO_ADDRESS(0xF3420004))
+#define AVALANCHE_PP_PREFETCHER_2_PARAM_RGN_BASE        (IO_ADDRESS(0xF3420004))
+#define AVALANCHE_PP_PREFETCHER_3_PARAM_RGN_BASE        (IO_ADDRESS(0xF3420004))
+
+#define AVALANCHE_PP_TurboDOX_IRAM_RGN_BASE             (IO_ADDRESS(0xF3600000))
+#define AVALANCHE_PP_TurboDOX_DBG_RGN_BASE              (IO_ADDRESS(0xF3602000))
+#define AVALANCHE_PP_TurboDOX_CTRL_RGN_BASE             (IO_ADDRESS(0xF3603000))
+#define AVALANCHE_PP_TurboDOX_CMD_RGN_BASE              (IO_ADDRESS(0xF3610000))
+#define AVALANCHE_PP_TurboDOX_PARAM_RGN_BASE            (IO_ADDRESS(0xF3610004))
+
+#define AVALANCHE_PP_RESEQUENCER_IRAM_RGN_BASE          (IO_ADDRESS(0xF3640000))
+#define AVALANCHE_PP_RESEQUENCER_DBG_RGN_BASE           (IO_ADDRESS(0xF3642000))
+#define AVALANCHE_PP_RESEQUENCER_CTRL_RGN_BASE          (IO_ADDRESS(0xF3643000))
+#define AVALANCHE_PP_RESEQUENCER_CMD_RGN_BASE           (IO_ADDRESS(0xF3650000))
+#define AVALANCHE_PP_RESEQUENCER_PARAM_RGN_BASE         (IO_ADDRESS(0xF3650004))
+
+#define AVALANCHE_PP_STATISTICAL_FRC_S1_CTL_BASE        (IO_ADDRESS(0xF36C3FF0))
+#define AVALANCHE_PP_STATISTICAL_FRC_S1_RESET_BASE      (IO_ADDRESS(0xF36C3FF4))
+#define AVALANCHE_PP_STATISTICAL_FRC_S1_L_BASE          (IO_ADDRESS(0xF36C3FF8))
+#define AVALANCHE_PP_STATISTICAL_FRC_S1_H_BASE          (IO_ADDRESS(0xF36C3FFC))
+
+#define AVALANCHE_PP_CRYPTO_CMD_RGN_BASE                (IO_ADDRESS(0xF3806000))
+
+#define AVALANCHE_PP_AQM_IRAM_RGN_BASE                  (IO_ADDRESS(0xF3C00000))
+#define AVALANCHE_PP_AQM_DBG_RGN_BASE                   (IO_ADDRESS(0xF3C02000))
+#define AVALANCHE_PP_AQM_CTRL_RGN_BASE                  (IO_ADDRESS(0xF3C03000))
+#define AVALANCHE_PP_AQM_CMD_RGN_BASE                   (IO_ADDRESS(0xF3C10000))
+#define AVALANCHE_PP_AQM_PARAM_RGN_BASE                 (IO_ADDRESS(0xF3C10004))
+
+#define AVALANCHE_PP_RANDOMIZER_AQM_BASE                (IO_ADDRESS(0xF3C04100))
+#define AVALANCHE_PP_RANDOMIZER_QOS_BASE                (IO_ADDRESS(0xF3E08300))
+
+/* MAILBOX */
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_REG_STAGE1        (IO_ADDRESS(0xF3C20108))
+
+/* AVALANCHE_PP_MAILBOX_CLK_CTRL definition for STAGE 1 */
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_CLASSIFIER_1_0    0x00000001
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_CLASSIFIER_1_1    0x00000002
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_CLASSIFIER_1_2    0x00000004
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_CLASSIFIER_1_3    0x00000008
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_CLASSIFIER_2_0    0x00000010
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_CLASSIFIER_2_1    0x00000020
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_CLASSIFIER_2_2    0x00000040
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_CLASSIFIER_2_3    0x00000080
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_MODIFIER_0        0x00000100
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_MODIFIER_1        0x00000200
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_MODIFIER_2        0x00000400
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_MODIFIER_3        0x00000800
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_PREFETCHER_0      0x00001000
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_PREFETCHER_1      0x00002000
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_PREFETCHER_2      0x00004000
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_PREFETCHER_3      0x00008000
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_TDOX              0x00010000
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_RE_SEQ            0x00020000
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_SESSION_CACHE     0x00040000
+
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_REG_STAGE2        (IO_ADDRESS(0xF3C2010C))
+
+/* AVALANCHE_PP_MAILBOX_CLK_CTRL definition for STAGE 2 */
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_US_PROCESSING     0x00020000
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_QOS_0             0x00010000
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_QOS_1             0x00008000
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_DPI               0x00004000
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_RECYCLER          0x00002000
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_RCE               0x00001000
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_ENCRYPT           0x00000800
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_DECRYPT           0x00000400
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_DS_RESEQ          0x00000200
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_ACCUMULATOR       0x00000100
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_MOCA              0x00000080
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_WIFI_TX           0x00000040
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_WIFI_RX           0x00000020
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_MC                0x00000010
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_SEC_ENGINE        0x00000008
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_CRYPTO_PDSP       0x00000004
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_SEQUENCER         0x00000002
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_AQM               0x00000001
+
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_REG_MISC          (IO_ADDRESS(0xF3C20110))
+
+/* AVALANCHE_PP_MAILBOX_CLK_CTRL definition misc*/
+#define AVALANCHE_PP_MAILBOX_CLK_CTRL_MPC_RCE_STATE     0x00000001
+
+#define AVALANCHE_PP_CLASSIFIER_1_0_INTRPT_BNDL_RGN_BASE (IO_ADDRESS(0xF3C21000))
+#define AVALANCHE_PP_CLASSIFIER_1_1_INTRPT_BNDL_RGN_BASE (IO_ADDRESS(0xF3C21020))
+#define AVALANCHE_PP_CLASSIFIER_1_2_INTRPT_BNDL_RGN_BASE (IO_ADDRESS(0xF3C21040))
+#define AVALANCHE_PP_CLASSIFIER_1_3_INTRPT_BNDL_RGN_BASE (IO_ADDRESS(0xF3C21060))
+#define AVALANCHE_PP_CLASSIFIER_2_0_INTRPT_BNDL_RGN_BASE (IO_ADDRESS(0xF3C21080))
+#define AVALANCHE_PP_CLASSIFIER_2_1_INTRPT_BNDL_RGN_BASE (IO_ADDRESS(0xF3C210A0))
+#define AVALANCHE_PP_CLASSIFIER_2_2_INTRPT_BNDL_RGN_BASE (IO_ADDRESS(0xF3C210C0))
+#define AVALANCHE_PP_CLASSIFIER_2_3_INTRPT_BNDL_RGN_BASE (IO_ADDRESS(0xF3C210E0))
+#define AVALANCHE_PP_MODIFIER_0_INTRPT_BNDL_RGN_BASE     (IO_ADDRESS(0xF3C21100))
+#define AVALANCHE_PP_MODIFIER_1_INTRPT_BNDL_RGN_BASE     (IO_ADDRESS(0xF3C21120))
+#define AVALANCHE_PP_MODIFIER_2_INTRPT_BNDL_RGN_BASE     (IO_ADDRESS(0xF3C21140))
+#define AVALANCHE_PP_MODIFIER_3_INTRPT_BNDL_RGN_BASE     (IO_ADDRESS(0xF3C21160))
+#define AVALANCHE_PP_PREFETCHER_0_INTRPT_BNDL_RGN_BASE   (IO_ADDRESS(0xF3C21180))
+#define AVALANCHE_PP_PREFETCHER_1_INTRPT_BNDL_RGN_BASE   (IO_ADDRESS(0xF3C211A0))
+#define AVALANCHE_PP_PREFETCHER_2_INTRPT_BNDL_RGN_BASE   (IO_ADDRESS(0xF3C211C0))
+#define AVALANCHE_PP_PREFETCHER_3_INTRPT_BNDL_RGN_BASE   (IO_ADDRESS(0xF3C211E0))
+#define AVALANCHE_PP_SESSION_CACHE_INTRPT_BNDL_RGN_BASE  (IO_ADDRESS(0xF3C21200))
+#define AVALANCHE_PP_TurboDOX_INTRPT_BNDL_RGN_BASE       (IO_ADDRESS(0xF3C21220))
+#define AVALANCHE_PP_RESEQUENCER_INTRPT_BNDL_RGN_BASE    (IO_ADDRESS(0xF3C21240))
+#define AVALANCHE_PP_QOS_0_INTRPT_BNDL_RGN_BASE          (IO_ADDRESS(0xF3C21260))
+#define AVALANCHE_PP_QOS_1_INTRPT_BNDL_RGN_BASE          (IO_ADDRESS(0xF3C21280))
+#define AVALANCHE_PP_DPI_INTRPT_BNDL_RGN_BASE            (IO_ADDRESS(0xF3C212A0))
+#define AVALANCHE_PP_RECYCLER_INTRPT_BNDL_RGN_BASE       (IO_ADDRESS(0xF3C212C0))
+#define AVALANCHE_PP_RCE_INTRPT_BNDL_RGN_BASE            (IO_ADDRESS(0xF3C212E0))
+#define AVALANCHE_PP_ENCRYPT_INTRPT_BNDL_RGN_BASE        (IO_ADDRESS(0xF3C21300))
+#define AVALANCHE_PP_DECRYPT_INTRPT_BNDL_RGN_BASE        (IO_ADDRESS(0xF3C21320))
+#define AVALANCHE_PP_ACCUMULATOR_INTRPT_BNDL_RGN_BASE    (IO_ADDRESS(0xF3C21360))
+#define AVALANCHE_PP_MOCA_INTRPT_BNDL_RGN_BASE           (IO_ADDRESS(0xF3C21380))
+#define AVALANCHE_PP_WIFI_TX_INTRPT_BNDL_RGN_BASE        (IO_ADDRESS(0xF3C213A0))
+#define AVALANCHE_PP_WIFI_RX_INTRPT_BNDL_RGN_BASE        (IO_ADDRESS(0xF3C213C0))
+#define AVALANCHE_PP_MC_INTRPT_BNDL_RGN_BASE             (IO_ADDRESS(0xF3C21400))
+#define AVALANCHE_PP_SEQUENCER_INTRPT_BNDL_RGN_BASE      (IO_ADDRESS(0xF3C21420))
+#define AVALANCHE_PP_AQM_INTRPT_BNDL_RGN_BASE            (IO_ADDRESS(0xF3C21440))
+#define AVALANCHE_PP_CRYPTO_INTRPT_BNDL_RGN_BASE         (IO_ADDRESS(0xF3C21460))
+#define AVALANCHE_PP_HOST_INTRPT_0_BNDL_RGN_BASE         (IO_ADDRESS(0xF3C21800))
+
+#define AVALANCHE_PP_HOST_INTRPT_0_BNDL_PP_EVENT        0x00000002
+// Following are in PP region but are actually used by DS FW Reseqencer PDSP
+#define AVALANCHE_DS_FW_RESEQ_INTRPT_0_BNDL_RGN_BASE    0xF3C21820
+#define AVALANCHE_DS_FW_RESEQ_INTRPT_1_BNDL_RGN_BASE    0xF3C21840
+#define AVALANCHE_DS_FW_RESEQ_INTRPT_2_BNDL_RGN_BASE    0xF3C21860
+
+//#define AVALANCHE_INTD_BASE                             (IO_ADDRESS(0xF3C22000))
+
+#define AVALANCHE_PP_STATISTICAL_FRC_S2_CTL_BASE        (IO_ADDRESS(0xF3C33FF0))
+#define AVALANCHE_PP_STATISTICAL_FRC_S2_RESET_BASE      (IO_ADDRESS(0xF3C33FF4))
+#define AVALANCHE_PP_STATISTICAL_FRC_S2_L_BASE          (IO_ADDRESS(0xF3C33FF8))
+#define AVALANCHE_PP_STATISTICAL_FRC_S2_H_BASE          (IO_ADDRESS(0xF3C33FFC))
+
+#define AVALANCHE_PP_QOS_0_IRAM_RGN_BASE                (IO_ADDRESS(0xF3E00000))
+#define AVALANCHE_PP_QOS_0_DBG_RGN_BASE                 (IO_ADDRESS(0xF3E02000))
+#define AVALANCHE_PP_QOS_0_CTRL_RGN_BASE                (IO_ADDRESS(0xF3E03000))
+#define AVALANCHE_PP_QOS_1_IRAM_RGN_BASE                (IO_ADDRESS(0xF3E04000))
+#define AVALANCHE_PP_QOS_1_DBG_RGN_BASE                 (IO_ADDRESS(0xF3E06000))
+#define AVALANCHE_PP_QOS_1_CTRL_RGN_BASE                (IO_ADDRESS(0xF3E07000))
+#define AVALANCHE_PP_QOS_0_CMD_RGN_BASE                 (IO_ADDRESS(0xF3E10000))
+#define AVALANCHE_PP_QOS_1_CMD_RGN_BASE                 (IO_ADDRESS(0xF3E10100))
+#define AVALANCHE_PP_QOS_0_PARAM_RGN_BASE               (IO_ADDRESS(0xF3E10004))
+#define AVALANCHE_PP_QOS_1_PARAM_RGN_BASE               (IO_ADDRESS(0xF3E10104))
+
+#define AVALANCHE_PP_ACCUMULATOR_CMD_RGN_BASE           (IO_ADDRESS(0xF3E20000))
+#define AVALANCHE_PP_ACCUMULATOR_PARAM_RGN_BASE         (IO_ADDRESS(0xF3E20004))
+#define AVALANCHE_PP_ACCUMULATOR_IRAM_RGN_BASE          (IO_ADDRESS(0xF3E30000))
+#define AVALANCHE_PP_ACCUMULATOR_DBG_RGN_BASE           (IO_ADDRESS(0xF3E32000))
+#define AVALANCHE_PP_ACCUMULATOR_CTRL_RGN_BASE          (IO_ADDRESS(0xF3E33000))
+
+#define AVALANCHE_PP_ENCRYPT_CMD_RGN_BASE                 (IO_ADDRESS(0xF3E40000))
+#define AVALANCHE_PP_DECRYPT_CMD_RGN_BASE                 (IO_ADDRESS(0xF3E40100))
+#define AVALANCHE_PP_ENCRYPT_PARAM_RGN_BASE               (IO_ADDRESS(0xF3E40004))
+#define AVALANCHE_PP_DECRYPT_PARAM_RGN_BASE               (IO_ADDRESS(0xF3E40104))
+#define AVALANCHE_PP_ENCRYPT_IRAM_RGN_BASE                (IO_ADDRESS(0xF3E60000))
+#define AVALANCHE_PP_ENCRYPT_DBG_RGN_BASE                 (IO_ADDRESS(0xF3E61000))
+#define AVALANCHE_PP_ENCRYPT_CTRL_RGN_BASE                (IO_ADDRESS(0xF3E62000))
+#define AVALANCHE_PP_DECRYPT_IRAM_RGN_BASE                (IO_ADDRESS(0xF3E63000))
+#define AVALANCHE_PP_DECRYPT_DBG_RGN_BASE                 (IO_ADDRESS(0xF3E64000))
+#define AVALANCHE_PP_DECRYPT_CTRL_RGN_BASE                (IO_ADDRESS(0xF3E65000))
+
+#define AVALANCHE_PP_MOCA_IRAM_RGN_BASE                 (IO_ADDRESS(0xF3EA0000))
+#define AVALANCHE_PP_MOCA_DBG_RGN_BASE                  (IO_ADDRESS(0xF3EA2000))
+#define AVALANCHE_PP_MOCA_CTRL_RGN_BASE                 (IO_ADDRESS(0xF3EA3000))
+#define AVALANCHE_PP_MOCA_CMD_RGN_BASE                  (IO_ADDRESS(0xF3EB0000))
+#define AVALANCHE_PP_MOCA_PARAM_RGN_BASE                (IO_ADDRESS(0xF3EB0004))
+
+#define AVALANCHE_PP_RECYCLER_CMD_RGN_BASE              (IO_ADDRESS(0xF3F00000))
+#define AVALANCHE_PP_RECYCLER_PARAM_RGN_BASE            (IO_ADDRESS(0xF3F00004))
+#define AVALANCHE_PP_RECYCLER_IRAM_RGN_BASE             (IO_ADDRESS(0xF3F10000))
+#define AVALANCHE_PP_RECYCLER_DBG_RGN_BASE              (IO_ADDRESS(0xF3F12000))
+#define AVALANCHE_PP_RECYCLER_CTRL_RGN_BASE             (IO_ADDRESS(0xF3F13000))
+
+#define AVALANCHE_PP_MC_IRAM_RGN_BASE                   (IO_ADDRESS(0xF3F20000))
+#define AVALANCHE_PP_MC_DBG_RGN_BASE                    (IO_ADDRESS(0xF3F22000))
+#define AVALANCHE_PP_MC_CTRL_RGN_BASE                   (IO_ADDRESS(0xF3F23000))
+#define AVALANCHE_PP_MC_CMD_RGN_BASE                    (IO_ADDRESS(0xF3F30000))
+#define AVALANCHE_PP_MC_PARAM_RGN_BASE                  (IO_ADDRESS(0xF3F30004))
+#define AVALNACHE_PP_MC_MTU_TABLE_BASE                  (IO_ADDRESS(0xF3F30100))    // MC PDSP MTU table
+
+#define AVALANCHE_PP_MC_MTU_TABLE_UPDATE(vpidId, mtuSize)              \
+{                                                                      \
+    volatile Uint16 *mtu_per_vpid = 0;                                 \
+    mtu_per_vpid = (Uint16 *)AVALNACHE_PP_MC_MTU_TABLE_BASE + (vpidId);\
+    *mtu_per_vpid = cpu_to_be16(mtuSize);                              \
+}
+
+#define AVALANCHE_PP_DPI_CMD_RGN_BASE                   (IO_ADDRESS(0xF3F40000))
+#define AVALANCHE_PP_DPI_PARAM_RGN_BASE                 (IO_ADDRESS(0xF3F40004))
+#define AVALANCHE_PP_DPI_IRAM_RGN_BASE                  (IO_ADDRESS(0xF3F50000))
+#define AVALANCHE_PP_DPI_DBG_RGN_BASE                   (IO_ADDRESS(0xF3F52000))
+#define AVALANCHE_PP_DPI_CTRL_RGN_BASE                  (IO_ADDRESS(0xF3F53000))
+
+#define AVALANCHE_PP_CRYPTO_CMD_RGN_BASE                (IO_ADDRESS(0xF3806000))
+#define AVALANCHE_PP_CRYPTO_PARAM_RGN_BASE              (IO_ADDRESS(0xF3806004))
+#define AVALANCHE_PP_CRYPTO_IRAM_RGN_BASE               (IO_ADDRESS(0xF3800000))
+#define AVALANCHE_PP_CRYPTO_DBG_RGN_BASE                (IO_ADDRESS(0xF3802000))
+#define AVALANCHE_PP_CRYPTO_CTRL_RGN_BASE               (IO_ADDRESS(0xF3803000))
+
+#define AVALANCHE_PP_RCE_CMD_RGN_BASE                   (IO_ADDRESS(0xF3E80000))
+#define AVALANCHE_PP_RCE_PARAM_RGN_BASE                 (IO_ADDRESS(0xF3E80004))
+#define AVALANCHE_PP_RCE_IRAM_RGN_BASE                  (IO_ADDRESS(0xF3E90000))
+#define AVALANCHE_PP_RCE_DBG_RGN_BASE                   (IO_ADDRESS(0xF3E94000))
+#define AVALANCHE_PP_RCE_CTRL_RGN_BASE                  (IO_ADDRESS(0xF3E98000))
+
+#define AVALANCHE_PP_WIFI_TX_CMD_RGN_BASE               (IO_ADDRESS(0xF3F60000))
+#define AVALANCHE_PP_WIFI_TX_PARAM_RGN_BASE             (IO_ADDRESS(0xF3F60004))
+#define AVALANCHE_PP_WIFI_TX_IRAM_RGN_BASE              (IO_ADDRESS(0xF3F70000))
+#define AVALANCHE_PP_WIFI_TX_DBG_RGN_BASE               (IO_ADDRESS(0xF3F72000))
+#define AVALANCHE_PP_WIFI_TX_CTRL_RGN_BASE              (IO_ADDRESS(0xF3F73000))
+
+#define AVALANCHE_PP_WIFI_RX_CMD_RGN_BASE               (IO_ADDRESS(0xF3FE0000))
+#define AVALANCHE_PP_WIFI_RX_PARAM_RGN_BASE             (IO_ADDRESS(0xF3FE0004))
+#define AVALANCHE_PP_WIFI_RX_IRAM_RGN_BASE              (IO_ADDRESS(0xF3FF0000))
+#define AVALANCHE_PP_WIFI_RX_DBG_RGN_BASE               (IO_ADDRESS(0xF3FF2000))
+#define AVALANCHE_PP_WIFI_RX_CTRL_RGN_BASE              (IO_ADDRESS(0xF3FF3000))
+
+#define AVALANCHE_PP_SEQUENCER_IRAM_RGN_BASE            (IO_ADDRESS(0xF3FC0000))
+#define AVALANCHE_PP_SEQUENCER_DBG_RGN_BASE             (IO_ADDRESS(0xF3FC2000))
+#define AVALANCHE_PP_SEQUENCER_CTRL_RGN_BASE            (IO_ADDRESS(0xF3FC3000))
+#define AVALANCHE_PP_SEQUENCER_CMD_RGN_BASE             (IO_ADDRESS(0xF3FD0000))
+#define AVALANCHE_PP_SEQUENCER_PARAM_RGN_BASE           (IO_ADDRESS(0xF3FD0004))
+
+
+/*********************/
+/* General PP macros */
+/*********************/
+
+/* PP Free running counter */
+#define FREE_RUNNING_COUNTER_ENABLE()                   {(*(volatile unsigned int *)AVALANCHE_PP_STATISTICAL_FRC_S1_CTL_BASE) |= cpu_to_be32(0x1); (*(volatile unsigned int *)AVALANCHE_PP_STATISTICAL_FRC_S2_CTL_BASE) |= cpu_to_be32(0x1);}
+#define FREE_RUNNING_COUNTER_RESET()                    {(*(volatile unsigned int *)AVALANCHE_PP_STATISTICAL_FRC_S1_RESET_BASE) |= cpu_to_be32(0x1); (*(volatile unsigned int *)AVALANCHE_PP_STATISTICAL_FRC_S2_RESET_BASE) |= cpu_to_be32(0x1);}
+#define FREE_RUNNING_COUNTER_L_GET()                    be32_to_cpu(*(volatile unsigned int *)AVALANCHE_PP_STATISTICAL_FRC_S2_L_BASE)
+#define FREE_RUNNING_COUNTER_H_GET()                    be32_to_cpu(*(volatile unsigned int *)AVALANCHE_PP_STATISTICAL_FRC_S2_H_BASE)
+
+/* Randomizer seeding */
+#define RANDOMIZER_AQM_SEED(seed)                      {(*(volatile unsigned int *)AVALANCHE_PP_RANDOMIZER_AQM_BASE) = cpu_to_be32(seed);}
+#define RANDOMIZER_QOS_SEED(seed)                      {(*(volatile unsigned int *)AVALANCHE_PP_RANDOMIZER_QOS_BASE) = cpu_to_be32(seed);}
+
+
+/* PP MTU size */
+#define UPDATE_MTU_TABLE_IN_PDSP_DMEM(vpidId, mtuSize)        \
+    AVALANCHE_PP_MODIFIER_MTU_TABLE_UPDATE(vpidId, mtuSize);  \
+    AVALANCHE_PP_MC_MTU_TABLE_UPDATE(vpidId, mtuSize);
+
+/* PP PDSPs Offsets in mailbox to get the PDSP and PP versions */
+#define AVALANCHE_PP_PDSPs_PP_VERSION_OFFSET                0xF8
+#define AVALANCHE_PP_PDSPs_PDSP_VERSION_OFFSET              0xFC
+
+/* PP Session Cache timer settings */
+#define SESSION_CACHE_TOTAL_SESSIONS_SUPPORTED              (35 * 1024)
+#define SESSION_CACHE_SESSIONS_TIMEOUTS_PER_TIMER           256
+#define SESSION_CACHE_NUM_TIMEOUT_EVENTS_UNTIL_WRAP         (SESSION_CACHE_TOTAL_SESSIONS_SUPPORTED / SESSION_CACHE_SESSIONS_TIMEOUTS_PER_TIMER)        // 140
+#define SESSION_CACHE_TOTAL_CACHED_SESSIONS                 1024
+#define SESSION_CACHE_SESSION_UPDATES_PER_TIMER             16
+#define SESSION_CACHE_NUM_UPDATE_EVENTS_UNTIL_WRAP          (SESSION_CACHE_TOTAL_CACHED_SESSIONS / SESSION_CACHE_SESSION_UPDATES_PER_TIMER)             // 64
+#define SESSION_CACHE_NUM_EVENTS_UNTIL_WRAP                 (SESSION_CACHE_NUM_TIMEOUT_EVENTS_UNTIL_WRAP + SESSION_CACHE_NUM_UPDATE_EVENTS_UNTIL_WRAP)  // We would like to have total of 204 events in 1 second
+#define SESSION_CACHE_TIMER_PRESCALER_REG_VAL               0b1100                                                                                      // Divides the frequency of the timer by a factor of 8192
+#define SESSION_CACHE_TIMER_PRESCALER_DIV_VAL               (1 << (SESSION_CACHE_TIMER_PRESCALER_REG_VAL + 1))                                          // 8192
+#define SESSION_CACHE_TIMER_LOAD_VAL_FOR_1SEC_LOOP          ((AVALANCHE_PP_CLOCK / SESSION_CACHE_NUM_EVENTS_UNTIL_WRAP) / SESSION_CACHE_TIMER_PRESCALER_DIV_VAL)
+
+extern int avalanche_pp_kernel_post_init (void);
+
+#endif /* !_INCLUDE_PUMA7_PP_H */
diff --git a/include/linux/avalanche/puma7/synopsys_gbe_interface.h b/include/linux/avalanche/puma7/synopsys_gbe_interface.h
new file mode 100755
index 0000000..a3e84b5
--- /dev/null
+++ b/include/linux/avalanche/puma7/synopsys_gbe_interface.h
@@ -0,0 +1,87 @@
+/*
+ *
+ * synopsys_gbe_interface.h
+ * Description:
+ * DWC ETHER QOS driver interface
+ *
+ *
+ * GPL LICENSE SUMMARY
+ *
+ *  Copyright(c) 2015 Intel Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of version 2 of the GNU General Public License as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *  The full GNU General Public License is included in this distribution
+ *  in the file called LICENSE.GPL.
+ *
+ *  Contact Information:
+ *  Intel Corporation
+ *  2200 Mission College Blvd.
+ *  Santa Clara, CA  97052
+ */
+
+#ifndef __SYNOPSYS_GBE_INTERFACE_H__
+
+#define __SYNOPSYS_GBE_INTERFACE_H__
+
+
+typedef enum{
+    DWC_ETH_QOS_INTEL_PRIVATE_CMD_START = 50,
+    DWC_ETH_QOS_MUX_SET_CMD = DWC_ETH_QOS_INTEL_PRIVATE_CMD_START,
+    DWC_ETH_QOS_MUX_GET_CMD,
+    DWC_ETH_QOS_MUX_SET_GBE_DBG_PRINT,
+    DWC_ETH_QOS_INTEL_PRIVATE_CMD_END
+}DWC_ETH_QOS_CMDS;
+
+typedef enum
+{
+    DBG_PRINT_NONE = 0x00,
+    DBG_PRINT_RX   = 0x01,
+    DBG_PRINT_TX   = 0x10,
+    DBG_PRINT_BOTH = DBG_PRINT_RX | DBG_PRINT_TX
+}e_print_dbg;
+
+#define PRINT_DBG_PRINT_MODE(print_mode)\
+        ((print_mode) == DBG_PRINT_NONE ? "Off" :\
+        ((print_mode) == DBG_PRINT_RX   ? "Rx"  :\
+        ((print_mode) == DBG_PRINT_TX   ? "Tx"  :\
+        ((print_mode) == DBG_PRINT_BOTH ? "Both": "UNKNOWN"))))
+
+#define DWC_ETH_QOS_RWK_FILTER_LENGTH	8
+
+/* common data structure between driver and application for
+ * sharing info through ioctl
+ * */
+struct ifr_data_struct {
+	unsigned int flags;
+	unsigned int qInx; /* dma channel no to be configured */
+	unsigned int cmd;
+    unsigned int mdioNum;
+    unsigned int param;
+	unsigned int context_setup;
+	unsigned int connected_speed;
+	unsigned int rwk_filter_values[DWC_ETH_QOS_RWK_FILTER_LENGTH];
+	unsigned int rwk_filter_length;
+	int command_error;
+	int test_done;
+	void *ptr;
+};
+
+#define NSGMII0_NAME         "nsgmii0"
+#define NSGMII1_NAME         "nsgmii1"
+#define NRGMII2_NAME         "nrgmii2"
+#define NRGMII3_NAME         "nrgmii3"
+#define NGMII_TO_ATOM_NAME   "ngmii4"
+
+#endif /* __SYNOPSYS_GBE_INTERFACE_H__ */
diff --git a/include/linux/hw_mbox_defs.h b/include/linux/hw_mbox_defs.h
index c4b39e6..98dd923 100644
--- a/include/linux/hw_mbox_defs.h
+++ b/include/linux/hw_mbox_defs.h
@@ -865,13 +865,8 @@ typedef Uint8 __hwMbox_opcodeMessageSizeExceededAllowedSize[HW_MBOX_OPCODE_MINIM
 |                                           |
 ********************************************/
 
-#if (defined CONFIG_TI_KERNEL_GW_APPCPU) || (defined CONFIG_INTEL_KERNEL_PP_DRIVER_ON_ATOM)
 #define HW_MBOX_NP_APP_SRAM_SIZE 256
 #define HW_MBOX_APP_NP_SRAM_SIZE 256
-#else
-#define HW_MBOX_NP_APP_SRAM_SIZE 64
-#define HW_MBOX_APP_NP_SRAM_SIZE 128
-#endif
 
 /*! \def HW_MBOX_STATIC_CHANNEL_TABLE
     \brief X-MACRO hardcoded table for STATIC Channel declarations.
diff --git a/include/linux/ipv6.h b/include/linux/ipv6.h
index 167c976..080d66d 100644
--- a/include/linux/ipv6.h
+++ b/include/linux/ipv6.h
@@ -194,7 +194,12 @@ struct ipv6_pinfo {
                                 rxflow:1,
 				rxtclass:1,
 				rxpmtu:1,
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+				rxorigdstaddr:1,
+				ti_rxinfo:1;
+#else
 				rxorigdstaddr:1;
+#endif
 				/* 2 bits hole */
 		} bits;
 		__u16		all;
diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h
index 450f19c..6ef09c5 100644
--- a/include/linux/mmzone.h
+++ b/include/linux/mmzone.h
@@ -21,7 +21,7 @@
 
 /* Free memory management - zoned buddy allocator.  */
 #ifndef CONFIG_FORCE_MAX_ZONEORDER
-#define MAX_ORDER 11
+#define MAX_ORDER 14
 #else
 #define MAX_ORDER CONFIG_FORCE_MAX_ZONEORDER
 #endif
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 79cd164..76febf8 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -22,9 +22,17 @@
  *
  *		Moved to /usr/include/linux for NET3
  */
+/*
+Includes Intel Corporation's changes/modifications dated: 2014.
+Changed/modified portions - Copyright  2014, Intel Corporation.
+*/
 #ifndef _LINUX_NETDEVICE_H
 #define _LINUX_NETDEVICE_H
 
+#ifndef CONFIG_ARM_AVALANCHE_SOC
+#include <linux/avalanche/puma7/puma7_defs.h>
+#endif
+
 #include <linux/pm_qos.h>
 #include <linux/timer.h>
 #include <linux/bug.h>
@@ -36,6 +44,14 @@
 #include <linux/percpu.h>
 #include <linux/rculist.h>
 #include <linux/dmaengine.h>
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+#ifndef CONFIG_ARM_AVALANCHE_SOC
+#include <linux/avalanche/generic/avalanche_pp_api.h>
+#else
+#include <linux/ti_ppm.h>
+#include <asm-arm/arch-avalanche/generic/avalanche_pp_api.h>
+#endif
+#endif /* CONFIG_TI_PACKET_PROCESSOR */
 #include <linux/workqueue.h>
 #include <linux/dynamic_queue_limits.h>
 
@@ -155,6 +171,15 @@ static inline bool dev_xmit_complete(int rc)
 #define MAX_HEADER (LL_MAX_HEADER + 48)
 #endif
 
+#ifdef CONFIG_TI_DEVICE_INDEX_REUSE
+/* Maximum number of net devices supported. TI L2 Selective forwarder uses
+ * 64 bits to mark the packet to indicate the device on which the packets should
+ * be forwarded. Hence Max Device Index is limited to 64.
+ * Do not increment the number.
+ */
+#define TI_MAX_DEVICE_INDEX     64
+#endif /* CONFIG_TI_DEVICE_INDEX_REUSE */
+
 /*
  *	Old network device statistics. Fields are native words
  *	(unsigned long) so they can be read and written atomically.
@@ -1403,6 +1428,78 @@ struct net_device {
 #if IS_ENABLED(CONFIG_NETPRIO_CGROUP)
 	struct netprio_map __rcu *priomap;
 #endif
+#ifdef CONFIG_TI_DEVICE_PROTOCOL_HANDLING
+    int (*packet_handler)(struct sk_buff *skb);
+#endif
+
+#ifdef CONFIG_INTEL_NS_DEVICE_FILTER
+   int (*ns_handler)(struct net_device *dev,struct	in6_addr* dst_addr,unsigned char banned_flags);
+#endif
+
+#ifdef CONFIG_TI_EGRESS_HOOK
+    int (*egress_hook)(struct sk_buff *skb);
+#endif
+
+#ifdef CONFIG_TI_DOCSIS_EGRESS_HOOK
+    int (*docsis_egress_hook)(struct sk_buff *skb);
+#endif
+
+#ifdef CONFIG_TI_GW_EGRESS_HOOK
+    int (*gw_egress_hook)(struct sk_buff *skb);
+#endif
+
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    /* PPM Device Information. Each networking device can be considered as a VPID
+     * instance executing on a PID. The PID is created when the hardware associated
+     * with the device has been initialized; the VPID Information is initialized and
+     * every subsequent call to bring the interface UP and DOWN results in VPID
+     * creation and deletion. Virtual networking interfaces do not have a matching
+     * VPID. So if the PID handle is -1 then there is no VPID manipulation done on the
+     * device. */
+    int         pid_handle;
+    int         vpid_handle;
+
+    /* The VPID Information block which is associated with the networking device.
+     * This field is kept in the networking device because it gives us a convenient
+     * place to store all the VPID specific information. As mentioned above not all
+     * networking devices are a networking endpoint. In such cases the values in this
+     * structure are ignored. */
+#ifdef CONFIG_MACH_PUMA5
+    TI_PP_VPID                  vpid_block;
+#else
+    AVALANCHE_PP_VPID_INFO_t    vpid_block;
+#endif
+
+#if PUMA7_OR_NEWER_SOC_TYPE
+    int (*netdev_copy_priv_hook)(struct net_device *newDev, struct net_device *origDev);
+
+    /* For GMAC it will be set with NULL. for VLAN netdev we will set the original netdev pointer */
+    struct net_device   *parentDev;
+#endif
+
+    /* There QoS may be defined either for physical or virtual device
+       The QoS setting hooks are being triggered by PID creation.
+       In case there is a need in alternative QoS scheme to be created it can be
+       specified by setting the  qos_virtual_scheme_idx to a valid non default index
+       This alternative scheme creation is being triggered from VPID creation.
+       It has to be defined by the appropriate device drived */
+#define NETDEV_PP_QOS_PROFILE_DEFAULT   (-1)
+    int qos_virtual_scheme_idx;
+
+    int (*qos_setup_hook)   (struct net_device *dev_p);
+    int (*qos_shutdown_hook)(struct net_device *dev_p);
+    int (*qos_select_hook)  (struct sk_buff    *skb);
+    void (*qos_get_params_hook)  (struct net_device *dev, Uint16 *egressQ, Uint32 *rate);
+    int devInstance;
+#else
+#ifdef CONFIG_PPA_PUMA7
+    /* pid handle for network device */
+    unsigned int pid_handle;
+
+    /* virtual pid handle for network device */
+    unsigned int vpid_handle;
+#endif /* CONFIG_PPA_PUMA7 */
+#endif
 	/* phy device may attach itself for hardware timestamping */
 	struct phy_device *phydev;
 
@@ -1411,15 +1508,7 @@ struct net_device {
 	/* group the device belongs to */
 	int group;
 
-	struct pm_qos_request	pm_qos_req;
-#ifdef CONFIG_PPA_PUMA7
-	/* pid handle for network device */
-	unsigned int pid_handle;
-
-	/* virtual pid handle for network device */
-	unsigned int vpid_handle;
-#endif /* CONFIG_PPA_PUMA7 */
-
+    struct pm_qos_request   pm_qos_req;
 };
 #define to_net_dev(d) container_of(d, struct net_device, dev)
 
@@ -3138,6 +3227,12 @@ do {								\
 })
 #endif
 
+
+#ifdef CONFIG_TI_DEVICE_PROTOCOL_HANDLING
+extern int ti_register_protocol_handler (struct net_device* dev, int (*packet_handler)(struct sk_buff *skb));
+extern int ti_deregister_protocol_handler (struct net_device* dev);
+#endif /* CONFIG_TI_DEVICE_PROTOCOL_HANDLING */
+
 /*
  *	The list of packet types we will receive (as opposed to discard)
  *	and the routines to invoke.
diff --git a/include/linux/netip_mem_util.h b/include/linux/netip_mem_util.h
new file mode 100644
index 0000000..2613911
--- /dev/null
+++ b/include/linux/netip_mem_util.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright  2008 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ * Authors:
+ *     Jesse Barnes <jbarnes@virtuousgeek.org>
+ *
+ */
+#ifndef _NETIP_MEM_UTIL_
+#define _NETIP_MEM_UTIL_
+
+int netip_memmap_init(void);
+void netip_memmap_cleanup(void);
+void *netip_mmio_to_virtual(unsigned long phys_addr);
+void *netip_mmio_to_physical(void* virt_addr);
+void cache_flush_buffer(void *bufptr, int size);
+
+#endif
diff --git a/include/linux/netip_subsystem.h b/include/linux/netip_subsystem.h
index 897ea2f..93f4eec 100644
--- a/include/linux/netip_subsystem.h
+++ b/include/linux/netip_subsystem.h
@@ -39,6 +39,8 @@
 #define NETIP_BRIDGE_ISR_OFFSET 0x202C
 #define NETIP_BRIDGE_IRQ_MASK 0x1FF
 
+#define NETSS_DEV_GPIO_MMIO_OFFSET (0x140000)
+#define NETSS_DEV_GPIO_MMIO_SIZE (0x10000)
 #define NETSS_DEV_HWMUTEX_MMIO_OFFSET (0x190000)
 #define NETSS_DEV_HWMUTEX_MMIO_SIZE (0x10000)
 #define NETSS_DEV_HWMBX_MMIO_OFFSET (0x1A0000)
@@ -53,8 +55,48 @@
 #define NETSS_DEV_HW_COUNTERS_MMIO_SIZE (0x10000)
 #define NETSS_DEV_MOCA_MMIO_OFFSET (0xE800000)
 #define NETSS_DEV_MOCA_MMIO_SIZE (0x800000)
-#define NETSS_DEV_GBE_MMIO_OFFSET (0x318000)
-#define NETSS_DEV_GBE_MMIO_SIZE (0x6000)
+#define NETSS_DEV_GBEG_MMIO_OFFSET (0x318000)
+#define NETSS_DEV_GBEG_MMIO_SIZE (0x6000)
+#define NETSS_DEV_GBE5_MMIO_OFFSET (0x314000)
+#define NETSS_DEV_GBE5_MMIO_SIZE (0x4000)
+#define NETSS_DEV_GBE4_MMIO_OFFSET (0x310000)
+#define NETSS_DEV_GBE4_MMIO_SIZE (0x4000)
+#define NETSS_DEV_GBE3_MMIO_OFFSET (0x30C000)
+#define NETSS_DEV_GBE3_MMIO_SIZE (0x4000)
+#define NETSS_DEV_GBE2_MMIO_OFFSET (0x308000)
+#define NETSS_DEV_GBE2_MMIO_SIZE (0x4000)
+#define NETSS_DEV_GBE1_MMIO_OFFSET (0x304000)
+#define NETSS_DEV_GBE1_MMIO_SIZE (0x4000)
+#define NETSS_DEV_GBE0_MMIO_OFFSET (0x300000)
+#define NETSS_DEV_GBE0_MMIO_SIZE (0x4000)
+#define NETSS_DEV_CLK_MMIO_OFFSET (0xD0000)
+#define NETSS_DEV_CLK_MMIO_SIZE (0x10000)
+
+#define NETSS_DEV_BOOTCFG_MMIO_OFFSET (0xC0000)
+#define NETSS_DEV_BOOTCFG_MMIO_SIZE   (0x10000)
+
+#define NETSS_DEV_TDM_MMIO_OFFSET     (0x100000)
+#define NETSS_DEV_TDM_MMIO_SIZE       (0x100)
+
+#define NETSS_DEV_TIMER0_MMIO_OFFSET  (0x30000)
+#define NETSS_DEV_TIMER0_MMIO_SIZE    (0x100)
+
+#define NETSS_DEV_TIMER1_MMIO_OFFSET  (0x110000)
+#define NETSS_DEV_TIMER1_MMIO_SIZE    (0x100)
+
+#define NETSS_DEV_TDM1_MMIO_OFFSET    (0x120000)
+#define NETSS_DEV_TDM1_MMIO_SIZE      (0x100)
+
+#define NETSS_DEV_TIMER2_MMIO_OFFSET  (0x130000)
+#define NETSS_DEV_TIMER2_MMIO_SIZE    (0x100)
+
+#define NETSS_DEV_TDM2_MMIO_OFFSET    (0x180000)
+#define NETSS_DEV_TDM2_MMIO_SIZE      (0x100)
+
+#define NETSS_DEV_VCODEC_MMIO_OFFSET  (0xF6000)
+#define NETSS_DEV_VCODEC_MMIO_SIZE    (0x150)
+
+
 #define NETSS_DEV_CLK_CTRL_MMIO_OFFSET (0xD0000)
 #define NETSS_DEV_CLK_CTRL_MMIO_SIZE (0x10000)
 #define NETSS_DEV_BBU_CTRLR_MMIO_OFFSET (0x160000)
@@ -66,6 +108,7 @@
 
 typedef enum {
    NETSS_DEV_HW_MAILBOX = 0,
+   NETSS_DEV_GPIO,
    NETSS_DEV_HW_MUTEX,
    NETSS_DEV_PACKET_PROCESSOR1,
    NETSS_DEV_PACKET_PROCESSOR2,
@@ -73,9 +116,24 @@ typedef enum {
    NETSS_DEV_HW_COUNTERS,
    NETSS_DEV_MOCA,
    NETSS_DEV_GBE,
+   NETSS_DEV_GBE5,
+   NETSS_DEV_GBE4,
+   NETSS_DEV_GBE3,
+   NETSS_DEV_GBE2,
+   NETSS_DEV_GBE1,
+   NETSS_DEV_GBE0,
+   NETSS_DEV_CLK,
    NETSS_DEV_CLK_CTRL,
    NETSS_DEV_BBU_CTRLR,
    NETSS_DEV_PERIPHERAL_SRAM,
+   NETSS_DEV_BOOTCFG,
+   NETSS_DEV_TDM,
+   NETSS_DEV_TIMER0,
+   NETSS_DEV_TIMER1,
+   NETSS_DEV_TDM1,
+   NETSS_DEV_TIMER2,
+   NETSS_DEV_TDM2,
+   NETSS_DEV_VCODEC,
    NETSS_DEV_MAX
 }netss_dev_t;
 
@@ -157,5 +215,7 @@ void netss_interrupt_ack(netss_interrupt_t intrpt);
  **************************************************************************/
 int netss_power_state_change_callback_register(netss_dev_t subdevice, netss_power_state_callback_info_t *cbinfo);
 
+int netss_request_npcpu_irq(int irq_num, char* irq_name, netss_subdevice_irq_func func, void *args);
+
 #endif
 
diff --git a/include/linux/proc_fs_macros.h b/include/linux/proc_fs_macros.h
new file mode 100644
index 0000000..8cb5b30
--- /dev/null
+++ b/include/linux/proc_fs_macros.h
@@ -0,0 +1,41 @@
+/*
+ * The proc filesystem macros 
+ */
+
+#ifndef _LINUX_PROC_FS_MACROS_H
+#define _LINUX_PROC_FS_MACROS_H
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#define DECLARE_PROCFS_ENTRY(name, read_proc, write_proc) \
+static int name##_proc_open(struct inode *inode, struct file *file) \
+{ \
+    return single_open(file, read_proc, PDE_DATA(inode)); \
+} \
+static const struct file_operations name##_proc_fops = { \
+    .open     = name##_proc_open, \
+    .read     = seq_read, \
+    .llseek   = seq_lseek, \
+    .release  = single_release, \
+    .write    = write_proc \
+};
+
+#define DECLARE_PROCFS_READ_ENTRY(name, read_proc) \
+static int name##_proc_open(struct inode *inode, struct file *file) \
+{ \
+    return single_open(file, read_proc, PDE_DATA(inode)); \
+} \
+static const struct file_operations name##_proc_fops = { \
+    .open     = name##_proc_open, \
+    .read     = seq_read, \
+    .llseek   = seq_lseek, \
+    .release  = single_release, \
+};
+
+#define DECLARE_PROCFS_WRITE_ENTRY(name, write_proc) \
+static const struct file_operations name##_proc_fops = { \
+    .write    = write_proc \
+};
+
+#endif /* _LINUX_PROC_FS_MACROS_H */
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 21ec52d..2737cb6 100755
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -40,6 +40,9 @@
 #include <linux/netdev_features.h>
 #include <net/flow_keys.h>
 
+#ifndef CONFIG_ARM_AVALANCHE_SOC
+#include <linux/avalanche/puma7/puma7_defs.h>
+#endif
 /* Don't change this without changing skb_csum_unnecessary! */
 #define CHECKSUM_NONE 0
 #define CHECKSUM_UNNECESSARY 1
@@ -257,9 +260,7 @@ enum {
 
     #include <linux/ti_pp_path.h>
 
-    #ifdef CONFIG_ARM_AVALANCHE_PDSP_PP
-        #include <linux/avalanche/generic/avalanche_pp_api.h>
-    #endif
+    #include <linux/avalanche/generic/avalanche_pp_api.h>
 
     /* Egress queue definitions... */
     #define TI_PPM_EGRESS_QUEUE_INVALID     (-1)
@@ -272,9 +273,7 @@ enum {
         TI_PP_SESSION                   ti_session;
     #endif
 
-    #ifdef CONFIG_ARM_AVALANCHE_PDSP_PP
         AVALANCHE_PP_SESSION_INFO_t     pp_session;
-    #endif
 
         unsigned int                    flags;
         int                             input_device_index;
@@ -587,12 +586,30 @@ struct sk_buff {
     __u16           mac_header;
 
 #ifdef CONFIG_TI_META_DATA
-    __u32   ti_meta_info;
-    __u32   ti_meta_info2;
+    unsigned int    ti_meta_info;
+    unsigned int    ti_meta_info2;
+    unsigned int    ti_ds_traffic_prio;
 #endif /* CONFIG_TI_META_DATA */
-
+#ifdef CONFIG_INTEL_NF_GWMETA_SUPPORT
+    __u32    ti_gw_meta;
+#endif /* INTEL_NF_GWMETA_SUPPORT */
+
+#ifdef CONFIG_TI_DOCSIS_INPUT_DEV
+    struct net_device   *ti_docsis_input_dev;
+#endif /* CONFIG_TI_DOCSIS_INPUT_DEV */
+#ifdef CONFIG_INTEL_DOCSIS_ICMP_IIF
+    int         docsis_icmp_iif;
+#endif /* CONFIG_INTEL_DOCSIS_ICMP_IIF */
+#ifdef CONFIG_TI_L2_SELECTIVE_FORWARDER
+    unsigned long long   ti_selective_fwd_dev_info;
+#endif /* CONFIG_TI_L2_SELECTIVE_FORWARDER */
 #ifdef CONFIG_TI_PACKET_PROCESSOR
+    #if PUMA7_OR_NEWER_SOC_TYPE
     PP_PACKET_INFO_t    *pp_packet_info;
+    #else
+    PP_PACKET_INFO_t    pp_packet_info;
+    #endif
+    __u16               vpid_vlan_tci;
 #endif  /* CONFIG_TI_PACKET_PROCESSOR */
 
     /* These elements must be at the end, see alloc_skb() for details.  */
@@ -2952,7 +2969,7 @@ static inline unsigned int skb_gso_network_seglen(const struct sk_buff *skb)
 	return hdr_len + skb_gso_transport_seglen(skb);
 }
 
-#ifdef CONFIG_PPA_PUMA7
+#if defined(CONFIG_PPA_PUMA7) && !defined(CONFIG_ARM_AVALANCHE_SOC)
 struct skb_buf_manager_cb {
 	bool (*is_bm_skb)(struct sk_buff *skb);
 	int  (*bm_free_skb)(struct sk_buff *skb);
diff --git a/include/linux/ti_hil.h b/include/linux/ti_hil.h
index 2a56e5c..a6681f9 100755
--- a/include/linux/ti_hil.h
+++ b/include/linux/ti_hil.h
@@ -39,9 +39,24 @@ struct hil_core_notifier_param
 };
 #endif /* CONFIG_APPCPU_GW_PP_HANDLE */
 
+#define TI_HIL_PACKET_FLAG_PP_SESSION_INGRESS_RECORDED          0x00000001
 #define TI_HIL_PACKET_FLAG_PP_SESSION_BYPASS                    0x00000002
 #define TI_HIL_PACKET_FLAG_PP_SESSION_DROP_OFFSET               24
 
+
+/**************************************************************************
+ ****************************** Module Identifers *************************
+ **************************************************************************/
+
+/* Module Identifers: These describe the module which generated the event. */
+#define TI_DEVICE   1
+#define TI_INET     2
+#define TI_PP       3
+
+/* MRPC module id used for module registration */
+#define PP_DEV      1
+#define PP_HIL      2
+
 /**************************************************************************
  **************************** PP Event Identifiers ************************
  **************************************************************************/
@@ -83,6 +98,33 @@ struct hil_core_notifier_param
 #define TI_BRIDGE_PACKET_FLOODED     (TI_BRIDGE_EVENT + 0x6)
 
 /**************************************************************************
+ **************************** PP Routing Event Identifiers *****************
+ **************************************************************************/
+
+/* Base for all routing PP Event identifiers. */
+#define TI_ROUTE_EVENT              0x10
+
+/* Event generated when a route is added. */
+#define TI_ROUTE_ADDED              (TI_ROUTE_EVENT + 0x1)
+
+/* Event generated when a route is deleted. */
+#define TI_ROUTE_DELETED            (TI_ROUTE_EVENT + 0x2)
+
+/**************************************************************************
+ **************************** PP VLAN Event Identifiers *****************
+ **************************************************************************/
+
+/* Base for all VLAN PP Event identifiers. */
+#define TI_VLAN_EVENT               0x20
+
+/* Event generated when a VLAN device is created. */
+#define TI_VLAN_DEV_CREATED         (TI_VLAN_EVENT + 0x1)
+
+/* Event generated when a VLAN device is deleted. */
+#define TI_VLAN_DEV_DELETED         (TI_VLAN_EVENT + 0x2)
+
+
+/**************************************************************************
  ********************* PP Connection Tracking Event Identifiers ***********
  **************************************************************************/
 
@@ -109,6 +151,102 @@ struct hil_core_notifier_param
 
 #define TI_NPCPU_CONNTRACK_FLUSH  (TI_CT_EVENT + 0x8)
 
+/* Event generated as part of ATOM conntrack MRPC server handle */
+#define CT_APPCPU_DEATH_BY_TIMEOUT  (TI_CT_EVENT + 0x7)
+
+/**************************************************************************
+ ********************* PP Multicast Routing Event Identifiers *************
+ **************************************************************************/
+
+/* Base for all Multicast Routing PP Event identifiers. */
+#define TI_MFC_EVENT                  0x40
+
+/* Event generated when a multicast routing entry is created. */
+#define TI_MFC_ENTRY_CREATED          (TI_MFC_EVENT + 0x1)
+
+/* Event generated when a multicast routing entry is deleted. */
+#define TI_MFC_ENTRY_DELETED          (TI_MFC_EVENT + 0x2)
+
+#define TI_MC_SESSION_DELETED         (TI_MFC_EVENT + 0x3)
+
+/**************************************************************************
+ **************************** PP PPP Event Identifiers *****************
+ **************************************************************************/
+
+/* Base for all PPP PP Event identifiers. */
+#define TI_PPP_EVENT               0x50
+
+/* Event generated when a PPP interface is created. */
+#define TI_PPP_INTERFACE_CREATED    (TI_PPP_EVENT + 0x1)
+
+/* Event generated when a PPP interface is deleted. */
+#define TI_PPP_INTERFACE_SHUTDOWN   (TI_PPP_EVENT + 0x2)
+
+
+/**************************************************************************
+ ************************* PP DOCSIS Event Identifiers ********************
+ **************************************************************************/
+
+/* Base for all DOCSIS PP Event identifiers. */
+#define TI_DOCSIS_EVENT         0x60
+
+/* Event generated when DOCSIS Bridge decides to drop(filter) the packet */
+#define TI_DOCSIS_FLTR_DISCARD_PKT          (TI_DOCSIS_EVENT + 0x1)
+
+/* Event generated when a new filter rule is added */
+#define TI_DOCSIS_FLTR_ADD                  (TI_DOCSIS_EVENT + 0x2)
+
+/* Event generated when a filter rule is deleted */
+#define TI_DOCSIS_FLTR_DEL                  (TI_DOCSIS_EVENT + 0x3)
+
+/* Event generated when a filter rule is being changed */
+#define TI_DOCSIS_FLTR_CHG                  (TI_DOCSIS_EVENT + 0x4)
+
+/* Event generated when a new classifier rule is added */
+#define TI_DOCSIS_CLASSIFY_ADD              (TI_DOCSIS_EVENT + 0x5)
+
+/* Event generated when a classifier rule is deleted */
+#define TI_DOCSIS_CLASSIFY_DEL              (TI_DOCSIS_EVENT + 0x6)
+
+/* Event generated when a classifier rule is being changed */
+#define TI_DOCSIS_CLASSIFY_CHG              (TI_DOCSIS_EVENT + 0x7)
+
+/* Event generated when DSID encoding is being changed, added or deleted */
+#define TI_DOCSIS_DSID_CHG                  (TI_DOCSIS_EVENT + 0x8)
+
+/* Event generated when MCAST filter is deleted */
+#define TI_DOCSIS_MCAST_DEL                 (TI_DOCSIS_EVENT + 0x9)
+
+/* Event generated when need to delete sessions from PP */
+#define TI_DOCSIS_SESSIONS_DEL              (TI_DOCSIS_EVENT + 0xA)
+
+/* Event generated when need to delete voice sessions from PP */
+#define TI_DOCSIS_VOICE_SESSIONS_DEL        (TI_DOCSIS_EVENT + 0xB)
+
+
+
+/**************************************************************************
+ ************************* PP General Event Identifiers *******************
+ **************************************************************************/
+
+/* Base for all general PP Event identifiers. */
+#define TI_PP_GENERAL_EVENT         0x70
+/* Event generated when create vpid */
+#define TI_PP_ADD_VPID          (TI_PP_GENERAL_EVENT + 0x1)
+
+/* Event generated when remove vpid */
+#define TI_PP_REMOVE_VPID       (TI_PP_GENERAL_EVENT + 0x2)
+
+/* DOCSIS Packet processor start/delete session notification defines */
+#define TI_DOCSIS_PP_SESSION_TYPE_FORWARDING                    0x1
+#define TI_DOCSIS_PP_SESSION_TYPE_DISCARDING                    0x2
+
+typedef enum
+{
+    TUNNEL_TYPE_L2TPv3 = 0,
+    TUNNEL_TYPE_GRE_MPLS = 1
+} TUNNEL_TYPE_E;
+
 /**************************************************************************
  ************************* PP IP Event Identifiers ************************
  **************************************************************************/
@@ -120,9 +258,87 @@ struct hil_core_notifier_param
 #define TI_IP_DISCARD_PKT_IPV4   (TI_IP_EVENT + 0x1)
 #define TI_IP_DISCARD_PKT_IPV6   (TI_IP_EVENT + 0x2)
 
+/**************************************************************************
+ **************************** HIL Profile Structures **********************
+ **************************************************************************/
+
+/* Prototype Declaration for the profile handler. */
+typedef int (*TI_PROFILE_HANDLER)(unsigned int module_id, unsigned long event_id, void* ptr);
+typedef int (*TI_PROFILE_INIT)(void);
+typedef int (*TI_PROFILE_DEINIT)(void);
+
+/**************************************************************************
+ * STRUCTURE NAME : TI_HIL_PROFILE
+ **************************************************************************
+ * DESCRIPTION   :
+ *  The structure describes the HIL Profile.
+ **************************************************************************/
+typedef struct TI_HIL_PROFILE
+{
+    char*               name;
+    TI_PROFILE_INIT     profile_init;
+    TI_PROFILE_HANDLER  profile_handler;
+    TI_PROFILE_DEINIT   profile_deinit;
+}TI_HIL_PROFILE;
+
+/**************************************************************************
+ ********************* PP Multicast Routing Event param *************
+ **************************************************************************/
+struct pp_mr_param {
+	struct vif_device *vif_table;
+    struct mfc_cache *cache;
+};
+
+/**************************************************************************
+ **************************** HIL Core Exported API ***********************
+ **************************************************************************/
+#if defined(__KERNEL__)
+/* Initialization and Cleanup API */
+extern int ti_hil_initialize (void);
+
+/* Profile Management API */
+extern int ti_hil_register_profile (TI_HIL_PROFILE* ptr_profile);
+
+/* This is the API which is used for the event generation to the PP chain.
+ * This should only be used in the networking subsystem to generate events
+ * which do not already exist and which are needed for the packet processor.
+ * This is needed only if the packet processor has been built into the system. */
 #ifdef CONFIG_TI_PACKET_PROCESSOR
 extern int ti_hil_pp_event(unsigned long val, void *v);
+extern void ti_hil_clone_netdev_pp_info(struct net_device *newDev, struct net_device *origDev);
+
 #else
 #define ti_hil_pp_event(val, v)
+#define ti_hil_clone_netdev_pp_info(newDev, origDev)
 #endif /* CONFIG_TI_PACKET_PROCESSOR */
+
+#ifdef CONFIG_TI_PACKET_PROCESSOR_STATS
+/* DOCSIS Packet processor session notification API */
+typedef int (*TI_HIL_START_SESSION)(unsigned int sessionHandle,
+                                    unsigned int sessionType,
+                                    struct sk_buff* skb);
+/* DOCSIS Packet processor delete session notification Callback */
+typedef int (*TI_HIL_DELETE_SESSION)(unsigned int sessionHandle,
+                                     unsigned int sessionPacketsFw,
+									 unsigned long long sessionOcttestsFw);
+
+extern int ti_hil_register_start_session_notification(TI_HIL_START_SESSION ti_hil_start_session_notification);
+extern int ti_hil_unregister_start_session_notification(void);
+extern int ti_hil_register_delete_session_notification(TI_HIL_DELETE_SESSION ti_hil_delete_session_notification);
+extern int ti_hil_unregister_delete_session_notification(void);
+#endif /* CONFIG_TI_PACKET_PROCESSOR_STATS */
+
+#ifdef CONFIG_MACH_PUMA5
+/* Power Saving Mode (PSM) API */
+extern int ti_hil_enable_psm (void);
+extern int ti_hil_disable_psm (void);
+#endif /* CONFIG_MACH_PUMA5 */
+#ifdef CONFIG_INTEL_PP_TUNNEL_SUPPORT
+extern int ti_hil_set_tunnel_mode(unsigned char tunnelMode);
+extern int ti_hil_set_cm_mac_address(unsigned char *cmAddress);
+extern int ti_hil_create_tunnel(char *tunnelHeader, unsigned char tunnelHeaderLen, unsigned char l2L3HeaderLen,
+                         TUNNEL_TYPE_E tunnelType, unsigned char udpMode);
+extern int ti_hil_delete_tunnel(void);
+#endif /*CONFIG_INTEL_PP_TUNNEL_SUPPORT*/
+#endif /*KERNEL*/
 #endif /* __TI_HIL_H__ */
diff --git a/include/net/addrconf.h b/include/net/addrconf.h
index 86505bf..3402178 100644
--- a/include/net/addrconf.h
+++ b/include/net/addrconf.h
@@ -84,6 +84,11 @@ int __ipv6_get_lladdr(struct inet6_dev *idev, struct in6_addr *addr,
 		      unsigned char banned_flags);
 int ipv6_get_lladdr(struct net_device *dev, struct in6_addr *addr,
 		    unsigned char banned_flags);
+#ifdef CONFIG_INTEL_NS_DEVICE_FILTER
+extern int intel_ipv6_ns_filter(struct net_device *dev,
+								struct in6_addr* dst_addr,
+								unsigned char banned_flags);
+#endif
 int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2);
 void addrconf_join_solict(struct net_device *dev, const struct in6_addr *addr);
 void addrconf_leave_solict(struct inet6_dev *idev, const struct in6_addr *addr);
diff --git a/include/net/ip.h b/include/net/ip.h
index 553c075..4dfa6ea 100644
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -55,6 +55,9 @@ static inline unsigned int ip_hdrlen(const struct sk_buff *skb)
 struct ipcm_cookie {
 	__be32			addr;
 	int			oif;
+#ifdef CONFIG_TI_META_DATA
+    unsigned int        ti_meta_info;
+#endif /* CONFIG_TI_META_DATA */
 	struct ip_options_rcu	*opt;
 	__u8			tx_flags;
 };
diff --git a/include/net/netfilter/nf_conntrack.h b/include/net/netfilter/nf_conntrack.h
index 613d58b..7cb0bd9 100644
--- a/include/net/netfilter/nf_conntrack.h
+++ b/include/net/netfilter/nf_conntrack.h
@@ -25,7 +25,7 @@
 #include <net/netfilter/ipv6/nf_conntrack_icmpv6.h>
 #include <net/netfilter/nf_conntrack_tuple.h>
 
-#ifdef CONFIG_APPCPU_GW_PP_HANDLE
+#if defined(CONFIG_APPCPU_GW_PP_HANDLE) || defined(CONFIG_TI_PACKET_PROCESSOR)
 /* Flag definitions that are carried in the PP status flag in the connection tracking
  *  * structure. */
 
@@ -36,7 +36,7 @@
 /* Set the flag to 1 indicates that all packets flowing through the box matching the
  *  * connection will have their BYPASS flag set. */
 #define TI_PP_BYPASS               0x2
-#endif
+#endif /* CONFIG_APPCPU_GW_PP_HANDLE */ /*CONFIG_TI_PACKET_PROCESSOR */
 /* per conntrack: protocol private data */
 union nf_conntrack_proto {
 	/* insert conntrack proto private data here */
@@ -115,7 +115,10 @@ struct nf_conn {
 #ifdef CONFIG_NET_NS
 	struct net *ct_net;
 #endif
-	int ti_pp_status_flag;
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    int             ti_pp_status_flag;
+    int             pp_appcpu_status_flag;
+#endif
 #ifdef CONFIG_APPCPU_GW_PP_HANDLE
 	/*flag used to indicate ct client mrpc call in progress b/w ATOM/ARM */
 	int ct_tuple_arm_sync_wait;
diff --git a/include/net/netfilter/nf_conntrack_tuple.h b/include/net/netfilter/nf_conntrack_tuple.h
index aea3f82..6b6f3fa 100644
--- a/include/net/netfilter/nf_conntrack_tuple.h
+++ b/include/net/netfilter/nf_conntrack_tuple.h
@@ -117,6 +117,25 @@ static inline void nf_ct_dump_tuple(const struct nf_conntrack_tuple *t)
 /* Connections have two entries in the hash table: one for each way */
 struct nf_conntrack_tuple_hash {
 	struct hlist_nulls_node hnnode;
+
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+
+#if PUMA7_OR_NEWER_SOC_TYPE
+#define    TI_PP_SESSION_CT_IDLE            0xA000
+#define    TI_PP_SESSION_CT_TCP_UPDATE      0xB000
+#define IS_TI_PP_SESSION_CT_INVALID(s)      ((s) >= TI_PP_SESSION_CT_IDLE)
+#define IS_TI_PP_SESSION_CT_IDLE(s)         ((s) == TI_PP_SESSION_CT_IDLE)
+#else
+#define    TI_PP_SESSION_CT_IDLE            0x8000
+#define    TI_PP_SESSION_CT_TCP_UPDATE      0x4000
+#define IS_TI_PP_SESSION_CT_INVALID(s)      ((s) & 0xF000)
+#define IS_TI_PP_SESSION_CT_IDLE(s)         ((s) & TI_PP_SESSION_CT_IDLE)
+#endif
+
+    unsigned short        ti_pp_session_handle;
+    unsigned short        ti_pp_sessions_count;
+#endif /* CONFIG_TI_PACKET_PROCESSOR */
+
 	struct nf_conntrack_tuple tuple;
 };
 
diff --git a/include/uapi/linux/in.h b/include/uapi/linux/in.h
index f9e8e49..4be7fad 100644
--- a/include/uapi/linux/in.h
+++ b/include/uapi/linux/in.h
@@ -100,6 +100,9 @@ struct in_addr {
 #define IP_PASSSEC	18
 #define IP_TRANSPARENT	19
 
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+#define TI_IP_PKTINFO	23
+#endif
 /* BSD compatibility */
 #define IP_RECVRETOPTS	IP_RETOPTS
 
@@ -110,6 +113,9 @@ struct in_addr {
 #define IP_MINTTL       21
 #define IP_NODEFRAG     22
 
+#ifdef CONFIG_TI_META_DATA
+#define TI_IP_META_DATA 18
+#endif /* CONFIG_TI_META_DATA */
 /* IP_MTU_DISCOVER values */
 #define IP_PMTUDISC_DONT		0	/* Never send DF frames */
 #define IP_PMTUDISC_WANT		1	/* Use per route hints	*/
@@ -202,6 +208,16 @@ struct in_pktinfo {
 	struct in_addr	ipi_spec_dst;
 	struct in_addr	ipi_addr;
 };
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+#ifndef TI_PKTINFO_STRUCT
+#define TI_PKTINFO_STRUCT
+struct ti_pktinfo
+{
+	int		ifcpe_side;
+    char    mac_addr[6];
+};
+#endif
+#endif
 
 /* Structure describing an Internet (IP) socket address. */
 #define __SOCK_SIZE__	16		/* sizeof(struct sockaddr)	*/
diff --git a/include/uapi/linux/in6.h b/include/uapi/linux/in6.h
index 599b0d4..d506629 100644
--- a/include/uapi/linux/in6.h
+++ b/include/uapi/linux/in6.h
@@ -288,4 +288,17 @@ enum {
  * ...
  * MRT6_MAX
  */
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+#define TI_IPV6_PKTINFO	81
+#endif
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+# ifndef TI_PKTINFO_STRUCT
+# define TI_PKTINFO_STRUCT
+struct ti_pktinfo
+{
+	int		ifcpe_side;
+    char    mac_addr[6];
+};
+# endif
+#endif
 #endif /* _UAPI_LINUX_IN6_H */
diff --git a/include/uapi/linux/mii.h b/include/uapi/linux/mii.h
index 237fac4..a937cdb 100644
--- a/include/uapi/linux/mii.h
+++ b/include/uapi/linux/mii.h
@@ -8,6 +8,10 @@
 #ifndef _UAPI__LINUX_MII_H__
 #define _UAPI__LINUX_MII_H__
 
+#ifndef CONFIG_ARM_AVALANCHE_SOC
+#include <linux/avalanche/puma7/puma7_defs.h>
+#endif
+
 #include <linux/types.h>
 #include <linux/ethtool.h>
 
@@ -156,6 +160,9 @@ struct mii_ioctl_data {
 	__u16		reg_num;
 	__u16		val_in;
 	__u16		val_out;
+#if PUMA7_OR_NEWER_SOC_TYPE
+    __u16		mdio_num;
+#endif
 };
 
 #endif /* _UAPI__LINUX_MII_H__ */
diff --git a/include/uapi/linux/netfilter.h b/include/uapi/linux/netfilter.h
index f7dc0eb..8a7d3f1 100644
--- a/include/uapi/linux/netfilter.h
+++ b/include/uapi/linux/netfilter.h
@@ -19,6 +19,9 @@
  * number or errno values. Not nice, but better than additional function
  * arguments. */
 #define NF_VERDICT_MASK 0x000000ff
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+#define NF_VERDICT_FLAG_PP_BYPASS		0x00000100
+#endif  /* CONFIG_TI_PACKET_PROCESSOR */
 
 /* extra verdict flags have mask 0x0000ff00 */
 #define NF_VERDICT_FLAG_QUEUE_BYPASS	0x00008000
diff --git a/net/8021q/vlan.c b/net/8021q/vlan.c
index 856499f..3afac13 100644
--- a/net/8021q/vlan.c
+++ b/net/8021q/vlan.c
@@ -37,6 +37,9 @@
 #include <asm/uaccess.h>
 
 #include <linux/if_vlan.h>
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+#include <linux/ti_hil.h>
+#endif
 #include "vlan.h"
 #include "vlanproc.h"
 
@@ -87,7 +90,9 @@ void unregister_vlan_dev(struct net_device *dev, struct list_head *head)
 
 	vlan_info = rtnl_dereference(real_dev->vlan_info);
 	BUG_ON(!vlan_info);
-
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    ti_hil_pp_event(TI_VLAN_DEV_DELETED, (void *)dev);
+#endif //CONFIG_TI_PACKET_PROCESSOR
 	grp = &vlan_info->grp;
 
 	grp->nr_vlan_devs--;
@@ -272,7 +277,11 @@ static int register_vlan_device(struct net_device *real_dev, u16 vlan_id)
 	err = register_vlan_dev(new_dev);
 	if (err < 0)
 		goto out_free_newdev;
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    ti_hil_clone_netdev_pp_info(new_dev, real_dev);
 
+    ti_hil_pp_event(TI_VLAN_DEV_CREATED, (void *)new_dev);
+#endif
 	return 0;
 
 out_free_newdev:
diff --git a/net/8021q/vlan_core.c b/net/8021q/vlan_core.c
index 5d56e05..e2da129 100644
--- a/net/8021q/vlan_core.c
+++ b/net/8021q/vlan_core.c
@@ -48,6 +48,14 @@ bool vlan_do_receive(struct sk_buff **skbp)
 	}
 
 	skb->priority = vlan_get_ingress_priority(vlan_dev, skb->vlan_tci);
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    /* 
+     * Need to save the vpid vlan_tci before it will erased
+     * We will use it later in the ingress hook to reproduce 
+     * the vlan_tci of the real internal vpid's Vlan. 
+     */
+    skb->vpid_vlan_tci = vlan_tx_tag_get(skb); 
+#endif
 	skb->vlan_tci = 0;
 
 	rx_stats = this_cpu_ptr(vlan_dev_priv(vlan_dev)->vlan_pcpu_stats);
diff --git a/net/Kconfig b/net/Kconfig
index d6f4cd5..5657158 100644
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -340,6 +340,8 @@ source "net/rxrpc/Kconfig"
 config FIB_RULES
 	bool
 
+# TI Specific Networking Extensions
+source "net/ti.Kconfig"
 menuconfig WIRELESS
 	bool "Wireless"
 	depends on !S390
diff --git a/net/bridge/Makefile b/net/bridge/Makefile
index e85498b2f..b61f03b 100644
--- a/net/bridge/Makefile
+++ b/net/bridge/Makefile
@@ -6,10 +6,13 @@ obj-$(CONFIG_BRIDGE) += bridge.o
 
 bridge-y	:= br.o br_device.o br_fdb.o br_forward.o br_if.o br_input.o \
 			br_ioctl.o br_notify.o br_stp.o br_stp_bpdu.o \
-			br_stp_if.o br_stp_timer.o br_netlink.o
+			br_stp_if.o br_stp_timer.o br_netlink.o ti_br_notify.o
 
 bridge-$(CONFIG_SYSFS) += br_sysfs_if.o br_sysfs_br.o
 
+bridge-$(CONFIG_TI_L2_SELECTIVE_FORWARDER) += ti_br_sf.o
+bridge-$(CONFIG_TI_L2_SELECTIVE_PACKET_HANDLING) += ti_br_sph.o
+bridge-$(CONFIG_INTEL_L2VPN_L2CP_FORWARD) += intel_br_l2vpn.o
 bridge-$(CONFIG_BRIDGE_NETFILTER) += br_netfilter.o
 
 bridge-$(CONFIG_BRIDGE_IGMP_SNOOPING) += br_multicast.o br_mdb.o
diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c
index 0d34001..4c7aaaa 100644
--- a/net/bridge/br_device.c
+++ b/net/bridge/br_device.c
@@ -382,4 +382,7 @@ void br_dev_setup(struct net_device *dev)
 	br_netfilter_rtable_init(br);
 	br_stp_timer_init(br);
 	br_multicast_init(br);
+#ifdef CONFIG_TI_L2_SELECTIVE_PACKET_HANDLING
+    br->selective_packet_handler = NULL;
+#endif /* CONFIG_TI_L2_SELECTIVE_PACKET_HANDLING */
 }
diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
index 33e8f23..6a4a86a 100644
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -18,6 +18,7 @@
 #include <linux/times.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
+#include <linux/ti_hil.h>
 #include <linux/jhash.h>
 #include <linux/random.h>
 #include <linux/slab.h>
@@ -25,6 +26,9 @@
 #include <asm/unaligned.h>
 #include <linux/if_vlan.h>
 #include "br_private.h"
+#ifdef CONFIG_INTEL_MAX_BRIDGE_MACS_LIMIT
+static int fdb_insert_cnt = 0;
+#endif
 
 static struct kmem_cache *br_fdb_cache __read_mostly;
 static int fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
@@ -87,6 +91,11 @@ static void fdb_delete(struct net_bridge *br, struct net_bridge_fdb_entry *f)
 	hlist_del_rcu(&f->hlist);
 	fdb_notify(br, f, RTM_DELNEIGH);
 	call_rcu(&f->rcu, fdb_rcu_free);
+#ifdef CONFIG_INTEL_MAX_BRIDGE_MACS_LIMIT
+	if (fdb_insert_cnt >= 1) {
+		fdb_insert_cnt--;
+	}
+#endif
 }
 
 void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr)
@@ -187,7 +196,16 @@ void br_fdb_cleanup(unsigned long _data)
 				continue;
 			this_timer = f->updated + delay;
 			if (time_before_eq(this_timer, jiffies))
+			{
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+                if(!f->is_local)
+                    ti_hil_pp_event(TI_BRIDGE_FDB_DELETED, (void*)f);
+                if (!(f->ti_pp_fdb_status & TI_PP_FDB_ACTIVE))
 				fdb_delete(br, f);
+#else
+                    fdb_delete(br, f);
+#endif
+			}
 			else if (time_before(this_timer, next_timer))
 				next_timer = this_timer;
 		}
@@ -390,6 +408,12 @@ static struct net_bridge_fdb_entry *fdb_create(struct hlist_head *head,
 {
 	struct net_bridge_fdb_entry *fdb;
 
+#ifdef CONFIG_INTEL_MAX_BRIDGE_MACS_LIMIT
+    if (fdb_insert_cnt >= CONFIG_INTEL_MAX_BRIDGE_MACS) {
+        printk(KERN_WARNING "\n fdb_create reached max bridge macs limit \n");
+		return 0;
+    }
+#endif
 	fdb = kmem_cache_alloc(br_fdb_cache, GFP_ATOMIC);
 	if (fdb) {
 		memcpy(fdb->addr.addr, addr, ETH_ALEN);
@@ -398,7 +422,17 @@ static struct net_bridge_fdb_entry *fdb_create(struct hlist_head *head,
 		fdb->is_local = 0;
 		fdb->is_static = 0;
 		fdb->updated = fdb->used = jiffies;
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+        fdb->ti_pp_fdb_status = TI_PP_FDB_INACTIVE;
+#endif
 		hlist_add_head_rcu(&fdb->hlist, head);
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+        if (!fdb->is_local)
+            ti_hil_pp_event(TI_BRIDGE_FDB_CREATED, (void *)fdb);
+#endif
+#ifdef CONFIG_INTEL_MAX_BRIDGE_MACS_LIMIT
+        fdb_insert_cnt++;
+#endif
 	}
 	return fdb;
 }
@@ -473,6 +507,9 @@ void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
 			/* fastpath: update of existing entry */
 			fdb->dst = source;
 			fdb->updated = jiffies;
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+            ti_hil_pp_event(TI_BRIDGE_FDB_CREATED, (void *)fdb);
+#endif
 		}
 	} else {
 		spin_lock(&br->hash_lock);
diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c
index 2dbe0fe..85ff688 100644
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@ -20,6 +20,12 @@
 #include <linux/rculist.h>
 #include "br_private.h"
 
+#ifdef CONFIG_TI_L2_SELECTIVE_FORWARDER
+extern int ti_selective_packet_handler (struct sk_buff *skb);
+#endif /* CONFIG_TI_L2_SELECTIVE_FORWARDER */
+#ifdef CONFIG_INTEL_L2VPN_L2CP_FORWARD
+extern int intel_l2vpn_packet_handler (struct sk_buff *skb, int *l2vpnRelate);
+#endif /* CONFIG_INTEL_L2VPN_L2CP_FORWARD */
 /* Hook for brouter */
 br_should_route_hook_t __rcu *br_should_route_hook __read_mostly;
 EXPORT_SYMBOL(br_should_route_hook);
@@ -124,6 +130,11 @@ int br_handle_frame_finish(struct sk_buff *skb)
 		skb2 = skb;
 		unicast = false;
 	} else if (is_multicast_ether_addr(dest)) {
+#ifdef CONFIG_TI_L2_SELECTIVE_FORWARDER
+        if (ti_selective_packet_handler(skb) != 0) {
+            goto out;
+		}
+#endif /* CONFIG_TI_L2_SELECTIVE_FORWARDER */
 		mdst = br_mdb_get(br, skb, vid);
 		if ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &&
 		    br_multicast_querier_exists(br, eth_hdr(skb))) {
@@ -150,8 +161,13 @@ int br_handle_frame_finish(struct sk_buff *skb)
 		if (dst) {
 			dst->used = jiffies;
 			br_forward(dst->dst, skb, skb2);
-		} else
+		} else {
+#ifdef CONFIG_TI_L2_SELECTIVE_FORWARDER
+			if (ti_selective_packet_handler(skb) != 0)
+				goto out;
+#endif /* CONFIG_TI_L2_SELECTIVE_FORWARDER */
 			br_flood_forward(br, skb, skb2, unicast);
+		}
 	}
 
 	if (skb2)
@@ -187,6 +203,9 @@ rx_handler_result_t br_handle_frame(struct sk_buff **pskb)
 	const unsigned char *dest = eth_hdr(skb)->h_dest;
 	br_should_route_hook_t *rhook;
 
+#ifdef CONFIG_INTEL_L2VPN_L2CP_FORWARD
+        int l2vpnRelated = 0;
+#endif /* CONFIG_INTEL_L2VPN_L2CP_FORWARD */
 	if (unlikely(skb->pkt_type == PACKET_LOOPBACK))
 		return RX_HANDLER_PASS;
 
@@ -197,9 +216,28 @@ rx_handler_result_t br_handle_frame(struct sk_buff **pskb)
 	if (!skb)
 		return RX_HANDLER_CONSUMED;
 
+#ifdef CONFIG_TI_DOCSIS_INPUT_DEV
+	if(!skb->ti_docsis_input_dev) {
+		skb->ti_docsis_input_dev = skb->dev;
+	}
+#endif
 	p = br_port_get_rcu(skb->dev);
 
+	if (WARN(p == NULL, "%s - %d: br_port_get_rcu(skb->dev) returned NULL, dropping packet (dev == %s)", 
+	         __func__, __LINE__, skb->dev ? skb->dev->name : "NULL"))
+	{
+		goto drop;
+	}
 	if (unlikely(is_link_local_ether_addr(dest))) {
+#ifdef CONFIG_INTEL_L2VPN_L2CP_FORWARD
+        if (!intel_l2vpn_packet_handler(skb, &l2vpnRelated)) 
+        {
+            if (l2vpnRelated)
+            {
+                goto forward;
+            }
+        }
+#endif /* CONFIG_INTEL_L2VPN_L2CP_FORWARD */
 		/*
 		 * See IEEE 802.1D Table 7-10 Reserved addresses
 		 *
diff --git a/net/bridge/br_notify.c b/net/bridge/br_notify.c
index 2998dd1..ed9efbc 100644
--- a/net/bridge/br_notify.c
+++ b/net/bridge/br_notify.c
@@ -23,6 +23,9 @@ struct notifier_block br_device_notifier = {
 	.notifier_call = br_device_event
 };
 
+#ifdef CONFIG_TI_UNMANAGED_BRIDGE
+extern int ti_unmanaged_bridge_handler (struct net_device *dev, unsigned long event);
+#endif /* CONFIG_TI_UNMANAGED_BRIDGE */
 /*
  * Handle changes in state of network devices enslaved to a bridge.
  *
@@ -36,6 +39,12 @@ static int br_device_event(struct notifier_block *unused, unsigned long event, v
 	struct net_bridge *br;
 	bool changed_addr;
 	int err;
+#ifdef CONFIG_TI_UNMANAGED_BRIDGE
+    if (ti_unmanaged_bridge_handler(dev, event) == 0)
+    {
+        return NOTIFY_DONE;
+    }
+#endif /* CONFIG_TI_UNMANAGED_BRIDGE */
 
 	/* register of bridge completed, add sysfs entries */
 	if ((dev->priv_flags & IFF_EBRIDGE) && event == NETDEV_REGISTER) {
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f02acd7..81d82e1 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -54,6 +54,10 @@ struct mac_addr
 	unsigned char	addr[6];
 };
 
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+#define     TI_PP_FDB_INACTIVE      0x0
+#define     TI_PP_FDB_ACTIVE        0x1
+#endif //CONFIG_TI_PACKET_PROCESSOR
 struct br_ip
 {
 	union {
@@ -105,6 +109,10 @@ struct net_bridge_fdb_entry
 	unsigned char			is_local;
 	unsigned char			is_static;
 	__u16				vlan_id;
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    int                 ti_pp_session_handle;
+    int                 ti_pp_fdb_status;
+#endif /* CONFIG_TI_PACKET_PROCESSOR */
 };
 
 struct net_bridge_port_group {
@@ -218,6 +226,15 @@ struct br_cpu_netstats {
 	struct u64_stats_sync	syncp;
 };
 
+#ifdef CONFIG_TI_L2_SELECTIVE_PACKET_HANDLING
+struct l2_sph
+{
+    int (*packet_handler)(struct sk_buff *skb);
+    int priority;
+    struct l2_sph *prev;
+    struct l2_sph *next;
+};
+#endif /* CONFIG_TI_L2_SELECTIVE_PACKET_HANDLING */
 struct net_bridge
 {
 	spinlock_t			lock;
@@ -301,6 +318,12 @@ struct net_bridge
 	u8				vlan_enabled;
 	struct net_port_vlans __rcu	*vlan_info;
 #endif
+#ifdef CONFIG_TI_L2_SELECTIVE_PACKET_HANDLING
+    struct l2_sph    *selective_packet_handler;
+#endif /* CONFIG_TI_L2_SELECTIVE_PACKET_HANDLING */
+#ifdef CONFIG_INTEL_L2VPN_L2CP_FORWARD
+    int (*l2vpn_packet_handler)(struct sk_buff *skb, int *l2vpnRelate);
+#endif
 };
 
 struct br_input_skb_cb {
diff --git a/net/bridge/intel_br_l2vpn.c b/net/bridge/intel_br_l2vpn.c
new file mode 100644
index 0000000..f92cc52
--- /dev/null
+++ b/net/bridge/intel_br_l2vpn.c
@@ -0,0 +1,136 @@
+/* 
+  GPL LICENSE SUMMARY
+
+  Copyright(c) 2014 Intel Corporation.
+
+  This program is free software; you can redistribute it and/or modify 
+  it under the terms of version 2 of the GNU General Public License as
+  published by the Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but 
+  WITHOUT ANY WARRANTY; without even the implied warranty of 
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License 
+  along with this program; if not, write to the Free Software 
+  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+  The full GNU General Public License is included in this distribution 
+  in the file called LICENSE.GPL.
+
+  Contact Information:
+    Intel Corporation
+    2200 Mission College Blvd.
+    Santa Clara, CA  97052
+*/
+
+/*
+ * intel_br_l2vpn.c
+ * Description:
+ * Intel L2VPN implementation
+ */
+
+#include <linux/bitops.h>
+#include <linux/cpu.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+//#include <net/net_namespace.h>
+#include "br_private.h"
+
+
+/**************************************************************************
+ * FUNCTION NAME : intel_l2vpn_packet_handler
+ **************************************************************************
+ * DESCRIPTION   :
+ *  The function is called from the bridge to verify if the packet is l2vpn l2vpn related.
+ *  If so, bridge will skip the special handling of link-local packets, and the handling 
+ *  will be done in docsis bridge
+ *    
+ * RETURNS       :
+ *  0   -   No packet handler. invoke default behavior 
+ *  ret -   Returns the return code passed by the registered functions
+ ***************************************************************************/
+int intel_l2vpn_packet_handler (struct sk_buff *skb, int *l2vpnRelate)
+{
+
+	struct net_bridge       *br;
+	struct net_bridge_port  *p;
+//    struct l2_sph       *handle;
+ 
+    int                 ret = 0;
+	/* Get bridge port. */ 
+    if ((p = br_port_get_rcu(skb->dev)) == NULL) 
+    {       
+        return -1;
+    }
+    
+    /* Get  bridge is valid. */ 
+    if ((br = p->br) == NULL) 
+    {        
+        return -1;
+    }
+    if (br->l2vpn_packet_handler  == NULL)
+    {
+        return -1;
+
+    }
+    ret = br->l2vpn_packet_handler(skb, l2vpnRelate); 
+    return ret;
+    
+}
+
+/**************************************************************************
+ * FUNCTION NAME : intel_register_l2vpn_packet_handler
+ **************************************************************************
+ * DESCRIPTION   :
+ *  The function registers/Unregisters a l2vpn packet handler for a bridge.
+ *  
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ ***************************************************************************/
+int intel_register_l2vpn_packet_handler (char *br_name, int (*packet_handler)(struct sk_buff *skb, int *sfIndex, int *phsIndex, int *l2vpnRelate))
+{
+    struct net_bridge       *br;
+	struct net_device       *dev;
+	struct net_bridge_port  *p;
+
+    /* Check if device is valid. */ 
+    if ((dev = dev_get_by_name (&init_net, br_name)) == NULL)
+    {
+        printk ("Error: Device %s does not exist\n", br_name);
+        return -1;
+    }
+
+    /* Check if bridge port. */ 
+    if ((p = br_port_get_rcu(dev)) == NULL) 
+    {
+        printk ("Error: Bridge port %s does not exist\n", br_name);
+        return -1;
+    }
+    
+    /* Check if bridge is valid. */     
+    if ((br = p->br) == NULL) 
+    {
+        printk ("Error: Bridge %s does not exist\n", br_name);
+        return -1;
+    }
+
+    br->l2vpn_packet_handler = packet_handler; 
+
+    if (packet_handler)
+    {
+        printk ("DEBUG: Register l2vpn packet handler successful\n"); 
+    }
+    else
+    {
+        printk ("DEBUG: Unregister l2vpn packet handler successful\n"); 
+    }
+
+
+    return 0;
+}
+
+EXPORT_SYMBOL(intel_register_l2vpn_packet_handler); 
diff --git a/net/bridge/ti_br_notify.c b/net/bridge/ti_br_notify.c
new file mode 100644
index 0000000..68c83ef
--- /dev/null
+++ b/net/bridge/ti_br_notify.c
@@ -0,0 +1,77 @@
+/*
+ * ti_br_notify.c
+ * Description:
+ * TI unmanaged bridge implementation
+ *
+ *  Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#include <linux/bitops.h>
+#include <linux/cpu.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+
+#ifdef CONFIG_TI_UNMANAGED_BRIDGE
+
+/**************************************************************************
+ * FUNCTION NAME : ti_blackhole
+ **************************************************************************
+ * DESCRIPTION   :
+ *  The function is the registered blackhole routine which swallows all
+ *  packets received from the bridge management interface before they reach 
+ *  the networking stacks.
+ *
+ * RETURNS       :
+ *  Always return -1 i.e. never pass the packet up the stack
+ ***************************************************************************/
+int ti_blackhole(struct sk_buff *skb)
+{       
+	kfree_skb(skb);
+    return -1;
+}
+
+/**************************************************************************
+ * FUNCTION NAME : ti_unmanaged_bridge_handler
+ **************************************************************************
+ * DESCRIPTION   :
+ *  This function is registered with the device notifier and its function
+ *  is to detect if a bridged management interface has been bought up. If 
+ *  one is detected it blackholes the management interface
+ *
+ * RETURNS       :
+ *  0   - Bridged Management Interface; event has been processed.
+ *  1   - Process the event normally as Open Source...
+ ***************************************************************************/
+int ti_unmanaged_bridge_handler (struct net_device *dev, unsigned long event)
+{
+    /* Check if the interface is a bridged management interface? */
+    if ((dev->priv_flags & IFF_EBRIDGE) == 0)
+        return 1;
+
+    /* Check if the bridged management interface is being bought up? */
+    if (event == NETDEV_UP)
+    {
+        ti_register_protocol_handler (dev, ti_blackhole);
+        return 0;
+    }
+
+    /* All other events are handled as open source. */
+    return 1;
+}
+
+#endif /* CONFIG_TI_UNMANAGED_BRIDGE */
diff --git a/net/bridge/ti_br_sf.c b/net/bridge/ti_br_sf.c
new file mode 100644
index 0000000..9feacef
--- /dev/null
+++ b/net/bridge/ti_br_sf.c
@@ -0,0 +1,150 @@
+/*
+ * ti_br_sf.c
+ * Description:
+ * TI Selective forwarding implementation
+ *
+ *  Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#include <linux/bitops.h>
+#include <linux/cpu.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include "br_private.h"
+
+#ifdef CONFIG_TI_L2_SELECTIVE_FORWARDER
+
+#undef CONFIG_TI_L2_SELECTIVE_FORWARDER_DEBUG
+
+/**************************************************************************
+ *************************** Extern Data Structures ***********************
+ **************************************************************************/
+extern struct net_device *ti_netdevice[TI_MAX_DEVICE_INDEX];
+
+/**************************************************************************
+ * FUNCTION NAME : get_enabled_bit_count
+ **************************************************************************
+ * DESCRIPTION   :
+ *  The function counts the number of bits enabled. 
+ *
+ * RETURNS       :
+ *  Number of enabled bits 0 to 32 (max)
+ ***************************************************************************/
+static int get_enabled_bit_count(unsigned long long value)
+{
+    int count = 0;
+    while (value != 0)
+    {
+        value &= value - 1;
+        count ++;
+    }
+    return count;
+}
+
+/**************************************************************************
+ * FUNCTION NAME : ti_selective_forward
+ **************************************************************************
+ * DESCRIPTION   :
+ *  The function selectively forwards the packets on the interfaces that are 
+ *  marked. If the mark is zero, packet is flooded.
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ *
+ ***************************************************************************/
+int ti_selective_forward(struct sk_buff *skb)
+{
+    if (!skb->ti_selective_fwd_dev_info)
+    {
+        /* Mark is zero. Return zero to flood the packet */
+        return 0;
+    }
+    else
+    {
+        unsigned long long  interface_list = skb->ti_selective_fwd_dev_info; 
+        unsigned int        dev_index = 0, count;
+        struct sk_buff      *skb2;
+        struct net_device   *dev = skb->dev;
+       
+        /* Get number of bits that are marked */ 
+        count = get_enabled_bit_count(interface_list);
+        
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    /* Check if the packet is about to be forwarded to single egress interface ONLY.
+       For all the cases of cloning make sure the BYPASS flag is set. */
+        if (1 != count)
+        {
+            SKB_GET_PP_INFO_P(skb)->flags |= TI_HIL_PACKET_FLAG_PP_SESSION_BYPASS;
+        }
+#endif
+
+        /* Iterate and forward the cloned packet on all interfaces that are marked */
+        while (interface_list)
+        {
+            if (interface_list & 0x1)
+            {
+                if (((dev = ti_netdevice[dev_index]) != NULL) && (br_port_get_rcu(dev) != NULL))
+                {
+                    if (count == 1)
+                        break;
+
+                    if ((skb2 = skb_clone(skb, GFP_ATOMIC)) != NULL)
+                    {
+#ifdef CONFIG_TI_L2_SELECTIVE_FORWARDER_DEBUG
+                        printk ("DEBUG Local Bridge: Forwarding Cloned multicast packet from (%s) to (%s) index (%d)\n", skb2->dev->name, dev->br_port->dev->name, dev_index+1);
+#endif /* CONFIG_TI_L2_SELECTIVE_FORWARDER_DEBUG */
+                        br_forward(br_port_get_rcu(dev), skb2,NULL);
+                    }
+                    else
+                    {
+                        printk ( KERN_DEBUG "Local Bridge: SKB Clone failed. Freeing original packet\n");
+                        dev_kfree_skb_any(skb); 
+                        return -1;
+                    }
+                }
+                else
+                {    
+                    printk ( KERN_DEBUG "Local Bridge: Device info not found for device index (%d), info = 0x%llx\n", dev_index+1, skb->ti_selective_fwd_dev_info);
+                }
+                count--;
+            }
+            dev_index++;
+            interface_list >>= 1;
+        }
+        if ((dev != NULL) && (br_port_get_rcu(dev)!= NULL))
+        {
+#ifdef CONFIG_TI_L2_SELECTIVE_FORWARDER_DEBUG
+            printk (KERN_DEBUG "Local Bridge: Forwarding Original multicast packet from (%s) to (%s) index (%d)\n", skb->dev->name, dev->br_port->dev->name, dev_index+1);
+#endif /* CONFIG_TI_L2_SELECTIVE_FORWARDER_DEBUG */
+
+            /* Send the original packet on the last interface */
+            br_forward(br_port_get_rcu(dev), skb,NULL);
+        }
+        else
+        {
+            dev_kfree_skb_any(skb);
+        }
+        return 1;
+    }
+}
+
+EXPORT_SYMBOL(ti_selective_forward);
+
+#endif /* CONFIG_TI_L2_SELECTIVE_FORWARDER */
+
diff --git a/net/bridge/ti_br_sph.c b/net/bridge/ti_br_sph.c
new file mode 100644
index 0000000..2f7533c
--- /dev/null
+++ b/net/bridge/ti_br_sph.c
@@ -0,0 +1,275 @@
+/*
+ * ti_br_sph.c
+ * Description:
+ * TI Selective packet handler implementation
+ *
+ *  Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ */
+
+#include <linux/bitops.h>
+#include <linux/cpu.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <net/net_namespace.h>
+#include "br_private.h"
+
+#ifdef CONFIG_TI_L2_SELECTIVE_PACKET_HANDLING
+
+#undef CONFIG_TI_L2_SELECTIVE_PACKET_HANDLING_DEBUG
+
+/**************************************************************************
+ * FUNCTION NAME : ti_selective_packet_handler
+ **************************************************************************
+ * DESCRIPTION   :
+ *  The function is called from the bridge to selective handle packets.
+ *  The function calls all registered packet handler in the order of priority.
+ *  Currently only multicast and broadcast packets are handled selectively.
+ *  
+ * RETURNS       :
+ *  0   -   No packet handlers. invoke default behavior 
+ *  ret -   Returns the return code passed by the registered functions
+ *
+ * NOTES         :
+ *  In the case of error; the packet memory is freed by the registered handlers.
+ ***************************************************************************/
+int ti_selective_packet_handler (struct sk_buff *skb)
+{
+	struct net_bridge       *br;
+	struct net_bridge_port  *p;
+
+    struct l2_sph       *handle;
+ 
+    int                 ret = 0;
+
+	/* Get bridge port. */ 
+    if ((p = br_port_get_rcu(skb->dev)) == NULL) 
+    {       
+        return -1;
+    }
+    
+    /* Get  bridge is valid. */ 
+    if ((br = p->br) == NULL) 
+    {        
+        return -1;
+    }
+	handle = br->selective_packet_handler;
+    /* Check if packet handler is installed. If no packet handler is installed 
+     * return 0 to invoke default behavior i.e., flood the packet  */
+    if (handle == NULL)
+    {
+#ifdef CONFIG_TI_L2_SELECTIVE_PACKET_HANDLING_DEBUG
+        printk ("No selective packet handler installed. Flooding packet\n"); 
+#endif /* CONFIG_TI_L2_SELECTIVE_PACKET_HANDLING_DEBUG */
+        return ret;
+    }
+    /* Run all registered packet handlers. */
+    while (handle != NULL)
+    {
+        if ((ret = handle->packet_handler(skb)) == -1)
+        {
+            /* Incase of error packet memory is freed by the registered handler. */
+            printk ("Error running selective packet handler (%d)\n", ret);
+            break;
+        }
+        handle = handle->next;
+    }
+    return ret;
+}
+
+/**************************************************************************
+ * FUNCTION NAME : ti_register_selective_packet_handler
+ **************************************************************************
+ * DESCRIPTION   :
+ *  The function registers a selective packet handler for a bridge.
+ *  
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ ***************************************************************************/
+int ti_register_selective_packet_handler (char *br_name, int (*packet_handler)(struct sk_buff *skb), int priority)
+{
+    struct l2_sph           *handle, *temp, *next_node;
+	struct net_bridge       *br;
+	struct net_device       *dev;
+	struct net_bridge_port  *p;
+
+    /* Check if device is valid. */ 
+    if ((dev = dev_get_by_name (&init_net,br_name)) == NULL)
+    {
+        printk ("Error: Device %s does not exist\n", br_name);
+        return -1;
+    }
+
+    /* Check if bridge port. */ 
+    if ((p = br_port_get_rcu(dev)) == NULL) 
+    {
+        printk ("Error: Bridge port %s does not exist\n", br_name);
+        return -1;
+    }
+    
+    /* Check if bridge is valid. */ 
+    if ((br = p->br) == NULL) 
+    {
+        printk ("Error: Bridge %s does not exist\n", br_name);
+        return -1;
+    }
+
+    /* Allocate memory for packet handler. */
+    handle = (struct l2_sph *) kmalloc(sizeof(struct l2_sph), GFP_KERNEL);
+    if (handle == NULL)
+    {
+        printk ("Error: Failed to allocate memory for packet handler\n");
+        return -1;
+    }
+
+    handle->packet_handler = packet_handler;
+    handle->priority = priority;
+    handle->next = NULL;
+    handle->prev = NULL;
+
+    /* Install the handler */    
+    if (br->selective_packet_handler == NULL)
+        br->selective_packet_handler = handle;
+    else
+    {
+        temp = br->selective_packet_handler;
+        while (temp != NULL)
+        {  
+            if (temp->priority == priority)
+            {
+                printk ("Error: Packet handler with priority %d already exists\n", priority); 
+                kfree (handle);
+                return -1;
+            }
+            else if (temp->priority > priority)
+            {
+                if (temp->prev == NULL)
+                {
+                    br->selective_packet_handler = handle;
+                    temp->prev = handle;
+                    handle->next = temp;
+                }
+                else
+                {
+                    next_node = temp->next;
+                    if (next_node != NULL)
+                    {
+                        handle->next = next_node;
+                        next_node->prev = handle;
+                        handle->prev = temp;
+                        temp->next = handle;
+                    }
+                    else
+                    {
+                        handle->prev = temp;
+                        temp->next = handle;
+                    }
+                }
+                break;
+            }
+            else if (temp->next == NULL)
+            {
+                handle->prev = temp;
+                temp->next = handle;
+                break;
+            }
+            temp = temp->next;
+        }
+    }   
+    printk ("DEBUG: Register selective packet handler successful\n"); 
+    return 0;
+}
+
+/**************************************************************************
+ * FUNCTION NAME : ti_deregister_selective_packet_handler
+ **************************************************************************
+ * DESCRIPTION   :
+ *  The function deregisters the selective packet handler for a bridge
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ ***************************************************************************/
+int ti_unregister_selective_packet_handler (char *br_name, int (*packet_handler)(struct sk_buff *skb), int priority)
+{
+	struct net_bridge       *br;
+	struct net_device       *dev;
+    struct l2_sph           *temp;
+   	struct net_bridge_port  *p;
+ 
+    if ((dev = dev_get_by_name (&init_net,br_name)) == NULL)
+    {
+        printk ("Error: Device %s does not exist\n", br_name);
+        return -1;
+    }
+
+    if ((p = br_port_get_rcu(dev)) == NULL) 
+    {
+        printk ("Error: Bridge port %s does not exist\n", br_name);
+        return -1;
+    }
+    
+    if ((br = p->br) == NULL) 
+    {
+        printk ("Error: Bridge %s does not exist\n", br_name);
+        return -1;
+    }
+
+    if (br->selective_packet_handler == NULL)
+    {
+        printk ("Error: Bridge %s has no selective packet handler installed\n", br->dev->name);
+        return -1;
+    }
+
+    /* Unregister the packet handler. */
+    temp = br->selective_packet_handler;
+    while (temp != NULL)
+    { 
+        if (temp->priority == priority)
+        {
+            if (temp->prev == NULL)
+            {
+                br->selective_packet_handler = temp->next;
+                if (temp->next != NULL)
+                    temp->next->prev = NULL;
+            }
+            else
+            {
+                if (temp->next == NULL)
+                    temp->prev->next = NULL;
+                else
+                {
+                    temp->prev->next = temp->next;
+                    temp->next->prev = temp->prev;
+                }
+            }
+            break;
+        }
+        temp = temp->next;
+    }
+
+    if (temp != NULL)
+        kfree (temp);
+    return 0;
+}
+
+EXPORT_SYMBOL(ti_register_selective_packet_handler); 
+EXPORT_SYMBOL(ti_unregister_selective_packet_handler);
+EXPORT_SYMBOL(ti_selective_packet_handler); 
+#endif /* CONFIG_TI_L2_SELECTIVE_PACKET_HANDLING */
+
diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c
index 3df6d3e..f6901bd 100644
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@ -79,6 +79,7 @@
 #include <net/tcp.h>
 #include <net/sock.h>
 #include <net/ip_fib.h>
+#include <linux/ti_hil.h>
 #include "fib_lookup.h"
 
 #define MAX_STAT_DEPTH 32
@@ -1322,6 +1323,9 @@ int fib_table_insert(struct fib_table *tb, struct fib_config *cfg)
 			  (fa ? &fa->fa_list : fa_head));
 
 	rt_cache_flush(cfg->fc_nlinfo.nl_net);
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    ti_hil_pp_event(TI_ROUTE_ADDED, (void *)new_fa);
+#endif //CONFIG_TI_PACKET_PROCESSOR
 	rtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen, tb->tb_id,
 		  &cfg->fc_nlinfo, 0);
 succeeded:
@@ -1681,6 +1685,9 @@ int fib_table_delete(struct fib_table *tb, struct fib_config *cfg)
 		return -ESRCH;
 
 	fa = fa_to_delete;
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    ti_hil_pp_event(TI_ROUTE_DELETED, (void *)fa);
+#endif // CONFIG_TI_PACKET_PROCESSOR
 	rtmsg_fib(RTM_DELROUTE, htonl(key), fa, plen, tb->tb_id,
 		  &cfg->fc_nlinfo, 0);
 
diff --git a/net/ipv4/icmp.c b/net/ipv4/icmp.c
index ff670ca..4161d3a 100644
--- a/net/ipv4/icmp.c
+++ b/net/ipv4/icmp.c
@@ -350,6 +350,9 @@ static void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)
 
 	inet->tos = ip_hdr(skb)->tos;
 	daddr = ipc.addr = ip_hdr(skb)->saddr;
+#ifdef CONFIG_TI_META_DATA
+    ipc.ti_meta_info = 0;
+#endif
 	saddr = fib_compute_spec_dst(skb);
 	ipc.opt = NULL;
 	ipc.tx_flags = 0;
@@ -363,6 +366,10 @@ static void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)
 	fl4.saddr = saddr;
 	fl4.flowi4_tos = RT_TOS(ip_hdr(skb)->tos);
 	fl4.flowi4_proto = IPPROTO_ICMP;
+#ifdef CONFIG_INTEL_DOCSIS_ICMP_IIF
+	if(skb->docsis_icmp_iif)
+		fl4.flowi4_oif = skb->docsis_icmp_iif,
+#endif /* CONFIG_INTEL_DOCSIS_ICMP_IIF */
 	security_skb_classify_flow(skb, flowi4_to_flowi(&fl4));
 	rt = ip_route_output_key(net, &fl4);
 	if (IS_ERR(rt))
@@ -609,6 +616,9 @@ void icmp_send(struct sk_buff *skb_in, int type, int code, __be32 info)
 	ipc.opt = &icmp_param->replyopts.opt;
 	ipc.tx_flags = 0;
 
+#ifdef CONFIG_TI_META_DATA
+    ipc.ti_meta_info = 0;
+#endif
 	rt = icmp_route_lookup(net, &fl4, skb_in, iph, saddr, tos,
 			       type, code, icmp_param);
 	if (IS_ERR(rt))
diff --git a/net/ipv4/ip_input.c b/net/ipv4/ip_input.c
index 0dd4b41..06b47cf 100644
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -147,6 +147,9 @@
 #include <linux/mroute.h>
 #include <linux/netlink.h>
 
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+#include <linux/ti_hil.h>
+#endif
 /*
  *	Process Router Attention IP option (RFC 2113)
  */
@@ -367,7 +370,7 @@ static int ip_rcv_finish(struct sk_buff *skb)
 
 drop:
 
-#ifdef CONFIG_APPCPU_GW_PP_HANDLE
+#if defined(CONFIG_APPCPU_GW_PP_HANDLE) || defined(CONFIG_TI_PACKET_PROCESSOR)
     /* Create a NULL PP device, to drop all dropped packets before they reach the host */
     ti_hil_pp_event (TI_IP_DISCARD_PKT_IPV4, (void *)skb);
 #endif
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 0b8edf4..1c19bc3 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -80,6 +80,23 @@
 #include <linux/netlink.h>
 #include <linux/tcp.h>
 
+#if PUMA7_OR_NEWER_SOC_TYPE
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+#include <asm-arm/arch-avalanche/generic/pal_cppi41.h>
+#else
+#include <linux/avalanche/generic/pal_cppi41.h>
+#endif
+#endif
+#ifdef CONFIG_TI_DOCSIS_INPUT_DEV
+#define DBRIDGE_IFINDEX_CHK(__ifindex, format, args...) \
+{ \
+    if (((__ifindex) < 0) || ((__ifindex) >= TI_MAX_DEVICE_INDEX)) \
+    { \
+        printk("\n===>>> %s - %d: Currupt " #__ifindex " - %d\n" format, __func__, __LINE__, __ifindex, ##args); \
+        BUG(); \
+    } \
+}
+#endif
 int sysctl_ip_default_ttl __read_mostly = IPDEFTTL;
 EXPORT_SYMBOL(sysctl_ip_default_ttl);
 
@@ -97,6 +114,14 @@ int __ip_local_out(struct sk_buff *skb)
 
 	iph->tot_len = htons(skb->len);
 	ip_send_check(iph);
+#ifdef CONFIG_TI_ICMP_ECHO_REPLY_NETFILTER_BYPASS
+    if(iph->protocol == IPPROTO_ICMP) {
+        struct icmphdr *icmph = (struct icmphdr *)((unsigned char *)(iph)+iph->ihl*4);
+        if(icmph->type == ICMP_ECHOREPLY) {
+            return 1;                   
+        } 
+    } 
+#endif /* CONFIG_TI_ICMP_ECHO_REPLY_NETFILTER_BYPASS */
 	return nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT, skb, NULL,
 		       skb_dst(skb)->dev, dst_output);
 }
@@ -427,8 +461,20 @@ static void ip_copy_metadata(struct sk_buff *to, struct sk_buff *from)
 #if defined(CONFIG_IP_VS) || defined(CONFIG_IP_VS_MODULE)
 	to->ipvs_property = from->ipvs_property;
 #endif
-
-#ifdef CONFIG_APPCPU_GW_PP_HANDLE
+#ifdef CONFIG_TI_DOCSIS_INPUT_DEV
+    to->ti_docsis_input_dev = from->ti_docsis_input_dev;
+    if (to->ti_docsis_input_dev)
+    {
+        DBRIDGE_IFINDEX_CHK(to->ti_docsis_input_dev->ifindex, "dev %p, devname %s, ti_docsis_input_dev %p, ti_docsis_input_dev->name %s", to->dev, to->dev ? to->dev->name : NULL, to->ti_docsis_input_dev, to->ti_docsis_input_dev->name);
+    }
+#endif /* CONFIG_TI_DOCSIS_INPUT_DEV */
+#ifdef CONFIG_INTEL_DOCSIS_ICMP_IIF
+    to->docsis_icmp_iif = from->docsis_icmp_iif;
+#endif /* CONFIG_INTEL_DOCSIS_ICMP_IIF */
+#ifdef CONFIG_TI_L2_SELECTIVE_FORWARDER
+    to->ti_selective_fwd_dev_info = from->ti_selective_fwd_dev_info;
+#endif /* CONFIG_TI_L2_SELECTIVE_FORWARDER */
+#ifdef CONFIG_TI_PACKET_PROCESSOR
     memcpy((void *)SKB_GET_PP_INFO_P(to), (void *)SKB_GET_PP_INFO_P(from), sizeof(*SKB_GET_PP_INFO_P(from)));
 #endif
 	skb_copy_secmark(to, from);
@@ -694,6 +740,17 @@ slow_path:
 		iph->tot_len = htons(len + hlen);
 
 		ip_send_check(iph);
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+        /* If this is not the last frag, clear the PTID Flag */
+        if (left > 0 )
+        {
+#ifdef PUMA7_OR_NEWER_SOC_TYPE
+            *(Uint32*)(SKB_GET_PP_INFO_P(skb2)->ti_epi_header) &= (~PAL_CPPI4_HOSTDESC_NETINFW0_PTID_FLAG_MASK);
+#else
+            SKB_GET_PP_INFO_P(skb2)->ti_epi_header[4] = 0;
+#endif
+        }
+#endif /* CONFIG_TI_PACKET_PROCESSOR */
 
 		err = output(skb2);
 		if (err)
@@ -801,7 +858,11 @@ static int __ip_append_data(struct sock *sk,
 			    int getfrag(void *from, char *to, int offset,
 					int len, int odd, struct sk_buff *skb),
 			    void *from, int length, int transhdrlen,
-			    unsigned int flags)
+                unsigned int flags
+#ifdef CONFIG_TI_META_DATA
+,unsigned int ti_meta_info
+#endif
+)
 {
 	struct inet_sock *inet = inet_sk(sk);
 	struct sk_buff *skb;
@@ -939,6 +1000,9 @@ alloc_new_skb:
 			skb_reserve(skb, hh_len);
 			skb_shinfo(skb)->tx_flags = cork->tx_flags;
 
+#ifdef CONFIG_TI_META_DATA
+            skb->ti_meta_info = ti_meta_info;
+#endif /* CONFIG_TI_META_DATA */
 			/*
 			 *	Find where to start putting bytes.
 			 */
@@ -1108,7 +1172,11 @@ int ip_append_data(struct sock *sk, struct flowi4 *fl4,
 
 	return __ip_append_data(sk, fl4, &sk->sk_write_queue, &inet->cork.base,
 				sk_page_frag(sk), getfrag,
-				from, length, transhdrlen, flags);
+                from, length, transhdrlen, flags
+#ifdef CONFIG_TI_META_DATA
+                ,ipc->ti_meta_info
+#endif
+    );
 }
 
 ssize_t	ip_append_page(struct sock *sk, struct flowi4 *fl4, struct page *page,
@@ -1431,7 +1499,11 @@ struct sk_buff *ip_make_skb(struct sock *sk,
 
 	err = __ip_append_data(sk, fl4, &queue, &cork,
 			       &current->task_frag, getfrag,
-			       from, length, transhdrlen, flags);
+                   from, length, transhdrlen, flags
+#ifdef CONFIG_TI_META_DATA
+                ,ipc->ti_meta_info
+#endif
+    );
 	if (err) {
 		__ip_flush_pending_frames(sk, &queue, &cork);
 		return ERR_PTR(err);
diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c
index 9e4f832..911c3b8 100644
--- a/net/ipv4/ip_sockglue.c
+++ b/net/ipv4/ip_sockglue.c
@@ -53,9 +53,28 @@
 #define IP_CMSG_PASSSEC		32
 #define IP_CMSG_ORIGDSTADDR     64
 
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+#define TI_IP_CMSG_PKTINFO		128
+#endif
 /*
  *	SOL_IP control messages.
  */
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+static void ip_cmsg_recv_ti_pktinfo(struct msghdr *msg, struct sk_buff *skb)
+{
+    struct ti_pktinfo info;
+    struct ethhdr *ehdr;
+#ifdef CONFIG_TI_META_DATA
+    info.ifcpe_side = skb->ti_meta_info;
+#endif
+    ehdr = eth_hdr(skb);
+    memcpy( info.mac_addr, ehdr->h_source, sizeof(info.mac_addr));
+#ifdef CONFIG_TI_META_DATA
+    skb->ti_meta_info=0;
+#endif
+    put_cmsg(msg, SOL_IP, TI_IP_PKTINFO, sizeof(info), &info);
+}
+#endif
 #define PKTINFO_SKB_CB(__skb) ((struct in_pktinfo *)((__skb)->cb))
 
 static void ip_cmsg_recv_pktinfo(struct msghdr *msg, struct sk_buff *skb)
@@ -184,6 +203,12 @@ void ip_cmsg_recv(struct msghdr *msg, struct sk_buff *skb)
 	if (flags & 1)
 		ip_cmsg_recv_dstaddr(msg, skb);
 
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+    if ((flags>>=1) == 0)
+		return;
+	if (flags & 1)
+		ip_cmsg_recv_ti_pktinfo(msg, skb);
+#endif
 }
 EXPORT_SYMBOL(ip_cmsg_recv);
 
@@ -217,6 +242,27 @@ int ip_cmsg_send(struct net *net, struct msghdr *msg, struct ipcm_cookie *ipc)
 			ipc->addr = info->ipi_spec_dst.s_addr;
 			break;
 		}
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+		case TI_IP_PKTINFO:
+                {
+			printk("TI_IP_PKTINFO option is off\n");
+ 			return -EINVAL;
+                }
+#endif
+#ifdef CONFIG_TI_META_DATA
+        case TI_IP_META_DATA:
+        {
+            unsigned int* ptr_meta_info;
+			if (cmsg->cmsg_len != CMSG_LEN(sizeof(unsigned int)))
+				return -EINVAL;
+            ptr_meta_info = (unsigned int *)CMSG_DATA(cmsg);
+            ipc->ti_meta_info = *ptr_meta_info;
+#ifdef CONFIG_TI_META_DATA_CONSOLE_DUMP
+            printk ("Received Meta-Data:0x%x\n", ipc->ti_meta_info);
+#endif /* CONFIG_TI_META_DATA_CONSOLE_DUMP */
+            break;
+        }
+#endif /* CONFIG_TI_META_DATA */
 		default:
 			return -EINVAL;
 		}
@@ -478,6 +524,9 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 	case IP_MULTICAST_ALL:
 	case IP_MULTICAST_LOOP:
 	case IP_RECVORIGDSTADDR:
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+	case TI_IP_PKTINFO:
+#endif
 		if (optlen >= sizeof(int)) {
 			if (get_user(val, (int __user *) optval))
 				return -EFAULT;
@@ -539,6 +588,14 @@ static int do_ip_setsockopt(struct sock *sk, int level,
 		else
 			inet->cmsg_flags &= ~IP_CMSG_PKTINFO;
 		break;
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+	case TI_IP_PKTINFO:
+		if (val)
+			inet->cmsg_flags |= TI_IP_CMSG_PKTINFO;
+		else
+			inet->cmsg_flags &= ~TI_IP_CMSG_PKTINFO;
+		break;
+#endif
 	case IP_RECVTTL:
 		if (val)
 			inet->cmsg_flags |=  IP_CMSG_TTL;
@@ -1158,6 +1215,11 @@ static int do_ip_getsockopt(struct sock *sk, int level, int optname,
 	case IP_PKTINFO:
 		val = (inet->cmsg_flags & IP_CMSG_PKTINFO) != 0;
 		break;
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+	case TI_IP_PKTINFO:
+		val = (inet->cmsg_flags & TI_IP_CMSG_PKTINFO) != 0;
+		break;
+#endif
 	case IP_RECVTTL:
 		val = (inet->cmsg_flags & IP_CMSG_TTL) != 0;
 		break;
@@ -1294,6 +1356,12 @@ static int do_ip_getsockopt(struct sock *sk, int level, int optname,
 			info.ipi_ifindex = inet->mc_index;
 			put_cmsg(&msg, SOL_IP, IP_PKTINFO, sizeof(info), &info);
 		}
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+		if (inet->cmsg_flags & TI_IP_CMSG_PKTINFO) {
+			printk("TI_IP_PKTINFO option is close in this mode\n");
+			return -ENOPROTOOPT;
+		}
+#endif
 		if (inet->cmsg_flags & IP_CMSG_TTL) {
 			int hlim = inet->mc_ttl;
 			put_cmsg(&msg, SOL_IP, IP_TTL, sizeof(hlim), &hlim);
diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c
index 2f8de5f..bb11c3d 100644
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -64,6 +64,7 @@
 #include <net/ip_tunnels.h>
 #include <net/checksum.h>
 #include <net/netlink.h>
+#include <linux/ti_hil.h>
 #include <net/fib_rules.h>
 #include <linux/netconf.h>
 
@@ -1167,7 +1178,13 @@ static int ipmr_mfc_add(struct net *net, struct mr_table *mrt,
 		c->mfc_flags |= MFC_STATIC;
 
 	list_add_rcu(&c->list, &mrt->mfc_cache_array[line]);
-
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    {
+        struct pp_mr_param pp_mr;
+        pp_mr.cache = c;
+        pp_mr.vif_table = &mrt->vif_table;
+    }
+#endif// CONFIG_TI_PACKET_PROCESSOR
 	/*
 	 *	Check to see if we resolved a queued list. If so we
 	 *	need to send on the frames and tidy up.
@@ -1867,6 +1884,10 @@ forward:
 	/*
 	 *	Forward the frame
 	 */
+    if ((cache->mfc_un.res.maxvif - cache->mfc_un.res.minvif) > 1)
+    {
+        SKB_GET_PP_INFO_P(skb)->flags |= TI_HIL_PACKET_FLAG_PP_SESSION_BYPASS;
+    }
 	if (cache->mfc_origin == htonl(INADDR_ANY) &&
 	    cache->mfc_mcastgrp == htonl(INADDR_ANY)) {
 		if (true_vifi >= 0 &&
diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c
index 2d70654..c433aba 100644
--- a/net/ipv4/netfilter/ip_tables.c
+++ b/net/ipv4/netfilter/ip_tables.c
@@ -25,9 +25,10 @@
 #include <linux/proc_fs.h>
 #include <linux/err.h>
 #include <linux/cpumask.h>
-#include <linux/ti_hil.h>
+
 #include <linux/netfilter/x_tables.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/ti_hil.h>
 #include <net/netfilter/nf_log.h>
 #include "../../netfilter/xt_repldata.h"
 
@@ -1231,7 +1232,7 @@ __do_replace(struct net *net, const char *name, unsigned int valid_hooks,
 	}
 	vfree(counters);
 	xt_table_unlock(t);
-#ifdef CONFIG_APPCPU_GW_PP_HANDLE
+#if defined(CONFIG_APPCPU_GW_PP_HANDLE) || defined(CONFIG_TI_PACKET_PROCESSOR)
         ti_hil_pp_event (TI_CT_NETFILTER_TABLE_UPDATE, (void *)t);
 #endif
 
diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c
index ed96b23..c9c035b 100644
--- a/net/ipv4/raw.c
+++ b/net/ipv4/raw.c
@@ -521,6 +521,9 @@ static int raw_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 	ipc.tx_flags = 0;
 	ipc.oif = sk->sk_bound_dev_if;
 
+#ifdef CONFIG_TI_META_DATA
+    ipc.ti_meta_info = 0;
+#endif
 	if (msg->msg_controllen) {
 		err = ip_cmsg_send(sock_net(sk), msg, &ipc);
 		if (unlikely(err)) {
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index f904b64..460068d 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -903,7 +903,9 @@ int udp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		connected = 1;
 	}
 	ipc.addr = inet->inet_saddr;
-
+#ifdef CONFIG_TI_META_DATA
+    ipc.ti_meta_info = 0;
+#endif
 	ipc.oif = sk->sk_bound_dev_if;
 
 	sock_tx_timestamp(sk, &ipc.tx_flags);
diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c
index fcfa288..459adef 100644
--- a/net/ipv6/datagram.c
+++ b/net/ipv6/datagram.c
@@ -499,7 +499,20 @@ int ip6_datagram_recv_ctl(struct sock *sk, struct msghdr *msg,
 		src_info.ipi6_addr = ipv6_hdr(skb)->daddr;
 		put_cmsg(msg, SOL_IPV6, IPV6_PKTINFO, sizeof(src_info), &src_info);
 	}
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+    if (np->rxopt.bits.ti_rxinfo) {
+		struct ti_pktinfo info;
+        struct ethhdr *ehdr;
+#ifdef CONFIG_TI_META_DATA
+		info.ifcpe_side = skb->ti_meta_info;
+        skb->ti_meta_info=0;
+#endif
+        ehdr = eth_hdr(skb);
+        memcpy( info.mac_addr, ehdr->h_source, sizeof(info.mac_addr));
 
+		put_cmsg(msg, SOL_IPV6, TI_IPV6_PKTINFO, sizeof(info), &info);
+	}
+#endif
 	if (np->rxopt.bits.rxhlim) {
 		int hlim = ipv6_hdr(skb)->hop_limit;
 		put_cmsg(msg, SOL_IPV6, IPV6_HOPLIMIT, sizeof(hlim), &hlim);
diff --git a/net/ipv6/ip6_input.c b/net/ipv6/ip6_input.c
index 05c94d9..6e60a5f 100644
--- a/net/ipv6/ip6_input.c
+++ b/net/ipv6/ip6_input.c
@@ -46,6 +46,7 @@
 #include <net/xfrm.h>
 #include <net/inet_ecn.h>
 
+extern int intel_ns_handler (struct net_device *dev,struct in6_addr* dst_addr,unsigned char banned_flags);
 
 int ip6_rcv_finish(struct sk_buff *skb)
 {
@@ -178,6 +179,18 @@ int ipv6_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt
 		}
 	}
 
+#ifdef CONFIG_INTEL_NS_DEVICE_FILTER
+    if (hdr->nexthdr == IPPROTO_ICMPV6)
+    {
+        struct icmp6hdr *icmpv6_hdr;
+        icmpv6_hdr = icmp6_hdr(skb);
+        if (icmpv6_hdr->icmp6_type == NDISC_NEIGHBOUR_SOLICITATION)
+        {
+			if (intel_ns_handler (skb->dev,&(hdr->daddr),IFA_F_TENTATIVE) == 0)
+				goto drop; 	 
+        }
+    }
+#endif
 	rcu_read_unlock();
 
 	/* Must drop socket now because of tproxy. */
diff --git a/net/ipv6/ipv6_sockglue.c b/net/ipv6/ipv6_sockglue.c
index f4d2412..78b8312 100644
--- a/net/ipv6/ipv6_sockglue.c
+++ b/net/ipv6/ipv6_sockglue.c
@@ -258,6 +258,12 @@ static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,
 		retv = 0;
 		break;
 
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+    case TI_IPV6_PKTINFO:
+		np->rxopt.bits.ti_rxinfo = valbool;
+		retv = 0;
+		break;
+#endif
 	case IPV6_RECVHOPLIMIT:
 		if (optlen < sizeof(int))
 			goto e_inval;
@@ -1071,6 +1077,11 @@ static int do_ipv6_getsockopt(struct sock *sk, int level, int optname,
 		val = np->rxopt.bits.rxinfo;
 		break;
 
+#ifdef CONFIG_TI_IP_PKTINFO_SOCKOPT
+    case TI_IPV6_PKTINFO:
+		val = np->rxopt.bits.ti_rxinfo;
+		break;
+#endif
 	case IPV6_2292PKTINFO:
 		val = np->rxopt.bits.rxoinfo;
 		break;
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index 0464f9a..218c84d 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -65,6 +65,9 @@
 #include <linux/sysctl.h>
 #endif
 
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+#include <linux/ti_hil.h>
+#endif
 enum rt6_nud_state {
 	RT6_NUD_FAIL_HARD = -2,
 	RT6_NUD_FAIL_SOFT = -1,
@@ -2138,7 +2141,12 @@ static int ip6_pkt_drop(struct sk_buff *skb, u8 code, int ipstats_mib_noroutes)
 
 static int ip6_pkt_discard(struct sk_buff *skb)
 {
-	return ip6_pkt_drop(skb, ICMPV6_NOROUTE, IPSTATS_MIB_INNOROUTES);
+    int ret;
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    ti_hil_pp_event (TI_IP_DISCARD_PKT_IPV6, (void *)skb);
+#endif //CONFIG_TI_PACKET_PROCESSOR
+	ret = ip6_pkt_drop(skb, ICMPV6_NOROUTE, IPSTATS_MIB_INNOROUTES);
+    return ret;
 }
 
 static int ip6_pkt_discard_out(struct sk_buff *skb)
diff --git a/net/netfilter/core.c b/net/netfilter/core.c
index 31fe8ad..816954f 100644
--- a/net/netfilter/core.c
+++ b/net/netfilter/core.c
@@ -23,7 +23,7 @@
 #include <linux/slab.h>
 #include <net/net_namespace.h>
 #include <net/sock.h>
-#ifdef CONFIG_APPCPU_GW_PP_HANDLE
+#if defined(CONFIG_APPCPU_GW_PP_HANDLE) || defined(CONFIG_TI_PACKET_PROCESSOR)
 #include <linux/ti_hil.h>
 #endif /* CONFIG_APPCPU_GW_PP_HANDLE */
 #include "nf_internals.h"
@@ -190,7 +190,7 @@ next_hook:
 		ret = 1;
 	} else if ((verdict & NF_VERDICT_MASK) == NF_DROP) {
 
-#ifdef CONFIG_APPCPU_GW_PP_HANDLE
+#if defined(CONFIG_APPCPU_GW_PP_HANDLE) || defined(CONFIG_TI_PACKET_PROCESSOR)
 #define MAC_ISMULTICAST( pa, hw )    ( ((pa)->hw[0] & 0x01)  )
 #define MAC_ISBROADCAST( pa, hw ) ( ~0xFF ==( (~(pa)->hw[0]) | \
                                               (~(pa)->hw[1]) | \
@@ -217,7 +217,7 @@ next_hook:
 	{
 	    ti_hil_pp_event (TI_CT_NETFILTER_DISCARD_PKT, (void *)skb);
 	}
-#endif /* CONFIG_APPCPU_GW_PP_HANDLE */
+#endif /* CONFIG_APPCPU_GW_PP_HANDLE || CONFIG_TI_PACKET_PROCESSOR	*/
                 kfree_skb(skb);
                 ret = NF_DROP_GETERR(verdict);
 		if (ret == 0)
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index 46fb54a..ca4edaa 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -33,7 +33,7 @@
 #include <linux/mm.h>
 #include <linux/nsproxy.h>
 #include <linux/rculist_nulls.h>
-#if defined(CONFIG_APPCPU_GW_PP_HANDLE) && defined(CONFIG_MRPC_CONNTRACK_CLIENT)
+#if defined(CONFIG_APPCPU_GW_PP_HANDLE) && defined(CONFIG_MRPC_CONNTRACK_CLIENT) && !defined(CONFIG_INTEL_KERNEL_PP_DRIVER_LOCAL)
 #include <linux/mrpc.h>
 #endif
 #include <net/netfilter/nf_conntrack.h>
diff --git a/net/netfilter/nf_conntrack_proto_tcp.c b/net/netfilter/nf_conntrack_proto_tcp.c
index 44d1ea3..cd8af4b 100644
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@ -858,6 +858,33 @@ static int tcp_packet(struct nf_conn *ct,
 		     & IP_CT_TCP_FLAG_CLOSE_INIT)
 		    || (ct->proto.tcp.last_dir == dir
 		        && ct->proto.tcp.last_index == TCP_RST_SET)) {
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+                /* Check if the ORIGINAL Tuple is being accelerated? */
+                if ((!IS_TI_PP_SESSION_CT_INVALID(ct->tuplehash[IP_CT_DIR_ORIGINAL].ti_pp_session_handle)) &&
+                    (1 == ct->tuplehash[IP_CT_DIR_ORIGINAL].ti_pp_sessions_count))
+                {
+                    /* YES. There is no point in accelerating this; since the session will be deleted. */
+#ifdef CONFIG_MACH_PUMA5
+                    if (ti_ppm_delete_session (ct->tuplehash[IP_CT_DIR_ORIGINAL].ti_pp_session_handle, NULL) < 0)
+                        printk ("ERROR: Unable to delete the ORIGINAL session\n");
+#else
+                    ti_hil_pp_event(TI_CT_NETFILTER_DELETE_SESSION, (void *)ct->tuplehash[IP_CT_DIR_ORIGINAL].ti_pp_session_handle);
+#endif
+                }
+
+                /* Check if the REPLY Tuple is being accelerated? */
+                if ((!IS_TI_PP_SESSION_CT_INVALID(ct->tuplehash[IP_CT_DIR_REPLY].ti_pp_session_handle)) &&
+                    (1 == ct->tuplehash[IP_CT_DIR_REPLY].ti_pp_sessions_count))
+                {
+                    /* YES. There is no point in accelerating this; since the session will be deleted. */
+#ifdef CONFIG_MACH_PUMA5
+                    if (ti_ppm_delete_session (ct->tuplehash[IP_CT_DIR_REPLY].ti_pp_session_handle, NULL) < 0)
+                        printk ("ERROR: Unable to delete the REPLY session\n");
+#else
+                    ti_hil_pp_event(TI_CT_NETFILTER_DELETE_SESSION, (void *)ct->tuplehash[IP_CT_DIR_REPLY].ti_pp_session_handle);
+#endif
+                }
+#endif /* CONFIG_TI_PACKET_PROCESSOR */
 			/* Attempt to reopen a closed/aborted connection.
 			 * Delete this connection and look up again. */
 			spin_unlock_bh(&ct->lock);
@@ -1004,11 +1031,33 @@ static int tcp_packet(struct nf_conn *ct,
 		break;
 	}
 
-	if (!tcp_in_window(ct, &ct->proto.tcp, dir, index,
-			   skb, dataoff, th, pf)) {
-		spin_unlock_bh(&ct->lock);
-		return -NF_ACCEPT;
-	}
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    /* TCP Window tracking does not make sense if the sessions are being accelerated. Thus
+     * we added this check... Maybe a better way is to make the window tracking more resilient. 
+     * Check here to see if both of the sessions are not accelerated and if so be the case do the 
+     * window checking else skip it! */
+
+    if (IS_TI_PP_SESSION_CT_IDLE(ct->tuplehash[IP_CT_DIR_ORIGINAL].ti_pp_session_handle) &&
+        IS_TI_PP_SESSION_CT_IDLE(ct->tuplehash[IP_CT_DIR_REPLY   ].ti_pp_session_handle))
+#endif
+	{
+		if (!tcp_in_window(ct, &ct->proto.tcp, dir, index,
+				   skb, dataoff, th, pf)) {
+			spin_unlock_bh(&ct->lock);
+			return -NF_ACCEPT;
+		}
+    }
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    else
+    {
+        if (ct->tuplehash[dir].ti_pp_session_handle == TI_PP_SESSION_CT_TCP_UPDATE)
+        {
+            ct->proto.tcp.seen[dir].td_end = 0;   
+            ct->tuplehash[dir].ti_pp_session_handle = TI_PP_SESSION_CT_IDLE;
+            tcp_in_window(ct, &ct->proto.tcp, dir, index,skb, dataoff, th, pf);
+        }
+    }
+#endif
      in_window:
 	/* From now on we have got in-window packets */
 	ct->proto.tcp.last_index = index;
diff --git a/net/netfilter/nf_conntrack_standalone.c b/net/netfilter/nf_conntrack_standalone.c
index f641751..f124f32 100644
--- a/net/netfilter/nf_conntrack_standalone.c
+++ b/net/netfilter/nf_conntrack_standalone.c
@@ -240,6 +240,28 @@ static int ct_seq_show(struct seq_file *s, void *v)
 	if (ct_show_delta_time(s, ct))
 		goto release;
 
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    if (ct->tuplehash[IP_CT_DIR_ORIGINAL].ti_pp_session_handle == 0xFFFF)
+    {
+    	if (seq_printf(s, "[ORG XXX] "))
+	    	goto release;
+    }
+    else
+    {
+    	if (seq_printf(s, "ORG %d ", ct->tuplehash[IP_CT_DIR_ORIGINAL].ti_pp_session_handle))
+	    	goto release;
+    }
+    if (ct->tuplehash[IP_CT_DIR_REPLY].ti_pp_session_handle == 0xFFFF)
+    {
+    	if (seq_printf(s, "[REPLY XXX] "))
+	    	goto release;
+    }
+    else
+    {
+    	if (seq_printf(s, "REPLY %d ", ct->tuplehash[IP_CT_DIR_REPLY].ti_pp_session_handle))
+	    	goto release;
+    }
+#endif /* CONFIG_TI_PACKET_PROCESSOR */
 	if (seq_printf(s, "use=%u\n", atomic_read(&ct->ct_general.use)))
 		goto release;
 
diff --git a/net/netfilter/nf_nat_core.c b/net/netfilter/nf_nat_core.c
index 13deb61..868f32e 100644
--- a/net/netfilter/nf_nat_core.c
+++ b/net/netfilter/nf_nat_core.c
@@ -16,6 +16,9 @@
 #include <net/xfrm.h>
 #include <linux/jhash.h>
 #include <linux/rtnetlink.h>
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+#include <linux/ti_hil.h>
+#endif
 
 #include <net/netfilter/nf_conntrack.h>
 #include <net/netfilter/nf_conntrack_core.h>
diff --git a/net/netfilter/nf_queue.c b/net/netfilter/nf_queue.c
index b28e427..a33c40f 100644
--- a/net/netfilter/nf_queue.c
+++ b/net/netfilter/nf_queue.c
@@ -15,9 +15,9 @@
 #include <net/protocol.h>
 #include <net/netfilter/nf_queue.h>
 #include <net/dst.h>
-#ifdef CONFIG_APPCPU_GW_PP_HANDLE
+#if defined(CONFIG_APPCPU_GW_PP_HANDLE) || defined(CONFIG_TI_PACKET_PROCESSOR)
 #include <linux/ti_hil.h>
-#endif /* CONFIG_APPCPU_GW_PP_HANDLE */
+#endif /* CONFIG_APPCPU_GW_PP_HANDLE || CONFIG_TI_PACKET_PROCESSOR*/
 #include "nf_internals.h"
 
 /*
@@ -222,7 +222,7 @@ void nf_reinject(struct nf_queue_entry *entry, unsigned int verdict)
 	case NF_STOLEN:
 		break;
 	default:
-#ifdef CONFIG_APPCPU_GW_PP_HANDLE
+#if defined(CONFIG_APPCPU_GW_PP_HANDLE) || defined(CONFIG_TI_PACKET_PROCESSOR)
                 {
 			int skip_pp_discard=0;
 			struct ethhdr* ptr_ethhdr = NULL;
@@ -253,7 +253,7 @@ void nf_reinject(struct nf_queue_entry *entry, unsigned int verdict)
 				ti_hil_pp_event (TI_CT_NETFILTER_DISCARD_PKT, (void *)skb);
 			}
 		}
-#endif /* CONFIG_APPCPU_GW_PP_HANDLE */
+#endif /* CONFIG_APPCPU_GW_PP_HANDLE || CONFIG_TI_PACKET_PROCESSOR*/
 		kfree_skb(skb);
 	}
 	rcu_read_unlock();
diff --git a/net/netfilter/nfnetlink_queue_core.c b/net/netfilter/nfnetlink_queue_core.c
index 8abb522..a89e00c 100644
--- a/net/netfilter/nfnetlink_queue_core.c
+++ b/net/netfilter/nfnetlink_queue_core.c
@@ -1028,6 +1028,12 @@ nfqnl_recv_verdict(struct sock *ctnl, struct sk_buff *skb,
 	if (nfqa[NFQA_MARK])
 		entry->skb->mark = ntohl(nla_get_be32(nfqa[NFQA_MARK]));
 
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+    if (verdict & NF_VERDICT_FLAG_PP_BYPASS) {
+        SKB_GET_PP_INFO_P(entry->skb)->flags |= TI_HIL_PACKET_FLAG_PP_SESSION_BYPASS;
+        verdict &= ~(NF_VERDICT_FLAG_PP_BYPASS);
+    }
+#endif  /* CONFIG_TI_PACKET_PROCESSOR */
 	nf_reinject(entry, verdict);
 	return 0;
 }
diff --git a/net/ti.Kconfig b/net/ti.Kconfig
new file mode 100644
index 0000000..47ac184
--- /dev/null
+++ b/net/ti.Kconfig
@@ -0,0 +1,318 @@
+#----------------------------------------------------------------
+# Copyright 2006-2007, Texas Instruments Incorporated
+#
+#   Kconfig file which defines and control all of the TI
+#   extensions to the networking stack.
+#
+# THIS MODIFIED SOFTWARE AND DOCUMENTATION ARE PROVIDED
+# "AS IS," AND TEXAS INSTRUMENTS MAKES NO REPRESENTATIONS 
+# OR WARRENTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED 
+# TO, WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY 
+# PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE OR 
+# DOCUMENTATION WILL NOT INFRINGE ANY THIRD PARTY PATENTS, 
+# COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. 
+#----------------------------------------------------------------
+# TI Specific configurations
+
+menu "Texas Instruments Kernel Extensions"
+config TI_DEVICE_PROTOCOL_HANDLING
+	bool "TI Device Specific Protocol Handling"
+	default y
+	help
+     This feature allows specific protocol handlers to be installed on a 
+     per device basis to do custom protocol specific handling. These handler
+     have higher precedence then the NET & Bridge stacks and allows the
+     custom protocol handler to be able to capture the packets and bypass 
+     the Networking stacks.
+
+config TI_UNMANAGED_BRIDGE
+	bool "TI Unmanaged Bridge"
+    depends on TI_DEVICE_PROTOCOL_HANDLING
+    default n
+	help
+        This feature enables the bridged interfaces to be unmanaged i.e. there is no
+        connectivity from a bridged interface to the local stack. 
+config INTEL_KERNEL_DOCSIS_SUPPORT
+	bool "INTEL DOCSIS support in kernel"
+        default n
+	help
+	This feature is available for DOCSIS support in kernel. 
+config INTEL_KERNEL_BBU_SUPPORT
+	bool "INTEL BBU support in kernel"
+        default n
+	help
+	This feature is available for BBU support in kernel. 
+config TI_META_DATA
+	bool "TI Meta Data"
+    default y
+	help
+        This feature is available for applications to add meta data while send out packets
+        The meta data is transferred from the socket layer into the networking packet and 
+        is available for all networking layers. The feature does not define the format of 
+        meta data but 4 bytes are available for storing information.
+         
+config INTEL_NF_TRIGGER_SUPPORT
+	bool "Intel Netfilter Port Trigger"
+    default y
+	help
+        This feature allows to use Port Trigger module of iptables/Netfilter 
+
+config INTEL_NF_GWMETA_SUPPORT
+	bool "Intel Gateway Packet Meta Data"
+    default y
+	help
+        This feature allows to label skb data of ip packets (GWMETA module of iptables/Netfilter )
+config INTEL_NF_WEBSTR_SUPPORT
+         bool "WEBSTR match support"
+    default y
+	help
+        This option allows to match string in http web header
+
+config TI_IP_PKTINFO_SOCKOPT
+	bool "TI IP level socket options <TI_IP_PKTINFO>/<TI_IPV6_PKTINFO>"
+    default y
+	help
+        The socket option level for IP is SOL_IP. A boolean integer flag is zero when it 
+        is false, otherwise true. Pass an TI_IP_PKTINFO ancillary message that contains 
+        a ti_pktinfo structure that supplies some information about the incoming packet. 
+        This only works for datagram oriented sockets. The argument is a flag that tells 
+        the socket whether the TI_IP_PKTINFO/TI_IPV6_PKTINFO message should be passed or
+        not. The message itself can only be sent/retrieved as control message with a 
+        packet using recvmsg(2) or sendmsg(2).  
+
+config TI_META_DATA_CONSOLE_DUMP
+	bool "TI Meta Data Console Dump"
+    default n
+    depends on TI_META_DATA
+	help
+        This feature dumps the meta-information output at various stages in the networking
+        layer to showcase that the meta-information is valid and available at various layers.
+        This feature is only available for DEBUG and should be turned OFF on production releases
+        Make sure that the kernel conosle error level is set to debug to see the messages on the
+        console. 
+
+config TI_DOCSIS_INPUT_DEV
+	bool "TI Docsis Input Device"
+    default n
+	help
+        This feature is an extension to SKB to support docsis specific requirement.
+
+config INTEL_DOCSIS_ICMP_IIF
+	bool "Intel  Docsis ICMP Interface Index"
+    default n
+	help
+        This feature is an extension to ICMP to support docsis specific requirement
+	We use the docsis_icmp_iif to support ICMP when wan0, mta0 or erouter0 are on the same subnet
+
+config TI_L2_SELECTIVE_FORWARDER
+	bool "TI Layer2 Selective Forwarder"
+    default y
+    select TI_DEVICE_INDEX_REUSE
+    select TI_L2_SELECTIVE_PACKET_HANDLING
+	help
+        This feature is an extension to the Layer 2 bridge to selectively forward multicast 
+        and broadcast packets.
+
+config TI_L2_SELECTIVE_FORWARDER_TEST
+	bool "Test TI Layer2 Selective Forwarder"
+    default n
+    depends on TI_L2_SELECTIVE_FORWARDER
+	help
+        This feature tests the Layer 2 Selective Forwarder feature. This feature is for debug and 
+        testing purposes only and SHOULD be turned OFF in production version
+
+config INTEL_L2VPN_L2CP_FORWARD
+        bool "Intel L2VPN L2 Control Protocol Forward"
+        default y
+        help
+        This feature enables L2VPN L2 Control Protocol handling according to L2VPN specification
+
+
+config TI_DEVICE_INDEX_REUSE
+	bool "TI Device Index Reuse"
+    default y
+	help
+        This feature allows the device indexes to be reused when freed instead of infinetely incrementing it.
+        The maximum device index limit is set to 32.
+
+config TI_L2_SELECTIVE_PACKET_HANDLING
+	bool "TI Layer2 Selective Packet Handling Framework"
+    default y
+	help
+     This feature allows multiple packet handlers to be installed on a bridge to do 
+     custom packet handling. The handlers are called in the order of priority with which 
+     they are installed. Handlers installed with lower priority number are called before 
+     a handler installed with a higher priority number
+
+config TI_DOCSIS_EGRESS_HOOK
+	bool "TI DOCSIS Egress Hook"
+	default n
+	help
+        This feature allows dicsis bridge specified hooks to be installed on a per device
+        basis. The hooks are installed just before the packet is passed to the 
+	driver for transmission.
+
+config TI_GW_EGRESS_HOOK
+	bool "TI GW Egress Hook"
+	default n
+	help
+        This feature inteand for GW it allows user specified hooks to be installed 
+	on a per device basis. The hooks are installed just before the packet is passed 
+	to the driver for transmission.
+
+config TI_EGRESS_HOOK
+	bool "TI Egress Hook"
+	default y
+	help
+        This feature allows user specified hooks to be installed on a per device
+        basis. The hooks are installed just before the packet is passed to the 
+        driver for transmission. The hook is the "Egress" counterpoint for the 
+        Device protocol handling.
+
+config TI_ICMP_ECHO_REPLY_NETFILTER_BYPASS
+	bool "TI ICMP echo reply netfilter bypass"
+	default n
+	help
+		Hack to bypass the Netfilter logic for ICMP echo reply. This bypass may be 
+		necessary when the Netfilter logic change the ICMP echo reply source MAC addres.
+
+config INTEL_NS_DEVICE_FILTER
+	bool "INTEL neighbour solicit device filter"
+	default y
+	help
+		This feature allows a neighbour solicit handler to be installed on a 
+		per device basis to do neighbour solicit filtering to neighbour solicit packets not destined
+		to the device.
+
+menu "TI Packet Processor Subsystem"
+
+
+config EXCLUDE_GMAC4
+        bool "Exclude GMAC4"
+    default y
+        help
+	exclude GMAC4 from synopsys-gbe driver
+
+config TI_PACKET_PROCESSOR
+	bool "TI Packet Processor"
+    default y
+	help
+        The TI packet processor is a hardware acclerator which can be used to acclerate
+        sessions and can improve the throughput of the system. 
+
+config TI_PACKET_PROCESSOR_STATS
+	bool "TI Packet Processor statistics"
+    	default y
+    	depends on TI_PACKET_PROCESSOR
+	help
+        Enable TI packet processor statistics mechanism. 
+
+config TI_PACKET_PROCESSOR_EXT_SWITCH
+    bool "TI Packet Processor external switch support"
+    default n
+    depends on TI_PACKET_PROCESSOR
+    help
+        This feature allows special tagging of outgoing ethernet packets for further
+        prioritization by the external ethernet switch hardware. The VLAN tagging technique
+        might be used.
+    
+config TI_HIL_DEBUG
+	bool "Enable HIL Debug"
+    default n
+    depends on TI_PACKET_PROCESSOR
+	help
+        Enable this to see debug output from the HIL profiles.
+
+choice
+    prompt "HIL Profile selection"
+    default TI_HIL_PROFILE_INTRUSIVE_P7
+    depends on TI_PACKET_PROCESSOR
+
+config TI_HIL_PROFILE_INTRUSIVE
+	bool "HIL Intrusive Profile"
+    select TI_EGRESS_HOOK
+    select TI_DEVICE_PROTOCOL_HANDLING
+	help
+      The HIL Intrusive mode profile hooks into the data path to capture necessary 
+      information for session creation. 
+
+config TI_HIL_PROFILE_STATIC
+	bool "HIL Static Profile"
+	help
+      The HIL static profile demonstrates the creation of the PP session data 
+      structure, i.e LUT and modification record based on user input from the console.
+
+config TI_HIL_PROFILE_INTRUSIVE_PP2K
+	bool "HIL Intrusive Profile PP2K"
+    select TI_EGRESS_HOOK
+    select TI_DEVICE_PROTOCOL_HANDLING
+	help
+      The HIL Intrusive mode profile hooks into the data path to capture necessary 
+      information for session creation. 
+
+config TI_HIL_PROFILE_INTRUSIVE_P7
+	bool "HIL Intrusive Profile Puma7"
+    select TI_EGRESS_HOOK
+    select TI_DEVICE_PROTOCOL_HANDLING
+	help
+      The HIL Intrusive mode profile hooks into the data path to capture necessary 
+      information for session creation. 
+endchoice
+
+config INTEL_PP_TUNNEL_SUPPORT
+	bool "L2TPv3 and GRE-MPLS Tunnels"
+        default n
+        depends on TI_PACKET_PROCESSOR
+	help
+      Enable this to support L2TPv3 and GRE-MPLS tunnels by PP.
+      This tunnels should be configured statically and regular session will not be created by PP.
+
+      
+endmenu
+config INTEL_IRQ_THREAD_CHANGE_PRIORITY
+	bool "Change scheduler policy and priority "
+        default y
+        depends on IRQ_FORCED_THREADING
+	help
+      Enable to change scheduler policy and priority
+
+config INTEL_DEFAULT_IPV6_AUTOCONF_DISABLES_IPV6_AUTOCONF
+	bool "Disable IPv6 Autoconf if the default Autoconf is False"
+        default y
+	help
+      Enable to allow the default Autoconf (set to False) to disable IPv6 Autoconf for newly created interfaces
+
+config INTEL_MAX_BRIDGE_MACS_LIMIT
+	bool "Enable limitation upon max briged CPE macs"
+	default y
+	help
+       Enable limitaion upon maximun number of CPE MAC addresses that can be saved in bridge DB. this is to eliminate memory leak
+
+config INTEL_MAX_BRIDGE_MACS
+        int "INTEL maximum bridge macs"
+	depends on INTEL_MAX_BRIDGE_MACS_LIMIT
+        default 1024
+        range 1 65536
+        help
+       Maximun number of CEPs MACs connected to bridge.
+
+config INTEL_KERNEL_VOICE_SUPPORT
+	bool "INTEL VOICE support in kernel"
+        default n
+	help
+	This feature is available for VOICE support in kernel. 
+
+
+config INTEL_KERNEL_FORCE_IPV6_DOWN_WHEN_NO_ADDRES
+	bool "INTEL force ipv6 down on network interface"
+        default y
+	help
+	force ipv6 down on network interface when it has no ipv6 address.  
+endmenu
+
+config INTEL_KERNEL_PP_DRIVER_LOCAL
+	bool "Packet Processor driver on CPU support in kernel"
+        default n
+	help
+	  Support for running the Packet Processor on current cpu.
+	  Cannot coexist with gateway support. 
diff --git a/net/ti/pp/ti_hil_core.c b/net/ti/pp/ti_hil_core.c
index 7cb827a..dacf275 100644
--- a/net/ti/pp/ti_hil_core.c
+++ b/net/ti/pp/ti_hil_core.c
@@ -25,20 +25,30 @@
 */
 
 /**************************************************************************
- * FUNCTION NAME : ti_hil_pp_event
- **************************************************************************
- * DESCRIPTION   :
- *  Placeholder for the hil event notifyer.  Remove when full hil layer
- *  is ported to the Atom SDK.
- *
- * RETURNS       :
- *  0   -   Success
- *  <0  -   Error
+ *************************** Include Files ********************************
  **************************************************************************/
 
+#include <linux/types.h>
 #include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/rtnetlink.h>
 #include <linux/byteorder/generic.h>
 #include <linux/ti_hil.h>
+#include <linux/notifier.h>
+
+#if PUMA7_OR_NEWER_SOC_TYPE
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+#include "synopsys_gbe_interface.h"
+#else
+#include <linux/avalanche/puma7/synopsys_gbe_interface.h>
+#include <linux/avalanche/puma7/puma7_defs.h>
+#endif
+#endif
 #ifdef CONFIG_NETFILTER
 #include <linux/netfilter.h>
 #include <net/netfilter/nf_conntrack.h>
@@ -49,7 +59,12 @@
 #ifdef CONFIG_APPCPU_GW_PP_HANDLE
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
+#endif
 
+/**************************************************************************
+ ***************************** Static Declarations  ***********************
+ **************************************************************************/
+#ifdef CONFIG_APPCPU_GW_PP_HANDLE
 static unsigned int notifier_list_was_init = 0;
 static struct   atomic_notifier_head notifier_list;
 static unsigned int dropped_packets_bit_map;
@@ -107,6 +122,260 @@ int create_drop_session(struct sk_buff* skb, unsigned long event)
 }
 #endif /* CONFIG_APPCPU_GW_PP_HANDLE */
 
+/* HIL Core Event Handler for all networking events. */
+static int ti_hil_net_event_handler(struct notifier_block *chain, unsigned long event, void *ptr);
+
+/* Dev Notifier Block for the HIL; this will get notifications for all the dev related events. */
+static struct notifier_block hil_dev_notifier_block =
+{
+    .notifier_call = ti_hil_net_event_handler,
+};
+
+/* INET Addr Notifier Block for the PPM; this will get notifications for all the INET related events. */
+static struct notifier_block hil_inetaddr_notifier_block =
+{
+    .notifier_call = ti_hil_net_event_handler,
+};
+
+/* PP Notifier Block for the PP; this will get notifications for all the PP related events. */
+static struct notifier_block hil_pp_notifier_block =
+{
+    .notifier_call = ti_hil_net_event_handler,
+};
+
+/**************************************************************************
+ * STRUCTURE NAME : TI_HIL_MCB
+ **************************************************************************
+ * DESCRIPTION   :
+ *  The structure describes the HIL Master control block which is used
+ *  to keep track of the HIL profiles which are active.
+ **************************************************************************/
+typedef struct TI_HIL_MCB
+{
+    /* HIL Status   */
+    int              initialized;
+
+    /* Active HIL Profile. */
+    TI_HIL_PROFILE*  active_profile;
+}TI_HIL_MCB;
+
+/**************************************************************************
+ ********************************* Globals ********************************
+ **************************************************************************/
+
+/* HIL Master Control Block. */
+TI_HIL_MCB             hil_mcb;
+
+/* Packet Processor Notifier Chain */
+ATOMIC_NOTIFIER_HEAD(pp_chain);
+
+#ifdef CONFIG_TI_PACKET_PROCESSOR_STATS
+/* DOCSIS Packet processor start session notification Callback */
+TI_HIL_START_SESSION ti_hil_start_session_notification_cb = NULL;
+EXPORT_SYMBOL(ti_hil_start_session_notification_cb);
+/* DOCSIS Packet processor delete session notification Callback */
+TI_HIL_DELETE_SESSION ti_hil_delete_session_notification_cb = NULL;
+EXPORT_SYMBOL(ti_hil_delete_session_notification_cb);
+#endif /* CONFIG_TI_PACKET_PROCESSOR_STATS */
+
+/**************************************************************************
+ ******************************* Functions  *******************************
+ **************************************************************************/
+
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_net_event_handler
+ **************************************************************************
+ * DESCRIPTION   :
+ *  HIL Core registered event handler. This function receives event from all
+ *  over the networking subsystem.
+ *
+ * RETURNS       :
+ *  Always returns NOTIFY_DONE
+ **************************************************************************/
+static int ti_hil_net_event_handler(struct notifier_block *chain, unsigned long event, void *ptr)
+{
+    unsigned int    module;
+
+    /* Check if there exists an active profile. */
+    if (hil_mcb.active_profile)
+    {
+        /* Use the chain to identify the module */
+        if (chain == &hil_dev_notifier_block)
+        {
+            /* Device Interface Management Module. */
+            module = TI_DEVICE;
+        }
+        else if (chain == &hil_inetaddr_notifier_block)
+        {
+            /* Inet address Management Module. */
+            module = TI_INET;
+        }
+        else if (chain == &hil_pp_notifier_block)
+        {
+            /* PP Chain Management Module. */
+            module = TI_PP;
+        }
+        else
+        {
+            /* Unrecognized chain: This is a FATAL Error and should not happen. */
+            printk ("FATAL HIL Core Error: Received event from unknown chain 0x%p\n", chain);
+            return NOTIFY_DONE;
+        }
+
+        /* Pass the event to the profile handler. */
+        hil_mcb.active_profile->profile_handler (module, event, ptr);
+    }
+
+    /* Work is succesfully completed. */
+    return NOTIFY_DONE;
+}
+
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_load_profile
+ **************************************************************************
+ * DESCRIPTION   :
+ *  The function is used to load the specific HIL Profile.
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ **************************************************************************/
+static int ti_hil_load_profile (TI_HIL_PROFILE* ptr_profile)
+{
+    /* Unload and deinitialize the profile. */
+    if (ptr_profile->profile_init() < 0)
+    {
+        printk ("HIL Core: Unable to load profile %s\n", ptr_profile->name);
+        return -1;
+    }
+
+    /* Profile has been succesfully loaded. */
+    printk ("HIL Core: Profile %s has been Loaded.\n", ptr_profile->name);
+    return 0;
+}
+
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_unload_profile
+ **************************************************************************
+ * DESCRIPTION   :
+ *  The function is used to unload the specific HIL Profile.
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ **************************************************************************/
+static int ti_hil_unload_profile (TI_HIL_PROFILE* ptr_profile)
+{
+    /* Unload and deinitialize the profile. */
+    if (ptr_profile->profile_deinit() < 0)
+    {
+        printk ("HIL Core: Unable to unload profile %s\n", ptr_profile->name);
+        return -1;
+    }
+
+    /* Profile has been succesfully unloaded. */
+    printk ("HIL Core: Profile %s has been unloaded.\n", ptr_profile->name);
+    return 0;
+}
+
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_register_profile
+ **************************************************************************
+ * DESCRIPTION   :
+ *  The function is used to register the HIL Profile.
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ **************************************************************************/
+int ti_hil_register_profile (TI_HIL_PROFILE* ptr_profile)
+{
+    /* Ensure that the HIL has been initialized before proceeding. */
+    if (hil_mcb.initialized == 0)
+        return -1;
+
+    /* Validate the arguments. */
+    if (ptr_profile == NULL)
+        return -1;
+
+    /* Check if a profile already exists? */
+    if (hil_mcb.active_profile != NULL)
+    {
+        /* Profile already exists. We need to unload the profile and load the
+         * new one instead. */
+        ti_hil_unload_profile (hil_mcb.active_profile);
+
+        /* Cleanup the memory associated with the active profile. */
+        kfree (hil_mcb.active_profile);
+    }
+
+    /* Allocate memory for the HIL Profile. */
+    hil_mcb.active_profile = (TI_HIL_PROFILE *)kmalloc(sizeof(TI_HIL_PROFILE), GFP_KERNEL);
+    if (hil_mcb.active_profile == NULL)
+    {
+        /* Memory Allocation Failed. */
+        printk ("HIL Core: Unable to allocate memory for the HIL Profile %s\n", ptr_profile->name);
+        return -1;
+    }
+
+    /* Copy the profile into the active profile. */
+    memcpy ((void *)hil_mcb.active_profile, (void *)ptr_profile, sizeof(TI_HIL_PROFILE));
+
+    /* Initialize the profile. */
+    if (ti_hil_load_profile (hil_mcb.active_profile) == 0)
+        return 0;
+
+    /* Error: Unable to initialize the profile. */
+    printk ("HIL Core: HIL Profile %s failed to initialize.\n", hil_mcb.active_profile->name);
+    return -1;
+}
+
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_initialize
+ **************************************************************************
+ * DESCRIPTION   :
+ *  Initialize the HIL Core Layer.
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ **************************************************************************/
+int ti_hil_initialize (void)
+{
+    /* Initialize the HIL Master Control Block */
+    memset ((void *)&hil_mcb, 0, sizeof(TI_HIL_MCB));
+
+    /* Register the HIL core to receive netdevice events */
+    register_netdevice_notifier(&hil_dev_notifier_block);
+
+    /* Register the HIL core to receive inet events */
+    register_inetaddr_notifier(&hil_inetaddr_notifier_block);
+
+    /* Register the HIL core to receive events */
+    atomic_notifier_chain_register(&pp_chain, &hil_pp_notifier_block);
+
+    /* The HIL core is operational now. */
+    hil_mcb.initialized = 1;
+    return 0;
+}
+
+
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_pp_event
+ **************************************************************************
+ * DESCRIPTION   :
+ *  Notify the HIL of a PP event.
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ **************************************************************************/
+#ifdef CONFIG_TI_PACKET_PROCESSOR
+int ti_hil_pp_event(unsigned long val, void *v)
+{
+    return atomic_notifier_call_chain(&pp_chain, val, v);
+}	
+#else //CONFIG_TI_PACKET_PROCESSOR
 int ti_hil_pp_event(unsigned long event, void *v)
 {
     struct sk_buff*              skb;
@@ -211,3 +480,197 @@ int ti_hil_pp_event(unsigned long event, void *v)
     }
     return 0;
 }
+#endif //else TI_PACKET_PROCESSOR
+
+
+#if PUMA7_OR_NEWER_SOC_TYPE
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_is_gbe_device
+ **************************************************************************
+ * DESCRIPTION   :
+ *  Return true if this is a gbe device
+ *
+ * RETURNS       :
+ *  None
+ **************************************************************************/
+int ti_hil_is_gbe_device(struct net_device *origDev)
+{
+    if (0 == strcmp(origDev->name, NSGMII0_NAME))
+    {
+        return 1;
+    }
+
+    if (0 == strcmp(origDev->name, NSGMII1_NAME))
+    {
+        return 1;
+    }
+
+    if (0 == strcmp(origDev->name, NRGMII2_NAME))
+    {
+        return 1;
+    }
+
+    if (0 == strcmp(origDev->name, NRGMII3_NAME))
+    {
+        return 1;
+    }
+
+    if (0 == strcmp(origDev->name, NGMII_TO_ATOM_NAME))
+    {
+        return 1;
+    }
+
+    return 0;
+}
+#endif
+
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_clone_netdev_pp_info
+ **************************************************************************
+ * DESCRIPTION   :
+ *  Copies all the relevant PP PID information from one network device to another
+ *
+ * RETURNS       :
+ *  None
+ **************************************************************************/
+void ti_hil_clone_netdev_pp_info(struct net_device *newDev, struct net_device *origDev)
+{
+    newDev->pid_handle              = origDev->pid_handle;
+    memcpy((void *)&newDev->vpid_block, (void *)&origDev->vpid_block, sizeof(origDev->vpid_block));
+#if PUMA7_OR_NEWER_SOC_TYPE
+    strncpy(newDev->vpid_block.devName, newDev->name, VPID_IF_NAME_SIZE);
+#endif
+    newDev->qos_setup_hook          = origDev->qos_setup_hook;
+    newDev->qos_shutdown_hook       = origDev->qos_shutdown_hook;
+    newDev->qos_select_hook         = origDev->qos_select_hook;
+#if PUMA7_OR_NEWER_SOC_TYPE
+    newDev->qos_get_params_hook       = origDev->qos_get_params_hook;
+#endif
+    newDev->qos_virtual_scheme_idx  = origDev->qos_virtual_scheme_idx;
+    newDev->devInstance             = origDev->devInstance;
+
+#if PUMA7_OR_NEWER_SOC_TYPE
+#ifdef CONFIG_ARM_AVALANCHE_SOC
+    if (ti_hil_is_gbe_device(origDev))
+#endif
+    {
+        if (origDev->netdev_copy_priv_hook)
+        {
+            origDev->netdev_copy_priv_hook(newDev, origDev);
+	        newDev->netdev_copy_priv_hook = origDev->netdev_copy_priv_hook;
+        }
+    }
+#endif
+}
+EXPORT_SYMBOL(ti_hil_clone_netdev_pp_info);
+
+#ifdef CONFIG_TI_PACKET_PROCESSOR_STATS
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_register_start_session_notification
+ **************************************************************************
+ * DESCRIPTION   :
+ *  Register the DOCSIS Packet Processor start session notification
+ *  callback function
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ **************************************************************************/
+int ti_hil_register_start_session_notification(TI_HIL_START_SESSION ti_hil_start_session_notification)
+{
+    if (ti_hil_start_session_notification_cb != NULL)
+    {
+        printk ("Error: DOCSIS Packet Processor start session notification callback already exist\n");
+        return -1;
+    }
+
+    ti_hil_start_session_notification_cb = ti_hil_start_session_notification;
+
+    return 0;
+}
+
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_unregister_start_session_notification
+ **************************************************************************
+ * DESCRIPTION   :
+ *  Un-Register the DOCSIS Packet Processor start session notification
+ *  callback function
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ **************************************************************************/
+int ti_hil_unregister_start_session_notification(void)
+{
+    if (ti_hil_start_session_notification_cb == NULL)
+    {
+        printk ("Error: DOCSIS Packet Processor start session notification callback empty\n");
+        return -1;
+    }
+
+    ti_hil_start_session_notification_cb = NULL;
+
+    return 0;
+}
+
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_register_delete_session_notification
+ **************************************************************************
+ * DESCRIPTION   :
+ *  Register the DOCSIS Packet processor delete session notification
+ *  callback function
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ **************************************************************************/
+int ti_hil_register_delete_session_notification(TI_HIL_DELETE_SESSION ti_hil_delete_session_notification)
+{
+    if (ti_hil_delete_session_notification_cb != NULL)
+    {
+        printk ("Error: DOCSIS Packet Processor delete session notification callback already exist\n");
+        return -1;
+    }
+
+    ti_hil_delete_session_notification_cb = ti_hil_delete_session_notification;
+
+    return 0;
+}
+
+/**************************************************************************
+ * FUNCTION NAME : ti_hil_unregister_delete_session_notification
+ **************************************************************************
+ * DESCRIPTION   :
+ *  Un-Register the DOCSIS Packet processor delete session notification
+ *  callback function
+ *
+ * RETURNS       :
+ *  0   -   Success
+ *  <0  -   Error
+ **************************************************************************/
+int ti_hil_unregister_delete_session_notification(void)
+{
+    if (ti_hil_delete_session_notification_cb == NULL)
+    {
+        printk ("Error: DOCSIS Packet Processor delete session notification callback empty\n");
+        return -1;
+    }
+
+    ti_hil_delete_session_notification_cb = NULL;
+
+    return 0;
+}
+#endif /* CONFIG_TI_PACKET_PROCESSOR_STATS */
+
+/* Export all the Symbols for Linux; so that these can be called from modules. */
+EXPORT_SYMBOL(ti_hil_initialize);
+EXPORT_SYMBOL(ti_hil_register_profile);
+EXPORT_SYMBOL(ti_hil_pp_event);
+#ifdef CONFIG_TI_PACKET_PROCESSOR_STATS
+/* DOCSIS Packet processor start/delete session notification API */
+EXPORT_SYMBOL(ti_hil_register_start_session_notification);
+EXPORT_SYMBOL(ti_hil_unregister_start_session_notification);
+EXPORT_SYMBOL(ti_hil_register_delete_session_notification);
+EXPORT_SYMBOL(ti_hil_unregister_delete_session_notification);
+#endif /* CONFIG_TI_PACKET_PROCESSOR_STATS */
+
-- 
2.10.1

